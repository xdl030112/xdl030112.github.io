{"meta":{"title":"自由を渇望する","subtitle":"ひとりぼっち","description":"Konjak_ldx's blog","author":"ldxcaicai","url":"http://ldxcaicai.github.io","root":"/"},"pages":[{"title":"所有分类","date":"2019-12-27T06:18:55.512Z","updated":"2019-12-27T06:18:55.512Z","comments":true,"path":"categories/index.html","permalink":"http://ldxcaicai.github.io/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2019-12-27T05:53:03.935Z","updated":"2019-12-27T05:53:03.935Z","comments":true,"path":"tags/index.html","permalink":"http://ldxcaicai.github.io/tags/index.html","excerpt":"","text":""},{"title":"Friends!","date":"2019-12-27T06:17:17.523Z","updated":"2019-12-27T06:17:17.523Z","comments":true,"path":"friends/index.html","permalink":"http://ldxcaicai.github.io/friends/index.html","excerpt":"","text":""}],"posts":[{"title":"杂题乱做 Round12","slug":"sol12","date":"2019-12-26T03:47:36.000Z","updated":"2019-12-27T06:42:04.741Z","comments":true,"path":"sol12/","link":"","permalink":"http://ldxcaicai.github.io/sol12/","excerpt":"","text":"某位歌姬的故事 解题思路 将序列离散化后，可以给每一段区间定一个最大值的最小上界，那么每一种上界的值是独立的，考虑把相同上界的块扯出来 DP 对于一种上界，把对应的段和限制提出来，对于每个块维护一个 maxlmaxlmaxl 表示处理到区间 iii 时，最后填入的一个等于上界的值所在的块标号应该不小于 maxlmaxlmaxl ，对于一个限制对应的块 [l,...,r][l,...,r][l,...,r] ，我们用 lll 更新 maxl[r]maxl[r]maxl[r] ，最后直接 DP 设 fi,jf_{i,j}fi,j​ 表示当前在第 iii 块，最后一个填的等于上界的数在第 jjj 块的方案数 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() &#123; int ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular &#123; const int mod=998244353; inline int add(int a,int b) &#123; return a+b&lt;mod?a+b:a+b-mod; &#125; inline int dec(int a,int b) &#123; return a&lt;b?a-b+mod:a-b; &#125; inline int mul(int a,int b) &#123; return (ll)a*b%mod; &#125; inline void Add(int&amp;a,int b) &#123; a=a+b&lt;mod?a+b:a+b-mod; &#125; inline void Dec(int&amp;a,int b) &#123; a=a&lt;b?a-b+mod:a-b; &#125; inline void Mul(int&amp;a,int b) &#123; a=(ll)a*b%mod; &#125; inline int ksm(int a,int p) &#123; int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; &#125; inline int Inv(int a) &#123; return ksm(a,mod-2); &#125; inline int fix(int a) &#123; return (a%mod+mod)%mod; &#125;&#125;using namespace modular;template&lt;typename T&gt; inline void ckmin(T&amp;a,T b) &#123; a&gt;b?a=b:0; &#125;template&lt;typename T&gt; inline void ckmax(T&amp;a,T b) &#123; a&lt;b?a=b:0; &#125;const int N=1005;int n,m,A,seg[N],sz,vl[N],sig,a[N];struct Q &#123; int l,r,v; friend inline bool operator&lt;(Q a,Q b) &#123; return a.v^b.v?a.v&lt;b.v:(a.l^b.l?a.l&lt;b.l:a.r&lt;b.r); &#125;&#125;qry[N];inline int findps(int x) &#123; return lower_bound(seg+1,seg+sig+1,x)-seg; &#125;inline int findvl(int x) &#123; return lower_bound(vl+1,vl+sz+1,x)-vl; &#125;inline int calc(int w) &#123; vector&lt;int&gt;upd,psl,f[2]; int cur=0; upd.pb(0),f[0].pb(0),f[1].pb(0),psl.pb(0); for(ri i=1;i&lt;sig;++i) if(a[i]==w) upd.pb(i),psl.pb(0),f[0].pb(0),f[1].pb(0); for(ri l,r,i=1;i&lt;=m;++i) if(qry[i].v==w) &#123; if(upd.size()==1) return 0; l=lower_bound(upd.begin(),upd.end(),qry[i].l)-upd.begin(); r=lower_bound(upd.begin(),upd.end(),qry[i].r)-upd.begin()-1; ckmax(psl[r],l); &#125; f[cur=0][0]=1; for(ri i=1,s,c1,c2,up=(int)upd.size()-1;i&lt;=up;++i) &#123; cur^=1; for(ri j=0;j&lt;=i;++j) f[cur][j]=0; c1=ksm(vl[w],seg[upd[i]+1]-seg[upd[i]]),c2=ksm(vl[w]-1,seg[upd[i]+1]-seg[upd[i]]); s=0; for(ri j=psl[i];j&lt;i;++j) if(f[cur^1][j]) Add(f[cur][j],mul(f[cur^1][j],c2)); for(ri j=0;j&lt;i;++j) if(f[cur^1][j]) Add(s,f[cur^1][j]); f[cur][i]=mul(dec(c1,c2),s); &#125; int res=0; for(ri i=0,up=(int)upd.size()-1;i&lt;=up;++i) Add(res,f[cur][i]); return res;&#125;int main() &#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif for(ri tt=read();tt;--tt) &#123; n=read(),m=read(),A=read(); sig=sz=0; for(ri i=1;i&lt;=m;++i) &#123; qry[i].l=read(),qry[i].r=read()+1,qry[i].v=read(); seg[++sig]=qry[i].l,seg[++sig]=qry[i].r,vl[++sz]=qry[i].v; &#125; seg[++sig]=1,seg[++sig]=n+1; sort(seg+1,seg+sig+1),sig=unique(seg+1,seg+sig+1)-seg-1; sort(vl+1,vl+sz+1),sz=unique(vl+1,vl+sz+1)-vl-1; for(ri i=1;i&lt;=sig;++i) a[i]=sz+1; sort(qry+1,qry+m+1); for(ri i=1;i&lt;=m;++i) &#123; qry[i].l=findps(qry[i].l); qry[i].r=findps(qry[i].r); qry[i].v=findvl(qry[i].v); for(ri j=qry[i].l;j&lt;qry[i].r;++j) ckmin(a[j],qry[i].v); &#125; int res=1,ss=0; for(ri i=1;i&lt;=sz;++i) &#123; Mul(res,calc(i)); if(!res) break; &#125; if(!res ) &#123; puts(\"0\");continue; &#125; for(ri i=1;i&lt;sig;++i) if(a[i]==sz+1) ss+=seg[i+1]-seg[i]; cout&lt;&lt;mul(res,ksm(A,ss))&lt;&lt;'\\n'; &#125; return 0;&#125; 九个太阳 解题思路 单位根反演裸题，不用写题解了 好吧还是水一发题解吧。 Ans=∑i=0n(∑j=0K−1ωKij)(ni)=∑i=0K−1∑j=0nωKij(nj)=∑i=0K−1(ωKi+1)n\\begin{aligned} Ans=&amp;\\sum\\limits_{i=0}^n(\\sum\\limits_{j=0}^{K-1}\\omega_K^{ij})\\binom ni\\\\ =&amp;\\sum\\limits_{i=0}^{K-1}\\sum\\limits_{j=0}^n\\omega_K^{ij}\\binom nj\\\\ =&amp;\\sum\\limits_{i=0}^{K-1}(\\omega_K^i+1)^n \\end{aligned} Ans===​i=0∑n​(j=0∑K−1​ωKij​)(in​)i=0∑K−1​j=0∑n​ωKij​(jn​)i=0∑K−1​(ωKi​+1)n​ CODE 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;namespace modular &#123; const int mod=998244353; inline int add(int a,int b) &#123; return a+b&lt;mod?a+b:a+b-mod; &#125; inline int dec(int a,int b) &#123; return a&lt;b?a-b+mod:a-b; &#125; inline int mul(int a,int b) &#123; return (ll)a*b%mod; &#125; inline void Add(int&amp;a,int b) &#123; a=a+b&lt;mod?a+b:a+b-mod; &#125; inline void Dec(int&amp;a,int b) &#123; a=a&lt;b?a-b+mod:a-b; &#125; inline void Mul(int&amp;a,int b) &#123; a=(ll)a*b%mod; &#125; inline int ksm(int a,int p) &#123; int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; &#125; inline int Inv(int a) &#123; return ksm(a,mod-2); &#125; inline int fix(int a) &#123; return (a%mod+mod)%mod; &#125;&#125;using namespace modular;ll n;int K,omega;int main() &#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif cin&gt;&gt;n&gt;&gt;K; n%=mod-1; omega=ksm(3,(mod-1)/K); int res=0; for(ri i=0,mt=1;i&lt;K;++i,Mul(mt,omega)) Add(res,ksm(mt+1,n)); cout&lt;&lt;mul(res,Inv(K)); return 0;&#125; Hard Nim 解题思路 考虑到问题转化为求异或值为 000 的方案数，那么对于每堆石子可以选取的集合为不超过 mmm 的素数集合，发现就是个 fwtfwtfwt 快速幂 CODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;namespace modular &#123; const int mod=1e9+7; inline int add(int a,int b) &#123; return a+b&lt;mod?a+b:a+b-mod; &#125; inline int dec(int a,int b) &#123; return a&lt;b?a-b+mod:a-b; &#125; inline int mul(int a,int b) &#123; return (ll)a*b%mod; &#125; inline void Add(int&amp;a,int b) &#123; a=a+b&lt;mod?a+b:a+b-mod; &#125; inline void Dec(int&amp;a,int b) &#123; a=a&lt;b?a-b+mod:a-b; &#125; inline void Mul(int&amp;a,int b) &#123; a=(ll)a*b%mod; &#125; inline int ksm(int a,int p) &#123; int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; &#125; inline int Inv(int a) &#123; return ksm(a,mod-2); &#125; inline int fix(int a) &#123; return (a%mod+mod)%mod; &#125;&#125;using namespace modular;const int N=50005;int n,m,pri[N],tot=0,a[N&lt;&lt;1];bool vs[N];inline void init() &#123; int up=50000; for(ri i=2;i&lt;=up;++i) &#123; if(!vs[i]) pri[++tot]=i; for(ri j=1,lm=up/i;j&lt;=tot&amp;&amp;pri[j]&lt;=lm;++j) &#123; vs[i*pri[j]]=1; if(i==i/pri[j]*pri[j]) break; &#125; &#125;&#125;int lim;inline void fwt(int*a,int typ) &#123; for(ri i=1,a0,a1,iv=mod+1&gt;&gt;1;i&lt;lim;i&lt;&lt;=1) for(ri j=0,len=i&lt;&lt;1;j&lt;lim;j+=len) for(ri k=0;k&lt;i;++k) &#123; a0=a[j+k],a1=a[j+k+i]; a[j+k]=add(a0,a1),a[j+k+i]=dec(a0,a1); if(typ==-1) Mul(a[j+k],iv),Mul(a[j+k+i],iv); &#125;&#125;int main() &#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif init(); while(cin&gt;&gt;n&gt;&gt;m) &#123; lim=1; while(lim&lt;=m) lim&lt;&lt;=1; for(ri i=0;i&lt;lim;++i) a[i]=0; for(ri i=1;i&lt;=tot&amp;&amp;pri[i]&lt;=m;++i) a[pri[i]]=1; fwt(a,1); for(ri i=0;i&lt;lim;++i) a[i]=ksm(a[i],n); fwt(a,-1); cout&lt;&lt;a[0]&lt;&lt;'\\n'; &#125; return 0;&#125; 二元运算 解题思路 题目给出了两种互补的基础卷积方式，那么考虑分治, 发现刚好 [l,mid][l,mid][l,mid] 中所有下标小于 [mid+1,r][mid+1,r][mid+1,r] 所有下标，于是分治 fft 处理即可 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() &#123; int ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;struct cp &#123; double a,b; cp(double a=0,double b=0):a(a),b(b) &#123;&#125; friend inline cp operator+(cp a,cp b) &#123; return cp(a.a+b.a,a.b+b.b); &#125; friend inline void operator+=(cp&amp;a,cp b) &#123; a=a+b; &#125; friend inline cp operator-(cp a,cp b) &#123; return cp(a.a-b.a,a.b-b.b); &#125; friend inline void operator-=(cp&amp;a,cp b) &#123; a=a-b; &#125; friend inline cp operator*(cp a,cp b) &#123; return cp(a.a*b.a-a.b*b.b,a.a*b.b+a.b*b.a); &#125; friend inline void operator*=(cp&amp;a,cp b) &#123; a=a*b; &#125; friend inline cp operator/(cp a,double b) &#123; return cp(a.a/b,a.b/b); &#125; friend inline void operator/=(cp&amp;a,double b) &#123; a=a/b; &#125;&#125;;typedef vector&lt;cp&gt; poly;const double pi=acos(-1.0);cp w[23];int lim,tim;vector&lt;int&gt;rev[23];inline void init_fft() &#123; for(ri i=0;i&lt;23;++i) w[i]=cp(cos(pi/(1&lt;&lt;i)),sin(pi/(1&lt;&lt;i))); &#125;inline void init(int up) &#123; lim=1,tim=0; while(lim&lt;up) lim&lt;&lt;=1,++tim; if(rev[tim].size()) return; rev[tim].resize(lim); for(ri i=1;i&lt;lim;++i) rev[tim][i]=(rev[tim][i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(tim-1));&#125;inline void fft(poly&amp;a,int typ) &#123; for(ri i=1;i&lt;lim;++i) if(i&lt;rev[tim][i]) swap(a[i],a[rev[tim][i]]); cp a0,a1,mt; for(ri i=1,t=0;i&lt;lim;i&lt;&lt;=1,++t) for(ri j=0,len=i&lt;&lt;1;j&lt;lim;j+=len) &#123; mt=cp(1,0); for(ri k=0;k&lt;i;++k,mt*=w[t]) &#123; a0=a[j+k],a1=a[j+k+i]*mt; a[j+k]=a0+a1,a[j+k+i]=a0-a1; &#125; &#125; if(~typ) return; reverse(++a.begin(),a.end()); for(ri i=0;i&lt;lim;++i) a[i]/=lim;&#125;inline poly operator*(poly a,poly b) &#123; int n=(int)a.size(),m=(int)b.size(),t=n+m-1; if(t&lt;=128) &#123; poly c(t); for(ri i=0;i&lt;n;++i) for(ri j=0;j&lt;m;++j) c[i+j]+=a[i]*b[j]; return c; &#125; init(t); a.resize(lim),fft(a,1); b.resize(lim),fft(b,1); for(ri i=0;i&lt;lim;++i) a[i]*=b[i]; return fft(a,-1),a.resize(t),a;&#125;const int N=50005;int n,m,mx,q,_a[N],_b[N];poly a,b,ta,tb,tc;ll res[N&lt;&lt;2];inline void solve(int l,int r) &#123; if(l==r) &#123; res[0]+=((ll)(a[l].a+0.5))*((ll)(b[l].a+0.5)); return; &#125; int mid=l+r&gt;&gt;1; solve(l,mid),solve(mid+1,r); if(r-l+1&lt;=256) &#123; for(ri i=l;i&lt;=mid;++i) for(ri j=mid+1;j&lt;=r;++j) &#123; res[i+j]+=((ll)(a[i].a+0.5))*((ll)(b[j].a+0.5)); res[j-i]+=((ll)(a[j].a+0.5))*((ll)(b[i].a+0.5)); &#125; &#125; else &#123; ta.resize(mid-l+1),tb.resize(r-mid); for(ri i=l;i&lt;=mid;++i) ta[i-l]=a[i]; for(ri i=mid+1;i&lt;=r;++i) tb[i-mid-1]=b[i]; tc=ta*tb; for(ri i=0;i&lt;(int)tc.size();++i) res[i+mid+1+l]+=(ll)(tc[i].a+0.5); for(ri i=mid+1;i&lt;=r;++i) tb[i-mid-1]=a[i]; for(ri i=l;i&lt;=mid;++i) ta[i-l]=b[i]; reverse(ta.begin(),ta.end()); tc=ta*tb; for(ri i=0;i&lt;(int)tc.size();++i) res[i+1]+=(ll)(tc[i].a+0.5); &#125;&#125;int main() &#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); freopen(\"own.out\",\"w\",stdout); #endif init_fft(); for(ri tt=read();tt;--tt) &#123; n=read(),m=read(),q=read(),mx=-1; for(ri i=1;i&lt;=n;++i) mx=max(mx,_a[i]=read()); for(ri i=1;i&lt;=m;++i) mx=max(mx,_b[i]=read()); a.clear(),a.resize(mx+1); b.clear(),b.resize(mx+1); for(ri i=0;i&lt;=(mx&lt;&lt;1);++i) res[i]=0; for(ri i=1;i&lt;=n;++i) ++a[_a[i]].a; for(ri i=1;i&lt;=m;++i) ++b[_b[i]].a; solve(0,mx); for(ri x;q;--q) &#123; x=read(); if(x&lt;=(mx&lt;&lt;1)) cout&lt;&lt;res[x]&lt;&lt;'\\n'; else puts(\"0\"); &#125; &#125; return 0;&#125; Lightsabers (hard) 解题思路 可以直接对每种颜色构造形式幂级数然后做双模分治 nttnttntt 不过看到了一种神奇的启发式合并的做法 大概是每次合并两个当前度最小的多项式，复杂度仍然是 O(nlog⁡n2)O(n\\log n^2)O(nlogn2) 本来听说要快一点但是由于我写的双模ntt太菜了于是被分治ntt吊着打 CODE1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef vector&lt;int&gt; poly;#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() &#123; int ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;const int N=2e5+5;int n,m,K,a[N],vl[N],cnt[N],sig=0;inline int find(int x) &#123; return lower_bound(vl+1,vl+sig+1,x)-vl; &#125;struct Ntt &#123; int mod,g,lim,tim,w[21],invv[21]; inline int add(int a,int b) &#123; return a+b&lt;mod?a+b:a+b-mod; &#125; inline int dec(int a,int b) &#123; return a&lt;b?a-b+mod:a-b; &#125; inline int mul(int a,int b) &#123; return (ll)a*b%mod; &#125; inline void Add(int&amp;a,int b) &#123; a=a+b&lt;mod?a+b:a+b-mod; &#125; inline void Dec(int&amp;a,int b) &#123; a=a&lt;b?a-b+mod:a-b; &#125; inline void Mul(int&amp;a,int b) &#123; a=(ll)a*b%mod; &#125; inline int ksm(int a,int p) &#123; int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; &#125; inline int Inv(int a) &#123; return ksm(a,mod-2); &#125; vector&lt;int&gt;rev[21]; inline void init_ntt() &#123; invv[0]=1; for(ri i=1,iv=mod+1&gt;&gt;1;i&lt;21;++i) invv[i]=mul(invv[i-1],iv); w[20]=ksm(g,(mod-1)&gt;&gt;21); for(ri i=19;~i;--i) w[i]=mul(w[i+1],w[i+1]); &#125; inline void init(int up) &#123; lim=1,tim=0; while(lim&lt;up) lim&lt;&lt;=1,++tim; if(rev[tim].size()) return; rev[tim].resize(lim); for(ri i=1;i&lt;lim;++i) rev[tim][i]=(rev[tim][i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(tim-1)); &#125; inline void ntt(poly&amp;a,int typ) &#123; for(ri i=1;i&lt;lim;++i) if(i&lt;rev[tim][i]) swap(a[i],a[rev[tim][i]]); for(ri i=1,t=0,a0,a1,mt;i&lt;lim;i&lt;&lt;=1,++t) for(ri j=0,len=i&lt;&lt;1;j&lt;lim;j+=len) &#123; mt=1; for(ri k=0;k&lt;i;++k,Mul(mt,w[t])) &#123; a0=a[j+k],a1=mul(a[j+k+i],mt); a[j+k]=add(a0,a1),a[j+k+i]=dec(a0,a1); &#125; &#125; if(~typ) return; reverse(++a.begin(),a.end()); for(ri i=0;i&lt;lim;++i) Mul(a[i],invv[tim]); &#125; inline poly poly_mul(poly a,poly b) &#123; int n=(int)a.size(),m=(int)b.size(),t=n+m-1; init(t); a.resize(lim),ntt(a,1); b.resize(lim),ntt(b,1); for(ri i=0;i&lt;lim;++i) Mul(a[i],b[i]); return ntt(a,-1),a.resize(t),a; &#125;&#125;A,B;const int mod=1009;int iv1,iv2;inline ll mul(ll a,ll b,ll mod) &#123; return a*b-(ll)((long double)a/mod*b+1e-8)*mod; &#125;inline int merge(int x,int y) &#123; ll md=(ll)A.mod*B.mod; return (mul(x,(ll)B.mod*iv1%md,md)+mul(y,(ll)A.mod*iv2%md,md))%md%mod;&#125;inline poly poly_mul(poly a,poly b) &#123; int n=(int)a.size(),m=(int)b.size(),t=n+m-1; if(t&lt;=128) &#123; poly c(t); for(ri i=0;i&lt;n;++i) if(a[i]) for(ri j=0;j&lt;m;++j) &#123; c[i+j]+=a[i]*b[j]; if(c[i+j]&gt;=100000000) c[i+j]%=mod; &#125; for(ri i=0;i&lt;t;++i) c[i]%=mod; return c; &#125; poly _a=A.poly_mul(a,b),_b=B.poly_mul(a,b); a.resize(t); for(ri i=0;i&lt;t;++i) a[i]=merge(_a[i],_b[i]); return a;&#125;inline poly getpoly(int x) &#123; return poly(x+1,1); &#125;inline poly solve(int l,int r) &#123; if(l==r) return getpoly(cnt[l]); int mid=l+r&gt;&gt;1; return poly_mul(solve(l,mid),solve(mid+1,r));&#125;int main() &#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif A.mod=998244353,A.g=3,A.init_ntt(); B.mod=1004535809,B.g=3,B.init_ntt(); iv1=A.Inv(B.mod),iv2=B.Inv(A.mod); n=read(),m=read(),K=read(); for(ri i=1;i&lt;=n;++i) a[i]=vl[++sig]=read(); sort(vl+1,vl+sig+1),sig=unique(vl+1,vl+sig+1)-vl-1; for(ri i=1;i&lt;=n;++i) ++cnt[find(a[i])]; cout&lt;&lt;solve(1,sig)[K]; return 0;&#125; CODE2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef vector&lt;int&gt; poly;#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() &#123; int ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;const int N=2e5+5;int n,m,K,a[N],vl[N],cnt[N],sig=0;inline int find(int x) &#123; return lower_bound(vl+1,vl+sig+1,x)-vl; &#125;struct Ntt &#123; int mod,g,lim,tim,w[21],invv[21]; inline int add(int a,int b) &#123; return a+b&lt;mod?a+b:a+b-mod; &#125; inline int dec(int a,int b) &#123; return a&lt;b?a-b+mod:a-b; &#125; inline int mul(int a,int b) &#123; return (ll)a*b%mod; &#125; inline void Add(int&amp;a,int b) &#123; a=a+b&lt;mod?a+b:a+b-mod; &#125; inline void Dec(int&amp;a,int b) &#123; a=a&lt;b?a-b+mod:a-b; &#125; inline void Mul(int&amp;a,int b) &#123; a=(ll)a*b%mod; &#125; inline int ksm(int a,int p) &#123; int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; &#125; inline int Inv(int a) &#123; return ksm(a,mod-2); &#125; vector&lt;int&gt;rev[21]; inline void init_ntt() &#123; invv[0]=1; for(ri i=1,iv=mod+1&gt;&gt;1;i&lt;21;++i) invv[i]=mul(invv[i-1],iv); w[20]=ksm(g,(mod-1)&gt;&gt;21); for(ri i=19;~i;--i) w[i]=mul(w[i+1],w[i+1]); &#125; inline void init(int up) &#123; lim=1,tim=0; while(lim&lt;up) lim&lt;&lt;=1,++tim; if(rev[tim].size()) return; rev[tim].resize(lim); for(ri i=1;i&lt;lim;++i) rev[tim][i]=(rev[tim][i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(tim-1)); &#125; inline void ntt(poly&amp;a,int typ) &#123; for(ri i=1;i&lt;lim;++i) if(i&lt;rev[tim][i]) swap(a[i],a[rev[tim][i]]); for(ri i=1,t=0,a0,a1,mt;i&lt;lim;i&lt;&lt;=1,++t) for(ri j=0,len=i&lt;&lt;1;j&lt;lim;j+=len) &#123; mt=1; for(ri k=0;k&lt;i;++k,Mul(mt,w[t])) &#123; a0=a[j+k],a1=mul(a[j+k+i],mt); a[j+k]=add(a0,a1),a[j+k+i]=dec(a0,a1); &#125; &#125; if(~typ) return; reverse(++a.begin(),a.end()); for(ri i=0;i&lt;lim;++i) Mul(a[i],invv[tim]); &#125; inline poly poly_mul(poly a,poly b) &#123; int n=(int)a.size(),m=(int)b.size(),t=n+m-1; init(t); a.resize(lim),ntt(a,1); b.resize(lim),ntt(b,1); for(ri i=0;i&lt;lim;++i) Mul(a[i],b[i]); return ntt(a,-1),a.resize(t),a; &#125;&#125;A,B;const int mod=1009;int iv1,iv2;inline ll mul(ll a,ll b,ll mod) &#123; return a*b-(ll)((long double)a/mod*b+1e-8)*mod; &#125;inline int merge(int x,int y) &#123; ll md=(ll)A.mod*B.mod; return (mul(x,(ll)B.mod*iv1%md,md)+mul(y,(ll)A.mod*iv2%md,md))%md%mod;&#125;inline poly poly_mul(poly a,poly b) &#123; int n=(int)a.size(),m=(int)b.size(),t=n+m-1; if(t&lt;=128) &#123; poly c(t); for(ri i=0;i&lt;n;++i) if(a[i]) for(ri j=0;j&lt;m;++j) &#123; c[i+j]+=a[i]*b[j]; if(c[i+j]&gt;=100000000) c[i+j]%=mod; &#125; for(ri i=0;i&lt;t;++i) c[i]%=mod; return c; &#125; poly _a=A.poly_mul(a,b),_b=B.poly_mul(a,b); a.resize(t); for(ri i=0;i&lt;t;++i) a[i]=merge(_a[i],_b[i]); return a;&#125;inline poly getpoly(int x) &#123; return poly(x+1,1); &#125;inline poly solve(int l,int r) &#123; if(l==r) return getpoly(cnt[l]); int mid=l+r&gt;&gt;1; return poly_mul(solve(l,mid),solve(mid+1,r));&#125;int main() &#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif A.mod=998244353,A.g=3,A.init_ntt(); B.mod=1004535809,B.g=3,B.init_ntt(); iv1=A.Inv(B.mod),iv2=B.Inv(A.mod); n=read(),m=read(),K=read(); for(ri i=1;i&lt;=n;++i) a[i]=vl[++sig]=read(); sort(vl+1,vl+sig+1),sig=unique(vl+1,vl+sig+1)-vl-1; for(ri i=1;i&lt;=n;++i) ++cnt[find(a[i])]; cout&lt;&lt;solve(1,sig)[K]; return 0;&#125; Kyoya and Train 解题思路 考虑朴素 dp ，设 fi,Tf_{i,T}fi,T​ 表示当前在点 iii 时刻为 ttt 的最小花费 那么有显然的转移 fu,T=min⁡v{∑i=1tfv,T+i×P(u,v),i}f_{u,T}=\\min\\limits_v\\{\\sum\\limits_{i=1}^tf_{v,T+i}\\times P_{(u,v),i}\\}fu,T​=vmin​{i=1∑t​fv,T+i​×P(u,v),i​} 发现可以分治 fft 出边的贡献，于是 O(mtlog⁡t2)O(mt\\log t^2)O(mtlogt2) 过了 我把单向边建成双向的调了一年 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() &#123; int ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;struct cp &#123; double x,y; cp(double x=0,double y=0):x(x),y(y) &#123;&#125; friend inline cp operator+(cp a,cp b) &#123; return cp(a.x+b.x,a.y+b.y); &#125; friend inline void operator+=(cp&amp;a,cp b) &#123; a=a+b; &#125; friend inline cp operator-(cp a,cp b) &#123; return cp(a.x-b.x,a.y-b.y); &#125; friend inline void operator-=(cp&amp;a,cp b) &#123; a=a-b; &#125; friend inline cp operator*(cp a,cp b) &#123; return cp(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x); &#125; friend inline void operator*=(cp&amp;a,cp b) &#123; a=a*b; &#125; friend inline cp operator*(cp a,double b) &#123; return cp(a.x*b,a.y*b); &#125; friend inline void operator*=(cp&amp;a,double b) &#123; a=a*b; &#125; friend inline cp operator/(cp a,double b) &#123; return cp(a.x/b,a.y/b); &#125; friend inline void operator/=(cp&amp;a,double b) &#123; a=a/b; &#125;&#125;;typedef vector&lt;cp&gt; poly;const double pi=acos(-1.0);int lim,tim,n,m,t,W;cp w[23];vector&lt;int&gt;rev[23];inline void init_fft() &#123; for(ri i=0;i&lt;23;++i) w[i]=cp(cos(pi/(1&lt;&lt;i)),sin(pi/(1&lt;&lt;i))); &#125;inline void init(int up) &#123; lim=1,tim=0; while(lim&lt;up) lim&lt;&lt;=1,++tim; if(rev[tim].size()) return; rev[tim].resize(lim); for(ri i=1;i&lt;lim;++i) rev[tim][i]=(rev[tim][i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(tim-1));&#125;inline void fft(poly&amp;a,int typ) &#123; for(ri i=1;i&lt;lim;++i) if(i&lt;rev[tim][i]) swap(a[i],a[rev[tim][i]]); cp a0,a1,mt; for(ri i=1,t=0;i&lt;lim;i&lt;&lt;=1,++t) for(ri j=0,len=i&lt;&lt;1;j&lt;lim;j+=len) &#123; mt=cp(1,0); for(ri k=0;k&lt;i;++k,mt*=w[t]) &#123; a0=a[j+k],a1=a[j+k+i]*mt; a[j+k]=a0+a1,a[j+k+i]=a0-a1; &#125; &#125; if(~typ) return; reverse(++a.begin(),a.end()); for(ri i=0;i&lt;lim;++i) a[i]/=lim;&#125;inline poly operator*(poly a,poly b) &#123; int n=(int)a.size(),m=(int)b.size(),t=n+m-1; init(t); a.resize(lim),fft(a,1); b.resize(lim),fft(b,1); for(ri i=0;i&lt;lim;++i) a[i]*=b[i]; return fft(a,-1),a.resize(t),a;&#125;const int N=105,M=205,K=20005;int a[M],b[M],c[M],dis[N][N];double f[N][K],sum[M][K],p[M][K];inline void solve(int l,int r) &#123; if(l==r) &#123; for(ri e=1;e&lt;=m;++e) f[a[e]][l]=min(f[a[e]][l],sum[e][l]+c[e]); return; &#125; int mid=l+r&gt;&gt;1; solve(mid+1,r); poly F(r-mid),G(r-l+1),H; for(ri e=1;e&lt;=m;++e) &#123; for(ri i=mid+1;i&lt;=r;++i) F[i-mid-1]=cp(f[b[e]][i],0); for(ri i=1;i&lt;=r-l;++i) G[r-l-i]=cp(p[e][i],0); H=F*G; for(ri i=l;i&lt;=mid;++i) sum[e][i]+=H[i-mid-1+r-l].x; &#125; solve(l,mid);&#125;int main() &#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif init_fft(); n=read(),m=read(),t=read(),W=read(); for(ri i=1;i&lt;=n;++i) for(ri j=1;j&lt;=n;++j) dis[i][j]=i==j?0:1e9; for(ri i=1;i&lt;=m;++i) &#123; a[i]=read(),b[i]=read(),c[i]=read(); if(c[i]&lt;dis[a[i]][b[i]]) dis[a[i]][b[i]]=c[i]; for(ri j=1;j&lt;=t;++j) p[i][j]=read()/100000.0; &#125; for(ri k=1;k&lt;=n;++k) for(ri i=1;i&lt;=n;++i) for(ri j=1;j&lt;=n;++j) dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]); for(ri i=0;i&lt;N;++i) for(ri j=0;j&lt;K;++j) f[i][j]=1e9; for(ri i=1;i&lt;=n;++i) f[i][t+1]=dis[i][n]+W; for(ri i=0;i&lt;=t;++i) f[n][i]=0; double ss; for(ri e=1;e&lt;=m;++e) &#123; ss=0; for(ri i=1;i&lt;=t;++i) &#123; ss+=p[e][t+1-i]; sum[e][i]=ss*f[b[e]][t+1]; &#125; &#125; solve(0,t); printf(\"%.10lf\",f[1][0]); return 0;&#125; Frightful Formula 解题思路 考虑每个格子对答案的贡献，发现格子 (i&gt;1,j&gt;1)(i&gt;1,j&gt;1)(i&gt;1,j&gt;1) 的系数是 (n+n−i−jn−i)an−jbn−i\\binom{n+n-i-j}{n-i}a^{n-j}b^{n-i}(n−in+n−i−j​)an−jbn−i ，格子 (1,i&gt;1)(1,i&gt;1)(1,i&gt;1) 的系数是 (n+n−2−in−2)an−ibn−1\\binom{n+n-2-i}{n-2}a^{n-i}b^{n-1}(n−2n+n−2−i​)an−ibn−1 ，格子 (i&gt;1,1)(i&gt;1,1)(i&gt;1,1) 的系数是 (n+n−2−in−2)an−1bn−i\\binom{n+n-2-i}{n-2}a^{n-1}b^{n-i}(n−2n+n−2−i​)an−1bn−i ，那么显然 Ans=∑i=2nf1,i(n+n−2−in−2)an−ibn−1+∑i=2nfi,1(n+n−2−in−2)an−1bn−i+∑i=2n∑j=2nc(n+n−i−jn−i)an−jbn−i\\begin{aligned} Ans=&amp;\\sum\\limits_{i=2}^nf_{1,i}\\binom{n+n-2-i}{n-2}a^{n-i}b^{n-1}+\\sum\\limits_{i=2}^nf_{i,1}\\binom{n+n-2-i}{n-2}a^{n-1}b^{n-i}+\\sum\\limits_{i=2}^n\\sum\\limits_{j=2}^nc\\binom{n+n-i-j}{n-i}a^{n-j}b^{n-i} \\end{aligned} Ans=​i=2∑n​f1,i​(n−2n+n−2−i​)an−ibn−1+i=2∑n​fi,1​(n−2n+n−2−i​)an−1bn−i+i=2∑n​j=2∑n​c(n−in+n−i−j​)an−jbn−i​ 发现前面的可以 O(n)O(n)O(n) 算后面的可以卷积算，复杂度 O(nlog⁡n)O(n\\log n)O(nlogn) 其实后面的式子可以用组合数推出O(n)的式子但由于我太懒了就不写了，可以参见官方题解 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() &#123; int ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;struct cp &#123; double x,y; cp(double x=0,double y=0):x(x),y(y) &#123;&#125; friend inline cp operator+(cp a,cp b) &#123; return cp(a.x+b.x,a.y+b.y); &#125; friend inline void operator+=(cp&amp;a,cp b) &#123; a=a+b; &#125; friend inline cp operator-(cp a,cp b) &#123; return cp(a.x-b.x,a.y-b.y); &#125; friend inline void operator-=(cp&amp;a,cp b) &#123; a=a-b; &#125; friend inline cp operator*(cp a,cp b) &#123; return cp(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x); &#125; friend inline void operator*=(cp&amp;a,cp b) &#123; a=a*b; &#125; friend inline cp operator*(cp a,double b) &#123; return cp(a.x*b,a.y*b); &#125; friend inline void operator*=(cp&amp;a,double b) &#123; a=a*b; &#125; friend inline cp operator/(cp a,double b) &#123; return cp(a.x/b,a.y/b); &#125; friend inline void operator/=(cp&amp;a,double b) &#123; a=a/b; &#125; inline cp operator~() const &#123; return cp(x,-y); &#125;&#125;;typedef vector&lt;cp&gt; poly;const double pi=acos(-1.0);int lim,tim;vector&lt;cp&gt; w[20];vector&lt;int&gt;rev[20];inline void init_fft() &#123; w[19].resize(1&lt;&lt;19); for(ri i=0,lm=1&lt;&lt;19;i&lt;lm;++i) w[19][i]=cp(cos(pi/lm*i),sin(pi/lm*i)); for(ri i=18;~i;--i) &#123; w[i].resize(1&lt;&lt;i); for(ri j=0,up=1&lt;&lt;i;j&lt;up;++j) w[i][j]=w[i+1][j&lt;&lt;1]; &#125;&#125;inline void init(int up) &#123; lim=1,tim=0; while(lim&lt;up) lim&lt;&lt;=1,++tim; if(rev[tim].size()) return; rev[tim].resize(lim); for(ri i=1;i&lt;lim;++i) rev[tim][i]=(rev[tim][i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(tim-1));&#125;inline void fft(poly&amp;a,int typ) &#123; for(ri i=1;i&lt;lim;++i) if(i&lt;rev[tim][i]) swap(a[i],a[rev[tim][i]]); cp a0,a1; for(ri i=1,t=0;i&lt;lim;i&lt;&lt;=1,++t) for(ri j=0,len=i&lt;&lt;1;j&lt;lim;j+=len) &#123; for(ri k=0;k&lt;i;++k) &#123; a0=a[j+k],a1=a[j+k+i]*w[t][k]; a[j+k]=a0+a1,a[j+k+i]=a0-a1; &#125; &#125; if(~typ) return; reverse(++a.begin(),a.end()); for(ri i=0;i&lt;lim;++i) a[i]/=lim;&#125;namespace modular &#123; const int mod=1e6+3; inline int add(int a,int b) &#123; return a+b&lt;mod?a+b:a+b-mod; &#125; inline int dec(int a,int b) &#123; return a&lt;b?a-b+mod:a-b; &#125; inline int mul(int a,int b) &#123; return (ll)a*b%mod; &#125; inline void Add(int&amp;a,int b) &#123; a=a+b&lt;mod?a+b:a+b-mod; &#125; inline void Dec(int&amp;a,int b) &#123; a=a&lt;b?a-b+mod:a-b; &#125; inline void Mul(int&amp;a,int b) &#123; a=(ll)a*b%mod; &#125; inline int ksm(int a,int p) &#123; int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; &#125; inline int Inv(int a) &#123; return ksm(a,mod-2); &#125;&#125;using namespace modular;const int N=4e5+5,blo=1023;inline int poly_mul(int*a,int*b,int n,int m,int*c) &#123; int t=n+m-1; init(t); poly A(lim),B(lim),P(lim),Q(lim); for(ri i=0;i&lt;n;++i) A[i]=cp(a[i]&gt;&gt;10,a[i]&amp;blo); for(ri i=0;i&lt;m;++i) B[i]=cp(b[i]&gt;&gt;10,b[i]&amp;blo); fft(A,1),fft(B,1); cp cur[4]; for(ri i=0,j=0;i&lt;lim;++i,j=j?j-1:lim-1) &#123; cur[0]=(A[i]+(~A[j]))*cp(0.5,0); cur[1]=((~A[j])-A[i])*cp(0,0.5); cur[2]=(B[i]+(~B[j]))*cp(0.5,0); cur[3]=((~B[j])-B[i])*cp(0,0.5); P[i]=cur[0]*cur[2]+cp(0,1)*cur[1]*cur[3]; Q[i]=cur[0]*cur[3]+cp(0,1)*cur[1]*cur[2]; &#125; fft(P,-1),fft(Q,-1); ll cr[4]; for(ri i=0;i&lt;t;++i) &#123; cr[0]=(ll)(P[i].x+0.5)%mod; cr[1]=(ll)(P[i].y+0.5)%mod; cr[2]=(ll)(Q[i].x+0.5)%mod; cr[3]=(ll)(Q[i].y+0.5)%mod; c[i]=((cr[0]&lt;&lt;20)+(cr[2]+cr[3]&lt;&lt;10)+cr[1])%mod; &#125; return t;&#125;int n,c,vl1[N&gt;&gt;1],vl2[N&gt;&gt;1],fac[N],ifac[N],pwa[N&gt;&gt;1],pwb[N&gt;&gt;1];inline void init() &#123; int up=n&lt;&lt;1; fac[0]=fac[1]=ifac[0]=ifac[1]=1; for(ri i=2;i&lt;=up;++i) &#123; fac[i]=mul(fac[i-1],i); ifac[i]=mul(ifac[mod-mod/i*i],mod-mod/i); &#125; for(ri i=2;i&lt;=up;++i) Mul(ifac[i],ifac[i-1]);&#125;inline int C(int n,int m) &#123; return n&lt;m||m&lt;0?0:(ll)fac[n]*ifac[m]*ifac[n-m]%mod; &#125;int F[N&gt;&gt;1],G[N&gt;&gt;1],H[N],len;int main() &#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif init_fft(); pwa[0]=pwb[0]=1; n=read(),pwa[1]=read(),pwb[1]=read(),c=read(); init(); for(ri i=2;i&lt;=n;++i) pwa[i]=mul(pwa[i-1],pwa[1]),pwb[i]=mul(pwb[i-1],pwb[1]); for(ri i=1;i&lt;=n;++i) vl1[i]=read(); for(ri i=1;i&lt;=n;++i) vl2[i]=read(); int res=0; for(ri i=2;i&lt;=n;++i) &#123; Add(res,mul(mul(vl1[i],C((n&lt;&lt;1)-2-i,n-2)),mul(pwa[n-1],pwb[n-i]))); Add(res,mul(mul(vl2[i],C((n&lt;&lt;1)-2-i,n-2)),mul(pwb[n-1],pwa[n-i]))); &#125; for(ri i=0;i&lt;n-1;++i) F[i]=mul(ifac[i],pwa[i]),G[i]=mul(ifac[i],pwb[i]); len=poly_mul(F,G,n-1,n-1,H); for(ri i=0;i&lt;len;++i) Add(res,mul(mul(c,fac[i]),H[i])); cout&lt;&lt;res; return 0;&#125;","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://ldxcaicai.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"杂题乱做 Round11","slug":"sol11","date":"2019-12-24T15:12:07.000Z","updated":"2019-12-25T00:05:39.723Z","comments":true,"path":"sol11/","link":"","permalink":"http://ldxcaicai.github.io/sol11/","excerpt":"","text":"Triple 解题思路： 还是跟 黎明前的巧克力 差不多，构造集合幂级数，那么答案等于 ∏i=1n(axXi+bxYi+cxZi)\\prod\\limits_{i=1}^n(ax^{X_i}+bx^{Y_i}+cx^{Z_i})i=1∏n​(axXi​+bxYi​+cxZi​) ，这样每一个式子对答案的贡献一定是 ±a±b±c\\pm a\\pm b\\pm c±a±b±c ，但直接 fwtfwtfwt 之后解方程常数实在太大，考虑优化，发现可以把式子改写成 ∑i=1n(a+bYi⊕Xi+cZi⊕Xi)\\sum\\limits_{i=1}^n(a+b^{Y_i\\oplus X_i}+c^{Z_i\\oplus X_i})i=1∑n​(a+bYi​⊕Xi​+cZi​⊕Xi​) 最后给结果异或上 ⊕i=1nXi\\oplus_{i=1}^nX_i⊕i=1n​Xi​ ，显然上述两种方式得到的结果是一样的，那么这次每个式子对答案的贡献就是 a±b±ca\\pm b\\pm ca±b±c ，于是就如同前置题目一样分别把 ∑i=1nxYi⊕Xi,∑i=1nxZi⊕Xi,∑i=1nxYi⊕Zi\\sum\\limits_{i=1}^nx^{Y_i\\oplus X_i},\\sum\\limits_{i=1}^nx^{Z_i\\oplus X_i},\\sum\\limits_{i=1}^nx^{Y_i\\oplus Z_i}i=1∑n​xYi​⊕Xi​,i=1∑n​xZi​⊕Xi​,i=1∑n​xYi​⊕Zi​ 给 dwtdwtdwt 掉，算成正确点值之后再 idwtidwtidwt 回去就行了 CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;#define ri register inttypedef long long ll;using namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() &#123; int ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular &#123; const int mod=998244353; inline int add(int a,int b) &#123; return a+b&lt;mod?a+b:a+b-mod; &#125; inline int dec(int a,int b) &#123; return a&lt;b?a-b+mod:a-b; &#125; inline int mul(int a,int b) &#123; return (ll)a*b%mod; &#125; inline void Add(int&amp;a,int b) &#123; a=a+b&lt;mod?a+b:a+b-mod; &#125; inline void Dec(int&amp;a,int b) &#123; a=a&lt;b?a-b+mod:a-b; &#125; inline void Mul(int&amp;a,int b) &#123; a=(ll)a*b%mod; &#125; inline int ksm(int a,int p) &#123; int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; &#125; inline int Inv(int a) &#123; return ksm(a,mod-2); &#125;&#125;using namespace modular;const int N=1e6+5;int lim,n,X,Y,Z,vl[4],a[N],b[N],c[N];inline void dwt(int*a,int typ) &#123; for(ri i=1,a0,a1,iv=mod+1&gt;&gt;1;i&lt;lim;i&lt;&lt;=1)for(ri j=0,len=i&lt;&lt;1;j&lt;lim;j+=len) for(ri k=0;k&lt;i;++k) &#123; a0=a[j+k],a1=a[j+k+i]; a[j+k]=add(a0,a1),a[j+k+i]=dec(a0,a1); if(typ==-1) Mul(a[j+k],iv),Mul(a[j+k+i],iv); &#125;&#125;int main() &#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),lim=1&lt;&lt;read(); X=read(),Y=read(),Z=read(); int ss=0; for(ri i=1,_a,_b,_c;i&lt;=n;++i) &#123; _a=read(),_b=read()^_a,_c=read()^_a; ss^=_a; ++a[_b^_c],++b[_b],++c[_c]; &#125; dwt(a,1),dwt(b,1),dwt(c,1); vl[0]=add(X,add(Y,Z)); vl[1]=add(X,dec(Y,Z)); vl[2]=add(X,dec(Z,Y)); vl[3]=dec(X,add(Y,Z)); for(ri iv=Inv(4),x,y,z,w,i=0;i&lt;lim;++i) &#123; x=mul(iv,add(add(n,a[i]),add(b[i],c[i]))); y=mul(iv,dec(add(n,b[i]),add(c[i],a[i]))); z=mul(iv,dec(add(n,c[i]),add(b[i],a[i]))); w=mul(iv,dec(add(n,a[i]),add(b[i],c[i]))); a[i]=mul(mul(ksm(vl[0],x),ksm(vl[1],y)),mul(ksm(vl[2],z),ksm(vl[3],w))); &#125; dwt(a,-1); for(ri i=0;i&lt;lim;++i) cout&lt;&lt;a[i^ss]&lt;&lt;' '; return 0;&#125; 小 Y 的背包计数问题 解题思路： 对于第 iii 种物品，如果按照模 iii 的余数记录前缀和做背包 DPDPDP 的话复杂度是 O(ni)O(ni)O(ni) 的，那么考虑对前 KKK 种物品按照上述做法进行背包，那么后面的物品最多能选 nK\\frac nKKn​ 个，所以考虑如下 DPDPDP ，设后面所有物品一共选了 iii 个，总和为 jjj 的方案数，对于转移作如下考虑，我们想象这 iii 个物品排好序放在一个序列上，现在有两种操作： 在队首插入一个大小为 K+1K+1K+1 的物品 给当前所有物品权值+1 这样能做到不重不漏，复杂度为 O(n2K)O(\\frac{n^2}K)O(Kn2​) ，因此 KKK 取 n\\sqrt nn​ 时最优 CODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() &#123; int ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular &#123; const int mod=23333333; inline int add(int a,int b) &#123; return a+b&lt;mod?a+b:a+b-mod; &#125; inline int dec(int a,int b) &#123; return a&lt;b?a-b+mod:a-b; &#125; inline int mul(int a,int b) &#123; return (ll)a*b%mod; &#125; inline void Add(int&amp;a,int b) &#123; a=a+b&lt;mod?a+b:a+b-mod; &#125; inline void Dec(int&amp;a,int b) &#123; a=a&lt;b?a-b+mod:a-b; &#125; inline void Mul(int&amp;a,int b) &#123; a=(ll)a*b%mod; &#125; inline int ksm(int a,int p) &#123; int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; &#125; inline int Inv(int a) &#123; return ksm(a,mod-2); &#125;&#125;using namespace modular;const int N=1e5+5;int f[2][N],cur,g[350][N],n,sum[350],ss[N];int main() &#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); f[cur=0][0]=1; int res=0,sig=sqrt(n); for(ri x,id=1;id&lt;=sig;++id) &#123; x=id*id; cur^=1; for(ri i=0;i&lt;id;++i) sum[i]=0; for(ri i=0,t=0;i&lt;=n;++i,t=t==id-1?0:t+1) &#123; Add(sum[t],f[cur^1][i]); f[cur][i]=sum[t]; if(i&gt;=x) Dec(sum[t],f[cur^1][i-x]); &#125; &#125; g[0][0]=1; for(ri i=0;i&lt;=sig;++i) for(ri j=0;j&lt;=n;++j) if(g[i][j]) &#123; if(i&amp;&amp;i+j&lt;=n) Add(g[i][j+i],g[i][j]); if(j+sig+1&lt;=n) Add(g[i+1][j+sig+1],g[i][j]); if(j) Add(ss[j],g[i][j]); &#125; ss[0]=1; for(ri i=0;i&lt;=n;++i) Add(res,mul(ss[i],f[cur][n-i])); cout&lt;&lt;res; return 0;&#125; 最大前缀和 解题思路： 暴力枚举每种前缀的集合为最大前缀和的答案那么后面填上的数组成的任意前缀和都必须小于0，把这个方案数设为 ggg 类似考虑一个集合作为最大前缀和，把这个序列反过来，则一定不存在前缀和小于0，于是同理定义一个 fff ，把这两个状压 dpdpdp 出来即可 CODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() &#123; int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch)) f^=ch=='-',ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;namespace modular &#123; const int mod=998244353; inline int add(int a,int b) &#123; return a+b&lt;mod?a+b:a+b-mod; &#125; inline int dec(int a,int b) &#123; return a&lt;b?a-b+mod:a-b; &#125; inline int mul(int a,int b) &#123; return (ll)a*b%mod; &#125; inline void Add(int&amp;a,int b) &#123; a=a+b&lt;mod?a+b:a+b-mod; &#125; inline void Dec(int&amp;a,int b) &#123; a=a&lt;b?a-b+mod:a-b; &#125; inline void Mul(int&amp;a,int b) &#123; a=(ll)a*b%mod; &#125; inline int ksm(int a,int p) &#123; int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; &#125; inline int Inv(int a) &#123; return ksm(a,mod-2); &#125; inline int fix(int a) &#123; return (a%mod+mod)%mod; &#125;&#125;using namespace modular;const int N=25;int n,lim;ll s1[1&lt;&lt;20];int s2[1&lt;&lt;20],f[1&lt;&lt;20],g[1&lt;&lt;20];inline void fmt(ll*a1,int*a2) &#123; for(ri i=1;i&lt;lim;i&lt;&lt;=1) for(ri j=0,len=i&lt;&lt;1;j&lt;lim;j+=len) for(ri k=0;k&lt;i;++k) s1[j+k+i]+=s1[j+k],Add(s2[j+k+i],s2[j+k]);&#125;int main() &#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),lim=1&lt;&lt;n; for(ri i=0;i&lt;n;++i) s1[1&lt;&lt;i]=read(),s2[1&lt;&lt;i]=fix(s1[1&lt;&lt;i]),f[1&lt;&lt;i]=1; fmt(s1,s2); g[0]=1; for(ri i=1;i&lt;lim;++i) &#123; if(s1[i]&gt;=0) &#123; for(ri j=0;j&lt;n;++j) if(!(i&gt;&gt;j&amp;1)) Add(f[i|(1&lt;&lt;j)],f[i]); &#125; else for(ri j=0;j&lt;n;++j) if(i&gt;&gt;j&amp;1) Add(g[i],g[i^(1&lt;&lt;j)]); &#125; int res=0; for(ri i=1;i&lt;lim;++i) Add(res,mul(mul(s2[i],f[i]),g[(lim-1)^i])); cout&lt;&lt;res; return 0;&#125; Chef and Horcrux 解题思路： 先简单求出 mexmexmex 为 iii 的子序列个数，然后直接 KKK 进制 fwtfwtfwt 转点值，然后快速幂一下再转回去统计答案就完了 CODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() &#123; int ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl() &#123; ll ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular &#123; const int mod=330301441; inline int add(int a,int b) &#123; return a+b&lt;mod?a+b:a+b-mod; &#125; inline int dec(int a,int b) &#123; return a&lt;b?a-b+mod:a-b; &#125; inline int mul(int a,int b) &#123; return (ll)a*b%mod; &#125; inline void Add(int&amp;a,int b) &#123; a=a+b&lt;mod?a+b:a+b-mod; &#125; inline void Dec(int&amp;a,int b) &#123; a=a&lt;b?a-b+mod:a-b; &#125; inline void Mul(int&amp;a,int b) &#123; a=(ll)a*b%mod; &#125; inline int ksm(int a,int p) &#123; int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; &#125; inline int Inv(int a) &#123; return ksm(a,mod-2); &#125;&#125;using namespace modular;const int N=1e5+5;int n,K,X,pw[N],inv[11],a[N&lt;&lt;4],cnt[N],mx,lim,w[11][11];inline void init() &#123; pw[0]=1; for(ri i=1;i&lt;=100000;++i) pw[i]=add(pw[i-1],pw[i-1]); inv[1]=1; for(ri i=2;i&lt;11;++i) &#123; inv[i]=mul(inv[mod-mod/i*i],mod-mod/i),w[i][0]=1,w[i][1]=ksm(3,(mod-1)/(i&lt;&lt;1)); for(ri j=2;j&lt;i;++j) w[i][j]=mul(w[i][j-1],w[i][1]); &#125;&#125;inline void fft(int*a,int typ) &#123; static int sum[11]; for(ri j=0;j&lt;K;++j) if(a[j]) for(ri i=0,t=0;i&lt;K;++i,t=t+j&lt;K?t+j:t+j-K) Add(sum[i],mul(a[j],w[K][t])); for(ri i=0;i&lt;K;++i) a[i]=sum[i],sum[i]=0; if(~typ) return; for(ri i=1;i+i&lt;K;++i) swap(a[i],a[K-i]); for(ri i=0;i&lt;K;++i) Mul(a[i],inv[K]);&#125;inline void fwt(int*a,int typ) &#123; static int cur[11]; for(ri i=1;i&lt;lim;i*=K) for(ri j=0,len=i*K;j&lt;lim;j+=len) for(ri k=0;k&lt;i;++k) &#123; for(ri o=0;o&lt;K;++o) cur[o]=a[o*i+j+k]; fft(cur,typ); for(ri o=0;o&lt;K;++o) a[o*i+j+k]=cur[o]; &#125;&#125;int main() &#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif init(); for(ri ps,tt=read();tt;--tt) &#123; n=read(),K=read(),X=readl()%(mod-1); mx=0; for(ri i=1,x;i&lt;=n;++i) x=read(),++cnt[x],mx=max(mx,x); ++mx; for(ri i=0,pre=0,premt=1;i&lt;=mx;++i) &#123; pre+=cnt[i]; a[i]=mul(premt,pw[n-pre]); if(!cnt[i]) &#123; ps=i;break; &#125; Mul(premt,dec(pw[cnt[i]],1)); &#125; for(lim=1;lim&lt;=ps;lim*=K); int res=0,ss=ksm(Inv(pw[n]),X); fwt(a,1); for(ri i=0;i&lt;lim;++i) a[i]=ksm(a[i],X); fwt(a,-1); for(ri i=0;i&lt;lim;++i) if(a[i]) Mul(a[i],ss),Add(res,mul(ksm(i,2*i),ksm(a[i],3*i))),a[i]=0; cout&lt;&lt;res&lt;&lt;'\\n'; for(ri i=0;i&lt;=mx;++i) cnt[i]=0; &#125; return 0;&#125; 生成树求和 解题思路： 主要是得观察到可以按位考虑，那么每一位本来应该是做不进位加法但是矩阵树只能做乘法，因此我们将其转为点值，矩阵树之后再转回来即可 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() &#123; int ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular &#123; const int mod=1e9+7,iv3=(mod+1)/3; inline int add(int a,int b) &#123; return a+b&lt;mod?a+b:a+b-mod; &#125; inline int dec(int a,int b) &#123; return a&lt;b?a-b+mod:a-b; &#125; inline int mul(int a,int b) &#123; return (ll)a*b%mod; &#125; inline void Add(int&amp;a,int b) &#123; a=a+b&lt;mod?a+b:a+b-mod; &#125; inline void Dec(int&amp;a,int b) &#123; a=a&lt;b?a-b+mod:a-b; &#125; inline void Mul(int&amp;a,int b) &#123; a=(ll)a*b%mod; &#125; inline int ksm(int a,int p) &#123; int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; &#125; inline int Inv(int a) &#123; return ksm(a,mod-2); &#125; inline int fix(int a) &#123; return (a%mod+mod)%mod; &#125;&#125;using namespace modular;struct cp &#123; int a,b; cp(int a=0,int b=0):a(a),b(b) &#123;&#125; friend inline cp operator+(cp a, cp b) &#123; return cp(add(a.a,b.a),add(a.b,b.b)); &#125; friend inline void operator+=(cp&amp;a,cp b) &#123; a=a+b; &#125; friend inline cp operator-(cp a,cp b) &#123; return cp(dec(a.a,b.a),dec(a.b,b.b)); &#125; friend inline void operator-=(cp&amp;a,cp b) &#123; a=a-b; &#125; friend inline cp operator*(cp a,cp b) &#123; return cp(dec(mul(a.a,b.a),mul(a.b,b.b)),dec(add(mul(a.a,b.b),mul(a.b,b.a)),mul(a.b,b.b))); &#125; friend inline void operator*=(cp&amp;a,cp b) &#123; a=a*b; &#125; friend inline cp operator*(cp a,int b) &#123; return cp(mul(a.a,b),mul(a.b,b)); &#125; friend inline void operator*=(cp&amp;a,int b) &#123; a=a*b; &#125; inline cp inv() const &#123; return cp(dec(a,b),mod-b)*Inv(dec(add(mul(a,a),mul(b,b)),mul(a,b))); &#125; friend inline cp operator/(cp a,cp b) &#123; return a*(b.inv()); &#125; friend inline void operator/=(cp&amp;a,cp b) &#123; a=a/b; &#125; friend inline bool operator!=(cp a,cp b) &#123; return a.a^b.a||a.b^b.b; &#125;&#125;w[3];const int N=105;int n,m;cp a[N][N];struct edge&#123; int u,v,w; edge(int u=0,int v=0,int w=0):u(u),v(v),w(w) &#123;&#125;&#125;e[N*N&gt;&gt;1];inline cp Det() &#123; cp res(1,0),iv,t; vector&lt;int&gt;pos; for(ri ps,i=1;i&lt;n;++i) &#123; for(ps=i;ps&lt;n;++ps) if(a[ps][i]!=cp(0,0)) break; if(ps==n) &#123; res=cp(0,0);break; &#125; if(ps&gt;i) &#123; res=cp(mod-res.a,mod-res.b); for(ri j=1;j&lt;n;++j) swap(a[i][j],a[ps][j]); &#125; pos.clear(); for(ri j=i;j&lt;n;++j) if(a[i][j]!=cp(0,0)) pos.pb(j); iv=a[i][i].inv(); for(ri j=i,up=pos.size();j&lt;n;++j) if(a[j][i]!=cp(0,0)&amp;&amp;j!=i) &#123; t=iv*a[j][i]; for(ri k=0;k&lt;up;++k) a[j][pos[k]]-=a[i][pos[k]]*t; &#125; res*=a[i][i]; &#125; for(ri i=1;i&lt;n;++i) for(ri j=1;j&lt;n;++j) a[i][j]=cp(0,0); return res;&#125;cp cur[3];int vl[N*N&gt;&gt;1];inline void idft() &#123; static cp sum[3]; for(ri j=0;j&lt;3;++j) for(ri i=0;i&lt;3;++i) sum[i]+=cur[j]*w[i*j&lt;3?i*j:i*j-3]; for(ri i=0;i&lt;3;++i) cur[i]=sum[i]*iv3,sum[i]=cp(0,0); swap(cur[1],cur[2]);&#125;inline int calc() &#123; return add(cur[1].a,add(cur[2].a,cur[2].a)); &#125;int main() &#123; freopen(\"sum.in\",\"r\",stdin); freopen(\"sum.out\",\"w\",stdout); n=read(),m=read(); w[0]=cp(1,0); w[1]=cp(0,1); w[2]=cp(mod-1,mod-1); int mx=0,res=0; for(ri i=1;i&lt;=m;++i) e[i].u=read(),e[i].v=read(),e[i].w=read(),mx=max(mx,e[i].w); cp t; for(ri i=1;i&lt;=mx;i*=3) &#123; for(ri j=1;j&lt;=m;++j) vl[j]=e[j].w/i%3; for(ri o=0;o&lt;3;++o) &#123; for(ri j=1;j&lt;=m;++j) &#123; t=w[vl[j]*o%3]; a[e[j].u][e[j].u]+=t; a[e[j].v][e[j].v]+=t; a[e[j].u][e[j].v]-=t; a[e[j].v][e[j].u]-=t; &#125; cur[o]=Det(); &#125; idft(),Add(res,mul(i,calc())); &#125; cout&lt;&lt;res; return 0;&#125; Petya and Sequence 解题思路： 考虑如何判定，发现把 BBB 给 reversereversereverse 过来就是在做循环卷积，那么相当于是问将 AAA 在转点值之后有没有零项，于是莽一个 Bluestein′s algorithmBluestein&#x27;s\\ algorithmBluestein′s algorithm 就行了 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef vector&lt;int&gt; poly;#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() &#123; int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch)) f^=ch=='-',ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;namespace modular &#123; int mod; inline int add(int a,int b) &#123; return a+b&lt;mod?a+b:a+b-mod; &#125; inline int dec(int a,int b) &#123; return a&lt;b?a-b+mod:a-b; &#125; inline int mul(int a,int b) &#123; return (ll)a*b%mod; &#125; inline void Add(int&amp;a,int b) &#123; a=a+b&lt;mod?a+b:a+b-mod; &#125; inline void Dec(int&amp;a,int b) &#123; a=a&lt;b?a-b+mod:a-b; &#125; inline void Mul(int&amp;a,int b) &#123; a=(ll)a*b%mod; &#125; inline int ksm(int a,int p) &#123; int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; &#125; inline int Inv(int a) &#123; return ksm(a,mod-2); &#125; inline int fix(int a) &#123; return (a%mod+mod)%mod; &#125;&#125;using namespace modular;const int N=30005;int iv1,iv2;int vl[N],n,G,pri[1000005],tot=0,omega[N&lt;&lt;1];bool vs[10000005];inline int C2(int x) &#123; return (ll)x*(x-1)/2%n; &#125;struct Ntt &#123; int mod,g,lim,tim; inline int add(int a,int b) &#123; return a+b&lt;mod?a+b:a+b-mod; &#125; inline int dec(int a,int b) &#123; return a&lt;b?a-b+mod:a-b; &#125; inline int mul(int a,int b) &#123; return (ll)a*b%mod; &#125; inline void Add(int&amp;a,int b) &#123; a=a+b&lt;mod?a+b:a+b-mod; &#125; inline void Dec(int&amp;a,int b) &#123; a=a&lt;b?a-b+mod:a-b; &#125; inline void Mul(int&amp;a,int b) &#123; a=(ll)a*b%mod; &#125; inline int ksm(int a,int p) &#123; int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; &#125; inline int Inv(int a) &#123; return ksm(a,mod-2); &#125; inline int fix(int a) &#123; return (a%mod+mod)%mod; &#125; int w[19],invv[19]; vector&lt;int&gt;rev[19]; inline void init_ntt() &#123; invv[0]=1; for(ri iv=mod+1&gt;&gt;1,i=1;i&lt;19;++i) invv[i]=mul(invv[i-1],iv); w[18]=ksm(g,(mod-1)&gt;&gt;19); for(ri i=17;~i;--i) w[i]=mul(w[i+1],w[i+1]); &#125; inline void init(int up) &#123; lim=1,tim=0; while(lim&lt;up) lim&lt;&lt;=1,++tim; if(rev[tim].size()) return; rev[tim].resize(lim); for(ri i=1;i&lt;lim;++i) rev[tim][i]=(rev[tim][i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(tim-1)); &#125; inline void ntt(poly&amp;a,int typ) &#123; for(ri i=1;i&lt;lim;++i) if(i&lt;rev[tim][i]) swap(a[i],a[rev[tim][i]]); for(ri i=1,t=0,a0,a1,mt;i&lt;lim;i&lt;&lt;=1,++t) for(ri j=0,len=i&lt;&lt;1;j&lt;lim;j+=len) &#123; mt=1; for(ri k=0;k&lt;i;++k,Mul(mt,w[t])) &#123; a0=a[j+k],a1=mul(mt,a[j+k+i]); a[j+k]=add(a0,a1),a[j+k+i]=dec(a0,a1); &#125; &#125; if(~typ) return; reverse(++a.begin(),a.end()); for(ri i=0;i&lt;lim;++i) Mul(a[i],invv[tim]); &#125; inline poly trans(poly a) &#123; poly b; int t=a.size(); init(t); a.resize(lim),ntt(a,1); b.resize(lim); for(ri i=0;i&lt;n;++i) b[i]=omega[((n&lt;&lt;1)-((ll)i*i%(n&lt;&lt;1)))%(n&lt;&lt;1)],i&amp;&amp;(b[lim-i]=b[i]); ntt(b,1); for(ri i=0;i&lt;lim;++i) Mul(a[i],b[i]); return ntt(a,-1),a.resize(t),a; &#125;&#125;A,B;inline void init_prime() &#123; for(ri i=2;i&lt;=10000000;++i) &#123; if(!vs[i]) pri[++tot]=i; for(ri j=1,up=10000000/i;j&lt;=tot&amp;&amp;pri[j]&lt;=up;++j) &#123; vs[i*pri[j]]=1; if(i==i/pri[j]*pri[j]) break; &#125; &#125;&#125;inline bool check(int x) &#123; for(ri i=1,lm=sqrt(x);i&lt;=tot&amp;&amp;pri[i]&lt;=lm;++i) if(x==x/pri[i]*pri[i]) return 0; return 1;&#125;inline void find_G() &#123; vector&lt;int&gt;divv; int cur=mod-1; for(ri i=2,lm=sqrt(cur);i&lt;=lm;++i) &#123; if(cur!=cur/i*i) continue; divv.pb(i); if(i*i!=cur) divv.pb(cur/i); &#125; for(G=2;;++G) &#123; bool ff=1; for(ri i=(int)divv.size()-1;~i;--i) if(ksm(G,divv[i])==1) &#123; ff=0;break; &#125; if(ff) break; &#125;&#125;inline ll ksc(ll a,ll b,ll mod) &#123; return a*b-(ll)((long double)a/mod*b+1e-8)*mod; &#125;inline void dft() &#123; poly a(n&lt;&lt;1),rsa,rsb; for(ri i=0;i&lt;n;++i) a[i]=mul(fix(vl[i]),omega[(ll)i*i%(n&lt;&lt;1)]); rsa=A.trans(a),rsb=B.trans(a); ll md=(ll)A.mod*B.mod; for(ri i=0;i&lt;n;++i) vl[i]=(ksc((ll)rsa[i]*iv1,B.mod,md)+ksc((ll)rsb[i]*iv2,A.mod,md))%md%mod*omega[C2(i)]%mod;&#125;int main() &#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif A.mod=998244353,A.g=3,A.init_ntt(); B.mod=1005060097,B.g=5,B.init_ntt(); iv1=A.Inv(B.mod),iv2=B.Inv(A.mod); init_prime(); for(ri tt=read();tt;--tt) &#123; n=read(); for(ri i=0;i&lt;n;++i) vl[i]=read(); mod=10000000/(n&lt;&lt;1)*(n&lt;&lt;1)+1; while(!check(mod)) mod+=n&lt;&lt;1; find_G(); omega[0]=1,omega[1]=ksm(G,(mod-1)/(n&lt;&lt;1)); for(ri i=2;i&lt;(n&lt;&lt;1);++i) omega[i]=mul(omega[i-1],omega[1]); dft(); bool ff=0; for(ri i=0;i&lt;n;++i) if(!vl[i]) &#123; ff=1;break; &#125; puts(ff?\"YES\":\"NO\"); &#125; return 0;&#125; Call It What You Want 解题思路： 大概考察了分圆多项式和莫比乌斯函数的一些小性质 首先设 fn(x)=xn−1f_n(x)=x^n-1fn​(x)=xn−1 ，那么有 fn(x)=∏d∣nΦd(x)f_n(x)=\\prod\\limits_{d|n}\\Phi_d(x)fn​(x)=d∣n∏​Φd​(x) ，进行多项式取对， ln⁡(xn−1)=∑d∣nln⁡(Φd(x))\\ln (x^n-1)=\\sum\\limits_{d|n}\\ln(\\Phi_d(x))ln(xn−1)=d∣n∑​ln(Φd​(x)) 然后莫比乌斯反演一下： ln⁡(Φn(x))=∑d∣nμ(d)ln⁡(xnd−1)\\ln(\\Phi_n(x))=\\sum\\limits_{d|n}\\mu(d)\\ln(x^{\\frac nd}-1)ln(Φn​(x))=d∣n∑​μ(d)ln(xdn​−1) 然后 expexpexp 回去： Φn(x)=∏d∣n(xd−1)μ(nd)\\Phi_n(x)=\\prod\\limits_{d|n}(x^d-1)^{\\mu(\\frac nd)}Φn​(x)=d∣n∏​(xd−1)μ(dn​) 考虑到 μ(x)\\mu(x)μ(x) 只在 xxx 没有平方因子的时候有贡献，而 2×3×5×7×11×13≤100000≤2×3×5×7×11×13×172\\times3\\times5\\times7\\times11\\times13\\le100000\\le2\\times3\\times5\\times7\\times11\\times13\\times172×3×5×7×11×13≤100000≤2×3×5×7×11×13×17 ，因此可以暴力状压每个数的有贡献的约数 CODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() &#123; int ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;const int N=1e5+5;int phi[N],pri[N&gt;&gt;2],tot=0,n;bool vs[N],vis[N];vector&lt;int&gt;divv[N],Phi[N];inline void init() &#123; phi[1]=1; for(ri i=2;i&lt;=100000;++i) &#123; if(!vs[i]) &#123; pri[++tot]=i,phi[i]=i-1; for(ri j=i;j&lt;=100000;j+=i) divv[j].pb(i); &#125; for(ri j=1,up=100000/i;j&lt;=tot&amp;&amp;pri[j]&lt;=up;++j) &#123; vs[i*pri[j]]=1; if(i==i/pri[j]*pri[j]) &#123; phi[i*pri[j]]=phi[i]*pri[j];break; &#125; phi[i*pri[j]]=phi[i]*(pri[j]-1); &#125; &#125;&#125;inline bool cmp(int a,int b) &#123; if(phi[a]^phi[b]) return phi[a]&lt;phi[b]; for(ri i=phi[a];~i;--i) if(Phi[a][i]^Phi[b][i]) return Phi[a][i]&lt;Phi[b][i]; return 1;&#125;int main() &#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif init(); for(ri tt=read();tt;--tt) &#123; n=read(); vector&lt;int&gt;id; for(ri i=1;i&lt;=n;++i) if(n==n/i*i) &#123; id.pb(i); if(vis[i]) continue; vis[i]=1; Phi[i].resize(phi[i]+1); Phi[i][0]=i&gt;1?1:-1; for(ri ct,x,s=0,lm=(int)divv[i].size();s&lt;(1&lt;&lt;lm);++s) &#123; ct=0,x=i; for(ri j=0;j&lt;lm;++j) if(s&gt;&gt;j&amp;1) ct^=1,x/=divv[i][j]; if(!ct) for(ri j=phi[i];j&gt;=x;--j) Phi[i][j]-=Phi[i][j-x]; else for(ri j=x;j&lt;=phi[i];++j) Phi[i][j]+=Phi[i][j-x]; &#125; &#125; sort(id.begin(),id.end(),cmp); for(ri i=0,x;i&lt;(int)id.size();++i) &#123; putchar('('); x=id[i]; for(ri j=phi[x];~j;--j) &#123; if(!Phi[x][j]) continue; if(Phi[x][j]&gt;0&amp;&amp;j!=phi[x]) putchar('+'); if(j&amp;&amp;Phi[x][j]==-1) putchar('-'); if(!j||Phi[x][j]&gt;1||Phi[x][j]&lt;-1) cout&lt;&lt;Phi[x][j]; if(j) putchar('x'); if(j&gt;1) putchar('^'),cout&lt;&lt;j; &#125; putchar(')'); &#125; puts(\"\"); &#125; return 0;&#125;","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://ldxcaicai.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"杂题乱做 Round10","slug":"sol10","date":"2019-12-19T02:10:32.000Z","updated":"2019-12-26T04:22:28.729Z","comments":true,"path":"sol10/","link":"","permalink":"http://ldxcaicai.github.io/sol10/","excerpt":"","text":"机器人高尔夫球赛 解题思路： 首先暴力 dpdpdp 设 fi,jf_{i,j}fi,j​ 表示先手在 (i,j)(i,j)(i,j) 处出发的结果直接转移。 然后考虑优化这个做法。打表会发现对于大部分格子，都有 fi,j=fi+1,j+1f_{i,j}=f_{i+1,j+1}fi,j​=fi+1,j+1​ ，认真思考后会发现如果格子 (i,j)(i,j)(i,j) 满足跟它曼哈顿距离不超过 222 的部分都没有标记那么 fi,j=fi+1,j+1f_{i,j}=f_{i+1,j+1}fi,j​=fi+1,j+1​ 那么暴力 dpdpdp 需要特殊处理的格子的值，用 mapmapmap 记录每条对角线的答案即可快速转移 CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;int,pii&gt; ppp;typedef map&lt;int,ppp&gt;::iterator It;#define fi first#define se second#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;namespace modular&#123; const int mod=998244353; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int fix(int a)&#123;return (a%mod+mod)%mod;&#125;&#125;using namespace modular;const int N=1e5+5;map&lt;pii,bool&gt;vs;map&lt;int,ppp&gt;F;map&lt;pii,pii&gt;mn_mx;vector&lt;pii&gt;ps;int n,m,K,res=0;inline void DP(int x,int y)&#123; if(F.count(x-y))Add(res,mul(dec(F[x-y].fi,x),fix(F[x-y].se.fi))); F[x-y]=ppp(x,mn_mx[pii(x,y)]);&#125;inline pii calc(int x,int y)&#123;return F.count(x-y)?F[x-y].se:pii(0,0);&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),m=read(),K=read(); for(ri x,y,v,i=1;i&lt;=K;++i)&#123; x=read(),y=read(),v=read(); vs[pii(x,y)]=1; mn_mx[pii(x,y)]=pii(v,v); for(ri dx=0;dx&lt;=2&amp;&amp;dx&lt;x;++dx)for(ri dy=0;dy&lt;=2-dx&amp;&amp;dy&lt;y;++dy) ps.pb(pii(x-dx,y-dy)); &#125; sort(ps.begin(),ps.end()); ps.erase(unique(ps.begin(),ps.end()),ps.end()); pii rgt,dwn; for(ri x,y,t=(int)ps.size()-1;~t;--t)&#123; x=ps[t].fi,y=ps[t].se; if(!vs[pii(x,y)])&#123; rgt=calc(x,y+1); dwn=calc(x+1,y); mn_mx[pii(x,y)]=pii(min(rgt.se,dwn.se),max(rgt.fi,dwn.fi)); &#125; DP(x,y); &#125; ppp cur; for(It it=F.begin();it!=F.end();++it)&#123; cur=it-&gt;se; Add(res,mul(fix(min(cur.fi,cur.fi-it-&gt;fi)),fix(cur.se.fi))); &#125; cout&lt;&lt;res; return 0;&#125; 有标号的DAG计数 IV 解题思路： 可能得先会前三道 DAGDAGDAG 计数，先考虑简单的问题，如果不要求连通怎么做，发现是个常见套路，枚举入度为 000 的点然后容斥即可： fi=∑j=1ifi−j2j(i−j)(−1)i+1fi=∑j=0i−1fj2i2−j2−(i−j)2(−1)i−j+1fi2i2=∑j=0i−1fj2j2(−1)i−j+12(i−j)2构造F(x)=∑i=0+∞fi2i2xi,G(x)=∑i=1+∞(−1)i+12i2F=F×G+1F=11−G\\begin{aligned} f_i=&amp;\\sum\\limits_{j=1}^if_{i-j}2^{j(i-j)}(-1)^{i+1}\\\\ f_i=&amp;\\sum\\limits_{j=0}^{i-1}f_j\\sqrt2^{i^2-j^2-(i-j)^2}(-1)^{i-j+1}\\\\ \\frac{f_i}{\\sqrt2^{i^2}}=&amp;\\sum\\limits_{j=0}^{i-1}\\frac{f_j}{\\sqrt2^{j^2}}\\frac{(-1)^{i-j+1}}{\\sqrt2^{(i-j)^2}}\\\\ 构造F(x)=&amp;\\sum\\limits_{i=0}^{+\\infty}\\frac{f_i}{\\sqrt2^{i^2}}x^i,G(x)=\\sum\\limits_{i=1}^{+\\infty}\\frac{(-1)^{i+1}}{\\sqrt2^{i^2}}\\\\ F=&amp;F\\times G+1\\\\ F=&amp;\\frac{1}{1-G} \\end{aligned} fi​=fi​=2​i2fi​​=构造F(x)=F=F=​j=1∑i​fi−j​2j(i−j)(−1)i+1j=0∑i−1​fj​2​i2−j2−(i−j)2(−1)i−j+1j=0∑i−1​2​j2fj​​2​(i−j)2(−1)i−j+1​i=0∑+∞​2​i2fi​​xi,G(x)=i=1∑+∞​2​i2(−1)i+1​F×G+11−G1​​ 这样能够在 O(nlog⁡n)O(n\\log n)O(nlogn) 的时间内求出 fff 接下来就有两种思路了，第一种是利用补集转化的思想，设答案等于 gig_igi​ ，那么 gi=fi−∑j=1i−1gjfi−j(i−1j−1)g_i=f_i-\\sum\\limits_{j=1}^{i-1}g_jf_{i-j}\\binom{i-1}{j-1}gi​=fi​−j=1∑i−1​gj​fi−j​(j−1i−1​) 然后一波化简上多项式求逆 第二种也挺容易想到的，设 GGG 为答案的生成函数，显然有 eG=Fe^G=FeG=F ，那么写个多项式取对即可 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef vector&lt;int&gt; poly;#define pb push_backnamespace modular &#123; const int mod=998244353,sqr2=116195171; inline int add(int a,int b) &#123; return a+b&lt;mod?a+b:a+b-mod; &#125; inline int dec(int a,int b) &#123; return a&lt;b?a-b+mod:a-b; &#125; inline int mul(int a,int b) &#123; return (ll)a*b%mod; &#125; inline void Add(int&amp;a,int b) &#123; a=a+b&lt;mod?a+b:a+b-mod; &#125; inline void Dec(int&amp;a,int b) &#123; a=a&lt;b?a-b+mod:a-b; &#125; inline void Mul(int&amp;a,int b) &#123; a=(ll)a*b%mod; &#125; inline int ksm(int a,int p) &#123; int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; &#125; inline int Inv(int a) &#123; return ksm(a,mod-2); &#125;&#125;using namespace modular;const int N=500005;int n,invv[23],w[23],lim,tim,inv[N],fac[N],ifac[N];vector&lt;int&gt;rev[23];inline int C(int n,int m) &#123; return n&lt;m||m&lt;0?0:mul(fac[n],mul(ifac[n-m],ifac[m])); &#125;inline void init() &#123; fac[0]=fac[1]=ifac[0]=ifac[1]=inv[1]=1; for(ri i=2;i&lt;=500000;++i) &#123; fac[i]=mul(fac[i-1],i); inv[i]=mul(inv[mod-mod/i*i],mod-mod/i); ifac[i]=mul(ifac[i-1],inv[i]); &#125;&#125;inline void init_ntt() &#123; invv[0]=1,w[22]=ksm(3,(mod-1)&gt;&gt;23); for(ri i=1,iv=mod+1&gt;&gt;1;i&lt;23;++i) invv[i]=mul(invv[i-1],iv); for(ri i=21;~i;--i) w[i]=mul(w[i+1],w[i+1]);&#125;inline void init(int up) &#123; lim=1,tim=0; while(lim&lt;up) lim&lt;&lt;=1,++tim; if(rev[tim].size()) return; rev[tim].resize(lim); for(ri i=1;i&lt;lim;++i) rev[tim][i]=(rev[tim][i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(tim-1));&#125;inline void ntt(poly&amp;a,int typ) &#123; for(ri i=0;i&lt;lim;++i) if(i&lt;rev[tim][i]) swap(a[i],a[rev[tim][i]]); for(ri i=1,t=0,a0,a1,mt;i&lt;lim;i&lt;&lt;=1,++t) for(ri j=0,len=i&lt;&lt;1;j&lt;lim;j+=len) &#123; mt=1; for(ri k=0;k&lt;i;++k,Mul(mt,w[t])) &#123; a0=a[j+k],a1=mul(mt,a[j+k+i]); a[j+k]=add(a0,a1),a[j+k+i]=dec(a0,a1); &#125; &#125; if(~typ) return; reverse(++a.begin(),a.end()); for(ri i=0;i&lt;lim;++i) Mul(a[i],invv[tim]);&#125;inline poly operator*(poly a,poly b) &#123; int n=a.size(),m=b.size(),t=n+m-1; if(t&lt;=64) &#123; poly c(t); for(ri i=0;i&lt;n;++i) if(a[i]) for(ri j=0;j&lt;m;++j) Add(c[i+j],mul(a[i],b[j])); return c; &#125; init(t); a.resize(lim),ntt(a,1); b.resize(lim),ntt(b,1); for(ri i=0;i&lt;lim;++i) Mul(a[i],b[i]); return ntt(a,-1),a.resize(t),a;&#125;inline poly operator-(poly a,poly b) &#123; if((int)a.size()&lt;(int)b.size()) a.resize((int)b.size()); for(ri i=0,up=(int)b.size();i&lt;up;++i) Dec(a[i],b[i]); return a;&#125;inline poly poly_inv(poly a,int K) &#123; poly b(1,Inv(a[0])),c; for(ri i=1;i&lt;K;i&lt;&lt;=1) &#123; init(i&lt;&lt;2); c=a,c.resize(i&lt;&lt;1),c.resize(lim),ntt(c,1); b.resize(lim),ntt(b,1); for(ri j=0;j&lt;lim;++j) Mul(b[j],dec(2,mul(b[j],c[j]))); ntt(b,-1),b.resize(i&lt;&lt;1); &#125; return b.resize(K),b;&#125;inline poly poly_integ(poly a) &#123; a.pb(0); for(ri i=(int)a.size()-1;i;--i)a[i]=mul(a[i-1],inv[i]); return a[0]=0,a;&#125;inline poly poly_direv(poly a) &#123; for(ri i=1,up=(int)a.size();i&lt;up;++i) a[i-1]=mul(a[i],i); return a.pop_back(),a;&#125;inline poly poly_ln(poly a,int K) &#123; poly res=poly_integ(poly_direv(a)*poly_inv(a,K)); return res.resize(K),res;&#125;int main() &#123; freopen(\"dagIV.in\",\"r\",stdin); freopen(\"dagIV.out\",\"w\",stdout); cin&gt;&gt;n; init(); init_ntt(); poly f(n+1); for(ri t,i=0;i&lt;=n;++i) &#123; t=mul(ifac[i],Inv(ksm(sqr2,(ll)i*i%(mod-1)))); f[i]=t?(i&amp;1?mod-t:t):0; &#125; f=poly_inv(f,n+1); for(ri i=0;i&lt;=n;++i) Mul(f[i],ksm(sqr2,(ll)i*i%(mod-1))); f=poly_ln(f,n+1); cout&lt;&lt;mul(f[n],fac[n]); return 0;&#125; arewell 解题思路： 容斥的思想跟上面的求 fff 的一样，枚举入度为 000 的点，然后发现转移变成了枚举子集，直接用子集卷积优化即可 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef vector&lt;int&gt; poly;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() &#123; int ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular &#123; const int mod=998244353; inline int add(int a,int b) &#123; return a+b&lt;mod?a+b:a+b-mod; &#125; inline int dec(int a,int b) &#123; return a&lt;b?a-b+mod:a-b; &#125; inline int mul(int a,int b) &#123; return (ll)a*b%mod; &#125; inline void Add(int&amp;a,int b) &#123; a=a+b&lt;mod?a+b:a+b-mod; &#125; inline void Dec(int&amp;a,int b) &#123; a=a&lt;b?a-b+mod:a-b; &#125; inline void Mul(int&amp;a,int b) &#123; a=(ll)a*b%mod; &#125; inline int ksm(int a,int p) &#123; int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; &#125; inline int Inv(int a) &#123; return ksm(a,mod-2); &#125;&#125;using namespace modular;int n,m,lim,coe,all,pw[25],ppw[405];poly cnt,f[25],g[25],bitcnt;inline void fwt(poly&amp;a,int typ) &#123; for(ri a0,a1,iv=mod+1&gt;&gt;1,i=1;i&lt;lim;i&lt;&lt;=1) for(ri j=0,len=i&lt;&lt;1;j&lt;lim;j+=len) for(ri k=0;k&lt;i;++k) &#123; a0=a[j+k],a1=a[j+k+i]; a[j+k]=add(a0,a1),a[j+k+i]=dec(a0,a1); if(typ==-1) Mul(a[j+k],iv),Mul(a[j+k+i],iv); &#125;&#125;int main() &#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),m=read(); coe=mod+1&gt;&gt;1; pw[0]=1,ppw[0]=1; for(ri i=1;i&lt;=n;++i) pw[i]=pw[i-1]&lt;&lt;1; for(ri i=1;i&lt;=m;++i) ppw[i]=mul(ppw[i-1],coe); lim=pw[n],all=lim-1; cnt.resize(lim),bitcnt.resize(lim); for(ri i=0;i&lt;=n;++i) f[i].resize(lim),g[i].resize(lim); for(ri u,v,i=1;i&lt;=m;++i) &#123; u=read()-1,v=read()-1; for(ri s=all^pw[u]^pw[v],t=s;~t;t=t?(t-1)&amp;s:-1) ++cnt[t^pw[u]^pw[v]]; &#125; for(ri t,s=0;s&lt;lim;++s) &#123; bitcnt[s]=bitcnt[s&gt;&gt;1]+(s&amp;1); g[bitcnt[s]][s]=bitcnt[s]&amp;1?ppw[cnt[s]]:mod-ppw[cnt[s]]; &#125; for(ri i=0;i&lt;=n;++i) fwt(g[i],1); f[0][0]=1; fwt(f[0],1); for(ri i=0;i&lt;n;++i) for(ri s=0;s&lt;lim;++s) if(f[i][s]) for(ri j=1;i+j&lt;=n;++j) Add(f[i+j][s],mul(f[i][s],g[j][s])); fwt(f[n],-1); cout&lt;&lt;mul(f[n][all],Inv(mul(ppw[m],ksm(3,m)))); return 0;&#125; ffort 解题思路： 设总伤害为 XXX 的方案数为 f(X)f(X)f(X) 那么最后这个会对答案产生 (X−1n−1)\\binom{X-1}{n-1}(n−1X−1​) 的贡献，由于 XXX 非常大因此需要换一个角度思考，观察上述式子发现是要插入 n−1n-1n−1 个板，那么我们对 mmm 种数据结构分别构造生成函数 Fi(x)F_i(x)Fi​(x) ，其中 Fi(x)[xj]F_i(x)[x^j]Fi​(x)[xj] 表示其中放 jjj 个板的方案数，然后我们对每一种数据结构做一次多项式快速幂最后乘起来即可，注意最后一个要特殊处理 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef vector&lt;int&gt; poly;#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() &#123; int ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular &#123; const int mod=998244353; inline int add(int a,int b) &#123; return a+b&lt;mod?a+b:a+b-mod; &#125; inline int dec(int a,int b) &#123; return a&lt;b?a-b+mod:a-b; &#125; inline int mul(int a,int b) &#123; return (ll)a*b%mod; &#125; inline void Add(int&amp;a,int b) &#123; a=a+b&lt;mod?a+b:a+b-mod; &#125; inline void Dec(int&amp;a,int b) &#123; a=a&lt;b?a-b+mod:a-b; &#125; inline void Mul(int&amp;a,int b) &#123; a=(ll)a*b%mod; &#125; inline int ksm(int a,int p) &#123; int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; &#125; inline int Inv(int a) &#123; return ksm(a,mod-2); &#125;&#125;using namespace modular;const int N=500005;int invv[23],w[23],inv[N],lim,tim;vector&lt;int&gt;rev[23];inline void init() &#123; inv[1]=1; for(ri i=2;i&lt;=500000;++i) inv[i]=mul(inv[mod-mod/i*i],mod-mod/i);&#125;inline void init_ntt() &#123; invv[0]=1,w[22]=ksm(3,(mod-1)&gt;&gt;23); for(ri i=1,iv=mod+1&gt;&gt;1;i&lt;23;++i) invv[i]=mul(invv[i-1],iv); for(ri i=21;~i;--i) w[i]=mul(w[i+1],w[i+1]);&#125;inline void init(int up) &#123; lim=1,tim=0; while(lim&lt;up) lim&lt;&lt;=1,++tim; if(rev[tim].size()) return; rev[tim].resize(lim); for(ri i=1;i&lt;lim;++i) rev[tim][i]=(rev[tim][i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(tim-1));&#125;inline void ntt(poly&amp;a,int typ) &#123; for(ri i=0;i&lt;lim;++i) if(i&lt;rev[tim][i]) swap(a[i],a[rev[tim][i]]); for(ri i=1,t=0,a0,a1,mt;i&lt;lim;i&lt;&lt;=1,++t) for(ri j=0,len=i&lt;&lt;1;j&lt;lim;j+=len) &#123; mt=1; for(ri k=0;k&lt;i;++k,Mul(mt,w[t])) &#123; a0=a[j+k],a1=mul(a[j+k+i],mt); a[j+k]=add(a0,a1),a[j+k+i]=dec(a0,a1); &#125; &#125; if(~typ) return; reverse(++a.begin(),a.end()); for(ri i=0;i&lt;lim;++i) Mul(a[i],invv[tim]);&#125;inline poly operator*(poly a,poly b) &#123; int n=a.size(),m=b.size(),t=n+m-1; if(t&lt;=64) &#123; poly c(t); for(ri i=0;i&lt;n;++i) if(a[i]) for(ri j=0;j&lt;m;++j) Add(c[i+j],mul(a[i],b[j])); return c; &#125; init(t); a.resize(lim),ntt(a,1); b.resize(lim),ntt(b,1); for(ri i=0;i&lt;lim;++i) Mul(a[i],b[i]); return ntt(a,-1),a.resize(t),a;&#125;inline poly operator-(poly a,poly b) &#123; if((int)a.size()&lt;(int)b.size()) a.resize((int)b.size()); for(ri i=0,up=(int)b.size();i&lt;up;++i) Dec(a[i],b[i]); return a;&#125;inline poly poly_inv(poly a,int K) &#123; poly b(1,Inv(a[0])),c; for(ri i=1;i&lt;K;i&lt;&lt;=1) &#123; init(i&lt;&lt;2); c=a,c.resize(i&lt;&lt;1),c.resize(lim),ntt(c,1); b.resize(lim),ntt(b,1); for(ri j=0;j&lt;lim;++j) Mul(b[j],dec(2,mul(b[j],c[j]))); ntt(b,-1),b.resize(i&lt;&lt;1); &#125; return b.resize(K),b;&#125;inline poly poly_deriv(poly a) &#123; for(ri i=1,up=(int)a.size();i&lt;up;++i) a[i-1]=mul(a[i],i); return a.pop_back(),a;&#125;inline poly poly_integ(poly a) &#123; a.pb(0); for(ri i=(int)a.size()-1;i;--i) a[i]=mul(inv[i],a[i-1]); return a[0]=0,a;&#125;inline poly poly_ln(poly a,int K) &#123; return a=poly_integ(poly_deriv(a)*poly_inv(a,K)),a.resize(K),a; &#125;inline poly poly_exp(poly a,int K) &#123; poly b(1,1),c; for(ri i=1;i&lt;K;i&lt;&lt;=1) &#123; c=a,c.resize(i&lt;&lt;1); c=c-poly_ln(b,i&lt;&lt;1); Add(c[0],1); b=b*c,b.resize(i&lt;&lt;1); &#125; return b.resize(K),b;&#125;inline poly poly_ksm(poly a,int pw,int K) &#123; int iv=Inv(a[0]),mt=ksm(a[0],pw); a.resize(K); for(ri i=0;i&lt;K;++i) Mul(a[i],iv); a=poly_ln(a,K); for(ri i=0;i&lt;K;++i) Mul(a[i],pw); a=poly_exp(a,K); for(ri i=0;i&lt;K;++i) Mul(a[i],mt); return a;&#125;int n,m,a[N],b[N];int main() &#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),m=read(); init(),init_ntt(); for(ri i=1;i&lt;=m;++i) a[i]=read(),b[i]=read(); ++m,a[m]=1,b[m]=b[m-1]-1,--a[m-1]; poly res(1,1),f; for(ri t,iv,i=1;i&lt;=m;++i) if(a[i]) &#123; f.resize(n); f[0]=b[i]; for(ri mt=add(b[i],1),j=1;j&lt;n;++j) &#123; Mul(mt,mul(inv[j+1],b[i]+1-j)); f[j]=mt; &#125; if(i==m) Add(f[0],1); f=poly_ksm(f,a[i],n); res=res*f; res.resize(n); &#125; cout&lt;&lt;res[n-1]; return 0;&#125; Temperature Survey 解题思路： 考虑把问题看成走网格的方案数，那么不断把 (mid,amid)(mid,a_{mid})(mid,amid​) 当成矩形的右上角，然后递归分治可以递归划分出 O(n)O(n)O(n) 个矩形，这些矩形边长和是 O(nlog⁡n)O(n\\log n)O(nlogn) 级别的，然后对于每个矩形用 nttnttntt 计算其上/左边界对其下/右边界的贡献即可 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include&lt;bits/stdc++.h&gt;#include&lt;tr1/unordered_map&gt;#define ri register intusing namespace std;typedef long long ll;typedef vector&lt;int&gt; poly;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() &#123; int ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular &#123; const int mod=998244353; inline int add(int a,int b) &#123; return a+b&lt;mod?a+b:a+b-mod; &#125; inline int dec(int a,int b) &#123; return a&lt;b?a-b+mod:a-b; &#125; inline int mul(int a,int b) &#123; return (ll)a*b%mod; &#125; inline void Add(int&amp;a,int b) &#123; a=a+b&lt;mod?a+b:a+b-mod; &#125; inline void Dec(int&amp;a,int b) &#123; a=a&lt;b?a-b+mod:a-b; &#125; inline void Mul(int&amp;a,int b) &#123; a=(ll)a*b%mod; &#125; inline int ksm(int a,int p) &#123; int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; &#125;&#125;using namespace modular;const int N=5e5+5;int lim,tim,invv[23],w[23],fac[N],ifac[N],a[N],n;vector&lt;int&gt;rev[23];inline void init_ntt() &#123; fac[0]=fac[1]=ifac[0]=ifac[1]=1; for(ri i=2;i&lt;=500000;++i) &#123; fac[i]=mul(fac[i-1],i); ifac[i]=mul(ifac[mod-mod/i*i],mod-mod/i); &#125; for(ri i=2;i&lt;=500000;++i) Mul(ifac[i],ifac[i-1]); w[22]=ksm(3,(mod-1)&gt;&gt;23); invv[0]=1; for(ri i=1,iv=mod+1&gt;&gt;1;i&lt;23;++i) invv[i]=mul(invv[i-1],iv); for(ri i=21;~i;--i) w[i]=mul(w[i+1],w[i+1]);&#125;inline int C(int n,int m) &#123; return n&lt;m||m&lt;0?0:mul(fac[n],mul(ifac[m],ifac[n-m])); &#125;inline void init(int up) &#123; lim=1,tim=0; while(lim&lt;up)lim&lt;&lt;=1,++tim; if(rev[tim].size()) return; rev[tim].resize(lim); for(ri i=1;i&lt;lim;++i) rev[tim][i]=(rev[tim][i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(tim-1));&#125;inline void ntt(poly&amp;a,int typ) &#123; for(ri i=0;i&lt;lim;++i) if(i&lt;rev[tim][i]) swap(a[i],a[rev[tim][i]]); for(ri mt,i=1,t=0,a0,a1;i&lt;lim;i&lt;&lt;=1,++t) for(ri j=0,len=i&lt;&lt;1;j&lt;lim;j+=len) &#123; mt=1; for(ri k=0;k&lt;i;++k,Mul(mt,w[t])) &#123; a0=a[j+k],a1=mul(a[j+k+i],mt); a[j+k]=add(a0,a1),a[j+k+i]=dec(a0,a1); &#125; &#125; if(~typ) return; reverse(++a.begin(),a.end()); for(ri i=0;i&lt;lim;++i) Mul(a[i],invv[tim]);&#125;inline poly operator*(poly a,poly b) &#123; int n=(int)a.size(),m=(int)b.size(),t=n+m-1; if(t&lt;=64) &#123; poly c(t); for(ri i=0;i&lt;n;++i) if(a[i]) for(ri j=0;j&lt;m;++j) Add(c[i+j],mul(a[i],b[j])); return c; &#125; init(t); a.resize(lim),ntt(a,1); b.resize(lim),ntt(b,1); for(ri i=0;i&lt;lim;++i) Mul(a[i],b[i]); return ntt(a,-1),a.resize(t),a;&#125;inline poly calc1(poly a,int len) &#123; int n=(int)a.size(); poly b(n); for(ri i=0;i&lt;n;++i) b[i]=C(i+len,i); a=a*b; return a.resize(n),a;&#125;inline poly calc2(poly a,int len) &#123; int n=(int)a.size(); poly b(len+n); for(ri i=0;i&lt;n;++i) Mul(a[i],ifac[n-i-1]); for(ri i=0;i&lt;len+n;++i) b[i]=fac[i]; b=a*b; a.resize(len+1); for(ri i=0;i&lt;=len;++i) a[i]=mul(ifac[i],b[i+n-1]); return a;&#125;tr1::unordered_map&lt;int,int&gt; f[N];inline void solve(int l,int r,int ql,int qr) &#123; if(l&gt;r||ql&gt;qr) return; int mid=l+r&gt;&gt;1,ps=mid+1; solve(l,mid-1,ql,a[mid-1]); poly F(a[mid]-ql+1),G; for(ri i=ql;i&lt;=a[mid];++i) F[i-ql]=f[mid-1][i]; G=calc1(F,r-mid); for(ri i=ql;i&lt;=a[mid];++i) Add(f[r][i],G[i-ql]); G=calc2(F,r-mid); for(ri i=mid;i&lt;r;++i) Add(f[i][a[mid]],G[i-mid]); F.clear(); F.resize(r-mid+1); for(ri i=mid;i&lt;=r;++i) F[i-mid]=f[i][ql-1]; G=calc1(F,a[mid]-ql); for(ri i=mid;i&lt;=r;++i) Add(f[i][a[mid]],G[i-mid]); G=calc2(F,a[mid]-ql); for(ri i=ql;i&lt;a[mid];++i) Add(f[r][i],G[i-ql]); while(ps&lt;=r&amp;&amp;a[ps]==a[mid]) ++ps; if(ps&lt;=r) solve(ps,r,a[mid]+1,qr);&#125;int main() &#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif init_ntt(); for(ri tt=read();tt;--tt) &#123; n=read(); for(ri i=0;i&lt;=n;++i) f[i].clear(); for(ri i=1;i&lt;=n;++i) a[i]=read(); f[1][0]=1; solve(1,n,1,a[n]); int res=0; for(ri i=1;i&lt;=a[n];++i) Add(res,f[n][i]); cout&lt;&lt;res&lt;&lt;'\\n'; &#125; return 0;&#125; 算力训练 解题思路： 相当于是求 ⊕i=1n(1+xai)\\oplus_{i=1}^n(1+x^{a_i})⊕i=1n​(1+xai​) ，那么可以先参考一下 黎明前的巧克力 是怎么做的，这题也比较类似，大概是扩域将每个数表示成 ∑i=0KaiωKi\\sum\\limits_{i=0}^Ka_i\\omega_K^ii=0∑K​ai​ωKi​ 的形式，然后先把 ∑i=1n(1+xai)\\sum\\limits_{i=1}^n(1+x^{a_i})i=1∑n​(1+xai​) 给 fwtfwtfwt 了，接着对于每一维分别求出它是由 ttt 个 ωKi\\omega_K^iωKi​ 加起来的，那么这一维的实际值应该是 (1+ωKi)t(1+\\omega_K^i)^t(1+ωKi​)t 成功还原点值之后再 ifwtifwtifwt 回去即可 注意到这题有点卡常，因此求 (1+ωKi)t(1+\\omega_K^i)^t(1+ωKi​)t 要用 BSGSBSGSBSGS 卡常 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;const int rlen=1&lt;&lt;18|1l;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)int n,K,tim,lim,iv;inline int read(int B) &#123; int ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=ans*B+(ch^48),ch=gc(); return ans;&#125;namespace modular &#123; const int mod=998244353; inline int add(int a,int b) &#123; return a+b&lt;mod?a+b:a+b-mod; &#125; inline int dec(int a,int b) &#123; return a&lt;b?a-b+mod:a-b; &#125; inline int mul(int a,int b) &#123; return (ll)a*b%mod; &#125; inline void Add(int&amp;a,int b) &#123; a=a+b&lt;mod?a+b:a+b-mod; &#125; inline void Dec(int&amp;a,int b) &#123; a=a&lt;b?a-b+mod:a-b; &#125; inline void Mul(int&amp;a,int b) &#123; a=(ll)a*b%mod; &#125; inline int ksm(int a,int p) &#123; int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; &#125; inline int Inv(int a) &#123; return ksm(a,mod-2); &#125;&#125;using namespace modular;const int N=1e6+5;struct cp &#123; int a[6]; cp() &#123; memset(a,0,sizeof(a)); &#125; inline int&amp;operator[](const int&amp;k) &#123; return a[k]; &#125; inline const int&amp;operator[](const int&amp;k) const &#123; return a[k]; &#125; friend inline cp operator+(cp a,cp b) &#123; for(ri i=0;i&lt;K;++i) Add(a[i],b[i]); return a; &#125; friend inline void operator+=(cp&amp;a,cp b) &#123; a=a+b; &#125; friend inline cp operator-(cp a,cp b) &#123; for(ri i=0;i&lt;K;++i) Dec(a[i],b[i]); return a; &#125; friend inline void operator-=(cp&amp;a,cp b) &#123; a=a-b; &#125; friend inline cp operator*(cp a,int b) &#123; for(ri i=0;i&lt;K;++i) Mul(a[i],b); return a; &#125; friend inline void operator*=(cp&amp;a,int b) &#123; a=a*b; &#125; friend inline cp operator*(cp a,cp b) &#123; cp res; for(ri i=0;i&lt;K;++i) if(a[i]) for(ri j=0;j&lt;K;++j) Add(res[i+j&lt;K?i+j:i+j-K],mul(a[i],b[j])); return res; &#125; friend inline void operator*=(cp&amp;a,cp b) &#123; a=a*b; &#125; inline int getval() &#123; return dec(add(a[0],a[1]),add(a[2],a[3])); &#125;&#125;a[N],w[6],cur[6];inline void init() &#123; w[0][0]=w[1][1]=1; for(ri i=2;i&lt;K;++i) w[i]=w[i-1]*w[1]; &#125;inline void dft(cp*a,int typ) &#123; static cp res[6]; for(ri i=0;i&lt;K;++i) &#123; res[i]=cp(); for(ri j=0;j&lt;K;++j) res[i]+=w[i*j%K]*a[j]; &#125; for(ri i=0;i&lt;K;++i) a[i]=res[i]; if(~typ) return; for(ri i=1;i+i&lt;K;++i) swap(a[i],a[K-i]); for(ri i=0;i&lt;K;++i) a[i]*=iv;&#125;inline void dwt(cp*a,int typ) &#123; for(ri i=1;i&lt;lim;i*=K) for(ri j=0,len=i*K;j&lt;lim;j+=len) &#123; for(ri k=0;k&lt;i;++k) &#123; for(ri o=0;o&lt;K;++o) cur[o]=a[j+k+o*i]; dft(cur,typ); for(ri o=0;o&lt;K;++o) a[j+k+o*i]=cur[o]; &#125; &#125;&#125;int sqr;cp tp[N],pws[N],pwb[N];inline cp getpow(int x) &#123; return pws[x%sqr]*pwb[x/sqr]; &#125;inline void trans(cp*a) &#123; for(ri i=0;i&lt;lim;++i) tp[i][0]=1; sqr=sqrt(1.0*n)+10; for(ri t=0;t&lt;K;++t) &#123; cp A; A[0]=pws[0][0]=pwb[0][0]=1,++A[t]; for(ri o=1;o&lt;=sqr;++o) pws[o]=A*pws[o-1]; pwb[1]=pws[sqr]; for(ri o=2;o&lt;=sqr;++o) pwb[o]=pwb[o-1]*pwb[1]; for(ri i=0;i&lt;lim;++i) tp[i]*=getpow(a[i][t]); &#125; for(ri i=0;i&lt;lim;++i) a[i]=tp[i];&#125;int main() &#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(10),K=read(10),tim=read(10),iv=Inv(K); lim=1; for(ri i=1;i&lt;=tim;++i) lim*=K; for(ri i=1;i&lt;=n;++i) ++a[read(K)][0]; init(); dwt(a,1); trans(a); dwt(a,-1); for(ri i=0;i&lt;lim;++i) cout&lt;&lt;a[i].getval()&lt;&lt;'\\n'; return 0;&#125; 魔力环 解题思路： 考虑 burnsideburnsideburnside 引理，发现只用枚举 d∣gcd⁡(n,m)d|\\gcd(n,m)d∣gcd(n,m) ，然后计算 f(d)f(d)f(d) 表示 md\\frac mddm​ 个黑球， n−md\\frac {n-m}ddn−m​ 个白球的序列，其中黑球（首尾的黑球要加起来）不连续超过 KKK 个的方案数 那么我们强制结尾没有黑球，枚举开头黑球有 ttt 个，方案数乘上 t+1t+1t+1 即可，现在问题变成了在 n−md\\frac{n-m}ddn−m​ 个白球中插入 md−t\\frac md-tdm​−t 个黑球，每个空隙不能插入超过 KKK 个，问方案数，那么容斥算即可 CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;namespace modular &#123; const int mod=998244353; inline int add(int a,int b) &#123; return a+b&lt;mod?a+b:a+b-mod; &#125; inline int dec(int a,int b) &#123; return a&lt;b?a-b+mod:a-b; &#125; inline int mul(int a,int b) &#123; return (ll)a*b%mod; &#125; inline void Add(int&amp;a,int b) &#123; a=a+b&lt;mod?a+b:a+b-mod; &#125; inline void Dec(int&amp;a,int b) &#123; a=a&lt;b?a-b+mod:a-b; &#125; inline void Mul(int&amp;a,int b) &#123; a=(ll)a*b%mod; &#125; inline int ksm(int a,int p) &#123; int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; &#125; inline int Inv(int a) &#123; return ksm(a,mod-2); &#125;&#125;using namespace modular;const int N=1e5+5;int n,m,K,fac[N],ifac[N],inv[N],g,tot=0,pri[N],phi[N];bool vs[N];inline int gcd(int a,int b) &#123; int t;while(b) t=a,a=b,b=t-t/a*a;return a; &#125;inline void init() &#123; fac[0]=fac[1]=ifac[0]=ifac[1]=inv[1]=1; for(ri i=2;i&lt;=n;++i) &#123; fac[i]=mul(fac[i-1],i); inv[i]=mul(inv[mod-mod/i*i],mod-mod/i); ifac[i]=mul(ifac[i-1],inv[i]); &#125;&#125;inline int C(int n,int m) &#123; return n&lt;m||m&lt;0?0:mul(fac[n],mul(ifac[m],ifac[n-m])); &#125;inline int F(int a,int b) &#123; int res=0; for(ri i=0,t,up=min(a/(K+1),b-1);i&lt;=up;++i) &#123; t=mul(C(b-1,i),C(a+b-2-i*(K+1),a-i*(K+1))); i&amp;1?Dec(res,t):Add(res,t); &#125; return res;&#125;inline int calc(int a,int b) &#123; if(b==1) return a&lt;=K?a+1:0; int res=0; for(ri i=0;i&lt;=a&amp;&amp;i&lt;=K;++i) Add(res,mul(i+1,F(a-i,b))); return res;&#125;int main() &#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif cin&gt;&gt;n&gt;&gt;m&gt;&gt;K; if(n==m) return cout&lt;&lt;(K&gt;=n),0; init(); g=gcd(n,m); int res=0; for(ri tm=1;tm&lt;=g;++tm) &#123; if(tm==1) phi[tm]=1; else &#123; if(!vs[tm]) phi[tm]=tm-1,pri[++tot]=tm; for(ri i=1,lm=g/tm;i&lt;=tot&amp;&amp;pri[i]&lt;=lm;++i) &#123; vs[tm*pri[i]]=1; if(tm==tm/pri[i]*pri[i]) &#123; phi[tm*pri[i]]=phi[tm]*pri[i];break; &#125; phi[tm*pri[i]]=phi[tm]*(pri[i]-1); &#125; &#125; if(g==g/tm*tm) Add(res,mul(phi[tm],calc(m/tm,(n-m)/tm))); &#125; cout&lt;&lt;mul(res,inv[n]); return 0;&#125; 魔法小程序 解题思路： 读完题发现是个任意进制前缀和，那么我们把 ccc 拿来做 ifmtifmtifmt 即可 CODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() &#123; int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch)) f^=ch=='-',ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;inline ll readl() &#123; ll ans=0; bool f=1; char ch=gc(); while(!isdigit(ch)) f^=ch=='-',ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;const int N=1e6+5;int len[N],n,m;ll c[N];int main() &#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif m=read(); cout&lt;&lt;m&lt;&lt;'\\n'; for(ri i=1;i&lt;=m;++i) cout&lt;&lt;(len[i]=read())&lt;&lt;' '; puts(\"\"); n=read(); len[++m]=n+1; for(ri i=0;i&lt;n;++i) c[i]=readl(); for(ri i=1,id=1;;i*=len[id++]) &#123; if(len[id]&gt;1) for(ri j=n-1;j&gt;=i;--j) if(j/i%len[id]&gt;0) c[j]-=c[j-i]; if(i&gt;n/len[id]) break; &#125; cout&lt;&lt;n&lt;&lt;'\\n'; for(ri i=0;i&lt;n;++i) cout&lt;&lt;c[i]&lt;&lt;' '; puts(\"\"); return 0;&#125; 如何优雅地求和 解题思路： 考虑构造组合数多项式： fj=∑i=0m(ji)aiaj=∑i=0m(ji)(−1)j−ifiajj!=(−1)j−i(j−i)!fii!ntt求出aires=∑i=0nfi(ni)xi(1−x)n−i=∑i=0n(∑j=0m(ij)aj)xi(1−x)n−i(ni)=∑j=0maj∑i=0n(ni)xi(1−x)n−i(ij)=∑j=0maj(nj)∑i=0nxi(1−x)n−i(n−ji−j)=∑j=0maj(nj)xj∑i=0n−jxi(1−x)n−j−i(n−ji)=∑j=0maj(nj)xi\\begin{aligned} f_j=&amp;\\sum\\limits_{i=0}^m\\binom jia_i\\\\ a_j=&amp;\\sum\\limits_{i=0}^m\\binom ji(-1)^{j-i}f_i\\\\ \\frac{a_j}{j!}=&amp;\\frac{(-1)^{j-i}}{(j-i)!}\\frac{f_i}{i!}\\\\ ntt&amp;求出a_i\\\\ res=&amp;\\sum\\limits_{i=0}^nf_i\\binom nix^i(1-x)^{n-i}\\\\ =&amp;\\sum\\limits_{i=0}^n(\\sum\\limits_{j=0}^m\\binom ija_j)x^i(1-x)^{n-i}\\binom ni\\\\ =&amp;\\sum\\limits_{j=0}^ma_j\\sum\\limits_{i=0}^n\\binom{n}{i}x^i(1-x)^{n-i}\\binom ij\\\\ =&amp;\\sum\\limits_{j=0}^ma_j\\binom nj\\sum\\limits_{i=0}^nx^i(1-x)^{n-i}\\binom {n-j}{i-j}\\\\ =&amp;\\sum\\limits_{j=0}^ma_j\\binom njx^j\\sum\\limits_{i=0}^{n-j}x^i(1-x)^{n-j-i}\\binom{n-j}i\\\\ =&amp;\\sum\\limits_{j=0}^ma_j\\binom njx^i\\\\ \\end{aligned} fj​=aj​=j!aj​​=nttres======​i=0∑m​(ij​)ai​i=0∑m​(ij​)(−1)j−ifi​(j−i)!(−1)j−i​i!fi​​求出ai​i=0∑n​fi​(in​)xi(1−x)n−ii=0∑n​(j=0∑m​(ji​)aj​)xi(1−x)n−i(in​)j=0∑m​aj​i=0∑n​(in​)xi(1−x)n−i(ji​)j=0∑m​aj​(jn​)i=0∑n​xi(1−x)n−i(i−jn−j​)j=0∑m​aj​(jn​)xji=0∑n−j​xi(1−x)n−j−i(in−j​)j=0∑m​aj​(jn​)xi​ 当然利用下降幂多项式同样能够解决问题 CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef vector&lt;int&gt; poly;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() &#123; int ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular &#123; const int mod=998244353; inline int add(int a,int b) &#123; return a+b&lt;mod?a+b:a+b-mod; &#125; inline int dec(int a,int b) &#123; return a&lt;b?a-b+mod:a-b; &#125; inline int mul(int a,int b) &#123; return (ll)a*b%mod; &#125; inline void Add(int&amp;a,int b) &#123; a=a+b&lt;mod?a+b:a+b-mod; &#125; inline void Dec(int&amp;a,int b) &#123; a=a&lt;b?a-b+mod:a-b; &#125; inline void Mul(int&amp;a,int b) &#123; a=(ll)a*b%mod; &#125; inline int ksm(int a,int p) &#123; int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; &#125;&#125;using namespace modular;const int N=20005;int invv[23],w[23],lim,tim,ifac[N],fac[N],n,m,t;vector&lt;int&gt; rev[23];inline void init_ntt() &#123; invv[0]=1,w[22]=ksm(3,(mod-1)&gt;&gt;23); for(ri i=21;~i;--i) w[i]=mul(w[i+1],w[i+1]); for(ri i=1,iv=mod+1&gt;&gt;1;i&lt;23;++i) invv[i]=mul(invv[i-1],iv);&#125;inline void init(int up) &#123; lim=1,tim=0; while(lim&lt;up) lim&lt;&lt;=1,++tim; if(rev[tim].size()) return; rev[tim].resize(lim); for(ri i=1;i&lt;lim;++i) rev[tim][i]=(rev[tim][i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(tim-1));&#125;inline void ntt(poly&amp;a,int typ) &#123; for(ri i=0;i&lt;lim;++i) if(i&lt;rev[tim][i]) swap(a[i],a[rev[tim][i]]); for(ri i=1,t=0,a0,a1,mt;i&lt;lim;i&lt;&lt;=1,++t) for(ri j=0,len=i&lt;&lt;1;j&lt;lim;j+=len) &#123; mt=1; for(ri k=0;k&lt;i;++k,Mul(mt,w[t])) &#123; a0=a[j+k],a1=mul(a[j+k+i],mt); a[j+k]=add(a0,a1),a[j+k+i]=dec(a0,a1); &#125; &#125; if(~typ) return; reverse(++a.begin(),a.end()); for(ri i=0;i&lt;lim;++i) Mul(a[i],invv[tim]);&#125;inline poly operator*(poly a,poly b) &#123; int n=(int)a.size(),m=(int)b.size(),t=n+m-1; if(t&lt;=128) &#123; poly c(t); for(ri i=0;i&lt;n;++i) if(a[i]) for(ri j=0;j&lt;m;++j) Add(c[i+j],mul(a[i],b[j])); return c; &#125; init(t); a.resize(lim),ntt(a,1); b.resize(lim),ntt(b,1); for(ri i=0;i&lt;lim;++i) Mul(a[i],b[i]); return ntt(a,-1),a.resize(t),a;&#125;inline void init() &#123; fac[0]=fac[1]=ifac[0]=ifac[1]=1; for(ri i=2;i&lt;=m;++i) &#123; fac[i]=mul(fac[i-1],i); ifac[i]=mul(ifac[mod-mod/i*i],mod-mod/i); &#125; for(ri i=2;i&lt;=m;++i) Mul(ifac[i],ifac[i-1]);&#125;int main() &#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),m=read(),t=read(); init_ntt(); init(); poly f(m+1),g(m+1); for(ri i=0;i&lt;=m;++i) f[i]=mul(ifac[i],read()),g[i]=i&amp;1?mod-ifac[i]:ifac[i]; f=f*g; int res=0; for(ri i=0,mt1=1,mt2=1,tim=n;i&lt;=m;++i,Mul(mt1,t),Mul(mt2,tim),--tim) Add(res,mul(mul(mt1,mt2),f[i])); cout&lt;&lt;res; return 0;&#125;","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://ldxcaicai.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"杂题乱做 Round9","slug":"sol9","date":"2019-11-27T14:19:34.000Z","updated":"2019-12-26T04:24:00.754Z","comments":true,"path":"sol9/","link":"","permalink":"http://ldxcaicai.github.io/sol9/","excerpt":"","text":"猎人杀 解题思路： 关键点在于对于一个死去的人的处理，根据题解观察可知这个概率等于在所有人中随机选人开枪，而在选到已经死去的人的时候重新选人，这样跟在未死去的人中随机选人的概率是相同的 在知道这一点之后就可以尝试容斥了，考虑至少 kkk 个人在第一个人之后死的概率发现这个可以把它们的权值放在生成函数指数上然后利用分治 nttnttntt 快速统计 CODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly;#define fi first#define se second#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular&#123; const int mod=998244353; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int a)&#123;return ksm(a,mod-2);&#125; inline int fix(int a)&#123;return (a%mod+mod)%mod;&#125;&#125;using namespace modular;int invv[23],w[23],lim,tim;vector&lt;int&gt;rev[23];inline void init_ntt()&#123; w[22]=ksm(3,(mod-1)&gt;&gt;23); for(ri i=21;~i;--i)w[i]=mul(w[i+1],w[i+1]); invv[0]=1; for(ri i=1,iv=mod+1&gt;&gt;1;i&lt;23;++i)invv[i]=mul(invv[i-1],iv);&#125;inline void init(const int&amp;up)&#123; lim=1,tim=0; while(lim&lt;up)lim&lt;&lt;=1,++tim; if(rev[tim].size())return; rev[tim].resize(lim); for(ri i=1;i&lt;lim;++i)rev[tim][i]=(rev[tim][i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(tim-1));&#125;inline void ntt(poly&amp;a,const int&amp;type)&#123; for(ri i=0;i&lt;lim;++i)if(i&lt;rev[tim][i])swap(a[i],a[rev[tim][i]]); for(ri i=1,a0,a1,t=0;i&lt;lim;i&lt;&lt;=1,++t)for(ri j=0,len=i&lt;&lt;1;j&lt;lim;j+=len) for(ri k=0,mt=1;k&lt;i;++k,Mul(mt,w[t]))&#123; a0=a[j+k],a1=mul(a[j+k+i],mt); a[j+k]=add(a0,a1),a[j+k+i]=dec(a0,a1); &#125; if(~type)return; reverse(++a.begin(),a.end()); for(ri i=0;i&lt;lim;++i)Mul(a[i],invv[tim]);&#125;inline poly operator*(poly a,poly b)&#123; int n=a.size(),m=b.size(),t=n+m-1; if(t&lt;=64)&#123; poly c(t); for(ri i=0;i&lt;n;++i)for(ri j=0;j&lt;m;++j) Add(c[i+j],mul(a[i],b[j])); return c; &#125; init(t); a.resize(lim),ntt(a,1); b.resize(lim),ntt(b,1); for(ri i=0;i&lt;lim;++i)Mul(a[i],b[i]); return ntt(a,-1),a.resize(t),a;&#125;const int N=1e5+5;int n,a[N],m=0,inv[N];inline poly solve(int l,int r)&#123; if(l==r)&#123; poly ret(a[l]+1); ret[0]=1,ret[a[l]]=mod-1; return ret; &#125; int mid=l+r&gt;&gt;1; return solve(l,mid)*solve(mid+1,r);&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif init_ntt(); n=read(); for(ri i=1;i&lt;=n;++i)a[i]=read(),m+=a[i]; inv[1]=1; for(ri i=2;i&lt;=m;++i)inv[i]=mul(inv[mod-mod/i*i],mod-mod/i); poly f=solve(2,n); int res=0; for(ri i=0;i&lt;f.size();++i)Add(res,mul(f[i],mul(a[1],inv[i+a[1]]))); cout&lt;&lt;res; return 0;&#125; 有意义的字符串 解题思路： 首先有个坑点是题目中数据范围不全，有一部分测试数据满足 b=1,d=5b=1,d=5b=1,d=5 ，现在考虑这题咋做 大概看到这个玩意儿会联系到数列里面用特征根方程求通项公式，不妨设 fn=(b+d2)n+(b−d2)nf_n=(\\frac{b+\\sqrt d}{2})^n+(\\frac{b-\\sqrt d}{2})^nfn​=(2b+d​​)n+(2b−d​​)n ，然后可以利用这个通项公式反解出数列递推式 fn=bfn−1+b2−d4fn−2f_n=bf_{n-1}+\\frac{b^2-d}4f_{n-2}fn​=bfn−1​+4b2−d​fn−2​ 这样就能搞出来 fnf_nfn​ ，然后由于题目给出的限制条件，这个 b−d2∈(−1,0]\\frac{b-\\sqrt d}2\\in(-1,0]2b−d​​∈(−1,0] ，所以这个 (b−d2)n∈(−1,1)(\\frac{b-\\sqrt d}2)^n\\in(-1,1)(2b−d​​)n∈(−1,1) ，也就是说最后需要特判 fnf_nfn​ 是否要减一 CODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef unsigned long long Ull;#define fi first#define se second#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline Ull readul()&#123; Ull ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;const Ull mod=7528443412579576937;inline Ull add(Ull a,Ull b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125;inline void Add(Ull&amp;a,Ull b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125;inline Ull mul(Ull a,Ull b)&#123;return (a*b-(Ull)((long double)a/mod*b)*mod+mod)%mod;&#125;Ull d,b,n;struct mat&#123; Ull a[2][2]; mat()&#123;memset(a,0,sizeof(a));&#125; inline Ull*operator[](const int&amp;k)&#123;return a[k];&#125; friend inline mat operator*(mat a,mat b)&#123; mat c; for(ri i=0;i&lt;2;++i)for(ri k=0;k&lt;2;++k)if(a[i][k]) for(ri j=0;j&lt;2;++j)Add(c[i][j],mul(a[i][k],b[k][j])); return c; &#125;&#125;t;int f[105];int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif b=readul(),d=readul(),n=readul(); if(n==0)&#123; cout&lt;&lt;1; return 0; &#125; if(n==1)&#123; cout&lt;&lt;b; return 0; &#125; t[0][0]=b,t[0][1]=1; t[1][0]=(d-b*b)&gt;&gt;2,t[1][1]=0; mat res=t; for(Ull p=n-2;p;t=t*t,p&gt;&gt;=1)if(p&amp;1)res=res*t; Ull ans=add(mul(res[0][0],b),mul(res[1][0],2)); ((n%2==0)&amp;&amp;(b*b!=d))&amp;&amp;(--ans); cout&lt;&lt;ans; return 0;&#125; 分拆数 解题思路： 貌似是个生成函数基础问题，大概是用多项式 expexpexp 和调和级数的性质来优化背包 大概就是对于每个数构造出其生成函数然后乘起来就可以算出答案，然后对多项式取对就变成加法，再用个求导的变化就能转成 expexpexp ，不理解的可以看看我博客里有一篇 Generating function 的背包优化部分 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef vector&lt;int&gt; poly;typedef long long ll;typedef pair&lt;int,int&gt; pii;#define fi first#define se second#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular&#123; const int mod=998244353; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;&#125;using namespace modular;int invv[23],w[23],lim,tim,inv[1&lt;&lt;23];vector&lt;int&gt;rev[23];inline void init_ntt()&#123; inv[1]=1; for(ri i=2,up=1&lt;&lt;23;i&lt;up;++i)inv[i]=mul(inv[mod-mod/i*i],mod-mod/i); invv[0]=1; for(ri i=1,iv=mod+1&gt;&gt;1;i&lt;23;++i)invv[i]=mul(invv[i-1],iv); w[22]=ksm(3,(mod-1)&gt;&gt;23); for(ri i=21;~i;--i)w[i]=mul(w[i+1],w[i+1]);&#125;inline void init(int up)&#123; lim=1,tim=0; while(lim&lt;up)lim&lt;&lt;=1,++tim; if(rev[tim].size())return; rev[tim].resize(lim); for(ri i=0;i&lt;lim;++i)rev[tim][i]=(rev[tim][i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(tim-1));&#125;inline void ntt(poly&amp;a,int type)&#123; for(ri i=0;i&lt;lim;++i)if(i&lt;rev[tim][i])swap(a[i],a[rev[tim][i]]); for(ri i=1,t=0,a0,a1;i&lt;lim;i&lt;&lt;=1,++t)for(ri j=0,len=i&lt;&lt;1;j&lt;lim;j+=len) for(ri k=0,mt=1;k&lt;i;++k,Mul(mt,w[t]))&#123; a0=a[j+k],a1=mul(a[j+k+i],mt); a[j+k]=add(a0,a1),a[j+k+i]=dec(a0,a1); &#125; if(~type)return; reverse(++a.begin(),a.end()); for(ri i=0;i&lt;lim;++i)Mul(a[i],invv[tim]);&#125;inline poly operator*(poly a,poly b)&#123; int n=a.size(),m=b.size(),t=n+m-1; if(t&lt;=64)&#123; poly c(t); for(ri i=0;i&lt;n;++i)if(a[i])for(ri j=0;j&lt;m;++j)if(b[j]) Add(c[i+j],mul(a[i],b[j])); return c; &#125; init(t); a.resize(lim),ntt(a,1); b.resize(lim),ntt(b,1); for(ri i=0;i&lt;lim;++i)Mul(a[i],b[i]); return ntt(a,-1),a.resize(t),a;&#125;inline poly operator-(poly a,poly b)&#123; a.resize(max(a.size(),b.size())); for(ri i=0;i&lt;b.size();++i)Dec(a[i],b[i]); return a;&#125;inline poly poly_inv(poly a,int k)&#123; poly b(1,ksm(a[0],mod-2)),c; for(ri i=1;i&lt;k;i&lt;&lt;=1)&#123; init(i&lt;&lt;2); c=a,c.resize(i&lt;&lt;1); b.resize(lim),ntt(b,1); c.resize(lim),ntt(c,1); for(ri j=0;j&lt;lim;++j)Mul(b[j],dec(2,mul(b[j],c[j]))); ntt(b,-1),b.resize(i&lt;&lt;1); &#125; return b.resize(k),b;&#125;inline poly poly_deriv(poly a)&#123; for(ri i=0;i&lt;(int)a.size()-1;++i)a[i]=mul(a[i+1],i+1); return a.pop_back(),a;&#125;inline poly poly_integ(poly a)&#123; a.pb(0); for(ri i=a.size()-1;i;--i)a[i]=mul(a[i-1],inv[i]); return a[0]=0,a;&#125;inline poly poly_ln(poly a,int k)&#123; a=poly_integ(poly_deriv(a)*poly_inv(a,k)); return a.resize(k),a;&#125;inline poly poly_exp(poly a,int k)&#123; poly b(1,1),c; a.resize(k&lt;&lt;1); for(ri i=1;i&lt;k;i&lt;&lt;=1)&#123; c=poly_ln(b,i&lt;&lt;1); for(ri j=0;j&lt;c.size();++j)c[j]=dec(a[j],c[j]); Add(c[0],1); b=b*c,b.resize(i&lt;&lt;1); &#125; return b.resize(k),b;&#125;poly f;int n;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); init_ntt(); f.resize(n+1); for(ri i=1;i&lt;=n;++i)for(ri j=1;i*j&lt;=n;++j)Add(f[i*j],inv[j]); f=poly_exp(f,n+1); for(ri i=1;i&lt;=n;++i)cout&lt;&lt;f[i]&lt;&lt;'\\n'; return 0;&#125; 整数的lqp拆分 解题思路： 可以直接 dpdpdp 推式子，也可以用生成函数貌似都挺快的，最后反正是可以用矩乘优化然而我太懒了就没写 CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef unsigned long long Ull;#define fi first#define se second#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;&#125;using namespace modular;int n;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); if(n&lt;2)&#123; cout&lt;&lt;n; return 0; &#125; int pre1=0,pre2=1; for(ri tmp,i=2;i&lt;=n;++i)&#123; tmp=pre2; pre2=add(pre1,add(pre2,pre2)); pre1=tmp; &#125; cout&lt;&lt;pre2; return 0;&#125; Perpetual Subtraction 解题思路： 要用一点线性代数中矩阵对角化的知识，前置知识可以在 Linear algebra 学 这题想办法推一推转移矩阵的桥接矩阵 Φ\\PhiΦ ，发现还蛮有规律的，大概是 Φi,j=(−1)i+jCji\\Phi_{i,j}=(-1)^{i+j}C_j^iΦi,j​=(−1)i+jCji​ ，然后可以比较简单的推出 Φi,j−1=Cji\\Phi^{-1}_{i,j}=C_j^iΦi,j−1​=Cji​ ，然后左乘矩阵就是一个沙雕卷积直接做就好，感觉啥都没讲有问题评论区问吧 下面介绍另外一个方法： 首先设 f0,if_{0,i}f0,i​ 表示当前轮值为 iii 的概率，那么下一轮值为 iii 的概率 f1,if_{1,i}f1,i​ 可以用 f0f_0f0​ 递推 f1,i=∑j=inf0,j1j+1列出生成函数F0(x),F1(x)F1(x)=∑i=0nxi∑j=0nf0,j1j+1=∑j=0nf0,jj+1∑i=0jxi=∑j=0nf0,jxjj+1xj+1−1x−1=1x−1∑j=0nf0,j∫1xtjdt=∫1xF0(t)dtx−1令G1(x)=F1(x+1)=∫0xF0(t)dtx−1那么g1,i=g0,ii−1,gm,i=g0,i(i−1)m用二项式反演推出f,g正逆变换即可\\begin{aligned} f_{1,i}=&amp;\\sum\\limits_{j=i}^nf_{0,j}\\frac1{j+1}\\\\ 列出生成&amp;函数F_0(x),F_1(x)\\\\ F_1(x)=&amp;\\sum\\limits_{i=0}^nx^i\\sum\\limits_{j=0}^nf_{0,j}\\frac1{j+1}\\\\ =&amp;\\sum\\limits_{j=0}^n\\frac{f_{0,j}}{j+1}\\sum\\limits_{i=0}^jx^i\\\\ =&amp;\\sum\\limits_{j=0}^nf_{0,j}\\frac{x_j}{j+1}\\frac{x^{j+1}-1}{x-1}\\\\ =&amp;\\frac1{x-1}\\sum\\limits_{j=0}^nf_{0,j}\\int_1^xt^j\\text dt\\\\ =&amp;\\frac{\\int_1^xF_0(t)\\text dt}{x-1}\\\\ 令G_1(x)=&amp;F_1(x+1)=\\frac{\\int_0^xF_0(t)\\text dt}{x-1}\\\\ 那么g_{1,i}=&amp;\\frac{g_{0,i}}{i-1},g_{m,i}=\\frac{g_{0,i}}{(i-1)^m}\\\\ 用二项式&amp;反演推出 f,g 正逆变换即可 \\end{aligned} f1,i​=列出生成F1​(x)=====令G1​(x)=那么g1,i​=用二项式​j=i∑n​f0,j​j+11​函数F0​(x),F1​(x)i=0∑n​xij=0∑n​f0,j​j+11​j=0∑n​j+1f0,j​​i=0∑j​xij=0∑n​f0,j​j+1xj​​x−1xj+1−1​x−11​j=0∑n​f0,j​∫1x​tjdtx−1∫1x​F0​(t)dt​F1​(x+1)=x−1∫0x​F0​(t)dt​i−1g0,i​​,gm,i​=(i−1)mg0,i​​反演推出f,g正逆变换即可​ CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly; #define fi first#define se second#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular&#123; const int mod=998244353; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;&#125;using namespace modular;const int N=1e5+5;int n,invv[23],w[23],lim,tim;vector&lt;int&gt;rev[N];inline void init(const int&amp;up)&#123; lim=1,tim=0; while(lim&lt;up)lim&lt;&lt;=1,++tim; if(rev[tim].size())return; rev[tim].resize(lim); for(ri i=0;i&lt;lim;++i)rev[tim][i]=(rev[tim][i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(tim-1));&#125;ll m;inline void init_ntt()&#123; w[22]=ksm(3,(mod-1)&gt;&gt;23); for(ri i=21;~i;--i)w[i]=mul(w[i+1],w[i+1]); invv[0]=1; for(ri i=1,iv=mod+1&gt;&gt;1;i&lt;23;++i)invv[i]=mul(invv[i-1],iv);&#125;inline void ntt(poly&amp;a,int type)&#123; for(ri i=0;i&lt;lim;++i)if(i&lt;rev[tim][i])swap(a[i],a[rev[tim][i]]); for(ri i=1,t=0,a0,a1;i&lt;lim;i&lt;&lt;=1,++t)for(ri j=0,len=i&lt;&lt;1;j&lt;lim;j+=len) for(ri k=0,mt=1;k&lt;i;++k,Mul(mt,w[t]))&#123; a0=a[j+k],a1=mul(a[j+k+i],mt); a[j+k]=add(a0,a1),a[j+k+i]=dec(a0,a1); &#125; if(~type)return; reverse(++a.begin(),a.end()); for(ri i=0;i&lt;lim;++i)Mul(a[i],invv[tim]);&#125;inline poly operator*(poly a,poly b)&#123; int n=a.size(),m=b.size(),t=n+m-1; if(t&lt;=64)&#123; poly c(t); for(ri i=0;i&lt;n;++i)for(ri j=0;j&lt;m;++j) Add(c[i+j],mul(a[i],b[j])); return c; &#125; init(t); a.resize(lim),ntt(a,1); b.resize(lim),ntt(b,1); for(ri i=0;i&lt;lim;++i)Mul(a[i],b[i]); return ntt(a,-1),a.resize(t),a;&#125;int fac[N],ifac[N],inv[N];inline void init_fac()&#123; fac[0]=fac[1]=ifac[0]=ifac[1]=inv[1]=1; for(ri i=2;i&lt;=n+1;++i)&#123; fac[i]=mul(fac[i-1],i); inv[i]=mul(inv[mod-mod/i*i],mod-mod/i); ifac[i]=mul(ifac[i-1],inv[i]); &#125;&#125;poly a,f,g;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); m=readl(); a.resize(n+1),f.resize(n+1),g.resize(n+1); for(ri i=0;i&lt;=n;++i)a[i]=read(); init_ntt(),init_fac(); for(ri i=0;i&lt;=n;++i)f[i]=mul(fac[i],a[i]),g[i]=ifac[i]; reverse(f.begin(),f.end()); a=f*g; a.resize(n+1); reverse(a.begin(),a.end()); for(ri i=0;i&lt;=n;++i)Mul(a[i],ifac[i]); for(ri i=0;i&lt;=n;++i)Mul(a[i],ksm(inv[i+1],m%(mod-1))); for(ri i=0;i&lt;=n;++i)f[i]=mul(fac[i],a[i]),g[i]=i&amp;1?mod-ifac[i]:ifac[i]; reverse(f.begin(),f.end()); a=f*g; a.resize(n+1); reverse(a.begin(),a.end()); for(ri i=0;i&lt;=n;++i)Mul(a[i],ifac[i]); for(ri i=0;i&lt;=n;++i)cout&lt;&lt;a[i]&lt;&lt;' '; return 0;&#125; 黎明前的巧克力 解题思路： 对于每个数构造集合幂级数，发现是要求 ⊕i=1n(1+2xai)[x0]\\oplus_{i=1}^n(1+2x^{a_i})[x^0]⊕i=1n​(1+2xai​)[x0] 然后观察异或卷积的性质，假如第 iii 位为 111 ，那么它会根据 j&amp;ij\\&amp;ij&amp;i 的奇偶性对 jjj 位置产生 ±1\\pm1±1 的贡献，因此每个数 fwtfwtfwt 后每一位的结果一定为 111 或者 −3-3−3 ，这样我们直接把 ∑i=1n(1+2xai)\\sum_{i=1}^n(1+2x^{a_i})∑i=1n​(1+2xai​) 拿来 fwtfwtfwt ，然后解每一位有多少个 −1,3-1,3−1,3 然后求出真实的点值表达式的乘积结果，然后再 ifwtifwtifwt 回去即可 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef vector&lt;int&gt; poly;typedef long long ll;typedef pair&lt;int,int&gt; pii;#define fi first#define se second#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular&#123; const int mod=998244353; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;&#125;using namespace modular;const int N=2e6+5;int n,a[N],mx=0,lim,pw[N];inline void fwt(int*f)&#123; for(ri a0,a1,i=1;i&lt;lim;i&lt;&lt;=1)for(ri j=0,len=i&lt;&lt;1;j&lt;lim;j+=len) for(ri k=0;k&lt;i;++k)&#123; a0=a[j+k],a1=a[j+k+i]; a[j+k]=a0+a1,a[j+k+i]=a0-a1; &#125;&#125;inline void ifwt(int*f)&#123; for(ri iv=mod+1&gt;&gt;1,a0,a1,i=1;i&lt;lim;i&lt;&lt;=1)for(ri j=0,len=i&lt;&lt;1;j&lt;lim;j+=len) for(ri k=0;k&lt;i;++k)&#123; a0=a[j+k],a1=a[j+k+i]; a[j+k]=add(a0,a1),a[j+k+i]=dec(a0,a1); Mul(a[j+k],iv),Mul(a[j+k+i],iv); &#125;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); pw[0]=1; for(ri i=1,vl;i&lt;=n;++i)&#123; pw[i]=add(pw[i-1],add(pw[i-1],pw[i-1])); ++a[0]; a[vl=read()]+=2; mx=max(mx,vl); &#125; for(lim=1;lim&lt;=mx;lim&lt;&lt;=1); fwt(a); for(ri x,i=0;i&lt;lim;++i)&#123; x=(a[i]+n)/4; a[i]=(n-x)&amp;1?mod-pw[x]:pw[x]; &#125; ifwt(a); cout&lt;&lt;dec(a[0],1); return 0;&#125; Radix sum 解题思路： 不考虑模数的话就是 101010 进制 fwtfwtfwt 裸题，现在有了模数，那么可以暴力扩域，用一个向量 (a0,a1,...,a9)T(a_0,a_1,...,a_9)^{\\text T}(a0​,a1​,...,a9​)T 来表示一个数 ∑i=09aiω10i\\sum\\limits_{i=0}^9a_i\\omega_{10}^ii=0∑9​ai​ω10i​，这样就能够正常的 dftdftdft 了，然后再考虑怎么求 101010 的逆元，发现 555 的逆元可以广义欧拉定理直接搞， 222 可以直接除，这样就做完了，不过最后求答案的时候需要爆算一波 CODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly;typedef unsigned long long ull;const ull inv_5=57646075230342349ull;#define fi first#define se second#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;const int N=1e5+5;int n,a[N],mx=0,lim;ull c[20];struct cp&#123; ull a[10]; inline void clear()&#123;for(ri i=0;i&lt;10;++i)a[i]=0;&#125; inline ull&amp;operator[](const int&amp;k)&#123;return a[k];&#125; inline const ull&amp;operator[](const int&amp;k)const&#123;return a[k];&#125; friend inline cp operator*(cp a,cp b)&#123; for(ri i=0;i&lt;10;++i)for(ri j=0;j&lt;10;++j)c[i+j]+=a[i]*b[j]; for(ri i=0;i&lt;10;++i)a[i]=c[i]+c[i+10],c[i]=c[i+10]=0; return a; &#125; friend inline void operator*=(cp&amp;a,cp b)&#123;a=a*b;&#125; friend inline cp operator^(cp a,int p)&#123; cp res; res.clear(),res[0]=1; for(;p;p&gt;&gt;=1,a=a*a)if(p&amp;1)res=res*a; return res; &#125; inline cp fix()&#123; cp res=*this; for(ri i=0;i&lt;10;++i)res[i]=(res[i]&gt;&gt;1)*inv_5; return res; &#125; inline ull val()&#123;return (a[0]-a[2]+a[7]-a[5])%(1ull&lt;&lt;58);&#125;&#125;f[N&lt;&lt;1];inline void dwt(cp*f)&#123; cp s[10]; for(ri i=1;i&lt;lim;i*=10)for(ri j=0,len=i*10;j&lt;lim;j+=len) for(ri k=0;k&lt;i;++k)&#123; for(ri ps,p=0;p&lt;10;++p)&#123; s[p].clear(); for(ri ps,q=0;q&lt;10;++q)&#123; ps=p*q%10; for(ri o=0;o+ps&lt;10;++o)s[p][o+ps]+=f[j+k+q*i][o]; for(ri o=10-ps;o&lt;10;++o)s[p][o+ps-10]+=f[j+k+q*i][o]; &#125; &#125; for(ri p=0;p&lt;10;++p)f[j+k+p*i]=s[p]; &#125;&#125;inline void idwt(cp*f)&#123; static cp s[10]; for(ri i=1;i&lt;lim;i*=10)for(ri j=0,len=i*10;j&lt;lim;j+=len) for(ri k=0;k&lt;i;++k)&#123; for(ri ps,p=0;p&lt;10;++p)&#123; s[p].clear(); for(ri ps,q=0;q&lt;10;++q)&#123; ps=p*q%10; ps=ps?10-ps:0; for(ri o=0;o+ps&lt;10;++o)s[p][o+ps]+=f[j+k+q*i][o]; for(ri o=10-ps;o&lt;10;++o)s[p][o+ps-10]+=f[j+k+q*i][o]; &#125; &#125; for(ri p=0;p&lt;10;++p)f[j+k+p*i]=s[p].fix(); &#125;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); for(ri i=1;i&lt;=n;++i)++f[a[i]=read()][0],mx=max(mx,a[i]); for(lim=10;lim&lt;mx;lim*=10); dwt(f); for(ri i=0;i&lt;lim;++i)f[i]=f[i]^n; idwt(f); for(ri i=0;i&lt;n;++i)cout&lt;&lt;f[i].val()&lt;&lt;'\\n'; return 0;&#125;","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://ldxcaicai.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"杂题乱做 Round8","slug":"sol8","date":"2019-11-23T03:29:21.000Z","updated":"2019-12-26T04:24:49.106Z","comments":true,"path":"sol8/","link":"","permalink":"http://ldxcaicai.github.io/sol8/","excerpt":"","text":"青春猪头少年不会梦到兔女郎学姐 解题思路： 首先是处理环的问题，这貌似是一个常见套路，即规定开头一定是第一种算出方案数再扣去开头结尾都是第一种的方案数，最后乘上每种方案被计算的次数即可 现在只需考虑序列上如何做，显然要对每种颜色分开考虑，相当于是将每种颜色分成若干段然后在序列上拼接使得相邻的两段不能是同一种颜色，这不又是那道[JSOI2019]神经网络吗，显然用容斥+生成函数解决，那么现在只用求把 nnn 个颜色的球划分成 mmm 段，所有方案的段乘积之和，这个也可以生成函数推导一下，推导如下： Ans=[xn](∑i=0+∞ixi)m=[xn]xm(∑i=0+∞xi)2m=[xn−m](∑i=0+∞xi)2m=Cn+m−12m−1\\begin{aligned} Ans=&amp;[x^n](\\sum\\limits_{i=0}^{+\\infty}ix^i)^m\\\\ =&amp;[x^n]x^m(\\sum\\limits_{i=0}^{+\\infty}x^i)^{2m}\\\\ =&amp;[x^{n-m}](\\sum\\limits_{i=0}^{+\\infty}x^i)^{2m}\\\\ =&amp;C_{n+m-1}^{2m-1} \\end{aligned} Ans====​[xn](i=0∑+∞​ixi)m[xn]xm(i=0∑+∞​xi)2m[xn−m](i=0∑+∞​xi)2mCn+m−12m−1​​ 考虑枚举第 iii 种颜色分为了 bib_ibi​ 段，最后在序列上将相邻的段合起来后至少 cic_ici​ 段，那么现在可以列出序列上答案的式子： Ans=∑c∑b(∏Cai+bi−12bi−1Cbi−1ci−1(−1)bi−ci)(∑i=1nci)!∏i=−1nci!\\begin{aligned} Ans=&amp;\\sum\\limits_{c}\\sum\\limits_{b}(\\prod\\limits C_{a_i+b_i-1}^{2b_i-1}C_{b_i-1}^{c_i-1}(-1)^{b_i-c_i})\\frac{(\\sum\\limits_{i=1}^nc_i)!}{\\prod\\limits_{i=-1}^nc_i!} \\end{aligned} Ans=​c∑​b∑​(∏Cai​+bi​−12bi​−1​Cbi​−1ci​−1​(−1)bi​−ci​)i=−1∏n​ci​!(i=1∑n​ci​)!​​ 然后把式子拆开对每种球都构造生成函数最后分治 nttnttntt 合并起来即可，注意第一种颜色需要进行特殊处理，好吧还是列一个生成函数的式子： fi(x)=∑i=0aixii!(∑b≥iCai+b−12bCb−1i−1(−1)b−c)\\begin{aligned} f_i(x)=&amp;\\sum\\limits_{i=0}^{a_i}\\frac{x^i}{i!}(\\sum\\limits_{b\\ge i}C_{a_i+b-1}^{2b}C_{b-1}^{i-1}(-1)^{b-c}) \\end{aligned} fi​(x)=​i=0∑ai​​i!xi​(b≥i∑​Cai​+b−12b​Cb−1i−1​(−1)b−c)​ 显然可以卷积处理 还剩一个问题是每种环被计算的次数，假设循环节的长度为 len,m=∑i=1nailen,m=\\sum\\limits_{i=1}^na_ilen,m=i=1∑n​ai​ ，第一种颜色的球在一个循环节中被分成了 xxx 段，那么用上述做法实际被计算了 xmlen\\frac{x}{\\frac{m}{len}}lenm​x​ 次，二十几杀是哪个应该计算 lenlenlen 次，因此对于第一种颜色的球我们对每一位多除以一个 xxx ，之后的答案再乘上 mmm 即可得到正确答案 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly;#define fi first#define se second#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular&#123; const int mod=998244353; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;&#125;using namespace modular;int invv[23],w[23],lim,tim;vector&lt;int&gt;rev[23];inline void init_ntt()&#123; invv[0]=1; for(ri iv=mod+1&gt;&gt;1,i=1;i&lt;23;++i)invv[i]=mul(invv[i-1],iv); w[22]=ksm(3,(mod-1)&gt;&gt;23); for(ri i=21;~i;--i)w[i]=mul(w[i+1],w[i+1]);&#125;inline void init(int up)&#123; lim=1,tim=0; while(lim&lt;up)lim&lt;&lt;=1,++tim; if(rev[tim].size())return; rev[tim].resize(lim); for(ri i=0;i&lt;lim;++i)rev[tim][i]=(rev[tim][i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(tim-1));&#125;inline void ntt(poly&amp;a,int typ)&#123; for(ri i=0;i&lt;lim;++i)if(i&lt;rev[tim][i])swap(a[i],a[rev[tim][i]]); for(ri i=1,a0,a1,t=0;i&lt;lim;i&lt;&lt;=1,++t)for(ri j=0,len=i&lt;&lt;1;j&lt;lim;j+=len) for(ri k=0,mt=1;k&lt;i;++k,Mul(mt,w[t]))a0=a[j+k],a1=mul(a[j+k+i],mt),a[j+k]=add(a0,a1),a[j+k+i]=dec(a0,a1); if(~typ)return; reverse(++a.begin(),a.end()); for(ri i=0;i&lt;lim;++i)Mul(a[i],invv[tim]);&#125;inline poly operator*(poly a,poly b)&#123; int n=a.size(),m=b.size(),t=n+m-1; if(t&lt;=64)&#123; poly c(t); for(ri i=0;i&lt;n;++i)for(ri j=0;j&lt;m;++j)Add(c[i+j],mul(a[i],b[j])); return c; &#125; init(t); a.resize(lim),ntt(a,1); b.resize(lim),ntt(b,1); for(ri i=0;i&lt;lim;++i)Mul(a[i],b[i]); return ntt(a,-1),a.resize(t),a;&#125;inline void revv(poly&amp;a)&#123;reverse(a.begin(),a.end());&#125;const int N=2e5+5;int a[N],n,m=0,fac[N&lt;&lt;1],inv[N&lt;&lt;1],ifac[N&lt;&lt;1];poly f[N];inline poly fix(poly a)&#123;for(ri i=0;i&lt;a.size();++i)Mul(a[i],ifac[i]);return a;&#125;inline poly solve(int l,int r)&#123; if(l==r)return fix(f[l]); int mid=l+r&gt;&gt;1; return solve(l,mid)*solve(mid+1,r);&#125;inline void init_fac()&#123; fac[0]=fac[1]=ifac[0]=ifac[1]=inv[1]=1; for(ri i=2;i&lt;=m;++i)&#123; fac[i]=mul(fac[i-1],i); inv[i]=mul(inv[mod-mod/i*i],mod-mod/i); ifac[i]=mul(ifac[i-1],inv[i]); &#125;&#125;inline int C(int n,int m)&#123;return n&lt;m||m&lt;0?0:mul(fac[n],mul(ifac[m],ifac[n-m]));&#125;inline void check()&#123; poly f(8); for(ri i=0;i&lt;8;++i)f[i]=i; init(8); f.resize(lim); ntt(f,1); ntt(f,-1);&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); for(ri i=1;i&lt;=n;++i)a[i]=read(),m+=a[i]; if(n==1)&#123; cout&lt;&lt;a[1]; return 0; &#125; init_fac(); init_ntt(); check(); for(ri i=1;i&lt;=n;++i)&#123; poly fa(a[i]+1),fb(a[i]+1); for(ri j=1;j&lt;=a[i];++j)fa[j]=mul(C(a[i]+j-1,a[i]-j),fac[j-1]); if(i==1)for(ri j=1;j&lt;=a[i];++j)Mul(fa[j],inv[j]); for(ri j=0;j&lt;=a[i];++j)fb[a[i]-j]=j&amp;1?mod-ifac[j]:ifac[j]; fa=fa*fb; f[i]=poly(a[i]+1); for(ri j=1;j&lt;=a[i];++j)f[i][j]=mul(fa[a[i]+j],ifac[j-1]); &#125; int res=0; poly g=solve(2,n),h(a[1]); for(ri i=0;i&lt;a[1];++i)h[i]=mul(f[1][i+1],ifac[i]); h=g*h; for(ri i=1;i&lt;h.size();++i)Add(res,mul(h[i],fac[i])); if(a[1]&gt;1)&#123; h=poly(a[1]-1); for(ri i=0;i&lt;a[1]-1;++i)h[i]=mul(f[1][i+2],ifac[i]); h=g*h; for(ri i=1;i&lt;h.size();++i)Dec(res,mul(h[i],fac[i])); &#125; cout&lt;&lt;mul(res,m); return 0;&#125; Endless Spin 解题思路： 又一道套路题，考虑用 min−maxmin-maxmin−max 容斥转化问题，变为求一个集合所有元素第一次被覆盖时间的最小值，这个可以用概率转化+一个简单 dpdpdp 来求，首先设这个集合某个元素被覆盖的概率为 PPP ，那么这个集合某个元素被覆盖的期望次数为 ∑i=0+∞(1−P1)i=1P\\sum\\limits_{i=0}^{+\\infty}(\\frac{1-P}{1})^i=\\frac1Pi=0∑+∞​(11−P​)i=P1​ ，设 fi,j,0/1f_{i,j,0/1}fi,j,0/1​ 表示处理到第 iii 个位置，有 jjj 个区间跟当前集合不相交，当前集合中元素的奇偶性为 0/10/10/1 的方案数，然后该怎么转移怎么转移，注意最后答案要维护一个小数类 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly;#define fi first#define se second#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;const int N=55;int n;struct Db&#123; ll a[31]; inline ll&amp;operator[](const int&amp;k)&#123;return a[k];&#125; inline const ll&amp;operator[](const int&amp;k)const&#123;return a[k];&#125; inline void trans(ll _a,ll _b)&#123; a[0]=_a/_b; _a%=_b; for(ri i=1;i&lt;=30;++i)_a*=10,a[i]=_a/_b,_a%=_b; &#125; friend inline Db operator+(Db a,Db b)&#123; Db c; ll dt=0; for(ri i=30;~i;--i)&#123; c[i]=a[i]+b[i]+dt; if(i)dt=c[i]/10,c[i]%=10; &#125; return c; &#125; friend inline Db operator-(Db a,Db b)&#123; for(ri i=30;i;--i)&#123; if(a[i]&lt;b[i])--a[i-1],a[i]+=10; a[i]-=b[i]; &#125; return a[0]-=b[0],a; &#125; friend inline Db operator*(Db a,ll b)&#123; ll dt=0; for(ri i=30;~i;--i)&#123; a[i]*=b; a[i]+=dt; if(i)dt=a[i]/10,a[i]%=10; &#125; return a; &#125;&#125;res[N],tmp1,tmp2,tmp;inline void print(Db a)&#123; if(a[16]&gt;4)++a[15]; for(ri i=15;i;--i)&#123; if(a[i]==10)++a[i-1],a[i]=0; else break; &#125; cout&lt;&lt;a[0]&lt;&lt;'.'; for(ri i=1;i&lt;=15;++i)cout&lt;&lt;a[i]; puts(\"\");&#125;inline int calc(int x)&#123;return x*(x+1)&gt;&gt;1;&#125;ll f[N][N*N][2];//double res[N];inline void init()&#123; for(ri all,n=1;n&lt;=50;++n)&#123; memset(f,0,sizeof(f)); f[0][0][0]=1; for(ri i=1;i&lt;=n;++i)for(ri j=0;j&lt;i;++j) for(ri num=calc(i-j-1),up=calc(i);num&lt;=up;++num) for(ri op=0;op&lt;2;++op)f[i][num][op]+=f[j][num-calc(i-j-1)][!op]; all=calc(n); tmp1.trans(0,1); tmp2.trans(0,1); for(ri i=1;i&lt;=n;++i)for(ri num=0,up=calc(i);num&lt;=up;++num)if(f[i][num][1]!=f[i][num][0])&#123; tmp.trans(f[i][num][1],all-num-calc(n-i)); tmp1=tmp1+tmp*all; tmp.trans(f[i][num][0],all-num-calc(n-i)); tmp2=tmp2+tmp*all; &#125; res[n]=tmp1-tmp2; &#125;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif init(); for(ri tt=read();tt;--tt)print(res[read()]); return 0;&#125; 斐波那契的最小公倍数 解题思路： 首先有一个结论 gcd⁡(fiba,fibb)=fibgcd⁡(a,b)\\gcd(fib_a,fib_b)=fib_{\\gcd(a,b)}gcd(fiba​,fibb​)=fibgcd(a,b)​ ，下面给出证明： 首先有两个引理 gcd⁡(fibi,fibi−1)=gcd⁡(fibi−1,fibi−2)=⋯=1\\gcd(fib_i,fib_{i-1})=\\gcd(fib_{i-1},fib_{i-2})=\\cdots=1gcd(fibi​,fibi−1​)=gcd(fibi−1​,fibi−2​)=⋯=1 fibn+m=fibn−1×fibm+fibn×fibm+1fib_{n+m}=fib_{n-1}\\times fib_{m}+fib_{n}\\times fib_{m+1}fibn+m​=fibn−1​×fibm​+fibn​×fibm+1​ ，这个考虑利用数学归纳法， m=1m=1m=1 时显然成立，那么 fibn+m=fibn+m−1+fibn+m−2=fibn−1fibm−1+fibnfibm+fibn−2fibm−1+fibn−1fibm=fibnfibm−1+fibnfibm+fibn−1fibm=fibn−1fibm+fibnfibm+1⇒gcd⁡(fibn+m,fibn)=gcd⁡(fibn−1fibm+fibnfibm+1,fibn)=gcd⁡(fibn−1fibm,fibn)=gcd⁡(fibn,fibm)\\begin{aligned} fib_{n+m}=&amp;fib_{n+m-1}+fib_{n+m-2}\\\\ =&amp;fib_{n-1}fib_{m-1}+fib_{n}fib_{m}+fib_{n-2}fib_{m-1}+fib_{n-1}fib_{m}\\\\ =&amp;fib_{n}fib_{m-1}+fib_{n}fib_{m}+fib_{n-1}fib_{m}\\\\ =&amp;fib_{n-1}fib_{m}+fib_{n}fib_{m+1}\\\\ \\Rightarrow \\gcd(fib_{n+m},fib_n)=&amp;\\gcd(fib_{n-1}fib_{m}+fib_{n}fib_{m+1},fib_n)\\\\ =&amp;\\gcd(fib_{n-1}fib_{m},fib_n)\\\\ =&amp;\\gcd(fib_n,fib_m) \\end{aligned} fibn+m​====⇒gcd(fibn+m​,fibn​)===​fibn+m−1​+fibn+m−2​fibn−1​fibm−1​+fibn​fibm​+fibn−2​fibm−1​+fibn−1​fibm​fibn​fibm−1​+fibn​fibm​+fibn−1​fibm​fibn−1​fibm​+fibn​fibm+1​gcd(fibn−1​fibm​+fibn​fibm+1​,fibn​)gcd(fibn−1​fibm​,fibn​)gcd(fibn​,fibm​)​ 发现就是辗转相除的形式，因此原命题得证 现在考虑到最后答案相当于是质因数的指数取 max⁡\\maxmax ，因此我们对指数给 min−maxmin-maxmin−max 容斥一波变成取 min⁡\\minmin lcm(f{S})=∏T⊆S,T≠∅fgcd⁡{T}(−1)∣T∣+1\\begin{aligned} lcm(f_{\\{S\\}})=\\prod\\limits_{T\\subseteq S,T\\not=\\emptyset}f_{\\gcd\\{T\\}}^{(-1)^{|T|+1}} \\end{aligned} lcm(f{S}​)=T⊆S,T​=∅∏​fgcd{T}(−1)∣T∣+1​​ 那么问题可以转化为求 gcd⁡=d\\gcd=dgcd=d 且集合大小为奇数/偶数的集合有多少个，显然可以用 MobiusMobiusMobius 反演搞，复杂度 O(nln⁡n)O(n\\ln n)O(nlnn) CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly;#define fi first#define se second#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p,int md)&#123;int ret=1;for(;p;p&gt;&gt;=1,a=(ll)a*a%md)(p&amp;1)&amp;&amp;(ret=(ll)ret*a%md);return ret;&#125;&#125;using namespace modular;const int N=50005,M=1e6+5;int fib[M],pw[M],cnt[M],a[N],mu[M],pri[M],tot=0,mx=0,n,ct[M];bool vs[M];inline void init()&#123; fib[1]=fib[2]=1; for(ri i=3;i&lt;=mx;++i)fib[i]=add(fib[i-1],fib[i-2]); for(ri i=1;i&lt;=mx;++i)for(ri j=i;j&lt;=mx;j+=i)cnt[i]+=ct[j]; mu[1]=1; for(ri i=2;i&lt;=mx;++i)&#123; if(!vs[i])pri[++tot]=i,mu[i]=mod-2; for(ri j=1,up=mx/i;j&lt;=tot&amp;&amp;pri[j]&lt;=up;++j)&#123; vs[i*pri[j]]=1; if(i==i/pri[j]*pri[j])&#123; mu[i*pri[j]]=0; break; &#125; mu[i*pri[j]]=mod-1-mu[i]; &#125; &#125;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); for(ri i=1;i&lt;=n;++i)a[i]=read(),mx=max(mx,a[i]); sort(a+1,a+n+1),n=unique(a+1,a+n+1)-a-1; for(ri i=1;i&lt;=n;++i)++ct[a[i]]; init(); for(ri i=1;i&lt;=mx;++i)cnt[i]&amp;&amp;(cnt[i]=ksm(2,cnt[i]-1,mod-1)); for(ri i=1;i&lt;=mx;++i)for(ri j=i;j&lt;=mx;j+=i) pw[i]=(pw[i]+(ll)mu[j/i]*cnt[j]%(mod-1))%(mod-1); for(ri i=1;i&lt;=mx;++i)cnt[i]&amp;&amp;(--cnt[i]); for(ri i=1;i&lt;=mx;++i)for(ri j=i;j&lt;=mx;j+=i) pw[i]=(pw[i]-(ll)mu[j/i]*cnt[j]%(mod-1)+(mod-1))%(mod-1); int res=1; for(ri i=1;i&lt;=mx;++i)Mul(res,ksm(fib[i],pw[i],mod)); cout&lt;&lt;res; return 0;&#125; 最小公倍佩尔数 解题思路： 首先可以解出递推式 fi=2fi−1+fi−2f_i=2f_{i-1}+f_{i-2}fi​=2fi−1​+fi−2​ ，跟上一道题一样可以推出 gcd⁡(fi,fj)=fgcd⁡(i,j)\\gcd(f_i,f_j)=f_{\\gcd(i,j)}gcd(fi​,fj​)=fgcd(i,j)​ ，但发现这题每组数据要求多个答案，因此上道题的方法貌似已经不适用了，我们考虑一种新的转化： lcm(f{S})=∏T⊆S,T≠∅fgcd⁡{T}(−1)∣T∣+1\\begin{aligned} lcm(f_{\\{S\\}})=\\prod\\limits_{T\\subseteq S,T\\not=\\emptyset}f_{\\gcd\\{T\\}}^{(-1)^{|T|+1}} \\end{aligned} lcm(f{S}​)=T⊆S,T​=∅∏​fgcd{T}(−1)∣T∣+1​​ 考虑构造函数 g(x)g(x)g(x) 满足 ∏d∣xg(d)=f(x)\\prod\\limits_{d|x}g(d)=f(x)d∣x∏​g(d)=f(x) ，发现这个 g(x)g(x)g(x) 居然也能 O(nln⁡n)O(n\\ln n)O(nlnn) 的时间预处理出来，且 lcm(f{S})=∏T⊆S,T≠∅(∏d∣gcd⁡{T}g(d))(−1)∣T∣+1=∏dgd∑T⊆S,T≠∅,d∣gcd⁡{T}(−1)T=∏dgd\\begin{aligned} lcm(f_{\\{S\\}})=&amp;\\prod\\limits_{T\\subseteq S,T\\not=\\emptyset}(\\prod\\limits_{d|\\gcd{\\{T\\}}}g(d))^{(-1)^{|T|+1}}\\\\ =&amp;\\prod\\limits_{d}g_d^{\\sum\\limits_{T\\subseteq S,T\\not=\\emptyset,d|\\gcd{\\{T\\}}}(-1)^T}\\\\ =&amp;\\prod\\limits_{d}g_d \\end{aligned} lcm(f{S}​)===​T⊆S,T​=∅∏​(d∣gcd{T}∏​g(d))(−1)∣T∣+1d∏​gdT⊆S,T​=∅,d∣gcd{T}∑​(−1)T​d∏​gd​​ CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly;#define fi first#define se second#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular&#123; int mod; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int a)&#123;return ksm(a,mod-2);&#125;&#125;using namespace modular;const int N=1e6+5;int f[N],g[N],n;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif for(ri tt=read();tt;--tt)&#123; n=read(),mod=read(); f[1]=g[1]=1; for(ri i=2;i&lt;=n;++i)f[i]=g[i]=add(add(f[i-1],f[i-1]),f[i-2]); for(ri t,i=2;i&lt;=n;++i)&#123; t=Inv(g[i]); for(ri j=i+i;j&lt;=n;j+=i)Mul(g[j],t); &#125; int res=0,pre=1; for(ri i=1;i&lt;=n;++i)Mul(pre,g[i]),Add(res,mul(pre,i)); cout&lt;&lt;res&lt;&lt;'\\n'; &#125; return 0;&#125; 生成树计数 解题思路： 考虑 kkk 次幂的组合意义可以用生成函数表示，那么对于每一条边构造生成函数 ft(x)=∑i=0+∞(wtx)ii!f_t(x)=\\sum\\limits_{i=0}^{+\\infty}\\frac{(w_tx)^i}{i!}ft​(x)=i=0∑+∞​i!(wt​x)i​ ，然后把这个当成元素求行列式值最后取多项式的第 KKK 项系数即可，然而直接用多项式求值不是很好做，因此我们带入点值进去算最后用牛顿插值/拉格朗日插值把系数搞出来就行了 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_backusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int x)&#123;return ksm(x,mod-2);&#125; inline int fix(int x)&#123;return (x%mod+mod)%mod;&#125;&#125;using namespace modular;const int N=55,M=10005;int n,K,m,w[N][N],a[N][N],f[N],fac[M],ifac[M],inv[M];inline void init()&#123; fac[0]=ifac[0]=fac[1]=ifac[1]=inv[1]=1; for(ri i=2;i&lt;=10000;++i)&#123; fac[i]=mul(fac[i-1],i); inv[i]=mul(inv[mod-mod/i*i],mod-mod/i); ifac[i]=mul(ifac[i-1],inv[i]); &#125;&#125;inline int calc()&#123; int res=1; for(ri ps,i=1;i&lt;n;++i)&#123; for(ps=i;ps&lt;=n;++ps)if(a[ps][i])&#123; ps=i; break; &#125; if(ps==n+1)return 0; if(ps^i)&#123; for(ri j=1;j&lt;=n;++j)swap(a[ps][j],a[i][j]); res=res?mod-res:0; &#125; for(ri j=1,t,iv=Inv(a[i][i]);j&lt;=n;++j)if(j!=i&amp;&amp;a[j][i])&#123; t=mul(a[j][i],iv); for(ri k=i;k&lt;=n;++k)Dec(a[j][k],mul(t,a[i][k])); &#125; Mul(res,a[i][i]); &#125; return res;&#125;struct Newton_Inter&#123; int up,px[M],py[M],cur,dt[2][M],f[M],ff[M]; Newton_Inter()&#123;up=cur=0;&#125; inline int&amp;operator[](const int&amp;k)&#123;return f[k];&#125; inline const int&amp;operator[](const int&amp;k)const&#123;return f[k];&#125; inline void insert(int x,int y)&#123; px[++up]=x,py[up]=y; if(up==1)dt[cur][0]=f[0]=y,ff[0]=1; else&#123; cur^=1,dt[cur][0]=y; for(ri i=1;i&lt;up;++i)dt[cur][i]=mul(dec(dt[cur][i-1],dt[!cur][i-1]),inv[px[up]-px[up-i]]); for(ri i=up-1;~i;--i)ff[i]=add(i?ff[i-1]:0,mul(mod-px[up-1],ff[i])); for(ri i=0;i&lt;up;++i)Add(f[i],mul(ff[i],dt[cur][up-1])); &#125; &#125;&#125;F;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),K=read(); init(); for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=n;++j)w[i][j]=read(); m=n*K; for(ri t=0;t&lt;=m;++t)&#123; for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=n;++j)a[i][j]=0; for(ri res,i=1;i&lt;=n;++i)for(ri j=1;j&lt;i;++j)&#123; res=0; for(ri mt=1,_t=mul(t,w[i][j]),_pw=0;_pw&lt;=K;++_pw)&#123; Add(res,mul(mt,ifac[_pw])); Mul(mt,_t); &#125; Add(a[i][i],res); Add(a[j][j],res); Dec(a[i][j],res); Dec(a[j][i],res); &#125; F.insert(t,calc()); &#125; cout&lt;&lt;mul(F[K],fac[K]); return 0;&#125; Mike and Fish 解题思路： 考虑将行列扯出来建二分图，然后将限制改为 black=whiteblack=whiteblack=white 且保证合法怎么做，发现只用在二分图上跑欧拉回路即可，那么现在可能有度数为奇数的点，我们在两边各建一个虚点处理即可 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_backusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;const int N=4e5+5;int n,idx=0;bool col[N],vs[N];pii a[N];vector&lt;pii&gt;e[N];void dfs(int p)&#123; pii tmp; while((int)e[p].size())&#123; tmp=e[p].back(); e[p].pop_back(); if(vs[tmp.se])continue; vs[tmp.se]=1; col[tmp.se]=p&lt;tmp.fi; dfs(tmp.fi); &#125;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); for(ri i=1;i&lt;=n;++i)&#123; a[i].fi=read(); a[i].se=read()+200000; ++idx; e[a[i].fi].pb(pii(a[i].se,idx)); e[a[i].se].pb(pii(a[i].fi,idx)); &#125; for(ri i=1;i&lt;=400000;++i)&#123; if(((int)e[i].size())&amp;1)&#123; ++idx; e[i].pb(pii(400001,idx)); e[400001].pb(pii(i,idx)); &#125; &#125; for(ri i=1;i&lt;=400001;++i)dfs(i); for(ri i=1;i&lt;=n;++i)cout&lt;&lt;(col[i]?'r':'b'); return 0;&#125; XOR Replace 解题思路： 设 an+1=⊕i=1naia_{n+1}=\\oplus_{i=1}^na_ian+1​=⊕i=1n​ai​ ，仔细观察发现每次操作相当于 swap(ai,an+1)swap(a_i,a_{n+1})swap(ai​,an+1​) ，那么我们将不同的 (ai,bi)(a_i,b_i)(ai​,bi​) 连边，最后按照连通块数讨论即可得到答案，大概就是联通块内按照置换的方式一定可以用连通块大小数次换完，两个连通块之间需要用一次来进行转换 CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_backusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;const int N=4e5+5;int n,a[N],b[N],_a[N],_b[N];inline bool check()&#123; for(ri i=1;i&lt;=n+1;++i)_a[i]=a[i],_b[i]=b[i]; sort(_a+1,_a+n+2); sort(_b+1,_b+n+2); for(ri i=1;i&lt;=n+1;++i)if(_a[i]^_b[i])return 0; return 1;&#125;int vl[N&lt;&lt;1],sig=0;inline int Find(int x)&#123;return lower_bound(vl+1,vl+sig+1,x)-vl;&#125;int ft[N&lt;&lt;1];inline int find(int x)&#123;return x^ft[x]?ft[x]=find(ft[x]):x;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); for(ri i=1;i&lt;=n;++i)a[n+1]^=(a[i]=read()); for(ri i=1;i&lt;=n;++i)b[n+1]^=(b[i]=read()); if(!check())&#123; cout&lt;&lt;-1; return 0; &#125; int res=0; vl[++sig]=a[n+1]; vl[++sig]=b[n+1]; for(ri i=1;i&lt;=n;++i)&#123; if(a[i]==b[i])continue; vl[++sig]=a[i]; vl[++sig]=b[i]; ++res; &#125; if(!res)&#123; cout&lt;&lt;0; return 0; &#125; sort(vl+1,vl+sig+1),sig=unique(vl+1,vl+sig+1)-vl-1; for(ri i=1;i&lt;=sig;++i)ft[i]=i; for(ri i=1;i&lt;=n+1;++i)&#123; if(a[i]==b[i])continue; a[i]=find(Find(a[i])); b[i]=find(Find(b[i])); if(a[i]^b[i])ft[b[i]]=a[i]; &#125; for(ri i=1;i&lt;=sig;++i)if(ft[i]==i)++res; cout&lt;&lt;res-1; return 0;&#125; Two Trees 解题思路： 能否构造只需考虑同一个点在两棵树中儿子数的奇偶性是否相同，下面给出相同时的构造方案 首先一棵树中一定有奇数个值为奇数的点，不妨设为 2k+12k+12k+1 个，考虑让其中 2k2k2k 个两两配对一个 111 一个 −1-1−1 ，剩下一个随意 111 或者 −1-1−1 就能保证这个子树的权值和绝对值为 111 ，那么考虑怎么限制 111 和 −1-1−1 匹配的关系：可以将当前未匹配且儿子数为偶数的点放到一个序列中然后每两个连一条边，这样两棵树都连好后一定搞出来一个二分图，二分图染色即可 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_backusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;const int N=1e5+5;int n,ans[N];vector&lt;int&gt;e[N];struct Tree&#123; vector&lt;int&gt;g[N]; int rt,stk[N],top; void dfs(int p)&#123; for(ri i=0,v;i&lt;g[p].size();++i)dfs(v=g[p][i]); if(!(((int)g[p].size())&amp;1))stk[++top]=p; while(top&gt;1)&#123; e[stk[top]].pb(stk[top-1]); e[stk[top-1]].pb(stk[top]); top-=2; &#125; &#125; inline void init()&#123; for(ri ft,i=1;i&lt;=n;++i)&#123; ft=read(); if(ft==-1)rt=i; else g[ft].pb(i); &#125; &#125; inline void solve()&#123; top=0; dfs(rt); &#125;&#125;t[2];bool vs[N],col[N];void dfs(int p,int cl)&#123; if(vs[p])return; vs[p]=1; col[p]=cl; for(ri i=0;i&lt;e[p].size();++i)dfs(e[p][i],cl^1);&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); for(ri i=0;i&lt;2;++i)t[i].init(); for(ri i=1;i&lt;=n;++i)if(((int)t[0].g[i].size()+(int)t[1].g[i].size())&amp;1)&#123; puts(\"IMPOSSIBLE\"); return 0; &#125; puts(\"POSSIBLE\"); for(ri i=0;i&lt;2;++i)t[i].solve(); for(ri i=1;i&lt;=n;++i)dfs(i,0); for(ri i=1;i&lt;=n;++i)cout&lt;&lt;((((int)t[0].g[i].size())&amp;1)?0:(col[i]?1:-1))&lt;&lt;' '; return 0;&#125;","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://ldxcaicai.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"杂题乱做 Round7","slug":"sol7","date":"2019-11-18T03:35:12.000Z","updated":"2019-12-26T04:26:08.642Z","comments":true,"path":"sol7/","link":"","permalink":"http://ldxcaicai.github.io/sol7/","excerpt":"","text":"Sockpuppets 解题思路： 考虑到题目的匹配条件显然需要建一棵 trietrietrie 树出来，注意到这棵树深度不超过 101010 ，考虑设 fi,j,kf_{i,j,k}fi,j,k​ 表示当前处理到子树 iii ，子树中有 jjj 个点需要进行匹配，自己的祖先已经有 kkk 个被提前选用匹配的方案数，然后按照当前点的类型分开转移即可 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;typedef double db;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;typedef pair&lt;ll,ll&gt; pll;typedef unsigned long long Ull;typedef unsigned int uii;typedef double db;typedef long double ld;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int a)&#123;return ksm(a,mod-2);&#125; inline void fix(int&amp;a)&#123;a=(a%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b)&#123;a&gt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmax(T&amp;a,T b)&#123;a&lt;b?a=b:0;&#125;const int N=20005;int f[N][15][25],tmp[15][25],n,m;inline int calc1(int x)&#123;return x&lt;2?1:mod+1&gt;&gt;1;&#125;inline int calc2(int x,int y)&#123; if(!x)return 1; if(x==1)return y; return (ll)y*(y-1)/2%mod;&#125;namespace trie&#123; int tot,son[N][26],cnt1[N],cnt2[N]; inline int newnode()&#123; ++tot; memset(son[tot],0,sizeof(son[tot])); cnt1[tot]=cnt2[tot]=0; return tot; &#125; inline void insert(char*s,int len,int c1,int c2)&#123; int p=0; for(ri x,i=1;i&lt;=len;++i)&#123; x=s[i]-'a'; if(!son[p][x])son[p][x]=newnode(); p=son[p][x]; &#125; cnt1[p]+=c1,cnt2[p]+=c2; &#125; void dfs(int p)&#123; for(ri i=0;i&lt;=10;++i)for(ri j=0;j&lt;=20;++j)f[p][i][j]=0; f[p][0][0]=1; for(ri v,s=0;s&lt;26;++s)if(son[p][s])&#123; dfs(v=son[p][s]); for(ri i=0;i&lt;=10;++i)for(ri j=0;j&lt;=20;++j)if(f[p][i][j]) for(ri k=0;k+i&lt;=10;++k)for(ri l=0;j+l&lt;=20;++l)if(f[v][k][l]) Add(tmp[i+k][j+l],mul(f[p][i][j],f[v][k][l])); for(ri i=0;i&lt;=10;++i)for(ri j=0;j&lt;=20;++j)&#123; f[p][i][j]=tmp[i][j]; tmp[i][j]=0; &#125; &#125; if(!cnt1[p]&amp;&amp;!cnt2[p])return; for(ri i=0;i&lt;=10;++i)for(ri j=0;j&lt;=20;++j)if(f[p][i][j])&#123; if(cnt1[p])&#123; for(ri k=0;k&lt;=2;++k)for(ri l=0;l&lt;=2;++l) if(k+l&gt;0&amp;&amp;k+l&lt;3&amp;&amp;i+k&lt;=10&amp;&amp;j&gt;=l)Add(tmp[i+k][j-l],mul(f[p][i][j],mul(calc1(k),calc2(l,j)))); &#125; else&#123; if(i)Add(tmp[i-1][j],mul(i,f[p][i][j])); if(j&lt;20)Add(tmp[i][j+1],f[p][i][j]); &#125; &#125; for(ri i=0;i&lt;=10;++i)for(ri j=0;j&lt;=20;++j)&#123; Add(f[p][i][j],tmp[i][j]); tmp[i][j]=0; &#125; &#125;&#125;char s[15];int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif for(ri tt=read(),cas=1;cas&lt;=tt;++cas)&#123; printf(\"Case #%d: \",cas); n=read(),m=read(); trie::tot=0; memset(trie::son[0],0,sizeof(trie::son[0])); for(ri i=1,len;i&lt;=n;++i)&#123; len=Read(s); trie::insert(s,len,1,0); &#125; for(ri i=1,len;i&lt;=m;++i)&#123; len=Read(s); trie::insert(s,len,0,1); &#125; trie::dfs(0); cout&lt;&lt;f[0][0][0]&lt;&lt;'\\n'; &#125; return 0;&#125; Drazil and Morning Exercise 解题思路： 我写的是自己想的一个垃圾 O(Tnlog⁡n)O(Tn\\log n)O(Tnlogn) 看了一下 mayaohuamayaohuamayaohua 神仙的 blogblogblog 貌似能用并查集优化到 O(Tnα(n))O(Tn\\alpha(n))O(Tnα(n)) ，首先预处理出每个点到其最远点的距离，然后发现若对于两个点 (u,v)(u,v)(u,v) 按照其距离从大的往小的连边会连出来一棵内向树，且对于这棵树每个点的合法范围一定是一个以其为根的连通块，那么用个离散化+ dfsdfsdfs 序+主席树就可以求子树内比某个数小的点数 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;typedef double db;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;typedef pair&lt;ll,ll&gt; pll;typedef unsigned long long Ull;typedef unsigned int uii;typedef double db;typedef long double ld;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int a)&#123;return ksm(a,mod-2);&#125; inline void fix(int&amp;a)&#123;a=(a%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b)&#123;a&gt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmax(T&amp;a,T b)&#123;a&lt;b?a=b:0;&#125;char xxx;const int N=1e5+5;vector&lt;pii&gt;e[N];int n,sig=0,rt[N];ll f[N],_f[N],g[N],vl[N],a[N];inline int find(ll x)&#123;return lower_bound(vl+1,vl+sig+1,x)-vl;&#125;void dfs1(int p,int ft)&#123; for(ri i=0,v;i&lt;e[p].size();++i)&#123; if((v=e[p][i].fi)==ft)continue; dfs1(v,p); if(f[v]+e[p][i].se&gt;=f[p])&#123; _f[p]=f[p]; f[p]=f[v]+e[p][i].se; &#125; else ckmax(_f[p],f[v]+e[p][i].se); &#125;&#125;void dfs2(int p,int ft)&#123; for(ri i=0,v;i&lt;e[p].size();++i)&#123; if((v=e[p][i].fi)==ft)continue; g[v]=max(g[p],f[v]+e[p][i].se==f[p]?_f[p]:f[p])+e[p][i].se; dfs2(v,p); &#125;&#125;int in[N],out[N],pred[N],tot=0,ps[N];void dfs(int p,int ft)&#123; pred[in[p]=++tot]=p; for(ri i=0,v;i&lt;e[p].size();++i)&#123; if((v=e[p][i].fi)==ft)continue; dfs(v,p); &#125; out[p]=tot;&#125;namespace sgt&#123; #define lc (son[p][0]) #define rc (son[p][1]) #define mid (l+r&gt;&gt;1) int siz[N*100],son[N*100][2],cnt=0; inline void update(int&amp;p,int o,int l,int r,int k)&#123; p=++cnt; siz[p]=siz[o]+1,lc=son[o][0],rc=son[o][1]; if(l==r)return; k&lt;=mid?update(lc,lc,l,mid,k):update(rc,rc,mid+1,r,k); &#125; inline int query(int a,int b,int l,int r,int ql,int qr)&#123; if(siz[a]==siz[b])return 0; if(ql&lt;=l&amp;&amp;r&lt;=qr)return siz[b]-siz[a]; if(qr&lt;=mid)return query(son[a][0],son[b][0],l,mid,ql,qr); if(ql&gt;mid)return query(son[a][1],son[b][1],mid+1,r,ql,qr); return query(son[a][0],son[b][0],l,mid,ql,qr)+query(son[a][1],son[b][1],mid+1,r,ql,qr); &#125; #undef lc #undef rc #undef mid&#125;char yyy;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); cerr&lt;&lt;(&amp;yyy-&amp;xxx)/1024/1024&lt;&lt;\"ldxcaicai\\n\"; #endif n=read(); for(ri i=1,u,v,w;i&lt;n;++i)&#123; u=read(),v=read(),w=read(); e[u].pb(pii(v,w)); e[v].pb(pii(u,w)); &#125; dfs1(1,0); dfs2(1,0); for(ri i=1;i&lt;=n;++i)vl[i]=a[i]=max(f[i],g[i]); sort(vl+1,vl+n+1),sig=unique(vl+1,vl+n+1)-vl-1; for(ri i=1;i&lt;=n;++i)a[i]=find(a[i]); int _rt=1; for(ri i=2;i&lt;=n;++i)if(a[i]&lt;a[_rt])_rt=i; dfs(_rt,0); for(ri i=1;i&lt;=n;++i)sgt::update(rt[i],rt[i-1],1,sig,a[pred[i]]); for(ri tt=read();tt;--tt)&#123; ll x=readl(); for(ri l=1,r=0;l&lt;=sig;++l)&#123; while(r&lt;sig&amp;&amp;vl[r+1]-vl[l]&lt;=x)++r; ps[l]=r; &#125; int res=0; for(ri L,R,i=1;i&lt;=n;++i)&#123; ckmax(res,sgt::query(rt[in[i]-1],rt[out[i]],1,sig,a[i],ps[a[i]])); &#125; cout&lt;&lt;res&lt;&lt;'\\n'; &#125; return 0;&#125; Numbers on the blackboard 解题思路： 这题比较有意思，考虑离线下所有询问将其放在其右端点处，同时用增量法构造一些组，最后从左向右合并每个组，而组内则从右向左合并。 考虑如何分组最优，如果一个组的所有数从右向左的累加和大于 000 就跟前一个组进行合并，否则就不合并，这个可以用并查集随便维护一下然后就做完了 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std; //MoBannamespace MoBan&#123;//Typetypedef long long ll;typedef double db;typedef long double ld;typedef unsigned long long Ull;typedef unsigned int uii;typedef const int csi; // Pairtypedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,ll&gt; pll;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;#define fi first#define se second //Vectortypedef vector&lt;int&gt; vi;typedef vector&lt;pii&gt; vii;typedef vector&lt;pll&gt; vll;typedef vector&lt;pli&gt; vli;typedef vector&lt;pil&gt; vil;#define pb push_back //Maptypedef map&lt;int,int&gt; mii;typedef map&lt;ll,int&gt; mli;typedef map&lt;int,bool&gt; mbi; //Settypedef set&lt;int&gt; si;typedef set&lt;pii&gt; sii;typedef set&lt;pli&gt; sli;typedef set&lt;pil&gt; sil;typedef set&lt;pll&gt; sll;#define ins insert#define del erase const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++) //Inputinline int read()&#123; bool f=1; int ans=0; char ch=gc(); while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125; //Fileinline void file()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); freopen(\"lx.out\",\"w\",stdout); #endif&#125; //Functionstemplate&lt;typename T&gt;inline void ckmax(T&amp;a,T b)&#123;a&lt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b)&#123;a&gt;b?a=b:0;&#125;&#125;using namespace MoBan; //Modularnamespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(csi&amp;a)&#123;return ksm(a,mod-2);&#125; inline int fix(csi&amp;a)&#123;return (a%mod+mod)%mod;&#125;&#125;using namespace modular; //My solconst int N=5e5+5,inf=1e9+7;int n,a[N],ft[N],m,ans[N],sum[N],idx[N],vl[N],pre[N],top=0,pw[N],ipw[N],ss[N];pii stk[N];vector&lt;pii&gt;qry[N];inline int find(int x)&#123;return ft[x]^x?ft[x]=find(ft[x]):x;&#125;inline int calc(int l,int r)&#123;return mul(ipw[l],dec(ss[r],ss[l-1]));&#125; //Mainsigned main()&#123; file(); n=read(),m=read(); pw[0]=ipw[0]=1; for(ri i=1;i&lt;=n;++i)&#123; a[i]=read(),ft[i]=i; pw[i]=add(pw[i-1],pw[i-1]); ipw[i]=mul(ipw[i-1],mod+1&gt;&gt;1); &#125; for(ri i=1,l,r;i&lt;=m;++i)&#123; l=read(),r=read(); qry[r].pb(pii(l,i)); &#125; for(ri i=1;i&lt;=n;++i)&#123; ss[i]=add(ss[i-1],mul(pw[i],fix(a[i]))); idx[i]=++top; stk[top]=pii(i,i); sum[top]=a[i]; vl[top]=fix(a[i]); while(top&gt;1&amp;&amp;sum[top]&gt;0)&#123; int fx=find(stk[top].fi),fy=find(stk[top-1].fi); ft[fx]=fy; if(stk[top-1].se-stk[top-1].fi+1&gt;=30||sum[top]==inf||sum[top-1]==inf)sum[top-1]=inf; else sum[top-1]=min((ll)inf,(((ll)sum[top])&lt;&lt;(stk[top-1].se-stk[top-1].fi+1))+sum[top-1]); vl[top-1]=add(mul(pw[stk[top-1].se-stk[top-1].fi+1],vl[top]),vl[top-1]); stk[top-1].se=stk[top].se; --top; &#125; pre[top]=add(pre[top-1],vl[top]); for(ri res=0,j=0,l,r,L,R,id;j&lt;qry[i].size();++j)&#123; l=qry[i][j].fi,r=i,id=qry[i][j].se; L=idx[find(l)],R=idx[find(r)]; ans[id]=add(calc(l,stk[L].se),mul(2,dec(pre[R],pre[L]))); &#125; &#125; for(ri i=1;i&lt;=m;++i)cout&lt;&lt;ans[i]&lt;&lt;'\\n'; return 0;&#125; 主旋律 解题思路： 比较套路的一道题，考虑这种 DAGDAGDAG 计数都是删去入度或者出度为 000 的点，然后枚举子集补集转化转移即可，关于这道题，定义 fsf_sfs​ 表示集合 sss 合法方案数， gsg_sgs​ 表示集合 sss 由若干强连通分量拼接而成的方案数， sumssum_ssums​ 表示集合 sss 中的边数， coes,tcoe_{s,t}coes,t​ 表示集合 sss 中子集 ttt 的出度为 000 的方案数，对于 gsg_sgs​ ，我们先不把 fsf_sfs​ 算入其中，这样就有 fs=2sums−∑T⊂SgTcoeS,Tf_s=2^{sum_s}-\\sum\\limits_{T\\subset S}g_Tcoe_{S,T}fs​=2sums​−T⊂S∑​gT​coeS,T​ ，显然 coecoecoe 是很好处理的，问题转化为求 ggg ，对于 ggg 我们枚举其最小标号所在的连通块然后就可以转移了 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;//MoBannamespace MoBan&#123;//Typetypedef long long ll;typedef double db;typedef long double ld;typedef unsigned long long Ull;typedef unsigned int uii;typedef const int csi;// Pairtypedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,ll&gt; pll;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;#define fi first#define se second//Vectortypedef vector&lt;int&gt; vi;typedef vector&lt;pii&gt; vii;typedef vector&lt;pll&gt; vll;typedef vector&lt;pli&gt; vli;typedef vector&lt;pil&gt; vil;#define pb push_back//Maptypedef map&lt;int,int&gt; mii;typedef map&lt;ll,int&gt; mli;typedef map&lt;int,bool&gt; mbi;//Settypedef set&lt;int&gt; si;typedef set&lt;pii&gt; sii;typedef set&lt;pli&gt; sli;typedef set&lt;pil&gt; sil;typedef set&lt;pll&gt; sll;#define ins insert#define del eraseconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)//Inputinline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;//Fileinline void file()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #else #ifndef ONLINE_JUDGE freopen(\"a.in\",\"r\",stdin); freopen(\"a.out\",\"w\",stdout); #endif #endif&#125;//Functionstemplate&lt;typename T&gt;inline void ckmax(T&amp;a,T b)&#123;a&lt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b)&#123;a&gt;b?a=b:0;&#125;&#125;using namespace MoBan;//Modularnamespace modular&#123; const int mod=1e9+7; inline int add(csi&amp;a,csi&amp;b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(csi&amp;a,csi&amp;b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(csi&amp;a,csi&amp;b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,csi&amp;b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,csi&amp;b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,csi&amp;b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,1),1);return ret;&#125; inline int Inv(csi&amp;a)&#123;return ksm(a,mod-2);&#125; inline void fix(int&amp;a)&#123;a=(a%mod+mod)%mod;&#125;&#125;using namespace modular;//My solconst int N=16;int n,m,in[1&lt;&lt;15],out[1&lt;&lt;15],pw[N*N],all,cnt[1&lt;&lt;15],f[1&lt;&lt;15],g[1&lt;&lt;15],sum[1&lt;&lt;15],coe[1&lt;&lt;15];inline void dfs(int S,int cur)&#123; if(!cur)return; dfs(S,(cur-1)&amp;S); int t=cur&amp;-cur; coe[cur]=add(dec(coe[cur^t],cnt[out[t]&amp;cur]),cnt[in[t]&amp;(S^cur)]);&#125;//Mainint main()&#123; file(); n=read(),m=read(); pw[0]=1; for(ri i=1;i&lt;=m;++i)pw[i]=add(pw[i-1],pw[i-1]); for(ri i=1,u,v;i&lt;=m;++i)&#123; u=read()-1,v=read()-1; out[pw[u]]|=pw[v]; in[pw[v]]|=pw[u]; &#125; all=pw[n]; for(ri s=1,t;s&lt;all;++s)&#123; t=s&amp;-s; cnt[s]=cnt[s^t]+1; sum[s]=sum[s^t]+cnt[in[t]&amp;s]+cnt[out[t]&amp;s]; dfs(s,s); for(ri ns=t^s,nt=ns;nt;nt=(nt-1)&amp;ns)Dec(g[s],mul(g[nt],f[s^nt])); f[s]=pw[sum[s]]; for(ri nt=s;nt;nt=(nt-1)&amp;s)Dec(f[s],mul(g[nt],pw[sum[s^nt]+coe[nt]])); Add(g[s],f[s]); &#125; cout&lt;&lt;f[all-1]; return 0;&#125; Biconnected 解题思路： 跟上一题思路类似，这不过这题缩完点之后变成了一棵树，因此要预处理一个 fsf_sfs​ 表示点集 sss 连通的方案数，剩下的跟上题基本一样，这里不一一赘述 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;//MoBannamespace MoBan&#123;//Typetypedef long long ll;typedef double db;typedef long double ld;typedef unsigned long long Ull;typedef unsigned int uii;typedef const int csi;// Pairtypedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,ll&gt; pll;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;#define fi first#define se second//Vectortypedef vector&lt;int&gt; vi;typedef vector&lt;pii&gt; vii;typedef vector&lt;pll&gt; vll;typedef vector&lt;pli&gt; vli;typedef vector&lt;pil&gt; vil;#define pb push_back//Maptypedef map&lt;int,int&gt; mii;typedef map&lt;ll,int&gt; mli;typedef map&lt;int,bool&gt; mbi;//Settypedef set&lt;int&gt; si;typedef set&lt;pii&gt; sii;typedef set&lt;pli&gt; sli;typedef set&lt;pil&gt; sil;typedef set&lt;pll&gt; sll;#define ins insert#define del eraseconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)//Inputinline int read()&#123; bool f=1; int ans=0; char ch=gc(); while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;//Fileinline void file()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif&#125;//Functionstemplate&lt;typename T&gt;inline void ckmax(T&amp;a,T b)&#123;a&lt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b)&#123;a&gt;b?a=b:0;&#125;&#125;using namespace MoBan;//Modularnamespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(csi&amp;a)&#123;return ksm(a,mod-2);&#125; inline int fix(csi&amp;a)&#123;return (a%mod+mod)%mod;&#125;&#125;using namespace modular;//My solconst int N=15;int n,m,f[1&lt;&lt;11],g[1&lt;&lt;11],cnt[1&lt;&lt;11],tot[1&lt;&lt;11],pw[15*15],res[1&lt;&lt;11],h[1&lt;&lt;11][1&lt;&lt;11];inline void init()&#123; pw[0]=1; for(ri i=1;i&lt;144;++i)pw[i]=add(pw[i-1],pw[i-1]); for(ri s=1;s&lt;pw[11];++s)cnt[s]=cnt[s&gt;&gt;1]+(s&amp;1);&#125;inline int lowbit(int x)&#123;return x&amp;-x;&#125;inline void init_f()&#123; f[0]=1; for(ri s=1;s&lt;pw[n];++s)&#123; g[s]=0; for(ri ns=s^lowbit(s),nt=ns;nt;nt=(nt-1)&amp;ns)Add(g[s],mul(f[s^nt],pw[tot[nt]])); f[s]=dec(pw[tot[s]],g[s]); &#125;&#125;inline int Connect(int s,int t)&#123;return dec(tot[s|t],add(tot[s],tot[t]));&#125;inline void init_h()&#123; for(ri s=0;s&lt;pw[n];++s)h[0][s]=1; for(ri s=1;s&lt;pw[n];++s)for(ri t=(pw[n]-1)^s,S=t;t;t=(t-1)&amp;S)&#123; h[s][t]=0; for(ri ns=s^lowbit(s),nt=ns;;nt=(nt-1)&amp;ns)&#123; Add(h[s][t],mul(mul(h[nt][t],f[s^nt]),Connect(s^nt,t))); if(!nt)break; &#125; &#125;&#125;//Mainint main()&#123; file(); init(); for(ri tt=read();tt;--tt)&#123; n=read(),m=read(); for(ri i=1;i&lt;pw[n];++i)tot[i]=cnt[i]*(cnt[i]-1)/2; for(ri i=1,u,v;i&lt;=m;++i)&#123; u=read()-1,v=read()-1; for(ri s=(pw[n]-1)^pw[u]^pw[v],t=s;;t=(t-1)&amp;s)&#123; --tot[t^pw[u]^pw[v]]; if(!t)break; &#125; &#125; init_f(); init_h(); for(ri s=0;s&lt;pw[n];++s)&#123; res[s]=f[s]; for(ri ns=s^lowbit(s),nt=ns;nt;nt=(nt-1)&amp;ns) Dec(res[s],mul(h[nt][s^nt],res[s^nt])); &#125; cout&lt;&lt;res[pw[n]-1]&lt;&lt;'\\n'; &#125; return 0;&#125; 集合选数 解题思路： 把题目上的限制拎出来建一个图发现是由若干网格图拼接起来的，且对于每个不被 2,32,32,3 整除的数一定作为一个网格图的左上角，每个矩阵行数约为 log⁡2n\\log_2 nlog2​n ，列数约为 log⁡3n\\log_3 nlog3​n ，这样把列状压起来转移即可 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std; //MoBannamespace MoBan&#123;//Typetypedef long long ll;typedef double db;typedef long double ld;typedef unsigned long long Ull;typedef unsigned int uii;typedef const int csi; // Pairtypedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,ll&gt; pll;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;#define fi first#define se second //Vectortypedef vector&lt;int&gt; vi;typedef vector&lt;pii&gt; vii;typedef vector&lt;pll&gt; vll;typedef vector&lt;pli&gt; vli;typedef vector&lt;pil&gt; vil;#define pb push_back //Maptypedef map&lt;int,int&gt; mii;typedef map&lt;ll,int&gt; mli;typedef map&lt;int,bool&gt; mbi; //Settypedef set&lt;int&gt; si;typedef set&lt;pii&gt; sii;typedef set&lt;pli&gt; sli;typedef set&lt;pil&gt; sil;typedef set&lt;pll&gt; sll;#define ins insert#define del erase const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++) //Inputinline int read()&#123; bool f=1; int ans=0; char ch=gc(); while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125; //Fileinline void file()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif&#125; //Functionstemplate&lt;typename T&gt;inline void ckmax(T&amp;a,T b)&#123;a&lt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b)&#123;a&gt;b?a=b:0;&#125;&#125;using namespace MoBan; //Modularnamespace modular&#123; const int mod=1e9+1; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(csi&amp;a)&#123;return ksm(a,mod-2);&#125; inline int fix(csi&amp;a)&#123;return (a%mod+mod)%mod;&#125;&#125;using namespace modular; //My solconst int N=1&lt;&lt;12;int f[2][N],n,cur;bool trans[N];inline int calc(int x)&#123; memset(f,0,sizeof(f)); vector&lt;int&gt;cnt; for(ri i=x,_cnt;i&lt;=n;i&lt;&lt;=1)&#123; _cnt=0; for(ri j=i;j&lt;=n;j*=3)++_cnt; cnt.pb(_cnt); &#125; cur=0; for(ri i=0,up=1&lt;&lt;cnt[0];i&lt;up;++i)f[cur][i]=trans[i]; for(ri i=1;i&lt;cnt.size();++i)&#123; cur^=1; for(ri t=0,_up=1&lt;&lt;cnt[i];t&lt;_up;++t)f[cur][t]=0; for(ri s=0,up=1&lt;&lt;cnt[i-1];s&lt;up;++s)if(f[cur^1][s]) for(ri t=0,_up=1&lt;&lt;cnt[i];t&lt;_up;++t)if(trans[t]&amp;&amp;(!(s&amp;t))) Add(f[cur][t],f[cur^1][s]); &#125; int res=0; for(ri i=0,up=1&lt;&lt;(cnt.back());i&lt;up;++i)Add(res,f[cur][i]); return res;&#125; //Mainint main()&#123; file(); n=read(); for(ri i=0;i&lt;(1&lt;&lt;12);++i)trans[i]=(i&lt;&lt;1)&amp;i?0:1; int res=1; for(ri i=1;i&lt;=n;++i)&#123; if(i==i/2*2||i==i/3*3)continue; Mul(res,calc(i)); &#125; cout&lt;&lt;res; return 0;&#125; 进攻！ 解题思路： 考虑一个矩形被计算的次数等于其 2×22\\times 22×2 的子矩形数+ 1×11\\times 11×1 的子矩形数- 1×21\\times 21×2 的子矩形数- 2×12\\times 12×1 的子矩形数，那么分别统计每个小矩形被计算的次数。 有一个比较显然的方法是枚举每个空白矩形然后差分，然而也可以直接对于每个点处理出其在差分数组中的值然后直接前缀和，这个用单调栈即可搞定，不会的可以看看这道题 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;#define fi first#define se second#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(bool*s)&#123; int top=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))s[++top]=ch^48,ch=gc(); return top;&#125;namespace modular&#123; const int mod=998244353; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int a)&#123;return ksm(a,mod-2);&#125; inline void fix(int&amp;x)&#123;x=(x%mod+mod)%mod;&#125;&#125;using namespace modular;const int N=2005;bool s[N][N];int n,m,K,stk[N],top=0,ht[N][N],a[N][N];int cnt1[N][N],cnt2[N][N],cnt3[N][N],cnt4[N][N],ss[N][N];//cnt3:×óÉÏ½Ç//cnt4:×óÏÂ½Ç//cnt1:ÓÒÏÂ½Ç//cnt2:ÓÒÉÏ½Ç void init(int cnt[][N],bool f1,bool f2)&#123; for(ri i=1;i&lt;=n;++i)&#123; top=0; for(ri j=1;j&lt;=m;++j)&#123; ht[i][j]=s[i][j]?ht[i-1][j]+1:0; while(top&amp;&amp;ht[i][stk[top]]&gt;ht[i][j])--top; cnt[i][j]=cnt[i][stk[top]]+ht[i][j]*(j-stk[top]); stk[++top]=j; &#125; &#125; if(f1)for(ri i=1;i+i&lt;=n;++i)for(ri j=1;j&lt;=m;++j)swap(cnt[i][j],cnt[n-i+1][j]); if(f2)for(ri i=1;i&lt;=n;++i)for(ri j=1;j+j&lt;=m;++j)swap(cnt[i][j],cnt[i][m-j+1]);&#125;inline int solve()&#123; int res=0; for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=m;++j)&#123; a[i][j]=add(dec(a[i][j],a[i-1][j-1]),add(a[i-1][j],a[i][j-1])); Add(res,ksm(a[i][j],K)); &#125; return res;&#125;inline void clear()&#123;for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=m;++j)a[i][j]=0;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),m=read(),K=read(); for(ri i=1;i&lt;=n;++i)Read(s[i]); init(cnt1,0,0); for(ri i=1;i+i&lt;=n;++i)for(ri j=1;j&lt;=m;++j)swap(s[i][j],s[n-i+1][j]); init(cnt2,1,0); for(ri i=1;i&lt;=n;++i)for(ri j=1;j+j&lt;=m;++j)swap(s[i][j],s[i][m-j+1]); init(cnt3,1,1); for(ri i=1;i+i&lt;=n;++i)for(ri j=1;j&lt;=m;++j)swap(s[i][j],s[n-i+1][j]); init(cnt4,0,1); int res=0; clear(); for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=m;++j)&#123; Add(a[i][j],cnt3[i][j]); Dec(a[i+1][j],cnt4[i][j]); Add(a[i+1][j+1],cnt1[i][j]); Dec(a[i][j+1],cnt2[i][j]); &#125; Add(res,solve()); clear(); for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=m;++j)&#123; Add(a[i][j],cnt3[i][j]); Dec(a[i+1][j],cnt4[i][j]); Add(a[i+1][j],cnt1[i][j]); Dec(a[i][j],cnt2[i][j]); &#125; Dec(res,solve()); clear(); for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=m;++j)&#123; Add(a[i][j],cnt3[i][j]); Dec(a[i][j],cnt4[i][j]); Add(a[i][j+1],cnt1[i][j]); Dec(a[i][j+1],cnt2[i][j]); &#125; Dec(res,solve()); clear(); for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=m;++j)&#123; Add(a[i][j],cnt3[i][j]); Dec(a[i][j],cnt4[i][j]); Add(a[i][j],cnt1[i][j]); Dec(a[i][j],cnt2[i][j]); &#125; Add(res,solve()); cout&lt;&lt;res; return 0;&#125; Permuted Matrices 解题思路： 考虑只有一行的时候咋做，考虑把整个序列分成 ⌊nk⌋\\lfloor\\frac{n}{k}\\rfloor⌊kn​⌋ 段，设 fif_ifi​ 表示前 iii 段带容斥系数的答案，然后枚举最后 jjj 段可以强制合并成一段转移即可，即 fi=∑j=1ifi−jCikjkf_{i}=\\sum\\limits_{j=1}^if_{i-j}C_{ik}^{jk}fi​=j=1∑i​fi−j​Cikjk​ ，加上行的限制就是把后面的组合数给行数次方，然后变个形就能上多项式搞 CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;#define fi first#define se second#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)namespace modular&#123; const int mod=1000000123; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;&#125;using namespace modular;const int N=50005;int fac[N],ifac[N],f[N],n,pre[N];inline void init()&#123; fac[0]=fac[1]=ifac[0]=ifac[1]=1; for(ri i=2;i&lt;=n;++i)&#123; fac[i]=mul(fac[i-1],i); ifac[i]=mul(ifac[mod-mod/i*i],mod-mod/i); &#125; for(ri i=2;i&lt;=n;++i)Mul(ifac[i],ifac[i-1]); for(ri i=1;i&lt;=n;++i)&#123; fac[i]=ksm(fac[i],n); ifac[i]=ksm(ifac[i],n); &#125;&#125;inline int C(int n,int m)&#123;return n&lt;m||m&lt;0?0:mul(fac[n],mul(ifac[m],ifac[n-m]));&#125;vector&lt;int&gt;a;inline int solve()&#123; f[0]=1; for(ri ss,pre=0,i=1;i&lt;a.size();++i)&#123; pre+=a[i]; f[i]=0; ss=0; for(ri j=i-1;~j;--j)&#123; ss+=a[j+1]; if((i-j)&amp;1)Add(f[i],mul(f[j],C(pre,ss))); else Dec(f[i],mul(f[j],C(pre,ss))); &#125; &#125; return f[a.size()-1];&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=50000; init(); int res=0; for(ri i=1;i&lt;=n;++i)&#123; a.resize(1); for(ri j=n;j;j-=a.back())a.pb(min(i,j)); Add(res,solve()); &#125; cout&lt;&lt;res; return 0;&#125;","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://ldxcaicai.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"杂题乱做 Round6","slug":"sol6","date":"2019-11-07T08:41:52.000Z","updated":"2019-12-26T04:26:31.458Z","comments":true,"path":"sol6/","link":"","permalink":"http://ldxcaicai.github.io/sol6/","excerpt":"","text":"随机数生成器 解题思路： 看了一下网上的解法大概是 O(nX)O(nX)O(nX) 的？其实有个 O(n2)O(n^2)O(n2) 的在这里讲一下吧 考虑用 min−maxmin-maxmin−max 容斥转化为求所有子集询问到的位置的最小值的期望，这样答案只跟所有询问覆盖的长度有关，首先考虑 nnn 个 [1,x][1,x][1,x] 间随机整数的期望最小值怎么求，考虑枚举最小值是多少以及有哪些位置是最小值然后进行变形即可，下面推一波式子： Emin=∑i=1xi∑j=1nCnj(x−i)n−jxn=∑i=1xi((x−i+1)n−(x−i)n)xn=∑i=1xinxn\\begin{aligned} E_{min}=&amp;\\frac{\\sum\\limits_{i=1}^xi\\sum\\limits_{j=1}^nC_n^j(x-i)^{n-j}}{x^n}\\\\ =&amp;\\frac{\\sum\\limits_{i=1}^xi((x-i+1)^n-(x-i)^n)}{x^n}\\\\ =&amp;\\frac{\\sum\\limits_{i=1}^xi^n}{x^n} \\end{aligned} Emin​===​xni=1∑x​ij=1∑n​Cnj​(x−i)n−j​xni=1∑x​i((x−i+1)n−(x−i)n)​xni=1∑x​in​​ 上式利用拉格朗日插值可以 O(n2)O(n^2)O(n2) 预处理，但由于该题的 xxx 范围跟 nnn 同阶因此代码里直接算的 那么现在只用考虑所有询问的子集对长度个数的贡献，因此考虑如下 dpdpdp ： 将所有的询问按左端点单增排序，设 fi,jf_{i,j}fi,j​ 表示当前覆盖长度为 iii ，之前被选中的询问覆盖到的最远点为 jjj 的带容斥系数方案数 假设当前询问区间为 [l,r][l,r][l,r] ，长度为 lenlenlen ，这样对于所有状态有如下三种转移： fi+len,r←(−1)fi,j&lt;lf_{i+len,r}\\leftarrow(-1)f_{i,j&lt;l}fi+len,r​←(−1)fi,j&lt;l​ ，维护一个行前缀和可以很快求 fi+r−j,r←(−1)fi,l≤j&lt;rf_{i+r-j,r}\\leftarrow(-1)f_{i,l\\le j&lt;r}fi+r−j,r​←(−1)fi,l≤j&lt;r​ ,维护一个对角线前缀和可以很快求 fi,j←(−1)fi,jf_{i,j}\\leftarrow(-1)f_{i,j}fi,j​←(−1)fi,j​ ，要求支持一个区间清零？？？ 经过讨论发现可以用线段树优化 dpdpdp ，复杂度为 O(n2log⁡n)O(n^2\\log n)O(n2logn) ，能过但复杂度貌似不太优秀 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174#include&lt;bits/stdc++.h&gt;#include&lt;tr1/unordered_map&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;typedef unsigned long long Ull;typedef unsigned int uii;typedef tr1::unordered_map&lt;ll,int&gt;::iterator It;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isdigit(ch)&amp;&amp;ch!='?')ch=gc(); while(isdigit(ch)||ch=='?')s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=666623333; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int a)&#123;return ksm(a,mod-2);&#125; inline void fix(int&amp;a)&#123;a=(a%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b)&#123;a&gt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmax(T&amp;a,T b)&#123;a&lt;b?a=b:0;&#125;const int N=2005;int cnt=0,f[N][N],g[N],n,q,x;inline void init()&#123; static int pw[N]; for(ri i=1;i&lt;=x;++i)pw[i]=1; for(ri i=0,res,iv=Inv(x),mt=1;i&lt;=n;++i,Mul(mt,iv))&#123; res=0; for(ri j=1;j&lt;=x;++j)&#123; Add(res,pw[j]); Mul(pw[j],j); &#125; g[i]=mul(res,mt); &#125;&#125;pii a[N];inline void check()&#123; static bool vs[N]; static int ans[N]; for(ri s=0,up=1&lt;&lt;q;s&lt;up;++s)&#123; int ct1=0,ct2=0; for(ri i=1;i&lt;=q;++i)&#123; if(s&gt;&gt;(i-1)&amp;1)&#123; ++ct1; for(ri j=a[i].fi;j&lt;=a[i].se;++j)vs[j]=1; &#125; &#125; for(ri i=1;i&lt;=n;++i)&#123; if(vs[i])++ct2; vs[i]=0; &#125; ct1&amp;1?Dec(ans[ct2],1):Add(ans[ct2],1); &#125; int res=0; for(ri i=1;i&lt;=n;++i)cerr&lt;&lt;ans[i]&lt;&lt;' '; for(ri i=1;i&lt;=n;++i)Add(res,mul(ans[i],g[i])); q&amp;1?res=dec(0,res):0; puts(\"\"); cerr&lt;&lt;res&lt;&lt;'\\n';&#125;struct sgt&#123; #define lc (p&lt;&lt;1) #define rc (p&lt;&lt;1|1) #define mid (l+r&gt;&gt;1) int ss[N&lt;&lt;2]; bool cle[N&lt;&lt;2]; inline void pushnow(int p)&#123; ss[p]=0; cle[p]=1; &#125; inline void pushdown(int p)&#123; if(cle[p])&#123; pushnow(lc); pushnow(rc); cle[p]=0; &#125; &#125; inline void pushup(int p)&#123;ss[p]=add(ss[lc],ss[rc]);&#125; inline void update(int p,int l,int r,int k,int v)&#123; if(l==r)&#123; Add(ss[p],v); return; &#125; pushdown(p); k&lt;=mid?update(lc,l,mid,k,v):update(rc,mid+1,r,k,v); pushup(p); &#125; inline void modify(int p,int l,int r,int ql,int qr)&#123; if(ql&lt;=l&amp;&amp;r&lt;=qr)return pushnow(p); pushdown(p); if(qr&lt;=mid)modify(lc,l,mid,ql,qr); else if(ql&gt;mid)modify(rc,mid+1,r,ql,qr); else modify(lc,l,mid,ql,qr),modify(rc,mid+1,r,ql,qr); pushup(p); &#125; inline int query(int p,int l,int r,int ql,int qr)&#123; if(ql&lt;=l&amp;&amp;r&lt;=qr)return ss[p]; pushdown(p); if(qr&lt;=mid)return query(lc,l,mid,ql,qr); if(ql&gt;mid)return query(rc,mid+1,r,ql,qr); return add(query(lc,l,mid,ql,qr),query(rc,mid+1,r,ql,qr)); &#125; #undef lc #undef rc #undef mid&#125;s1[N],s2[N];inline void update(int a,int b,int vl)&#123; if(!vl)return; s1[a].update(1,0,n,b,vl); s2[b-a].update(1,0,n,a,vl);&#125;int sig=0;inline bool cmp(pii a,pii b)&#123;return a.fi^b.fi?a.fi&gt;b.fi:a.se&lt;b.se;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),x=read(),q=read(); init(); for(ri i=1;i&lt;=q;++i)a[i].fi=read(),a[i].se=read(); sort(a+1,a+q+1,cmp); int mnr=0x3f3f3f3f; for(ri i=1;i&lt;=q;++i)&#123; if(mnr&gt;a[i].se)&#123; mnr=a[i].se; a[++sig]=a[i]; &#125; &#125; q=sig; sort(a+1,a+q+1); update(0,0,mod-1); for(ri i=1,l,r,len;i&lt;=q;++i)&#123; l=a[i].fi,r=a[i].se,len=r-l+1; for(ri j=0;j+len&lt;=n&amp;&amp;j&lt;l;++j)update(j+len,r,dec(0,s1[j].query(1,0,n,0,l-1))); if(l&lt;r)for(ri j=1;j&lt;r;++j)update(j+1,r,dec(0,s2[r-j-1].query(1,0,n,max(j+l-r+1,1),j))); &#125; int res=0; for(ri i=1;i&lt;=n;++i)Add(res,mul(g[i],s1[i].query(1,0,n,0,n))); cout&lt;&lt;res; return 0;&#125; 考虑继续优化 经过观察发现如果一个大区间包含了一个小区间，那么大区间可以舍掉，因为最终答案一定在小区间中，于是在进行掉这一步处理之后所有询问区间的左右端点都是单增的，也就是说对于第三种转移后面的 fi,jf_{i,j}fi,j​ 本来就是 000 ，那么只用维护行前缀和和对角线前缀和即可，复杂度为 O(qlog⁡q+n2)O(q\\log q+n^2)O(qlogq+n2) ，可以加强到 n≤5000,x≤1e9,q≤1e6n\\le5000,x\\le 1e9,q\\le1e6n≤5000,x≤1e9,q≤1e6 了 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include&lt;bits/stdc++.h&gt;#include&lt;tr1/unordered_map&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;typedef unsigned long long Ull;typedef unsigned int uii;typedef tr1::unordered_map&lt;ll,int&gt;::iterator It;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isdigit(ch)&amp;&amp;ch!='?')ch=gc(); while(isdigit(ch)||ch=='?')s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=666623333; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int a)&#123;return ksm(a,mod-2);&#125; inline void fix(int&amp;a)&#123;a=(a%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b)&#123;a&gt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmax(T&amp;a,T b)&#123;a&lt;b?a=b:0;&#125;const int N=2005;int cnt=0,f[N][N],g[N],n,q,x;inline void init()&#123; static int pw[N]; for(ri i=1;i&lt;=x;++i)pw[i]=1; for(ri i=0,res,iv=Inv(x),mt=1;i&lt;=n;++i,Mul(mt,iv))&#123; res=0; for(ri j=1;j&lt;=x;++j)&#123; Add(res,pw[j]); Mul(pw[j],j); &#125; g[i]=mul(res,mt); &#125;&#125;pii a[N];int s1[N][N],s2[N][N];int sig=0;inline bool cmp(pii a,pii b)&#123;return a.fi^b.fi?a.fi&gt;b.fi:a.se&lt;b.se;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),x=read(),q=read(); init(); for(ri i=1;i&lt;=q;++i)a[i].fi=read(),a[i].se=read(); sort(a+1,a+q+1,cmp); int mnr=0x3f3f3f3f; for(ri i=1;i&lt;=q;++i)&#123; if(mnr&gt;a[i].se)&#123; mnr=a[i].se; a[++sig]=a[i]; &#125; &#125; q=sig; sort(a+1,a+q+1); s1[0][0]=s2[0][0]=f[0][0]=mod-1; int prer=0; for(ri i=1,prer=0,l,r,len;i&lt;=q;++i)&#123; l=a[i].fi,r=a[i].se,len=r-l+1; while(prer&lt;r-1)&#123; ++prer; for(ri j=0;j&lt;=prer;++j)&#123; s1[j][prer]=add(s1[j][prer-1],f[j][prer]); s2[prer-j][j]=add(j?s2[prer-j][j-1]:0,f[j][prer]); &#125; &#125; for(ri t,j=0;j+len&lt;=n&amp;&amp;j&lt;l;++j)&#123; t=s1[j][l-1]; if(t)Add(f[j+len][r],mod-t); &#125; if(l&lt;r)for(ri t,j=1;j&lt;r;++j)&#123; t=dec(s2[r-j-1][j],s2[r-j-1][max(j+l-r,0)]); if(t)Add(f[j+1][r],mod-t); &#125; &#125; while(prer&lt;n)&#123; ++prer; for(ri i=0;i&lt;=prer;++i)&#123; s1[i][prer]=add(s1[i][prer-1],f[i][prer]); s2[prer-i][i]=add(i?s2[prer-i][i-1]:0,f[i][prer]); &#125; &#125; int res=0; for(ri i=1;i&lt;=n;++i)Add(res,mul(g[i],s1[i][n])); cout&lt;&lt;res; return 0;&#125; 地震后的幻想乡 解题思路： 看到全排列就想到状压连通块子集 dpdpdp ，设 fs,if_{s,i}fs,i​ 表示当前连通块为 sss ，用了 iii 条边使得其连通的方案数， gs,ig_{s,i}gs,i​ 表示其不连通的方案数，补集转化转移最后统计答案即可 CODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;typedef double db;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;typedef unsigned long long Ull;typedef unsigned int uii;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isdigit(ch)&amp;&amp;ch!='?')ch=gc(); while(isdigit(ch)||ch=='?')s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=666623333; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int a)&#123;return ksm(a,mod-2);&#125; inline void fix(int&amp;a)&#123;a=(a%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b)&#123;a&gt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmax(T&amp;a,T b)&#123;a&lt;b?a=b:0;&#125;db f[1&lt;&lt;10][46],g[1&lt;&lt;10][46],C[46][46];int n,m,all,cnt[1&lt;&lt;10],pw[11];inline void init()&#123; pw[0]=1; for(ri i=1;i&lt;=n;++i)pw[i]=pw[i-1]+pw[i-1]; for(ri i=0;i&lt;=m;++i)&#123; C[i][0]=1; for(ri j=1;j&lt;=i;++j)C[i][j]=C[i-1][j-1]+C[i-1][j]; &#125;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),m=read(); init(); all=pw[n]-1; for(ri i=1,a,b;i&lt;=m;++i)&#123; a=read()-1,b=read()-1; for(ri s=all^pw[a]^pw[b],t=s;;t=(t-1)&amp;s)&#123; ++cnt[t^pw[a]^pw[b]]; if(!t)break; &#125; &#125; for(ri s=0;s&lt;=all;++s)&#123; for(ri i=0;i&lt;=cnt[s];++i)&#123; for(ri ts=s^(s&amp;-s),t=ts;t;t=(t-1)&amp;ts)&#123; for(ri j=0,up=min(cnt[t],i);j&lt;=up;++j) g[s][i]+=C[cnt[t]][j]*f[s^t][i-j]; &#125; f[s][i]=C[cnt[s]][i]-g[s][i]; &#125; &#125; db res=0; for(ri i=0;i&lt;=m;++i)res+=g[all][i]/C[m][i]; res/=m+1; printf(\"%.6lf\",res); return 0;&#125; Hero meet devil 解题思路： [TJOI2018][TJOI2018][TJOI2018] 某题的原型吧，设 fi,jf_{i,j}fi,j​ 表示当前枚举到构造串的第 iii 位，对于模板串的 LCSLCSLCS 状态为 jjj 的方案数，然后直接转移就行了 CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;typedef double db;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;typedef unsigned long long Ull;typedef unsigned int uii;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int a)&#123;return ksm(a,mod-2);&#125; inline void fix(int&amp;a)&#123;a=(a%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b)&#123;a&gt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmax(T&amp;a,T b)&#123;a&lt;b?a=b:0;&#125;char str[20];int n,f[2][1&lt;&lt;15|5],cur,all,pw[16],cnt[1&lt;&lt;15|5],ans[20],m,a[20],b[20],trans[1&lt;&lt;15|5][4];inline void init()&#123; pw[0]=1; for(ri i=1;i&lt;=15;++i)pw[i]=pw[i-1]+pw[i-1]; for(ri i=1;i&lt;pw[15];++i)cnt[i]=cnt[i&gt;&gt;1]+(i&amp;1);&#125;char cmp[4]=&#123;'A','T','C','G'&#125;;inline void Init()&#123; for(ri s=0;s&lt;=all;++s)&#123; for(ri ns,op=0;op&lt;4;++op)&#123; for(ri j=1;j&lt;=m;++j)&#123; a[j]=(s&gt;&gt;(j-1)&amp;1)+a[j-1]; b[j]=max(max(a[j],b[j-1]),a[j-1]+(str[j]==cmp[op])); &#125; ns=0; for(ri j=1;j&lt;=m;++j)ns|=(b[j]-b[j-1])&lt;&lt;(j-1); trans[s][op]=ns; &#125; &#125;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif init(); for(ri tt=read();tt;--tt)&#123; m=Read(str); for(ri i=1;i&lt;=m;++i)ans[i]=0; n=read(),all=pw[m]-1; f[cur=0][0]=1; Init(); for(ri i=1;i&lt;=all;++i)f[cur][i]=0; for(ri i=1;i&lt;=n;++i)&#123; cur^=1; for(ri s=0;s&lt;=all;++s)f[cur][s]=0; for(ri s=0;s&lt;=all;++s)if(f[cur^1][s])for(ri op=0;op&lt;4;++op) Add(f[cur][trans[s][op]],f[cur^1][s]); &#125; for(ri i=0;i&lt;=all;++i)Add(ans[cnt[i]],f[cur][i]); for(ri i=0;i&lt;=m;++i)cout&lt;&lt;ans[i]&lt;&lt;'\\n'; &#125; return 0;&#125; 购票 解题思路： 有一眼的状态转移式和限制条件，放在序列上面的话直接斜率优化即可，现在放在树上就需要用 cdqcdqcdq 分治的思想先更新祖先，那么每次选当前树的重心然后将其儿子抠掉递归处理剩余部分，然后用剩余部分更新抠掉的部分，然后递归抠掉的部分即可 口胡：貌似也可以利用 dfsdfsdfs 序搞四维偏序，但没实现不知道正确性 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;typedef double db;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;typedef pair&lt;ll,ll&gt; pll;typedef unsigned long long Ull;typedef unsigned int uii;typedef double db;typedef long double ld;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int a)&#123;return ksm(a,mod-2);&#125; inline void fix(int&amp;a)&#123;a=(a%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b)&#123;a&gt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmax(T&amp;a,T b)&#123;a&lt;b?a=b:0;&#125;const int N=2e5+5;int n,typ,siz[N],fa[N],all,msz,rt;bool vs[N];vector&lt;int&gt;e[N];ll dis[N],p[N],q[N],lm[N],f[N];void getroot(int p)&#123; siz[p]=1; int ms=0; for(ri i=0,v;i&lt;e[p].size();++i)&#123; if(vs[v=e[p][i]])continue; getroot(v); siz[p]+=siz[v]; ckmax(ms,siz[v]); &#125; ckmax(ms,all-siz[p]); if(msz&gt;ms&amp;&amp;siz[p]!=1)msz=ms,rt=p;&#125;pll a1[N],a2[N];int top1,top2;void get(int p)&#123; a2[++top2]=pll(dis[p]-lm[p],p); for(ri i=0,v;i&lt;e[p].size();++i)if(!vs[v=e[p][i]])get(v);&#125;inline ll calc(int x,pll y)&#123;return y.se+q[x]+(dis[x]-y.fi)*p[x];&#125;const ld inf=1e499;const ll inff=1e18;inline ld slope(pll a,pll b)&#123;return a.fi==b.fi?inf:(ld)(a.se-b.se)/(ld)(a.fi-b.fi);&#125;void dfs(int p,int sz)&#123; if(sz==1)return; all=msz=sz,rt=p; getroot(p); int cur=rt,x; for(ri i=0;i&lt;e[cur].size();++i)vs[e[cur][i]]=1; dfs(p,sz-siz[cur]+1); top2=0; for(ri i=0;i&lt;e[cur].size();++i)get(e[cur][i]); sort(a2+1,a2+top2+1); x=cur; a1[top1=0]=pll(0ll,inff); pll tmp; for(ri i=top2;i;--i)&#123; while(x!=fa[p]&amp;&amp;dis[x]&gt;=a2[i].fi)&#123; tmp=pll(dis[x],f[x]); while(top1&gt;1&amp;&amp;slope(tmp,a1[top1-1])&gt;=slope(a1[top1],a1[top1-1]))--top1; a1[++top1]=tmp; x=fa[x]; &#125; if(top1)&#123; int l=1,r=top1,res=1; while(l&lt;=r)&#123; int mid=l+r&gt;&gt;1; if(calc(a2[i].se,a1[mid])&lt;=calc(a2[i].se,a1[mid-1]))res=mid,l=mid+1; else r=mid-1; &#125; ckmin(f[a2[i].se],calc(a2[i].se,a1[res])); &#125; &#125; for(ri i=0,v;i&lt;e[cur].size();++i)dfs(e[cur][i],siz[e[cur][i]]);&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); freopen(\"lx.out\",\"w\",stdout); #endif n=read(),typ=read(); for(ri i=2;i&lt;=n;++i)&#123; fa[i]=read(); dis[i]=dis[fa[i]]+readl(); e[fa[i]].pb(i); p[i]=readl(); q[i]=readl(); lm[i]=readl(); &#125; for(ri i=2;i&lt;=n;++i)f[i]=inff; dfs(1,n); for(ri i=2;i&lt;=n;++i)cout&lt;&lt;f[i]&lt;&lt;'\\n'; return 0;&#125; 随机游走 解题思路： 考虑设 fs,if_{s,i}fs,i​ 表示从 iii 出发走完集合 sss 的期望步数，发现对于 i∈si\\in si∈s ，可以从 sss 的子集转移，否则就与儿子和父亲有一个带环的转移，这样从小到大枚举 sss 再利用树上消元的思想就能用 O(2nnlog⁡)O(2^nn\\log)O(2nnlog) 预处理出答案（ log⁡\\loglog 是快速幂求逆元） CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;typedef double db;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;typedef unsigned long long Ull;typedef unsigned int uii;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isdigit(ch)&amp;&amp;ch!='?')ch=gc(); while(isdigit(ch)||ch=='?')s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=998244353; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int a)&#123;return ksm(a,mod-2);&#125; inline void fix(int&amp;a)&#123;a=(a%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b)&#123;a&gt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmax(T&amp;a,T b)&#123;a&lt;b?a=b:0;&#125;const int N=19;int n,q,x,f[1&lt;&lt;18][19],pw[19],all,inv[19];vector&lt;int&gt;e[N];int que[N],hd,tl,fa[N];struct coef&#123; int a,b; coef(int a=0,int b=0):a(a),b(b)&#123;&#125;&#125;g[19];inline void init()&#123; pw[0]=1; for(ri i=1;i&lt;=n;++i)pw[i]=pw[i-1]+pw[i-1]; all=pw[n]-1; inv[1]=1; for(ri i=2;i&lt;=n;++i)inv[i]=mul(inv[mod-mod/i*i],mod-mod/i);&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),q=read(),x=read(); init(); for(ri u,v,i=1;i&lt;n;++i)&#123; u=read(),v=read(); e[u].pb(v); e[v].pb(u); &#125; que[hd=tl=1]=1; while(hd&lt;=tl)&#123; int x=que[hd++]; for(ri i=0,v;i&lt;e[x].size();++i)&#123; if((v=e[x][i])==fa[x])continue; fa[v]=x,que[++tl]=v; &#125; &#125; for(ri s=0;s&lt;=all;++s)&#123; for(ri p,t,i=n;i;--i)&#123; p=que[i]; if(s==pw[p-1])g[p]=coef(0,0); else if(s&amp;pw[p-1])&#123; g[p]=coef(0,0); for(ri j=0;j&lt;e[p].size();++j)Add(g[p].b,f[s^pw[p-1]][e[p][j]]+1); Mul(g[p].b,inv[e[p].size()]); &#125; else&#123; g[p].a=inv[e[p].size()]; g[p].b=0; t=0; for(ri j=0,v;j&lt;e[p].size();++j)if((v=e[p][j])!=fa[p])&#123; Add(g[p].b,g[v].b); Add(t,g[v].a); &#125; Mul(g[p].b,inv[e[p].size()]); Mul(t,inv[e[p].size()]); Add(g[p].b,1); t=dec(1,t); Mul(g[p].a,Inv(t)); Mul(g[p].b,Inv(t)); &#125; &#125; for(ri p,i=1;i&lt;=n;++i)&#123; p=que[i]; f[s][p]=add(mul(g[p].a,f[s][fa[p]]),g[p].b); &#125; &#125; while(q--)&#123; int k=read(),s=0; while(k--)s^=pw[read()-1]; cout&lt;&lt;f[s][x]&lt;&lt;'\\n'; &#125; return 0;&#125; 随机算法 解题思路： 貌似我写的 O(n2n)O(n2^n)O(n2n) 被 cyktxdycyktxdycyktxdy 的 O(n22n)O(n^22^n)O(n22n) 吊着打，被喷惨了=_= 设 fsf_{s}fs​ 表示集合 sss 的答案， gsg_sgs​ 表示集合 sss 的最大独立集大小，那么我们观察 sss 中哪些点在最大独立集中，把它们和它们相邻的点删点从子集转移过来即可 CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;typedef double db;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;typedef unsigned long long Ull;typedef unsigned int uii;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isdigit(ch)&amp;&amp;ch!='?')ch=gc(); while(isdigit(ch)||ch=='?')s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=998244353; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int a)&#123;return ksm(a,mod-2);&#125; inline void fix(int&amp;a)&#123;a=(a%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b)&#123;a&gt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmax(T&amp;a,T b)&#123;a&lt;b?a=b:0;&#125;int m,trans[21],f[1&lt;&lt;20],n,pw[21],all,g[1&lt;&lt;20],inv[21];inline void init()&#123; pw[0]=1; for(ri i=1;i&lt;=n;++i)pw[i]=pw[i-1]+pw[i-1]; all=pw[n]-1; inv[1]=1; for(ri i=2;i&lt;=n;++i)inv[i]=mul(inv[mod-mod/i*i],mod-mod/i);&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),m=read(); init(); for(ri i=1,u,v;i&lt;=m;++i)&#123; u=read()-1,v=read()-1; trans[u]|=pw[v]; trans[v]|=pw[u]; &#125; for(ri s=f[0]=1,ct;s&lt;=all;++s)&#123; ct=0; for(ri t,i=0;i&lt;n;++i)if(s&amp;pw[i])&#123; t=(s&amp;(~trans[i]))^pw[i]; ++ct; if(g[t]+1==g[s])Add(f[s],f[t]); else if(g[t]+1&gt;g[s])g[s]=g[t]+1,f[s]=f[t]; &#125; Mul(f[s],inv[ct]); &#125; cout&lt;&lt;f[all]; return 0;&#125; Slay the Spire 解题思路： 易得一个性质：最多选一张攻击牌 在知道这个性质之后直接枚举选出来攻击牌的数量然后左右的贡献可以 dpdpdp 预处理出来，组合数学算就完了 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;typedef double db;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;typedef unsigned long long Ull;typedef unsigned int uii;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isdigit(ch)&amp;&amp;ch!='?')ch=gc(); while(isdigit(ch)||ch=='?')s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=998244353; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int a)&#123;return ksm(a,mod-2);&#125; inline void fix(int&amp;a)&#123;a=(a%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b)&#123;a&gt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmax(T&amp;a,T b)&#123;a&lt;b?a=b:0;&#125;const int N=3005;int n,m,K,fac[N],ifac[N],a1[N],a2[N],f1[N][N],f2[N][N];inline void init()&#123; fac[0]=fac[1]=ifac[0]=ifac[1]=1; for(ri i=2;i&lt;=3000;++i)&#123; fac[i]=mul(fac[i-1],i); ifac[i]=mul(ifac[mod-mod/i*i],mod-mod/i); &#125; for(ri i=2;i&lt;=3000;++i)Mul(ifac[i],ifac[i-1]);&#125;inline int C(int n,int m)&#123;return n&lt;m||m&lt;0?0:mul(fac[n],mul(ifac[m],ifac[n-m]));&#125;inline int calc1(int x,int ps)&#123; if(x&gt;n)return 0; int res=0; for(ri i=x-ps+1;i&lt;=n;++i)Add(res,mul(C(i-1,x-ps),dec(f1[i][ps],f1[i+1][ps]))); return res;&#125;inline int calc2(int x,int ps)&#123; if(!ps)return C(n,x); if(x&gt;n)return 0; int res=0; for(ri i=x-ps+1;i&lt;=n;++i)Add(res,mul(C(i-1,x-ps),dec(f2[i][ps],f2[i+1][ps]))); return res;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif init(); for(ri tt=read();tt;--tt)&#123; n=read(),m=read(),K=read(); for(ri i=1;i&lt;=n;++i)a2[i]=read(); for(ri i=1;i&lt;=n;++i)a1[i]=read(); sort(a1+1,a1+n+1); sort(a2+1,a2+n+1); for(ri i=1;i&lt;=n+1;++i)for(ri j=0;j&lt;=n+1;++j)f1[i][j]=f2[i][j]=0; for(ri i=n;i;--i)for(ri j=1;j&lt;=n-i+1;++j) f1[i][j]=add(add(f1[i+1][j],f1[i+1][j-1]),mul(C(n-i,j-1),a1[i])); f2[n+1][0]=1; for(ri i=n;i;--i)for(ri j=0;j&lt;=n-i+1;++j) f2[i][j]=add(f2[i+1][j],mul(a2[i],j?f2[i+1][j-1]:0)); int res=0; for(ri L,R,i=1,up=min(m,n);i&lt;=m;++i)&#123; if(m-i&gt;n)continue; R=min(K-1,m-i); L=K-R; Add(res,mul(calc1(i,L),calc2(m-i,R))); &#125; cout&lt;&lt;res&lt;&lt;'\\n'; &#125; return 0;&#125; 珍珠 解题思路： 考虑到每种数会出现奇数次或者偶数次，其中奇数次的最多有 n−2mn-2mn−2m 种，那么显然可以列出如下式子： Ans= n!∑i=0n−2mCDi(ex−e−x2)i(ex+e−x2)D−i[xn]\\begin{aligned} Ans=&amp;\\ n!\\sum\\limits_{i=0}^{n-2m}C_D^i(\\frac{e^x-e^{-x}}2)^i(\\frac{e^x+e^{-x}}2)^{D-i}[x^n] \\end{aligned} Ans=​ n!i=0∑n−2m​CDi​(2ex−e−x​)i(2ex+e−x​)D−i[xn]​ 但这样变形后并不好计算，于是考虑加一个函数对出现奇数次的生成函数进行限制： Ans= n!∑i=0n−2m(ex+e−x2+yex−e−x2)D[xn][yi]=n!2D∑i=0n−2m((1+y)ex+(1−y)e−x)D[xn][yi]=n!2D∑i=0n−2m∑j=0DCDj(1+y)j(1−j)D−je(2i−D)x[xn][yi]=n!2D∑i=0DCDi(2i−D)nn!∑j=0n−2m(1+y)i(1−y)D−i[yj]观察到(1+y)+(1−y)=2=12D∑i=0DCDi(2i−D)n∑j=0n−2m(2−(1−y))i(1−y)D−i[yj]=12D∑i=0DCDi(2i−D)n∑j=0n−2m∑k=0iCik2k(−1)i−k(1−y)D−k[yj]=12D∑i=0DCDi(2i−D)n∑j=0iCij2j(−1)i−j∑k=0n−2mCD−jk(−1)k\\begin{aligned} Ans=&amp;\\ n!\\sum\\limits_{i=0}^{n-2m}(\\frac{e^x+e^{-x}}2+y\\frac{e^x-e^{-x}}2)^D[x^n][y^i]\\\\ =&amp;\\frac{n!}{2^D}\\sum\\limits_{i=0}^{n-2m}((1+y)e^x+(1-y)e^{-x})^D[x^n][y^i]\\\\ =&amp;\\frac{n!}{2^D}\\sum\\limits_{i=0}^{n-2m}\\sum\\limits_{j=0}^DC_{D}^{j}(1+y)^j(1-j)^{D-j}e^{(2i-D)x}[x^n][y^i]\\\\ =&amp;\\frac{n!}{2^D}\\sum\\limits_{i=0}^DC_{D}^{i}\\frac{(2i-D)^n}{n!}\\sum\\limits_{j=0}^{n-2m}(1+y)^i(1-y)^{D-i}[y^j]\\\\ &amp;观察到(1+y)+(1-y)=2\\\\ =&amp;\\frac1{2^D}\\sum\\limits_{i=0}^DC_{D}^{i}(2i-D)^n\\sum\\limits_{j=0}^{n-2m}(2-(1-y))^i(1-y)^{D-i}[y^j]\\\\ =&amp;\\frac1{2^D}\\sum\\limits_{i=0}^DC_{D}^{i}(2i-D)^n\\sum\\limits_{j=0}^{n-2m}\\sum\\limits_{k=0}^iC_{i}^{k}2^k(-1)^{i-k}(1-y)^{D-k}[y^j]\\\\ =&amp;\\frac1{2^D}\\sum\\limits_{i=0}^DC_{D}^{i}(2i-D)^n\\sum\\limits_{j=0}^iC_{i}^{j}2^j(-1)^{i-j}\\sum\\limits_{k=0}^{n-2m}C_{D-j}^{k}(-1)^k\\\\ \\end{aligned} Ans=======​ n!i=0∑n−2m​(2ex+e−x​+y2ex−e−x​)D[xn][yi]2Dn!​i=0∑n−2m​((1+y)ex+(1−y)e−x)D[xn][yi]2Dn!​i=0∑n−2m​j=0∑D​CDj​(1+y)j(1−j)D−je(2i−D)x[xn][yi]2Dn!​i=0∑D​CDi​n!(2i−D)n​j=0∑n−2m​(1+y)i(1−y)D−i[yj]观察到(1+y)+(1−y)=22D1​i=0∑D​CDi​(2i−D)nj=0∑n−2m​(2−(1−y))i(1−y)D−i[yj]2D1​i=0∑D​CDi​(2i−D)nj=0∑n−2m​k=0∑i​Cik​2k(−1)i−k(1−y)D−k[yj]2D1​i=0∑D​CDi​(2i−D)nj=0∑i​Cij​2j(−1)i−jk=0∑n−2m​CD−jk​(−1)k​ 推导到这里已经有 60pts60pts60pts 了 CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular&#123; const int mod=998244353; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;&#125;using namespace modular;const int N=4005;int n,m,D,C[N][N],pw[N],_s[N][N];inline void init()&#123; pw[0]=1; for(ri i=1;i&lt;=D;++i)pw[i]=add(pw[i-1],pw[i-1]); for(ri i=0;i&lt;=D;++i)&#123; C[i][0]=1; for(ri j=1;j&lt;=i;++j) C[i][j]=add(C[i-1][j-1],C[i-1][j]); &#125; for(ri i=0;i&lt;=D;++i)&#123; _s[i][0]=C[i][0]; for(ri j=1;j&lt;=i;++j) _s[i][j]=add(_s[i][j-1],j&amp;1?mod-C[i][j]:C[i][j]); &#125;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif D=read(),n=read(),m=read(); if(n&lt;2*m)return puts(\"0\"),0; init(); int res=0; for(ri c1,c2,i=0;i&lt;=D;++i)&#123; c1=mul(C[D][i],ksm(dec(2*i,D),n)); for(ri j=0;j&lt;=i;++j)&#123; c2=mul(pw[j],C[i][j]); if((i-j)&amp;1)c2=mod-c2; Add(res,mul(c1,mul(c2,_s[D-j][min(D-j,n-2*m)]))); &#125; &#125; cout&lt;&lt;mul(res,ksm(pw[D],mod-2)); return 0;&#125; 继续推导 然后经过简单推导容易发现，s(n,m)=∑i=0mCni(−1)i=(−1)mCi−1m (m≠0)s(n,m)=\\sum\\limits_{i=0}^mC_{n}^{i}(-1)^i=(-1)^mC_{i-1}^{m}\\ (m\\not=0)s(n,m)=i=0∑m​Cni​(−1)i=(−1)mCi−1m​ (m​=0) 令 fi=s(D−i,n−m∗2)f_i=s(D-i,n-m*2)fi​=s(D−i,n−m∗2) 原式变为： 12D∑i=0DCDi(2i−D)n∑j=0iCijfj2j(−1)i−j=12D∑i=0DCDi(2i−D)ni!∑j=0ifj2jj!(−1)i−j(i−j)!\\begin{aligned} &amp;\\frac1{2^D}\\sum\\limits_{i=0}^DC_{D}^{i}(2i-D)^n\\sum\\limits_{j=0}^iC_{i}^{j}f_j2^j(-1)^{i-j}\\\\ =&amp;\\frac1{2^D}\\sum\\limits_{i=0}^DC_{D}^{i}(2i-D)^ni!\\sum\\limits_{j=0}^i\\frac{f_j2^j}{j!}\\frac{(-1)^{i-j}}{(i-j)!}\\\\ \\end{aligned} =​2D1​i=0∑D​CDi​(2i−D)nj=0∑i​Cij​fj​2j(−1)i−j2D1​i=0∑D​CDi​(2i−D)ni!j=0∑i​j!fj​2j​(i−j)!(−1)i−j​​ 然后卷积处理出 gi=∑j=0ifj2jj!(−1)i−j(i−j)!g_i=\\sum\\limits_{j=0}^i\\frac{f_j2^j}{j!}\\frac{(-1)^{i-j}}{(i-j)!}gi​=j=0∑i​j!fj​2j​(i−j)!(−1)i−j​ 即可 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef vector&lt;int&gt; poly;typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular&#123; const int mod=998244353; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int x)&#123;return ksm(x,mod-2);&#125;&#125;using namespace modular;const int N=1e5+5;int n,m,D,fac[N],ifac[N],pw[N];inline void init()&#123; fac[0]=fac[1]=ifac[0]=ifac[1]=1,pw[0]=1,pw[1]=2; for(ri i=2;i&lt;=D;++i)&#123; pw[i]=add(pw[i-1],pw[i-1]); fac[i]=mul(fac[i-1],i); ifac[i]=mul(ifac[mod-mod/i*i],mod-mod/i); &#125; for(ri i=2;i&lt;=D;++i)Mul(ifac[i],ifac[i-1]);&#125;vector&lt;int&gt;rev[23];int invv[23],w[23];inline void init_ntt()&#123; invv[0]=1; for(ri iv=mod+1&gt;&gt;1,i=1;i&lt;23;++i) invv[i]=mul(invv[i-1],iv); w[22]=ksm(3,(mod-1)&gt;&gt;23); for(ri i=21;~i;--i)w[i]=mul(w[i+1],w[i+1]);&#125;int lim,tim;inline void init(int up)&#123; lim=1,tim=0; while(lim&lt;up)lim&lt;&lt;=1,++tim; if(rev[tim].size())return; rev[tim].resize(lim); for(ri i=1;i&lt;lim;++i)rev[tim][i]=(rev[tim][i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(tim-1));&#125;inline void ntt(poly&amp;a,int type)&#123; for(ri i=0;i&lt;lim;++i)if(i&lt;rev[tim][i])swap(a[i],a[rev[tim][i]]); for(ri i=1,t=0,a0,a1;i&lt;lim;i&lt;&lt;=1,++t)for(ri j=0,len=i&lt;&lt;1;j&lt;lim;j+=len) for(ri k=0,mt=1;k&lt;i;++k,Mul(mt,w[t])) a0=a[j+k],a1=mul(a[j+k+i],mt),a[j+k]=add(a0,a1),a[j+k+i]=dec(a0,a1); if(~type)return; reverse(++a.begin(),a.end()); for(ri i=0;i&lt;lim;++i)Mul(a[i],invv[tim]);&#125;inline poly operator*(poly a,poly b)&#123; int n=a.size(),m=b.size(),t=n+m-1; if(t&lt;=64)&#123; poly c(t); for(ri i=0;i&lt;n;++i)for(ri j=0;j&lt;m;++j) Add(c[i+j],mul(a[i],b[j])); return c; &#125; init(t); a.resize(lim),ntt(a,1); b.resize(lim),ntt(b,1); for(ri i=0;i&lt;lim;++i)Mul(a[i],b[i]); return ntt(a,-1),a.resize(t),a;&#125;int f[N],g[N];inline int C(int n,int m)&#123;return n&lt;m||m&lt;0?0:mul(fac[n],mul(ifac[m],ifac[n-m]));&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif D=read(),n=read(),m=read(); if(n&lt;2*m)return puts(\"0\"),0; init(); init_ntt(); if(n==2*m)for(ri i=0;i&lt;=D;++i)f[i]=1; else&#123; if(n&amp;1)for(ri i=0;i&lt;=D;++i)f[i]=n-m*2&gt;=i?!i:add(dec(0,C(i-1,n-m*2)),i==1); else for(ri i=0;i&lt;=D;++i)f[i]=n-m*2&gt;=i?!i:add(C(i-1,n-m*2),i==1); &#125; poly a(D+1),b(D+1); for(ri i=0;i&lt;=D;++i)a[i]=mul(f[D-i],mul(pw[i],ifac[i])),b[i]=i&amp;1?dec(0,ifac[i]):ifac[i]; a=a*b; int res=0; for(ri i=0;i&lt;=D;++i)Add(res,mul(mul(C(D,i),ksm(dec(2*i,D),n)),mul(a[i],fac[i]))); cout&lt;&lt;mul(res,Inv(pw[D])); return 0;&#125;","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://ldxcaicai.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"杂题乱做 Round5","slug":"sol5","date":"2019-11-05T14:40:45.000Z","updated":"2019-12-26T04:28:08.918Z","comments":true,"path":"sol5/","link":"","permalink":"http://ldxcaicai.github.io/sol5/","excerpt":"","text":"染色 解题思路： 对于 k=2k=2k=2 的情况特判一下，然后剩下的点发现用状压 dpdpdp 会 TLETLETLE ，于是按格子转移，写个 kkk 进制轮廓线即可 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include&lt;bits/stdc++.h&gt;#include&lt;tr1/unordered_map&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;typedef unsigned long long Ull;typedef unsigned int uii;typedef tr1::unordered_map&lt;int,int&gt;::iterator It;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=376544743; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int a)&#123;return ksm(a,mod-2);&#125; inline void fix(int&amp;a)&#123;a=(a%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b)&#123;a&gt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmax(T&amp;a,T b)&#123;a&lt;b?a=b:0;&#125;const int N=1e5+5;int n,m,K,a1[N],a2[N],cur=0,pw[15],sta=0;tr1::unordered_map&lt;int,int&gt;f[2],tmp;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),m=read(),K=read(); for(ri i=1;i&lt;=m;++i)a1[i]=read(); for(ri i=1;i&lt;=m;++i)a2[i]=read(); if(K==2)&#123; for(ri i=1;i&lt;=m;++i)&#123; if(i&gt;1&amp;&amp;(a1[i]==a1[i-1]||a2[i]==a2[i-1]))&#123; puts(\"0\"); return 0; &#125; if(!(a1[i]^a2[i]^(n&amp;1)))&#123; puts(\"0\"); return 0; &#125; &#125; puts(\"1\"); return 0; &#125; pw[0]=1; int ss=0; for(ri i=1;i&lt;=m;++i)pw[i]=pw[i-1]*K,ss+=pw[i]*a1[i]; f[cur=0][ss]=1; for(ri ns,sta,trans,i=2;i&lt;n;++i)&#123; for(ri j=1;j&lt;=m;++j)&#123; cur^=1; f[cur].clear(); for(It it=f[cur^1].begin();it!=f[cur^1].end();++it)&#123; sta=it-&gt;fi,trans=it-&gt;se; for(ri k=0;k&lt;K;++k)&#123; if((j!=1&amp;&amp;(k==sta/pw[j-1]%K))||k==sta/pw[j]%K)continue; ns=sta-(sta/pw[j]%K)*pw[j]-(sta/pw[j-1]%K)*pw[j-1]; ns+=k*pw[j]+k*pw[j-1]; Add(f[cur][ns],trans); &#125; &#125; &#125; tmp.clear(); for(It it=f[cur].begin();it!=f[cur].end();++it)tmp[it-&gt;fi%pw[m]*K]=it-&gt;se; f[cur]=tmp; &#125; int res=0,sta,trans; for(It it=f[cur].begin();it!=f[cur].end();++it)&#123; bool ff=1; sta=it-&gt;fi,trans=it-&gt;se; for(ri i=1;i&lt;=m;++i)if(sta/pw[i]%K==a2[i])&#123; ff=0; break; &#125; if(ff)Add(res,trans); &#125; cout&lt;&lt;res; return 0;&#125; 外星人 解题思路： 考虑把所有人从小到大排序，然后一个一个插入现在的序列，这样一个人有贡献当且仅当其在队首，然后转移即可 CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;#include&lt;tr1/unordered_map&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;typedef unsigned long long Ull;typedef unsigned int uii;typedef tr1::unordered_map&lt;int,int&gt;::iterator It;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=998244353; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int a)&#123;return ksm(a,mod-2);&#125; inline void fix(int&amp;a)&#123;a=(a%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b)&#123;a&gt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmax(T&amp;a,T b)&#123;a&lt;b?a=b:0;&#125;const int N=5005;int n,x,a[N],cur;struct F&#123; int x,y; F(int x=0,int y=0):x(x*(y!=0)),y(y)&#123;&#125; friend inline F operator+(F a,F b)&#123;return a.x^b.x?(a.x&gt;b.x?a:b):F(a.x,add(a.y,b.y));&#125; friend inline void operator+=(F&amp;a,F b)&#123;a=a+b;&#125; friend inline F operator*(F a,int b)&#123;return F(a.x,mul(a.y,b));&#125;&#125;f[2][N];int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),x=read(); for(ri i=1;i&lt;=n;++i)a[i]=read(); sort(a+1,a+n+1); cur=0; for(ri i=0;i&lt;=x;++i)f[cur][i]=F(i,1); for(ri i=1;i&lt;=n;++i)&#123; cur^=1; for(ri j=0;j&lt;=x;++j)f[cur][j]=f[cur^1][j]*(i-1); for(ri j=0;j&lt;=x;++j)f[cur][j]+=f[cur^1][j%a[i]]; &#125; cout&lt;&lt;f[cur][x].x&lt;&lt;'\\n'&lt;&lt;f[cur][x].y; return 0;&#125; Lesson Timetable 解题思路： 比较简单的组合计数 先不考虑标号，设 fi,jf_{i,j}fi,j​ 表示前 iii 个位置放了 jjj 个人的方案数，可以轻松转移，最后再计算标号的贡献即可 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;typedef unsigned long long Ull;typedef unsigned int uii;typedef map&lt;int,int&gt;::iterator It;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int a)&#123;return ksm(a,mod-2);&#125; inline void fix(int&amp;a)&#123;a=(a%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b)&#123;a&gt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmax(T&amp;a,T b)&#123;a&lt;b?a=b:0;&#125;const int N=1005;int f[2][N],n,m,cur=0,fac[N],ifac[N],sum[N];inline void init()&#123; fac[0]=fac[1]=ifac[0]=ifac[1]=1; for(ri i=2;i&lt;=m;++i)&#123; fac[i]=mul(fac[i-1],i); ifac[i]=mul(ifac[mod-mod/i*i],mod-mod/i); &#125; for(ri i=2;i&lt;=m;++i)Mul(ifac[i],ifac[i-1]);&#125;inline int C(int n,int m)&#123;return n&lt;m||m&lt;0?0:mul(fac[n],mul(ifac[m],ifac[n-m]));&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); for(ri i=1;i&lt;=n;++i)sum[i]=sum[i-1]+read(); m=sum[n]; init(); f[cur=0][0]=1; for(ri i=1,x;i&lt;=n;++i)&#123; x=read(); cur^=1; for(ri j=0;j&lt;=sum[i];++j)f[cur][j]=0; for(ri j=0;j&lt;=sum[i-1];++j)if(f[cur^1][j])for(ri k=0,up=min(sum[i]-j,x);k&lt;=up;++k) Add(f[cur][j+k],mul(f[cur^1][j],C(sum[i]-j,k))); &#125; int res=f[cur][m]; for(ri i=1;i&lt;=n;++i)Mul(res,C(sum[n]-sum[i-1],sum[i]-sum[i-1])); cout&lt;&lt;res; return 0;&#125; On the Bench 解题思路： 考虑到若有 a×b,a×ca\\times b,a\\times ca×b,a×c 均为完全平方数的话，那么 b×cb\\times cb×c 也为完全平方数，于是可以把整个数列分成若干不相交组，组内元素相乘必定为完全平方数，不同组两个数相乘必定不为完全平方数 那么现在问题转化成了给你 mmm 个组，这 mmm 个组一共有 nnn 个数，让你将这 nnn 个数进行排列，使得相邻两个数不属于同一个组，问方案数 随便构造个带容斥系数的额生成函数乘起来即可，跟 [JSOI2019]神经网络 类似 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;typedef unsigned long long Ull;typedef unsigned int uii;typedef map&lt;int,int&gt;::iterator It;typedef vector&lt;int&gt; poly;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int a)&#123;return ksm(a,mod-2);&#125; inline void fix(int&amp;a)&#123;a=(a%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b)&#123;a&gt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmax(T&amp;a,T b)&#123;a&lt;b?a=b:0;&#125;const int N=305;int n,all=0,fac[N],ifac[N];vector&lt;int&gt;vl[N];poly f,g;inline void init()&#123; fac[0]=fac[1]=ifac[0]=ifac[1]=1; for(ri i=2;i&lt;=n;++i)&#123; fac[i]=mul(fac[i-1],i); ifac[i]=mul(ifac[mod-mod/i*i],mod-mod/i); &#125; for(ri i=2;i&lt;=n;++i)Mul(ifac[i],ifac[i-1]);&#125;inline int C(int n,int m)&#123;return n&lt;m||m&lt;0?0:mul(fac[n],mul(ifac[m],ifac[n-m]));&#125;inline bool check(int a,int b)&#123; int c=sqrt((ll)a*b); return (ll)c*c==(ll)a*b;&#125;inline poly operator*(poly a,poly b)&#123; int n=a.size(),m=b.size(),t=n+m-1; poly c(t); for(ri i=0;i&lt;n;++i)for(ri j=0;j&lt;m;++j) Add(c[i+j],mul(a[i],b[j])); return c;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); init(); for(ri x,i=1;i&lt;=n;++i)&#123; x=read(); bool ff=1; for(ri j=1;j&lt;=all;++j)if(check(vl[j].back(),x))&#123; ff=0; vl[j].pb(x); break; &#125; if(ff)vl[++all].pb(x); &#125; f=poly(1,1); int mt=1,res=0; for(ri pre=0,i=1;i&lt;=all;++i)&#123; g.resize(vl[i].size()+1); g[0]=0; for(ri j=1,up=vl[i].size();j&lt;=up;++j)g[j]=(up-j)&amp;1?mod-C(up-1,j-1):C(up-1,j-1); for(ri j=0;j&lt;=vl[i].size();++j)Mul(g[j],ifac[j]); f=f*g; pre+=vl[i].size(); Mul(mt,fac[vl[i].size()]); &#125; for(ri i=0;i&lt;f.size();++i)Add(res,mul(f[i],fac[i])); cout&lt;&lt;mul(mt,res); return 0;&#125; 摘苹果 解题思路： 首先考虑一个位置 vvv 在第一轮被走到的概率，发现是 ∑u,[(u,v)⊂e]duu2m×duu=∑duv12m=duv2m\\sum\\limits_{u,[(u,v)\\subset e]}\\frac{du_u}{2m}\\times du_u=\\sum\\limits_{du_v}\\frac1{2m}=\\frac{du_v}{2m}u,[(u,v)⊂e]∑​2mduu​​×duu​=duv​∑​2m1​=2mduv​​ 这样推下去那么每一轮走到点 iii 的概率都是 dui2m\\frac{du_i}{2m}2mdui​​ ，成 sbsbsb 题了 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;typedef unsigned long long Ull;typedef unsigned int uii;typedef map&lt;int,int&gt;::iterator It;typedef vector&lt;int&gt; poly;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int a)&#123;return ksm(a,mod-2);&#125; inline void fix(int&amp;a)&#123;a=(a%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b)&#123;a&gt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmax(T&amp;a,T b)&#123;a&lt;b?a=b:0;&#125;const int N=1e5+5;vector&lt;int&gt;e[N];int n,K,m,a[N];int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),m=read(),K=read(); for(ri i=1;i&lt;=n;++i)a[i]=read(); for(ri i=1,u,v;i&lt;=m;++i)&#123; u=read(),v=read(); e[u].pb(v); e[v].pb(u); &#125; int res=0; for(ri i=1,iv=Inv(2*m);i&lt;=n;++i)Add(res,mul(mul(e[i].size(),iv),a[i])); cout&lt;&lt;mul(res,K); return 0;&#125; 假面 解题思路： 考虑设 fi,jf_{i,j}fi,j​ 表示第 iii 个人还剩 jjj 点血的概率，然后对一个人 111 操作直接 O(ai)O(a_i)O(ai​) 转移 fif_ifi​ ， 222 操作把需要的点提出来补集转化即可 当然如果你像我一样懒的话也可以写一个暴力前后缀优化艹过去，不过复杂度是错的，当然我尝试加上了ntt优化结果本来能卡过去的TLE了。 CODE(暴力非正解优化) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;typedef unsigned long long Ull;typedef unsigned int uii;typedef map&lt;int,int&gt;::iterator It;typedef vector&lt;int&gt; poly;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=998244353; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int a)&#123;return ksm(a,mod-2);&#125; inline void fix(int&amp;a)&#123;a=(a%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b)&#123;a&gt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmax(T&amp;a,T b)&#123;a&lt;b?a=b:0;&#125;const int N=205;int n,q,c,a[N],f[N][N],m,g[N],ps[N],inv[N];inline void init()&#123; inv[1]=1; for(ri i=2;i&lt;=n;++i)inv[i]=mul(inv[mod-mod/i*i],mod-mod/i);&#125;inline int query(int id)&#123; int res=0,ad=0; for(ri i=0;i&lt;=a[id];++i)Add(ad,f[id][i]); assert(ad==1); for(ri i=1;i&lt;=a[id];++i)Add(res,mul(i,f[id][i])); return res;&#125;inline void DP()&#123; static int pre[N][N],suf[N][N],ss[N]; m=read(); for(ri i=1;i&lt;=m;++i)ps[i]=read(); for(ri i=1;i&lt;=m;++i)pre[0][i]=suf[m+1][i]=0; pre[0][0]=suf[m+1][0]=1; for(ri i=1,P1,P2;i&lt;=m;++i)&#123; P1=dec(1,f[ps[i]][0]),P2=f[ps[i]][0]; for(ri j=1;j&lt;=m;++j)pre[i][j]=add(mul(pre[i-1][j-1],P1),mul(pre[i-1][j],P2)); pre[i][0]=mul(pre[i-1][0],P2); &#125; for(ri i=m,P1,P2;i;--i)&#123; P1=dec(1,f[ps[i]][0]),P2=f[ps[i]][0]; for(ri j=1;j&lt;=m;++j)suf[i][j]=add(mul(suf[i+1][j-1],P1),mul(suf[i+1][j],P2)); suf[i][0]=mul(suf[i+1][0],P2); &#125; for(ri res=0,i=1,P;i&lt;=m;++i,res=0)&#123; P=dec(1,f[ps[i]][0]); for(ri j=0;j&lt;m;++j)if(pre[i-1][j])for(ri k=0;j+k&lt;m;++k)if(suf[i+1][k]) Add(ss[j+k],mul(pre[i-1][j],suf[i+1][k])); for(ri j=0;j&lt;m;++j)&#123; Add(res,mul(ss[j],inv[j+1])); ss[j]=0; &#125; cout&lt;&lt;mul(res,P)&lt;&lt;' '; &#125; puts(\"\");&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); for(ri i=1;i&lt;=n;++i)&#123; a[i]=read(); f[i][a[i]]=1; &#125; init(); for(ri op,p,vl,tt=read();tt;--tt)&#123; op=read(); if(!op)&#123; p=read(),vl=read(); Mul(vl,Inv(read())); for(ri i=0;i&lt;=a[p];++i)f[p][i]=add(mul(f[p][i],i?dec(1,vl):1),mul(f[p][i+1],vl)); &#125; else DP(); &#125; for(ri i=1;i&lt;=n;++i)cout&lt;&lt;query(i)&lt;&lt;' '; return 0;&#125; 记忆的轮廓 解题思路： 水题，考虑预处理一下 wi,jw_{i,j}wi,j​ 表示当前 i,ji,ji,j 为特殊点， i+1⋯j−1i+1\\cdots j-1i+1⋯j−1 均不为特殊点时从 iii 到 jjj 的期望步数，然后显然 wi,jw_{i,j}wi,j​ 满足四边形不等式，于是随便上一个决策单调性优化即可，不过该题用 O(n2)O(n^2)O(n2) 的写法的话最好 infinfinf 设到 1e3001e3001e300 左右，另外两种可以不用 infinfinf 因此就不存在什么问题 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_backusing namespace std;typedef pair&lt;int,int&gt; pii;typedef long long ll;typedef unsigned long long Ull;typedef unsigned int Uint;typedef double db;typedef long double ld;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;typedef pair&lt;ll,ll&gt; pll;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isdigit(ch)&amp;&amp;ch!='?')ch=gc(); while(isdigit(ch)||ch=='?')s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b-mod:a+b;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int a)&#123;return ksm(a,mod-2);&#125; inline void fix(int&amp;a)&#123;a=(a%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmax(T&amp;a,T&amp;b)&#123;a&lt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmin(T&amp;a,T&amp;b)&#123;a&gt;b?a=b:0;&#125;const int N=1505,M=705;int n,m,K,cur=0;ld dis[M],f[2][M],w[M][M];vector&lt;int&gt;e[N];void dfs(int p,int dep,int ori,ld coe)&#123; if(!e[p].size())&#123; dis[ori]+=coe*dep; return; &#125; int du=e[p].size()+(ori==p); for(ri i=0;i&lt;e[p].size();++i) dfs(e[p][i],dep+1,ori,coe/(ld)du);&#125;inline ld calc(int x,int p)&#123;return f[cur^1][x]+w[x][p];&#125;inline void solve(int l,int r,int L,int R)&#123; if(L==R)&#123; for(ri i=l;i&lt;=r;++i)f[cur][i]=calc(L,i); return; &#125; int mid=l+r&gt;&gt;1,ps=L; ld tmp=calc(ps,mid),t; for(ri i=ps+1;i&lt;=R&amp;&amp;i&lt;mid;++i)if((t=calc(i,mid))&lt;tmp)&#123; tmp=t; ps=i; &#125; f[cur][mid]=tmp; if(l&lt;mid)solve(l,mid-1,L,ps); if(mid&lt;r)solve(mid+1,r,ps,R);&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif for(ri tt=read();tt;--tt)&#123; n=read(),m=read(),K=read(); for(ri i=1;i&lt;=m;++i)e[i].clear(); for(ri i=1;i&lt;=n;++i)dis[i]=0; for(ri i=1,u,v;i&lt;=m-n;++i)&#123; u=read(),v=read(); e[u].pb(v); &#125; for(ri i=1;i&lt;=n;++i)if(e[i].size())dfs(i,1,i,1); ld coe,sum=0; for(ri len,i=1;i&lt;=n;++i)&#123; w[i][i]=0; coe=1.0/((ld)e[i].size()+1); len=1,sum=dis[i]; for(ri j=i+1;j&lt;=n;++j)&#123; w[i][j]=len+sum/coe; sum+=coe*dis[j]; sum+=coe*(1.0-1.0/((ld)e[j].size()+1))*len; ++len; coe*=1.0/((ld)e[j].size()+1); &#125; &#125; cur=0; for(ri i=2;i&lt;=n;++i)f[cur][i]=w[1][i]; for(ri i=3;i&lt;=K;++i)cur^=1,solve(i,n,i-1,n); printf(\"%.4Lf\\n\",f[cur][n]); &#125; return 0;&#125;","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://ldxcaicai.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"杂题乱做 Round4","slug":"sol4","date":"2019-11-03T14:46:34.000Z","updated":"2019-12-26T04:28:23.115Z","comments":true,"path":"sol4/","link":"","permalink":"http://ldxcaicai.github.io/sol4/","excerpt":"","text":"交与并 解题思路： 容易探究出如下性质： 所有合法集合可以由集合中的两个区间代替 那么对于每个区间找一个跟它交并长度乘积最大的区间即可 发现有两种相交和包含，那么先考虑如何处理包含的情况 考虑先左端点递增后右端点递减的顺序进行排序，维护当前最右端点来判断是否包含，并跟当前最右端点对应区间求贡献，但这样不一定能求出所有包含当前区间中最长的那个，这个时候考虑如下一点性质： 假设存在 A⊂B,A⊂CA\\subset B,A\\subset CA⊂B,A⊂C ，那么 B,CB,CB,C 产生的贡献优于 A,BA,BA,B 和 A,CA,CA,C 产生的贡献 这样就可以放心搞掉所有被包含的区间了，剩下的区间两两不包含且左右端点均递增，于是区间 i,ji,ji,j 的贡献为 (ri−lj+1)×(rj−li+1)(r_i-l_j+1)\\times(r_j-l_i+1)(ri​−lj​+1)×(rj​−li​+1) 拆开看发现有决策单调性，直接分治搞搞即可 CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;typedef unsigned long long Ull;typedef unsigned int uii;typedef set&lt;int&gt;::iterator It;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int a)&#123;return ksm(a,mod-2);&#125; inline void fix(int&amp;a)&#123;a=(a%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b)&#123;a&gt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmax(T&amp;a,T b)&#123;a&lt;b?a=b:0;&#125;inline bool cmp(pii a,pii b)&#123;return a.fi^b.fi?a.fi&lt;b.fi:a.se&gt;b.se;&#125;const int N=1e6+5;pii a[N];int n,sig=0;ll ans=0;inline ll calc(int x,int p)&#123;return (ll)(a[p].se-a[x].fi)*(a[x].se-a[p].fi);&#125;inline void solve(int l,int r,int L,int R)&#123; if(l&gt;r)return; if(L==R)&#123; for(ri i=l;i&lt;=r;++i)if(i&gt;L)ckmax(ans,calc(L,i)); return; &#125; int mid=l+r&gt;&gt;1,ps=L; ll tmp=calc(ps,mid),t; for(ri i=ps+1;i&lt;=R&amp;&amp;i&lt;mid;++i)if((t=calc(i,mid))&gt;tmp)&#123; tmp=t; ps=i; &#125; if(ps&lt;mid)ckmax(ans,tmp); solve(l,mid-1,L,ps); solve(mid+1,r,ps,R); &#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); for(ri i=1;i&lt;=n;++i)a[i].fi=read(),a[i].se=read(); sort(a+1,a+n+1,cmp); sig=1; for(ri ps=1,mx=a[1].se,i=2;i&lt;=n;++i)&#123; if(a[i].se&gt;mx)&#123; mx=a[i].se; ps=i; a[++sig]=a[i]; &#125; else ckmax(ans,(ll)(a[i].se-a[i].fi)*(a[ps].se-a[ps].fi)); &#125; solve(1,sig,1,sig); cout&lt;&lt;ans; return 0;&#125; 地图 解题思路： 首先考虑一个贪心，将所有数进行排序然后分成不超过 mmm 块一定是最优的，证明显然 然后就可以 fi,jf_{i,j}fi,j​ 表示前 iii 个数分为 jjj 块的最优贡献，预处理所有区间的贡献即可，复杂度 O(n2m)O(n^2m)O(n2m) CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;typedef unsigned long long Ull;typedef unsigned int uii;typedef set&lt;int&gt;::iterator It;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int a)&#123;return ksm(a,mod-2);&#125; inline void fix(int&amp;a)&#123;a=(a%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b)&#123;a&gt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmax(T&amp;a,T b)&#123;a&lt;b?a=b:0;&#125;const int N=3005,M=22;const ll inf=1e18;ll f[N][M],w[N][N],s[N];int n,m,a[N];int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),m=read(); for(ri i=1;i&lt;=n;++i)a[i]=read(); sort(a+1,a+n+1); for(ri i=1;i&lt;=n;++i)s[i]=a[i]+s[i-1]; for(ri mid,len=2;len&lt;=n;++len)for(ri l=1,r=len;r&lt;=n;++l,++r)&#123; mid=l+r&gt;&gt;1; w[l][r]=(ll)a[mid]*(mid-l)-(s[mid-1]-s[l-1])+(s[r]-s[mid])-(ll)a[mid]*(r-mid); &#125; for(ri i=0;i&lt;=n;++i)for(ri j=0;j&lt;=m;++j)f[i][j]=inf; f[0][0]=0; for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=min(m,i);++j)for(ri k=1;k&lt;=i;++k) if(f[k-1][j-1]!=inf)ckmin(f[i][j],f[k-1][j-1]+w[k][i]); cout&lt;&lt;f[n][m]; return 0;&#125; 魔兽地图DotR 解题思路： 设 fi,j,kf_{i,j,k}fi,j,k​ 表示 iii 为根的子树花费至多 jjj 元，最后拼出来了 kkk 个 iii 的最大贡献，然后由于是森林因此要分组转移，转移的时候利用提前计算贡献的思想加上后缀和优化就好 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;typedef unsigned long long Ull;typedef unsigned int uii;typedef set&lt;int&gt;::iterator It;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int a)&#123;return ksm(a,mod-2);&#125; inline void fix(int&amp;a)&#123;a=(a%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b)&#123;a&gt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmax(T&amp;a,T b)&#123;a&lt;b?a=b:0;&#125;const int inf=1e9;int g[2005],f[55][2005][105],suf[55][2005][105],cur=0,du[55],a[55],b[55],vl[55],n,m;vector&lt;pii&gt;e[55];void dfs(int p)&#123; if(!e[p].size())&#123; ckmin(b[p],m/a[p]); for(ri i=b[p];~i;--i)&#123; f[p][a[p]*i][i]=vl[p]*i; for(ri j=1;j&lt;=m;++j)&#123; ckmax(f[p][j][i],f[p][j-1][i]); suf[p][j][i]=max(f[p][j][i],suf[p][j][i+1]); &#125; &#125; return; &#125; b[p]=inf,a[p]=0; for(ri v,w,i=0;i&lt;e[p].size();++i)&#123; v=e[p][i].fi,w=e[p][i].se; dfs(v); a[p]+=a[v]*w; ckmin(b[p],b[v]/w); &#125; ckmin(b[p],m/a[p]); for(ri i=b[p];~i;--i)&#123; f[p][i*a[p]][i]=i*vl[p]; for(ri j=0,v,w,sw,svl;j&lt;e[p].size();++j)&#123; v=e[p][j].fi,w=e[p][j].se,sw=w*i*a[v],svl=w*i*vl[v]; for(ri k=m;k&gt;=i*a[p];--k)for(ri l=0,up=m-max(k,sw);l&lt;=up;++l) ckmax(f[p][k+l][i],f[p][k][i]+suf[v][sw+l][w*i]-svl); &#125; for(ri j=1;j&lt;=m;++j)&#123; ckmax(f[p][j][i],f[p][j-1][i]); suf[p][j][i]=max(f[p][j][i],suf[p][j][i+1]); &#125; &#125;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),m=read(); char ch; for(ri i=1;i&lt;=n;++i)&#123; vl[i]=read(); ch=gc(); while(!isalpha(ch))ch=gc(); if(ch=='B')a[i]=read(),b[i]=read(); else&#123; for(ri tt=read(),v,w;tt;--tt)&#123; v=read(),w=read(); e[i].pb(pii(v,w)); ++du[v]; &#125; &#125; &#125; memset(f,-0x3f,sizeof(f)); memset(suf,-0x3f,sizeof(suf)); for(ri i=1;i&lt;=n;++i)&#123; if(du[i])continue; dfs(i); for(ri j=m;j;--j)for(ri k=0;k&lt;=j;++k)ckmax(g[j],g[j-k]+suf[i][k][0]); &#125; cout&lt;&lt;g[m]; return 0;&#125; 小 Y 和二叉树 解题思路： 显然要选一个 du≤2du\\le2du≤2 的最小编号作为根，剩下的用 dfsdfsdfs 处理出子树中 du≤2du\\le2du≤2 的最小编号来贪心构造即可 实际上就是分类讨论一波 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;typedef unsigned long long Ull;typedef unsigned int uii;typedef set&lt;int&gt;::iterator It;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int a)&#123;return ksm(a,mod-2);&#125; inline void fix(int&amp;a)&#123;a=(a%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b)&#123;a&gt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmax(T&amp;a,T b)&#123;a&lt;b?a=b:0;&#125;const int N=1e6+5,inf=0x3f3f3f3f;vector&lt;int&gt;e[N];int n,du[N],rt,mn[N];void dfs(int p,int ft)&#123; if(du[p]&lt;=2)mn[p]=p; else mn[p]=inf; for(ri i=0,v;i&lt;e[p].size();++i)&#123; if((v=e[p][i])==ft)continue; dfs(v,p),ckmin(mn[p],mn[v]); &#125;&#125;inline int get1(int x,int ft)&#123; int res=0x3f3f3f3f; for(ri i=0,v;i&lt;e[x].size();++i)&#123; if((v=e[x][i])==ft)continue; ckmin(res,mn[e[x][i]]); &#125; return res;&#125;inline int get2(int x,int ft)&#123; int res=0x3f3f3f3f,siz=du[x]-(ft!=0); if(!siz)return x; if(siz==1)return min(x,get1(x,ft)); return get1(x,ft);&#125;void print(int p,int ft,bool f)&#123; vector&lt;int&gt;tmp; for(ri i=0,v;i&lt;e[p].size();++i)&#123; if((v=e[p][i])==ft)continue; tmp.pb(v); &#125; if(!tmp.size())cout&lt;&lt;p&lt;&lt;' '; else if(tmp.size()==1)&#123; if(f)&#123; cout&lt;&lt;p&lt;&lt;' '; if(get1(tmp[0],p)&lt;tmp[0])print(tmp[0],p,0); else print(tmp[0],p,1); &#125; else&#123; if(p&lt;mn[tmp[0]])&#123; cout&lt;&lt;p&lt;&lt;' '; print(tmp[0],p,0); &#125; else&#123; print(tmp[0],p,0); cout&lt;&lt;p&lt;&lt;' '; &#125; &#125; &#125; else&#123; if(f)&#123; if(get2(tmp[0],p)&gt;get2(tmp[1],p))swap(tmp[0],tmp[1]); cout&lt;&lt;p&lt;&lt;' '; print(tmp[0],p,0); print(tmp[1],p,1); &#125; else&#123; if(mn[tmp[0]]&gt;mn[tmp[1]])swap(tmp[0],tmp[1]); print(tmp[0],p,0); cout&lt;&lt;p&lt;&lt;' '; print(tmp[1],p,0); &#125; &#125;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); for(ri i=1;i&lt;=n;++i)&#123; du[i]=read(); for(ri j=1;j&lt;=du[i];++j)e[i].pb(read()); &#125; rt=n+1; for(ri i=1;i&lt;=n;++i)if(du[i]&lt;3)ckmin(rt,i); dfs(rt,0); print(rt,0,1); return 0;&#125; Anthem of Berland 解题思路： 有一个很显然的暴力思路 fi,jf_{i,j}fi,j​ 表示走到 sss 前 iii 为匹配到 ttt 的第 jjj 位的最优值，然后暴力转移（貌似还能过） 现在考虑一个不那么暴力的思路，设 fif_ifi​ 表示前 iii 位的最优值，首先考虑 s[i−m+1⋯i]s[i-m+1\\cdots i]s[i−m+1⋯i] 是否能与 ttt 匹配，如果可以就能从其 borderborderborder ， borderborderborder 的 borderborderborder 等位置转移过来，因此我们再记录一个 gig_igi​ 表示以 iii 结尾的位置跟 ttt 匹配上的最优值，然后就能转移啦 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;typedef unsigned long long Ull;typedef unsigned int uii;typedef set&lt;int&gt;::iterator It;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int a)&#123;return ksm(a,mod-2);&#125; inline void fix(int&amp;a)&#123;a=(a%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b)&#123;a&gt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmax(T&amp;a,T b)&#123;a&lt;b?a=b:0;&#125;const int N=1e5+5;char s[N],t[N];int n,m,f[N],g[N],nxt[N];int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif scanf(\"%s%s\",s+1,t+1); n=strlen(s+1),m=strlen(t+1); for(ri i=1,j=0;i&lt;m;++i)&#123; while(j&amp;&amp;t[i+1]!=t[j+1])j=nxt[j]; nxt[i+1]=t[i+1]==t[j+1]?++j:0; &#125; for(ri p,i=m;i&lt;=n;++i)&#123; bool ff=1; for(ri j=i-m+1,k=1;j&lt;=i;++j,++k)if(s[j]!='?'&amp;&amp;s[j]!=t[k])&#123; ff=0; break; &#125; if(ff)&#123; ckmax(g[i],f[i-m]+1); p=nxt[m]; while(p)&#123; ckmax(g[i],g[i-m+p]+1); p=nxt[p]; &#125; &#125; f[i]=max(f[i-1],g[i]); &#125; cout&lt;&lt;f[n]; return 0;&#125; 火鼠的皮衣 -不焦躁的内心- 解题思路： 推式子题： =∑i=0⌊n2⌋(a)2ibn−2iCn2i=∑i=0n(a)ibn−iCni[2∣i]\\begin{aligned} =&amp;\\sum\\limits_{i=0}^{\\lfloor\\frac{n}2\\rfloor}(\\sqrt a)^{2i}b^{n-2i}C_{n}^{2i}\\\\ =&amp;\\sum\\limits_{i=0}^n(\\sqrt a)^ib^{n-i}C_{n}^i[2|i] \\end{aligned} ==​i=0∑⌊2n​⌋​(a​)2ibn−2iCn2i​i=0∑n​(a​)ibn−iCni​[2∣i]​ 单位根反演一下成 sbsbsb 题了 CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;#define int long long#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() getchar()typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular&#123; int mod; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline int mul(int a,int b)&#123;return (a*b-(ll)((long double)a/mod*b)*mod+mod)%mod;&#125;&#125;using namespace modular;ll n,A,B;struct F&#123; ll x,y; F(ll x=0,ll y=0):x(x),y(y)&#123;&#125; friend inline F operator*(F &amp;a,F &amp;b)&#123;return F(add(mul(a.x,b.y),mul(a.y,b.x)),add(mul(a.y,b.y),mul(mul(a.x,b.x),A)));&#125; friend inline F operator+(F &amp;a,F &amp;b)&#123;return F(add(a.x,b.x),add(a.y,b.y));&#125;&#125;;inline F ksm(F x,ll b)&#123; F res=F(0,1); for(;b;b&gt;&gt;=1,x=x*x)if(b&amp;1)&#123; res=res*x; &#125; return res;&#125;signed main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif for(ri tt=read();tt;--tt)&#123; n=readl(),A=readl(),B=readl(),mod=readl(); F a=F(1,B%mod); a=ksm(a,n); cout&lt;&lt;a.y&lt;&lt;'\\n'; &#125; return 0;&#125; Ternary String Counting 解题思路： 设 fi,j,kf_{i,j,k}fi,j,k​ 表示填了前 iii 位，最近不同颜色出现位置为 j,kj,kj,k 的方案数 (i&gt;j&gt;k)(i&gt;j&gt;k)(i&gt;j&gt;k) ，然后能得到如下转移： fi,j,k→fi+1,i,kf_{i,j,k}\\rightarrow f_{i+1,i,k}fi,j,k​→fi+1,i,k​ fi,j,k→fi+1,j,kf_{i,j,k}\\rightarrow f_{i+1,j,k}fi,j,k​→fi+1,j,k​ fi,j,k→fi+1,i,jf_{i,j,k}\\rightarrow f_{i+1,i,j}fi,j,k​→fi+1,i,j​ 然后把每个 iii 对应的 fff 矩阵拎出来看发现等价于是每次给你画一个矩形，把外面的值变为 000 ，然后将一列/一行的和加给一个格子，并且一个位置被清零后之后那个地方不会再被修改，且对于每一行来说有值的是连续区间，于是对每一行维护有值的左右端点，行和，列和即可 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef vector&lt;int&gt; poly;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;&#125;using namespace modular;template&lt;class T&gt;inline void ckmax(T&amp;a,T b)&#123;a&lt;b?a=b:0;&#125;template&lt;class T&gt;inline void ckmin(T&amp;a,T b)&#123;a&gt;b?a=b:0;&#125;const int N=5005;int n,m;signed main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif for(ri tt=read();tt;--tt)&#123; n=read(),m=read(); vector&lt;int&gt;mn1(n+2),mx1(n+2),mn2(n+2),mx2(n+2),row(n+2),col(n+2),lp(n+2),rp(n+2); vector&lt;vector&lt;int&gt; &gt;f(n+2); for(ri i=0;i&lt;=n+1;++i)&#123; mx1[i]=mx2[i]=i-1; f[i].resize(n+2); &#125; for(ri l,r,v,i=1;i&lt;=m;++i)&#123; l=read(),r=read(),v=read(); if(v==1)&#123; ckmin(mx1[r],l-1); ckmin(mx2[r],l-1); &#125; else if(v==2)&#123; ckmax(mn1[r],l); ckmin(mx2[r],l-1); &#125; else&#123; ckmax(mn1[r],l); ckmax(mn2[r],l); &#125; &#125; bool ff=1; for(ri i=1;i&lt;=n;++i)if(mn1[i]&gt;mx1[i]||mn2[i]&gt;mx2[i])&#123; ff=0; break; &#125; if(!ff)&#123; puts(\"0\"); continue; &#125; row[0]=col[0]=f[0][0]=3,lp[0]=rp[0]=0; for(ri cur=2;cur&lt;=n;++cur)&#123; if(mx1[cur]+1==cur)&#123; for(ri i=mn2[cur];i&lt;=mx2[cur];++i) Add(f[cur-1][i],add(row[i],col[i])); for(ri i=mn2[cur];i&lt;=mx2[cur];++i) Add(col[i],f[cur-1][i]),Add(row[cur-1],f[cur-1][i]); lp[cur-1]=mn2[cur],rp[cur-1]=mx2[cur]; &#125; else lp[cur-1]=1,rp[cur-1]=0; for(ri i=0;i&lt;mn1[cur];++i)&#123; if(lp[i]&gt;rp[i])continue; for(ri j=lp[i];j&lt;=rp[i];++j)Dec(col[j],f[i][j]); row[i]=0; lp[i]=1,rp[i]=0; &#125; for(ri i=mn1[cur];i&lt;=mx1[cur];++i)&#123; if(lp[i]&lt;=rp[i])&#123; if(lp[i]&gt;mx2[cur]||rp[i]&lt;mn2[cur])&#123; for(ri j=lp[i];j&lt;=rp[i];++j)Dec(col[j],f[i][j]); row[i]=0; lp[i]=1,rp[i]=0; &#125; else&#123; for(ri j=lp[i];j&lt;mn2[cur];++j) Dec(col[j],f[i][j]),Dec(row[i],f[i][j]); ckmax(lp[i],mn2[cur]); for(ri j=rp[i];j&gt;mx2[cur];--j) Dec(col[j],f[i][j]),Dec(row[i],f[i][j]); ckmin(rp[i],mx2[cur]); &#125; &#125; &#125; for(ri i=mx1[cur]+1;i&lt;cur-1;++i)&#123; if(lp[i]&gt;rp[i])continue; for(ri j=lp[i];j&lt;=rp[i];++j)Dec(col[j],f[i][j]); row[i]=0; lp[i]=1,rp[i]=0; &#125; &#125; int res=0; for(ri i=0;i&lt;n;++i)Add(res,row[i]); cout&lt;&lt;res&lt;&lt;'\\n'; &#125; return 0;&#125;","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://ldxcaicai.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"杂题乱做 Round3","slug":"sol3","date":"2019-11-01T14:39:01.000Z","updated":"2019-12-26T04:29:22.187Z","comments":true,"path":"sol3/","link":"","permalink":"http://ldxcaicai.github.io/sol3/","excerpt":"","text":"建设游乐场 解题思路： 在 mmm 很小的时候可以考虑用轮廓线做，但现在 mmm 较大，因此要对该题的特殊条件进行分析： 考虑到最后会形成若干回路，因此若将整张图进行黑白染色，那么一个白格一定连接两个黑格，由于弯道的权值为 vli,jvl_{i,j}vli,j​ ，直道的权值为 000 ，因此可以将每个格子按照横纵方向建两个点并进行如下连边： 源点向每个白格对应点连边，费用 000 ，流量 222 每个黑格对应点向汇点连边，费用 000 ，流量 222 每个格子的横/纵向对应点向格子对应点连两条边，一条费用 000 ，流量 111 ，一条费用 vli,jvl_{i,j}vli,j​ ，流量 111 相邻的合法格子在对应方向连边 然后跑最大费用流即可，若是弯道会被计算 2vli,j2vl_{i,j}2vli,j​ 的费用，直道会被计算 vli,jvl_{i,j}vli,j​ 的费用，因此最后减去所有合法格子的权值即可 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;typedef unsigned long long Ull;typedef unsigned int uii;typedef set&lt;int&gt;::iterator It;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=998244353; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int a)&#123;return ksm(a,mod-2);&#125; inline void fix(int&amp;a)&#123;a=(a%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b)&#123;a&gt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmax(T&amp;a,T b)&#123;a&lt;b?a=b:0;&#125;const int inf=0x3f3f3f3f,N=155,M=35,L=N*M*3;int n,m,vl[N][M],ct=0;struct edge&#123;int v,next,c,w;&#125;;namespace mcmf&#123; int d[L],cnt,first[L],s,t,id[L],res,fl; bool in[L]; edge e[L&lt;&lt;4]; inline void init()&#123; s=0; t=n*m*3+1; cnt=-1; for(ri i=s;i&lt;=t;++i)first[i]=-1; res=0; fl=0; &#125; inline void addedge(int u,int v,int c,int w)&#123; e[++cnt]=(edge)&#123;v,first[u],c,w&#125;; first[u]=cnt; &#125; inline void add_(int u,int v,int c,int w)&#123; addedge(u,v,c,w); addedge(v,u,0,-w); &#125; inline bool spfa()&#123; static int que[L&lt;&lt;4],hd,tl; for(ri i=s;i&lt;=t;++i)d[i]=-inf; que[hd=tl=1]=s; d[s]=0; while(hd&lt;=tl)&#123; int x=que[hd++]; in[x]=0; for(ri i=first[x],v;~i;i=e[i].next)&#123; v=e[i].v; if(e[i].c&gt;0&amp;&amp;d[v]&lt;d[x]+e[i].w)&#123; d[v]=d[x]+e[i].w; id[v]=i; if(!in[v])&#123; in[v]=1; que[++tl]=v; &#125; &#125; &#125; &#125; if(d[t]==-inf)return 0; res+=d[t]; ++fl; int p=t; while(p!=s)--e[id[p]].c,++e[id[p]^1].c,p=e[id[p]^1].v; return 1; &#125; inline int solve()&#123; while(spfa()); if(fl!=ct)puts(\"-1\"),exit(0); return res; &#125;&#125;bool s[N][M];inline int idx(int a,int b,int c)&#123;return c*n*m+(a-1)*m+b;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),m=read(); for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=m;++j)s[i][j]=read(); int res=0; mcmf::init(); for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=m;++j)&#123; vl[i][j]=read(); if(!s[i][j])res-=vl[i][j],++ct; &#125; for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=m;++j)&#123; if(s[i][j])continue; if((i+j)&amp;1)&#123; mcmf::add_(mcmf::s,idx(i,j,2),2,0); mcmf::add_(idx(i,j,2),idx(i,j,0),1,0); mcmf::add_(idx(i,j,2),idx(i,j,0),1,vl[i][j]); mcmf::add_(idx(i,j,2),idx(i,j,1),1,0); mcmf::add_(idx(i,j,2),idx(i,j,1),1,vl[i][j]); if(i!=1&amp;&amp;!s[i-1][j])mcmf::add_(idx(i,j,0),idx(i-1,j,0),1,0); if(i!=n&amp;&amp;!s[i+1][j])mcmf::add_(idx(i,j,0),idx(i+1,j,0),1,0); if(j!=1&amp;&amp;!s[i][j-1])mcmf::add_(idx(i,j,1),idx(i,j-1,1),1,0); if(j!=m&amp;&amp;!s[i][j+1])mcmf::add_(idx(i,j,1),idx(i,j+1,1),1,0); &#125; else&#123; mcmf::add_(idx(i,j,2),mcmf::t,2,0); mcmf::add_(idx(i,j,0),idx(i,j,2),1,0); mcmf::add_(idx(i,j,0),idx(i,j,2),1,vl[i][j]); mcmf::add_(idx(i,j,1),idx(i,j,2),1,0); mcmf::add_(idx(i,j,1),idx(i,j,2),1,vl[i][j]); &#125; &#125; res+=mcmf::solve(); cout&lt;&lt;res; return 0;&#125; Druzyny 解题思路： 考虑设 fi=(a,b)f_{i}=(a,b)fi​=(a,b) 表示当前序列段开头为 iii ，之前最多有 aaa 段序列，方案数为 bbb 很明显可以考虑枚举该段的结尾位置然后进行转移，复杂度为 O(n2)O(n^2)O(n2) 转移式条件如下： 若i能向j转移，则max⁡{ci⋯j}≤j−i+1≤min⁡{di⋯j}若i能向j转移，则\\max\\{c_{i\\cdots j}\\}\\le j-i+1\\le\\min\\{d_{i\\cdots j}\\}若i能向j转移，则max{ci⋯j​}≤j−i+1≤min{di⋯j​} 观察转移条件容易发现合法的转移区间被分成了若干连续段，而如果只有一个限制条件我们可以通过预处理每个数延伸的最远位置来进行 dpdpdp 优化，因此现在问题变为用巧妙的方法去掉其中一个限制条件 那么利用最值分治的思想即可，每一层分别先更新出最值左边的答案，然后用其更新右侧答案，然后递归分治右边即可 在更新的时候通过手画可以发现要么是区间中间的一段，要么是区间的一个前缀，对于后者直接记录前缀和转移即可，每层复杂度 O(1)O(1)O(1) ，总复杂度为 O(nlog⁡n)O(n\\log n)O(nlogn) ，而对于前者在所有层中只会出现 O(n)O(n)O(n) 次，每次用线段树查询区间和，复杂度 O(nlog⁡n)O(n\\log n)O(nlogn) 但由于笔者的实现不够好成功被卡了空间，于是线段树变成了 N×3N\\times 3N×3 的上限 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171#include&lt;bits/stdc++.h&gt;#define ri int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() getchar()typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int a)&#123;return ksm(a,mod-2);&#125; inline void fix(int&amp;a)&#123;a=(a%mod+mod)%mod;&#125;&#125;using namespace modular;const int N=1e6+5;struct F&#123; int a,b; F(int a=-1000000,int b=0):a(a),b(b)&#123;&#125; friend inline F operator+(F a,F b)&#123;return a.a^b.a?(a.a&gt;b.a?a:b):F(a.a,add(a.b,b.b));&#125; friend inline void operator+=(F&amp;a,F b)&#123;a=a+b;&#125;&#125;f[N];namespace sgt&#123; #define lc (p&lt;&lt;1) #define rc (p&lt;&lt;1|1) #define mid (l+r&gt;&gt;1) F vl[N*3],tg[N*3]; void pushnow(int p,F v)&#123; vl[p]+=v; tg[p]+=v; &#125; void pushdown(int p)&#123; if(tg[p].a||tg[p].b)&#123; pushnow(lc,tg[p]); pushnow(rc,tg[p]); tg[p]=F(0,0); &#125; &#125; void pushup(int p)&#123;vl[p]=vl[lc]+vl[rc];&#125; void update(int p,int l,int r,int ql,int qr,F v)&#123; if(ql&lt;=l&amp;&amp;r&lt;=qr)return pushnow(p,v); pushdown(p); if(qr&lt;=mid)update(lc,l,mid,ql,qr,v); else if(ql&gt;mid)update(rc,mid+1,r,ql,qr,v); else update(lc,l,mid,ql,qr,v),update(rc,mid+1,r,ql,qr,v); pushup(p); &#125; F query(int p,int l,int r,int ql,int qr)&#123; if(ql&lt;=l&amp;&amp;r&lt;=qr)return vl[p]; pushdown(p); if(qr&lt;=mid)return query(lc,l,mid,ql,qr); if(ql&gt;mid)return query(rc,mid+1,r,ql,qr); return query(lc,l,mid,ql,qr)+query(rc,mid+1,r,ql,qr); &#125;&#125;int n,mn[N],mx[N],ps[N];namespace sgtt&#123; int vl[N*3]; void pushup(int p)&#123;vl[p]=mn[vl[lc]]&gt;mn[vl[rc]]?vl[lc]:vl[rc];&#125; void build(int p,int l,int r)&#123; if(l==r)&#123; vl[p]=l; return; &#125; build(lc,l,mid),build(rc,mid+1,r); pushup(p); &#125; int query(int p,int l,int r,int ql,int qr)&#123; if(ql&lt;=l&amp;&amp;r&lt;=qr)return vl[p]; if(qr&lt;=mid)return query(lc,l,mid,ql,qr); if(ql&gt;mid)return query(rc,mid+1,r,ql,qr); int res1=query(lc,l,mid,ql,qr),res2=query(rc,mid+1,r,ql,qr); return mn[res1]&gt;mn[res2]?res1:res2; &#125; int query(int l,int r)&#123;return query(1,1,n,l,r);&#125; #undef lc #undef rc #undef mid&#125;F pre,upd;void solve(int l,int r)&#123; if(l&gt;r)return; if(l==r)&#123; sgt::update(1,1,n,l,l,f[l]); f[l]=sgt::query(1,1,n,l,l); return; &#125; int mid=sgtt::query(l,r-1); solve(l,mid); int pos=max(mid,l+mn[mid]-1); if(pos-mn[mid]+1&gt;l)&#123; upd=sgt::query(1,1,n,l,pos-mn[mid]); pre=F(upd.a+1,upd.b); &#125; else pre=F(); for(ri L,R,res,ql=l,qr=pos-mn[mid]+1,i=pos;i&lt;r;++i,++qr)&#123; if(ps[i]&gt;mid)break; if(qr&gt;=l)&#123; pre+=F(f[qr].a+1,f[qr].b); if(qr==mid)&#123; L=i,R=r-1,res=i-1; while(L&lt;=R)&#123; int md=L+R&gt;&gt;1; if(ps[md]&lt;=l)L=md+1,res=md; else R=md-1; &#125; if(i&lt;=res)sgt::update(1,1,n,i+1,res+1,pre); for(i=res+1;i&lt;r;++i)&#123; if(ps[i]&gt;mid)break; upd=sgt::query(1,1,n,ps[i],qr); f[i+1]+=F(upd.a+1,upd.b); &#125; break; &#125; if(ps[i]&gt;l)&#123; if(ps[i]&lt;=qr)&#123; upd=sgt::query(1,1,n,ps[i],qr); f[i+1]+=F(upd.a+1,upd.b); &#125; continue; &#125; f[i+1]+=pre; &#125; &#125; solve(mid+1,r);&#125;struct Que&#123; priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;a,b; inline void ins(int x)&#123;a.push(x);&#125; inline void del(int x)&#123;b.push(x);&#125; inline int top()&#123;while(b.size()&amp;&amp;a.top()==b.top())a.pop(),b.pop();return a.top();&#125;&#125;vl;signed main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); for(ri i=1;i&lt;=n;++i)mn[i]=read(),mx[i]=read(); ++n; mn[n]=mx[n]=1; f[1]=F(0,1); sgtt::build(1,1,n); for(ri l=1,r=1;r&lt;=n;++r)&#123; vl.ins(mx[r]); while(vl.top()&lt;r-l+1)vl.del(mx[l++]); ps[r]=l; &#125; while(vl.a.size())vl.a.pop(); while(vl.b.size())vl.b.pop(); solve(1,n); F res=f[n]; if(!res.b)puts(\"NIE\"); else cout&lt;&lt;res.a&lt;&lt;' '&lt;&lt;res.b; return 0;&#125; MachineWorks 解题思路： 考虑把所有机器按照 did_idi​ 排序，然后设 fif_ifi​ 表示到第 iii 个物品手中能有的最多的钱 那么转移式为 fi=max⁡{fj+(di−dj−1)×gj+rj}f_i=\\max\\{f_j+(d_i-d_j-1)\\times g_j+r_j\\}fi​=max{fj​+(di​−dj​−1)×gj​+rj​} 貌似可以斜率优化，然后发现 gjg_jgj​ 不是单增的，于是利用 cdqcdqcdq 分治来维护这个偏序即可 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;typedef unsigned long long Ull;typedef unsigned int uii;typedef set&lt;int&gt;::iterator It;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=998244353; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int a)&#123;return ksm(a,mod-2);&#125; inline void fix(int&amp;a)&#123;a=(a%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b)&#123;a&gt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmax(T&amp;a,T b)&#123;a&lt;b?a=b:0;&#125;const int N=1e5+5;int n,C,D,cas=0;const ll inf=1e13;struct F&#123; int d,p,r,g; friend inline bool operator&lt;(F a,F b)&#123;return a.d&lt;b.d;&#125;&#125;a[N];pil b[N],c[N];ll f[N];int q[N],hd,tl,t1,t2;inline double slope(pil a,pil b)&#123;return a.fi==b.fi?inf:(double)(a.se-b.se)/(double)(a.fi-b.fi);&#125;inline void solve(int l,int r)&#123; if(l==r)&#123; f[l]-=a[l].p; if(f[l]&lt;0)f[l]=-inf; return; &#125; int mid=l+r&gt;&gt;1; solve(l,mid); t1=0,t2=0; for(ri i=l;i&lt;=mid;++i)if(f[i]!=-inf)b[++t1]=pil(a[i].g,f[i]+a[i].r-(ll)(a[i].d+1)*a[i].g); for(ri i=mid+1;i&lt;=r;++i)c[++t2]=pil(a[i].d,i); sort(b+1,b+t1+1); sort(c+1,c+t2+1); hd=1,tl=0; for(ri i=1;i&lt;=t1;++i)&#123; while(tl-hd&gt;=1&amp;&amp;slope(b[i],b[q[tl]])&gt;slope(b[q[tl]],b[q[tl-1]]))--tl; q[++tl]=i; &#125; if(hd&lt;=tl)for(ri i=1;i&lt;=t2;++i)&#123; while(tl-hd&gt;=1&amp;&amp;slope(b[q[hd]],b[q[hd+1]])&gt;-c[i].fi)++hd; ckmax(f[c[i].se],b[q[hd]].se+(ll)b[q[hd]].fi*c[i].fi); &#125; solve(mid+1,r);&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif while(1)&#123; n=read(),C=read(),D=read(); if(!(n+C+D))break; ++cas; cout&lt;&lt;\"Case \"&lt;&lt;cas&lt;&lt;\": \"; for(ri i=1;i&lt;=n;++i)&#123; a[i].d=read(),a[i].p=read(),a[i].r=read(),a[i].g=read(); f[i+1]=-inf; &#125; a[++n]=(F)&#123;0,0,0,0&#125;; a[++n]=(F)&#123;D+1,0,0,0&#125;; sort(a+1,a+n+1); f[1]=C; f[n]=-inf; solve(1,n); cout&lt;&lt;f[n]&lt;&lt;'\\n'; &#125; return 0;&#125; 珠宝 解题思路： 首先考虑按照代价进行分组，然后设 fi,jf_{i,j}fi,j​ 表示前 iii 个组代价为 jjj 的最优美观度 这样就有了 O(300K2)O(300K^2)O(300K2) 的暴力搞法（不如 O(nK)O(nK)O(nK) 暴力分多 然后每个组满足决策单调性（这个非常易证），于是可以对每个组按照模数分类然后决策单调性优化转移 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;typedef unsigned long long Ull;typedef unsigned int uii;typedef set&lt;int&gt;::iterator It;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int a)&#123;return ksm(a,mod-2);&#125; inline void fix(int&amp;a)&#123;a=(a%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b)&#123;a&gt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmax(T&amp;a,T b)&#123;a&lt;b?a=b:0;&#125;const int M=50005,K=305;int n,m,cur,blo;ll f[2][M];vector&lt;ll&gt;vl[K];vector&lt;int&gt;ps;inline ll calc(int x,int p)&#123;return f[cur^1][ps[x]]+(x==p?0:vl[blo][p-x-1]);&#125;inline void solve(int l,int r,int L,int R)&#123; if(l&gt;r)return; if(L==R)&#123; for(ri i=l;i&lt;=r;++i)f[cur][ps[i]]=calc(L,i); return; &#125; int mid=l+r&gt;&gt;1,x=max(L,mid-(int)vl[blo].size()); ll tmp=calc(x,mid),t; for(ri i=x+1;i&lt;=R&amp;&amp;i&lt;=mid;++i)if((t=calc(i,mid))&gt;tmp)&#123; x=i; tmp=t; &#125; f[cur][ps[mid]]=tmp; solve(l,mid-1,L,x); solve(mid+1,r,x,R);&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),m=read(); for(ri a,b,i=1;i&lt;=n;++i)&#123; a=read(),b=read(); vl[a].pb(b); &#125; cur=0; for(ri i=1;i&lt;=300;++i)&#123; if(!vl[i].size())continue; blo=i; sort(vl[i].begin(),vl[i].end()); reverse(vl[i].begin(),vl[i].end()); for(ri j=1;j&lt;vl[i].size();++j)vl[i][j]+=vl[i][j-1]; cur^=1; for(ri j=0;j&lt;i;++j)&#123; ps.clear(); for(ri k=j;k&lt;=m;k+=i)ps.pb(k); if(ps.size())solve(0,ps.size()-1,0,ps.size()-1); &#125; &#125; for(ri i=1;i&lt;=m;++i)cout&lt;&lt;f[cur][i]&lt;&lt;' '; return 0;&#125; Ember and Storm’s Tree Game 解题思路： 考虑到合法的树满足每条路径一定是单调或者单峰的，且每条路径有 222 种调整方法，于是只用求出可行树的方案数，考虑设 fi,jf_{i,j}fi,j​ 表示整颗子树满足儿子小于父亲，子树 siz=isiz=isiz=i ，根的度数为 jjj 的方案数 然后用个前缀和优化能够非常简单的转移出来 现在在整棵树的根处可以将满足儿子小于父亲和儿子大于父亲的树给拼接起来，统计方案数即可 注意到同一棵树的可行根由若干个，但它们形成了一条单调路径，我们在端点统计即可 CODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;#define int long long#define ri register int#define pb push_back#define fi first#define se second#define double long doubleusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() getchar()typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular&#123; int mod; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int a)&#123;return ksm(a,mod-2);&#125; inline void fix(int&amp;a)&#123;a=(a%mod+mod)%mod;&#125;&#125;using namespace modular;const int N=205;int C[N][N],n,K,f[N][N],s[N];inline void init()&#123; for(ri i=0;i&lt;=n;++i)&#123; C[i][0]=1; for(ri j=1;j&lt;=i;++j)C[i][j]=add(C[i-1][j-1],C[i-1][j]); &#125;&#125;signed main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),K=read(),mod=read(); init(); s[1]=f[1][0]=1; for(ri i=2;i&lt;=n;++i)&#123; for(ri j=1;j&lt;=K;++j)&#123; for(ri k=1;k&lt;i;++k)Add(f[i][j],mul(mul(f[i-k][j-1],s[k]),C[i-2][k-1])); if(j&lt;K)Add(s[i],f[i][j]); &#125; &#125; int res=0; for(ri i=1;i&lt;=n;++i)for(ri j=0;j&lt;=K;++j)for(ri k=0;j+k&lt;=K;k?++k:k+=2)Add(res,mul(f[i][j],f[n-i+1][k])); cout&lt;&lt;mul(mul(res,2),mul(n,n-1)); return 0;&#125; Path Counting 解题思路： 笔者想出了一个暴力做法，即考虑利用 lcalcalca 枚举路径，然后用 mttmttmtt 优化做到 O(n2log⁡n)O(n^2\\log n)O(n2logn) 下面是正经做法： 考虑对于每条路径从端点处求方案数，设 fi,jf_{i,j}fi,j​ 表示从深度 iii 的某个点开始向下走 jjj 步的方案数， gi,jg_{i,j}gi,j​ 表示从某个深度为 iii 的点开始至少向上走一步总共走 jjj 步的方案数 显然有： fi,j=fi+1,j−1×ai+1,gi,j=gi−1,j−1+fi,j−2×(ai−1−1)f_{i,j}=f_{i+1,j-1}\\times a_i+1,g_{i,j}=g_{i-1,j-1}+f_{i,j-2}\\times (a_{i-1}-1)fi,j​=fi+1,j−1​×ai​+1,gi,j​=gi−1,j−1​+fi,j−2​×(ai−1​−1) 直接开两个数组会 MLEMLEMLE ，因此先求 fff 再求 ggg CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;typedef unsigned long long Ull;typedef unsigned int uii;typedef set&lt;int&gt;::iterator It;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int a)&#123;return ksm(a,mod-2);&#125; inline void fix(int&amp;a)&#123;a=(a%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b)&#123;a&gt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmax(T&amp;a,T b)&#123;a&lt;b?a=b:0;&#125;const int N=5005;int n,a[N],b[N],f[N][N&lt;&lt;1],cur=0,ans[N&lt;&lt;1];int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); b[1]=1; for(ri i=1;i&lt;n;++i)a[i]=read(),b[i+1]=mul(b[i],a[i]); f[n][0]=1; for(ri i=n-1;i;--i)&#123; f[i][0]=1; for(ri j=0,up=n-i;j&lt;up;++j)&#123; f[i][j+1]=mul(f[i+1][j],a[i]); Add(ans[j+1],mul(f[i][j+1],b[i])); &#125; &#125; for(ri i=1;i&lt;=n;++i)&#123; for(ri j=n+i-2;j;--j)&#123; f[i][j]=f[i-1][j-1]; if(j&gt;1&amp;&amp;i!=1)Add(f[i][j],mul(a[i-1]-1,f[i][j-2])); Add(ans[j],mul(f[i][j],b[i])); &#125; &#125; for(ri iv=mod+1&gt;&gt;1,i=1;i&lt;=n*2-2;++i)cout&lt;&lt;mul(ans[i],iv)&lt;&lt;' '; return 0;&#125; How many trees? 解题思路： 该题可以将数据加强到 n=400n=400n=400 考虑设 fi,jf_{i,j}fi,j​ 表示 iii 个点深度为 jjj 的树的方案数，显然可以枚举左右儿子的 sizsizsiz 转移，利用前缀和优化能够做到 O(n3)O(n^3)O(n3) CODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;#define ri int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() getchar()typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read()&#123; int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int a)&#123;return ksm(a,mod-2);&#125; inline void fix(int&amp;a)&#123;a=(a%mod+mod)%mod;&#125;&#125;using namespace modular;const int N=40;int n,m;ll f[N][N],g[N][N];int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),m=read(); g[0][0]=g[1][1]=f[0][0]=f[1][1]=g[1][0]=1; for(ri i=2;i&lt;=n;++i)&#123; for(ri j=1;j&lt;=i;++j)for(ri k=0;k&lt;i;++k) f[i][j]+=f[k][j-1]*(g[i-k-1][0]-g[i-k-1][j])*2-f[k][j-1]*f[i-k-1][j-1]; g[i][i]=f[i][i]; for(ri j=i-1;~j;--j)g[i][j]=g[i][j+1]+f[i][j]; &#125; cout&lt;&lt;g[n][m]; return 0;&#125;","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://ldxcaicai.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"杂题乱做 Round2","slug":"sol2","date":"2019-10-28T14:56:09.000Z","updated":"2019-12-24T23:53:02.041Z","comments":true,"path":"sol2/","link":"","permalink":"http://ldxcaicai.github.io/sol2/","excerpt":"","text":"吉夫特 解题思路： 显然用 lucaslucaslucas 定理转化一下条件，可以转化成相邻两项的关系，然后有了无脑的 70pts70pts70pts 暴力：设 fif_ifi​ 表示以第 iii 个数结尾的方案数，直接暴力 checkcheckcheck 即可： CODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() getchar()typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;&#125;using namespace modular;const int N=3e5+5;int f[N],a[N],n;inline bool check(int a,int b)&#123; for(ri i=30;~i;--i)if((a&gt;&gt;i&amp;1)&lt;(b&gt;&gt;i&amp;1))return 0; return 1;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); int res=0; for(ri i=1;i&lt;=n;++i)&#123; a[i]=read(); f[i]=1; for(ri j=1;j&lt;i;++j)if(check(a[j],a[i]))Add(f[i],f[j]); Add(res,dec(f[i],1)); &#125; cout&lt;&lt;res; return 0;&#125; 然后考虑优化 然后考虑优化，发现可以设 fif_ifi​ 表示当前选择序列的结尾的数为 iii 的合法方案数，然后枚举子集转移更新即可 这样做是询问 O(1)O(1)O(1) ，修改 O(218)O(2^{18})O(218) 的，不过已经能够通过了 CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() getchar()typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;&#125;using namespace modular;const int N=3e5+5;int f[N],n;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); int res=0; for(ri x,t,i=1;i&lt;=n;++i)&#123; x=read(); t=add(f[x],1); for(ri s=x;s;s=(s-1)&amp;x)Add(f[s],t); Add(res,dec(t,1)); &#125; cout&lt;&lt;res; return 0;&#125; 考虑继续优化 发现可以通过分块摊下复杂度，即设 fi,jf_{i,j}fi,j​ 表示当前选择序列的结尾的前 292^929 位等于 iii ，后 292^929 为 jjj 的子集的方案数，这样复杂度是 O(n∗29)O(n*2^9)O(n∗29) 的 CODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() getchar()typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;&#125;using namespace modular;const int N=3e5+5;int f[1&lt;&lt;9|5][1&lt;&lt;9|5],n;inline int query(int x)&#123; int a=x&gt;&gt;9,b=x&amp;511,c=511^b; int res=0; for(ri s=c;;s=(s-1)&amp;c)&#123; Add(res,f[a][s^b]); if(!s)break; &#125; return res;&#125;inline void update(int x,int t)&#123; int a=x&gt;&gt;9,b=x&amp;511; for(ri s=a;;s=(s-1)&amp;a)&#123; Add(f[s][b],t); if(!s)break; &#125;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); int res=0; for(ri x,t,i=1;i&lt;=n;++i)&#123; x=read(); t=add(query(x),1); update(x,t); Add(res,dec(t,1)); &#125; cout&lt;&lt;res; return 0;&#125; 游览计划 解题思路： 使用斯坦纳树的思想，不过这道题给出的是点权，因此转移如下： fp,s=min⁡{fp,t+fp,s⊕t−valuep}f_{p,s}=\\min\\{f_{p,t}+f_{p,s\\oplus t}-value_p\\}fp,s​=min{fp,t​+fp,s⊕t​−valuep​} fp,s=min⁡{fv,s+dist(p,v)}f_{p,s}=\\min\\{f_{v,s}+dist(p,v)\\}fp,s​=min{fv,s​+dist(p,v)} 然后顺便要记录并输出方案 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() getchar()typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;&#125;//using namespace modular;int dx[]=&#123;0,0,1,-1&#125;;int dy[]=&#123;1,-1,0,0&#125;;const int N=15,S=1&lt;&lt;10|5;int d[N][N][S],n,m,K,ct=0,vl[N][N],tr[N][N],all;struct Node&#123;int x,y,s;&#125;pre[N][N][S];set&lt;pair&lt;pii,int&gt; &gt;q;inline void dijkstra(int s)&#123; while(q.size())&#123; pii v,x=q.begin()-&gt;fi; q.erase(q.begin()); for(ri i=0;i&lt;4;++i)&#123; v=pii(x.fi+dx[i],x.se+dy[i]); if(d[v.fi][v.se][s]&gt;d[x.fi][x.se][s]+vl[v.fi][v.se])&#123; if(d[v.fi][v.se][s]!=d[0][0][0])q.erase(make_pair(v,d[v.fi][v.se][s])); d[v.fi][v.se][s]=d[x.fi][x.se][s]+vl[v.fi][v.se]; pre[v.fi][v.se][s]=(Node)&#123;x.fi,x.se,s&#125;; q.insert(make_pair(v,d[v.fi][v.se][s])); &#125; &#125; &#125;&#125;bool vs[N][N];inline void getprint(int x,int y,int s)&#123; if(!x)return; vs[x][y]=1; getprint(pre[x][y][s].x,pre[x][y][s].y,pre[x][y][s].s); if(pre[x][y][s].x==x&amp;&amp;pre[x][y][s].y==y)getprint(x,y,(pre[x][y][s].s^s)|tr[x][y]);&#125;inline void print()&#123; for(ri i=1;i&lt;=n;++i,puts(\"\"))for(ri j=1;j&lt;=m;++j)&#123; if(tr[i][j])cout&lt;&lt;'x'; else if(vs[i][j])cout&lt;&lt;'o'; else cout&lt;&lt;'_'; &#125; exit(0);&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),m=read(); for(ri i=1;i&lt;=n;++i)&#123; for(ri j=1;j&lt;=m;++j)&#123; vl[i][j]=read(); if(!vl[i][j])&#123; ++ct; tr[i][j]=1&lt;&lt;(ct-1); &#125; &#125; &#125; all=(1&lt;&lt;ct)-1; for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=m;++j)memset(d[i][j],0x3f,sizeof(int)*(all+3)); for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=m;++j)if(tr[i][j])d[i][j][tr[i][j]]=0; d[0][0][0]=d[1][1][0]; for(ri s=0;s&lt;=all;++s)&#123; for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=m;++j)&#123; if(tr[i][j]&amp;&amp;!(tr[i][j]&amp;s))continue; for(ri t=(s-1)&amp;s,upd;t;t=(t-1)&amp;s)&#123; upd=d[i][j][t|tr[i][j]]+d[i][j][(s^t)|tr[i][j]]-vl[i][j]; if(d[i][j][s]&gt;upd)&#123; d[i][j][s]=upd; pre[i][j][s]=(Node)&#123;i,j,t|tr[i][j]&#125;; &#125; &#125; if(d[i][j][s]!=d[0][0][0])q.insert(make_pair(pii(i,j),d[i][j][s])); &#125; dijkstra(s); &#125; for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=m;++j)if(tr[i][j])&#123; cout&lt;&lt;d[i][j][all]&lt;&lt;'\\n'; getprint(i,j,all); print(); &#125; return 0;&#125; Umnozak 解题思路： 首先一打开题就有一个暴力的思路，枚举这个数由多少个 1,2,...,91,2,...,91,2,...,9 组成然后对于每种情况做数位 dpdpdp，但方案数较大，约在 106⋯10710^6\\cdots10^7106⋯107 的级别，无法通过此题 因此考虑到上述做法中较多方案的所有数位的乘积相同，进而想到只需要枚举乘积由多少个 2,3,5,72,3,5,72,3,5,7 组成即可，然后对每种方案进行数位 dpdpdp 就能够通过此题 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() getchar()typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;&#125;//using namespace modular;ll L,R;int ct[10][4]=&#123; &#123;0,0,0,0&#125;, &#123;0,0,0,0&#125;, &#123;1,0,0,0&#125;, &#123;0,1,0,0&#125;, &#123;2,0,0,0&#125;, &#123;0,0,1,0&#125;, &#123;1,1,0,0&#125;, &#123;0,0,0,1&#125;, &#123;3,0,0,0&#125;, &#123;0,2,0,0&#125;&#125;;int vl[20],ctt[4],len;ll f[20][30][19][13][11];inline ll dfs(int ps,int*a,bool lim,bool zero)&#123; if(ps==0)return !zero&amp;&amp;!(a[0]+a[1]+a[2]+a[3]); if(!lim&amp;&amp;!zero&amp;&amp;~f[ps][a[0]][a[1]][a[2]][a[3]])return f[ps][a[0]][a[1]][a[2]][a[3]]; ll res=0; if(zero)res+=dfs(ps-1,a,0,1); for(ri ff,i=1,up=lim?vl[ps]:9;i&lt;=up;++i)&#123; ff=1; for(ri j=0;j&lt;4;++j)if(ct[i][j]&gt;a[j])&#123; ff=0; break; &#125; if(!ff)continue; for(ri j=0;j&lt;4;++j)a[j]-=ct[i][j]; res+=dfs(ps-1,a,lim&amp;&amp;i==up,0); for(ri j=0;j&lt;4;++j)a[j]+=ct[i][j]; &#125; if(!lim&amp;&amp;!zero)f[ps][a[0]][a[1]][a[2]][a[3]]=res; return res;&#125;inline void init(ll tp)&#123; len=0; while(tp)vl[++len]=tp%10,tp/=10;&#125;inline ll solve(ll x)&#123; if(!x)return 0; if(x==1)return 1; ll up=min(x,1000000000ll); ctt[0]=0; ll res=0; memset(f,-1,sizeof(f)); for(ll mt1=1;;mt1*=2,++ctt[0])&#123; ctt[1]=0; for(ll mt2=mt1;;mt2*=3,++ctt[1])&#123; ctt[2]=0; for(ll mt3=mt2;;mt3*=5,++ctt[2])&#123; ctt[3]=0; for(ll mt4=mt3;;mt4*=7,++ctt[3])&#123; init(x/mt4); res+=dfs(len,ctt,1,1); if(up/7&lt;mt4)break; &#125; if(up/5&lt;mt3)break; &#125; if(up/3&lt;mt2)break; &#125; if(up/2&lt;mt1)break; &#125; return res;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif cin&gt;&gt;L&gt;&gt;R; cout&lt;&lt;solve(R)-solve(L-1); return 0;&#125; Ksenia and Combinatorics 解题思路： 首先通过归纳可以证明出如下结论： 对于树的匹配，设 fi,0/1f_{i,0/1}fi,0/1​ 表示对于 iii 的子树用/不用根能得到的最大匹配数，那么有 fi,0≤fi,1≤fi,0+1f_{i,0}\\le f_{i,1}\\le f_{i,0}+1fi,0​≤fi,1​≤fi,0​+1 因此可以定义如下状态: fi,j,0/1f_{i,j,0/1}fi,j,0/1​ 表示 iii 个点的树，最大匹配数为 jjj ，用根进行匹配的最大匹配数减去不用根进行匹配的最大匹配数的值为 0/10/10/1 时的方案数，转移比较自然，因此不一一赘述 CODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() getchar()typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular&#123; const int mod=1e9+7,inv2=5e8+4; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;&#125;using namespace modular;const int N=55;int n,K,f[N][N][2],C[N][N];inline void init()&#123; for(ri i=0;i&lt;=n;++i)&#123; C[i][0]=1; for(ri j=1;j&lt;=i;++j)C[i][j]=add(C[i-1][j],C[i-1][j-1]); &#125;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),K=read(); f[0][0][1]=f[1][0][0]=1; init(); for(ri i=2,t;i&lt;=n;++i)for(ri j=0;j&lt;=K&amp;&amp;j+j&lt;=i;++j)&#123; for(ri k=0;k+k+1&lt;=i;++k)&#123; t=mul(mul(k+k+1==i?inv2:1,C[i-1][k]),mul(max(k,1),i-k-1)); for(ri p=0;p&lt;=j&amp;&amp;p+p&lt;=k;++p)&#123; Add(f[i][j][0],mul(t,mul(f[k][p][1],f[i-k-1][j-p][1]))); if(j==p)continue; Add(f[i][j][1],mul(t,mul(f[k][p][0],f[i-k-1][j-p-1][0]))); Add(f[i][j][1],mul(t,mul(f[k][p][1],f[i-k-1][j-p-1][0]))); Add(f[i][j][1],mul(t,mul(f[k][p][0],f[i-k-1][j-p-1][1]))); &#125; &#125; &#125; cout&lt;&lt;add(f[n][K][0],f[n][K][1]); return 0;&#125; isn 解题思路： 首先用 bitbitbit 辅助求出 fi,jf_{i,j}fi,j​ 表示以 iii 结尾的长度为 jjj 的不降序列方案数，进而统计出 gig_igi​ 表示长度为 iii 的不降序列的方案数 然后进行简单容斥来求答案 假设对于 gig_igi​ 中每个方案添上任意一个数都会不满足不降，那么 Ans=∑i=1ngi×(n−i)!Ans=\\sum\\limits_{i=1}^ng_i\\times(n-i)!Ans=i=1∑n​gi​×(n−i)! ，但现在会算入添上一个数之后仍然不降的方案数，于是扣掉 ∑i=1ngi+1×(n−i+1)!×(i+1)\\sum\\limits_{i=1}^ng_{i+1}\\times(n-i+1)!\\times(i+1)i=1∑n​gi+1​×(n−i+1)!×(i+1) 即可 CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() getchar()typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;&#125;using namespace modular;const int N=2005;int a[N],n,cur,f[2][N],g[N],vl[N],sig;inline int find(int x)&#123;return lower_bound(vl+1,vl+sig+1,x)-vl;&#125;int bit[N];inline int lowbit(int x)&#123;return x&amp;-x;&#125;inline void update(int x,int v)&#123;for(;x&lt;=n;x+=lowbit(x))Add(bit[x],v);&#125;inline int query(int x)&#123;int res=0;for(;x;x^=lowbit(x))Add(res,bit[x]);return res;&#125;int fac[N];inline void init()&#123; fac[0]=fac[1]=1; for(ri i=2;i&lt;=n;++i)fac[i]=mul(fac[i-1],i);&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); init(); for(ri i=1;i&lt;=n;++i)a[i]=vl[++sig]=read(); sort(vl+1,vl+sig+1),sig=unique(vl+1,vl+sig+1)-vl-1; for(ri i=1;i&lt;=n;++i)a[i]=find(a[i]); cur=0; update(1,1); for(ri len=1;len&lt;=n;++len)&#123; cur^=1; for(ri i=1;i&lt;=n;++i)&#123; f[cur][i]=query(a[i]); update(a[i],f[cur^1][i]); Add(g[len],f[cur][i]); &#125; for(ri i=1;i&lt;=n;++i)bit[i]=0; &#125; int res=0; for(ri i=1;i&lt;=n;++i)Mul(g[i],fac[n-i]); for(ri i=1;i&lt;=n;++i)&#123; Dec(g[i],mul(g[i+1],i+1)); Add(res,g[i]); &#125; cout&lt;&lt;res; return 0;&#125; 神经网络 解题思路： 首先转化题意，相当于是把每棵树拆成若干条链然后把链缩成点求若干排点之间的哈密顿回路数（同一排点之间不能连边），这样对每棵树树形 dpdpdp 出 fif_{i}fi​ 表示把整棵树拆成 iii 条链的方案数，然后考虑如何求答案，发现可以利用连通块容斥，即强制某一排中的某些链一定连通来容斥，如果将哈密顿回路的遍历映射到序列上，则相当于是一个连续段都属于同一排这样的不合法方案数，直接枚举段与段之间的空隙来进行容斥即可。 然后现在要将所有树给合起来，用 EGFEGFEGF 搞即可，注意第一棵树有限制条件：第一个和最后一个不能是同一排的 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_backusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,ll&gt; pll;typedef pair&lt;ll,int&gt; pli;typedef unsigned int uii;typedef unsigned long long Ull;typedef vector&lt;int&gt; poly;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=998244353,inv2=499122177; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a-b&lt;0?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int a)&#123;return ksm(a,mod-2);&#125; inline void fix(int&amp;a)&#123;a=(a%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmax(T&amp;a,T b)&#123;a&lt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b)&#123;a&gt;b?a=b:0;&#125;const int N=5005;int m,n,f[N][N][3],fac[N],ifac[N],siz[N],tmp[N][3];poly res(1,1);vector&lt;int&gt;e[N];int *tv,*tp;void dfs(int p,int ft)&#123; f[p][1][0]=1,siz[p]=1; for(ri i=0,v;i&lt;e[p].size();++i)&#123; if((v=e[p][i])==ft)continue; dfs(v,p); for(ri j=0;j&lt;=siz[v]+siz[p];++j)tmp[j][0]=tmp[j][1]=tmp[j][2]=0; for(ri j=0;j&lt;=siz[v];++j)if(f[v][j][0]||f[v][j][1]||f[v][j][2])&#123; tv=f[v][j]; for(ri k=0;k&lt;=siz[p];++k)if(f[p][k][0]||f[p][k][1]||f[p][k][2])&#123; tp=f[p][k]; for(ri a=0;a&lt;3;++a)for(ri b=0;b&lt;3;++b)Add(tmp[j+k][a],mul(tp[a],tv[b])); Add(tmp[j+k-1][1],mul(tp[0],tv[1])); Add(tmp[j+k-1][2],mul(mul(inv2,tp[1]),tv[1])); Add(tmp[j+k-1][1],mul(mul(2,tp[0]),tv[0])); Add(tmp[j+k-1][2],mul(tp[1],tv[0])); &#125; &#125; for(ri j=0;j&lt;=siz[v]+siz[p];++j)&#123; f[p][j][0]=tmp[j][0]; f[p][j][1]=tmp[j][1]; f[p][j][2]=tmp[j][2]; &#125; siz[p]+=siz[v]; &#125;&#125;inline void init()&#123; fac[0]=fac[1]=ifac[0]=ifac[1]=1; for(ri i=2;i&lt;=5000;++i)&#123; fac[i]=mul(fac[i-1],i); ifac[i]=mul(ifac[mod-mod/i*i],mod-mod/i); &#125; for(ri i=2;i&lt;=5000;++i)Mul(ifac[i],ifac[i-1]);&#125;inline int C(int n,int m)&#123;return mul(fac[n],mul(ifac[m],ifac[n-m]));&#125;inline poly operator*(poly a,poly b)&#123; int n=a.size(),m=b.size(),t=n+m-1; poly c(t); for(ri i=0;i&lt;n;++i)if(a[i]) for(ri j=0;j&lt;m;++j)if(b[j]) Add(c[i+j],mul(a[i],b[j])); return c;&#125;inline void update(int dt)&#123; poly ad(n+1); for(ri t,s,sz=1;sz&lt;=n;++sz)&#123; s=mul(fac[sz-dt],add(add(f[1][sz][0],f[1][sz][1]),f[1][sz][2])); for(ri i=1;i&lt;=sz;++i)&#123; t=mul(C(sz-1,i-1),s); t=(sz-i)&amp;1?mod-t:t; Add(ad[i-dt],t); if(dt&amp;&amp;i&gt;1)Dec(ad[i-2],t); &#125; &#125; for(ri i=0;i&lt;ad.size();++i)Mul(ad[i],ifac[i]); res=res*ad;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif m=read(); init(); for(ri tt=1;tt&lt;=m;++tt)&#123; n=read(); for(ri i=1;i&lt;=n;++i)&#123; e[i].clear(); for(ri j=1;j&lt;=n;++j)&#123; f[i][j][0]=0; f[i][j][1]=0; f[i][j][2]=0; &#125; &#125; for(ri i=1,u,v;i&lt;n;++i)&#123; u=read(),v=read(); e[u].pb(v); e[v].pb(u); &#125; dfs(1,0); update(tt==1); &#125; int ans=0; for(ri i=0;i&lt;res.size();++i)Add(ans,mul(res[i],fac[i])); cout&lt;&lt;ans; return 0;&#125; 侦查守卫 解题思路： 考虑 fi,jf_{i,j}fi,j​ 表示将 iii 子树中关键点覆盖完且能向 iii 子树外覆盖 jjj 单位距离的最小代价， gi,jg_{i,j}gi,j​ 表示 iii 子树中只剩下跟 iii 距离小于 jjj 的关键点未覆盖的最小权值，然后有显然的转移，这里不一一赘述，要提到的则是可能在儿子对父亲进行更新之后出现 fi,j&gt;fi,j+1f_{i,j}&gt;f_{i,j+1}fi,j​&gt;fi,j+1​ 或者 gi,j&gt;gi,j−1g_{i,j}&gt;g_{i,j-1}gi,j​&gt;gi,j−1​ 的情况，因此要把两个状态的定义加上最少和至多的限制，然后前后缀进行更新 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() getchar()typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b)&#123;a&gt;b?a=b:0;&#125;const int N=5e5+5,inf=0x3f3f3f3f,D=22;vector&lt;int&gt;e[N];bool is[N];int n,m,d,a[N],f[N][D],g[N][D];void dfs(int p,int ft)&#123; if(is[p])f[p][0]=g[p][0]=a[p]; for(ri i=1;i&lt;=d;++i)f[p][i]=a[p]; f[p][d+1]=inf; for(ri i=0,v;i&lt;e[p].size();++i)&#123; if((v=e[p][i])==ft)continue; dfs(v,p); for(ri j=d;~j;--j)f[p][j]=min(f[p][j]+g[v][j],g[p][j+1]+f[v][j+1]); for(ri j=d;~j;--j)ckmin(f[p][j],f[p][j+1]); g[p][0]=f[p][0]; for(ri j=1;j&lt;=d;++j)g[p][j]+=g[v][j-1]; for(ri j=1;j&lt;=d;++j)ckmin(g[p][j],g[p][j-1]); &#125; ckmin(g[p][d+1],g[p][d]);&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),d=read(); for(ri i=1;i&lt;=n;++i)a[i]=read(); m=read(); for(ri i=1;i&lt;=m;++i)is[read()]=1; for(ri i=1,u,v;i&lt;n;++i)&#123; u=read(),v=read(); e[u].pb(v); e[v].pb(u); &#125; dfs(1,0); cout&lt;&lt;f[1][0]; return 0;&#125;","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://ldxcaicai.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"杂题乱做 Round1","slug":"sol1","date":"2019-10-17T03:28:59.000Z","updated":"2019-12-27T06:48:30.602Z","comments":true,"path":"sol1/","link":"","permalink":"http://ldxcaicai.github.io/sol1/","excerpt":"","text":"线段树 解题思路： 考虑到如果统计统计 fi,jf_{i,j}fi,j​ 表示第 iii 个位置的数最终等于 jjj 的概率，然后对于一个位置 iii 答案就是 ∑jfi,jvlj\\sum\\limits_{j}f_{i,j}vl_jj∑​fi,j​vlj​ ，然后就能够进行转化，变为求每个位置最终 ≥j\\ge j≥j 的概率，然后就能够枚举每个排名然后对笛卡尔树的一些子树进行如下 dpdpdp : 对于一个树根，设其能够管辖的范围为 [l,r][l,r][l,r] ，那么最后区间 [i≥l,j≤r][i\\ge l,j\\le r][i≥l,j≤r] 中的数的大小不超过树根大小的概率可以 dpdpdp 出来，设 fT,i,jf_{T,i,j}fT,i,j​ 表示在上界 xxx 确定后，在经过 TTT 轮操作后区间 [i,j][i,j][i,j] 的答案不超过 xxx 的概率，这个直接前缀和优化转移即可，由于数据随机，笛卡尔树高可以视为 logloglog 的，这样复杂度就是对的 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include&lt;bits/stdc++.h&gt;#define ri register int#define csi const int&amp;#define fi first#define se second#define pb push_backusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;vector&lt;int&gt; &gt; vii;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(ch!='*'&amp;&amp;ch!='.')ch=gc(); while(ch=='*'||ch=='.')s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int x)&#123;return ksm(x,mod-2);&#125; inline void fix(int&amp;x)&#123;x=(x%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,const T&amp;b)&#123;a&gt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmax(T&amp;a,const T&amp;b)&#123;a&lt;b?a=b:0;&#125;const int N=405;int n,m,L[N],R[N],cur=0,trans[N][N],vl[N],sig,ori[N],mx[N][N];int f[2][N][N],res[N][N];inline int calc(int x)&#123;return x*(x+1)/2;&#125;inline int find(int x)&#123;return lower_bound(vl+1,vl+sig+1,x)-vl;&#125;inline void init()&#123; for(ri i=1;i&lt;=n;++i)ori[i]=find(ori[i]); ori[0]=ori[n+1]=sig+1; for(ri a=1;a&lt;=n;++a)for(ri b=a;b&lt;=n;++b)&#123; mx[a][b]=max(mx[a][b-1],ori[b]); trans[a][b]=calc(a-1)+calc(b-a+1)+calc(n-b); &#125;&#125;inline void clear(int l,int r)&#123; cur^=1; for(ri i=l;i&lt;=r;++i)for(ri j=i;j&lt;=r;++j) f[cur][i][j]=0;&#125;inline void solve(int l,int r,int t)&#123; int transum; clear(l,r); f[cur][l][r]=1; for(ri T=1;T&lt;=m;++T)&#123; cur^=1; for(ri a=l;a&lt;=r;++a)for(ri b=a;b&lt;=r;++b) f[cur][a][b]=mul(f[cur^1][a][b],trans[a][b]); for(ri b=l;b&lt;=r;++b)&#123; transum=0; for(ri a=l;a&lt;=b;++a)&#123; Add(f[cur][a][b],transum); Add(transum,mul(f[cur^1][a][b],a-1)); &#125; &#125; for(ri a=r;a&gt;=l;--a)&#123; transum=0; for(ri b=r;b&gt;=a;--b)&#123; Add(f[cur][a][b],transum); Add(transum,mul(f[cur^1][a][b],n-b)); &#125; &#125; &#125; for(ri b=l;b&lt;=r;++b)&#123; transum=0; for(ri a=l;a&lt;=b;++a)&#123; Add(transum,f[cur][a][b]); Add(res[a][t],transum); &#125; &#125;&#125;int stk[N],tp;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); freopen(\"own.out\",\"w\",stdout); #endif n=read(),m=read(); for(ri i=1;i&lt;=n;++i)ori[i]=vl[i]=read(); sort(vl+1,vl+n+1),sig=unique(vl+1,vl+n+1)-vl-1; init(); for(ri rk=1;rk&lt;=sig;++rk)&#123; tp=0; for(ri i=0;i&lt;=n+1;++i)if(ori[i]&gt;rk)stk[++tp]=i; for(ri i=1;i&lt;tp;++i)&#123; if(mx[stk[i]+1][stk[i+1]-1]&lt;rk)&#123; for(ri ps=stk[i]+1;ps&lt;=stk[i+1]-1;++ps) Add(res[ps][rk],res[ps][rk-1]); &#125; else solve(stk[i]+1,stk[i+1]-1,rk); &#125; &#125; for(ri p=1,sum;p&lt;=n;++p,sum=0)&#123; for(ri rk=1;rk&lt;=sig;++rk) Add(sum,mul(vl[rk],dec(res[p][rk],res[p][rk-1]))); cout&lt;&lt;sum&lt;&lt;' '; &#125; return 0;&#125; 愤怒的元首 解题思路： DAGDAGDAG 计数一般考虑入度为 000 或者出度为 000 的点来进行容斥，因为删掉这些点和它们涉及到的边之后还是个 DAGDAGDAG 设 fif_{i}fi​ 表示 iii 个点的 DAGDAGDAG 方案数， gig_igi​ 为至少有 iii 个出度为 000 的点的方案数，显然有转移 gj=fi−j(ij)2j×(i−j)g_j=f_{i-j}\\binom{i}{j}2^{j\\times(i-j)}gj​=fi−j​(ji​)2j×(i−j) 和 fi=∑j=1igj(−1)j−1f_i=\\sum\\limits_{j=1}^ig_j(-1)^{j-1}fi​=j=1∑i​gj​(−1)j−1 这样可以 O(n2)O(n^2)O(n2) 搞定了 CODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;bits/stdc++.h&gt;#define ri register int#define csi const int&amp;#define fi first#define se second#define pb push_backusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;vector&lt;int&gt; &gt; vii;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(ch!='*'&amp;&amp;ch!='.')ch=gc(); while(ch=='*'||ch=='.')s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int x)&#123;return ksm(x,mod-2);&#125; inline void fix(int&amp;x)&#123;x=(x%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,const T&amp;b)&#123;a&gt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmax(T&amp;a,const T&amp;b)&#123;a&lt;b?a=b:0;&#125;const int N=3005;int n,f[N],fac[N],ifac[N],pw[N*N];inline void init()&#123; fac[0]=fac[1]=ifac[0]=ifac[1]=1; for(ri i=2;i&lt;=n;++i)&#123; fac[i]=mul(fac[i-1],i); ifac[i]=mul(ifac[mod-mod/i*i],mod-mod/i); &#125; pw[0]=1; for(ri i=1;i&lt;=n*n;++i)pw[i]=add(pw[i-1],pw[i-1]); for(ri i=2;i&lt;=n;++i)Mul(ifac[i],ifac[i-1]);&#125;inline int C(int n,int m)&#123;return n&lt;m||m&lt;0?0:mul(fac[n],mul(ifac[m],ifac[n-m]));&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); init(); f[0]=1; for(ri i=1;i&lt;=n;++i)for(ri t,j=1;j&lt;=i;++j)&#123; t=mul(f[i-j],mul(C(i,j),pw[j*(i-j)])); j&amp;1?Add(f[i],t):Dec(f[i],t); &#125; cout&lt;&lt;f[n]; return 0;&#125; numbers 解题思路： 考虑直接转化为求合法括号序列的方案数，这样对于现在的区间 [l,r][l,r][l,r] ，可以枚举 lll 的右括号放的位置然后转移成子区间求解，现在只用考虑合法性如何快速判断，发现是两个不相交的连续区间的信息叠加起来的，于是用二维前缀和来记录限制即可判断合法性 CODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;bits/stdc++.h&gt;#define ri register int#define csi const int&amp;#define fi first#define se second#define pb push_backusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;vector&lt;int&gt; &gt; vii;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int x)&#123;return ksm(x,mod-2);&#125; inline void fix(int&amp;x)&#123;x=(x%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,const T&amp;b)&#123;a&gt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmax(T&amp;a,const T&amp;b)&#123;a&lt;b?a=b:0;&#125;const int N=305;int n,sum[N][N],m,f[N][N],tim[N][N],tot=0;inline int getsum(int x1,int x2,int y1,int y2)&#123; return sum[x2][y2]+sum[x1-1][y1-1]-sum[x2][y1-1]-sum[x1-1][y2];&#125;inline int dfs(int l,int r)&#123; if(l==r)return 1; if(tim[l][r]==tot)return f[l][r]; tim[l][r]=tot; f[l][r]=0; if(!getsum(l,l,l,r))Add(f[l][r],dfs(l+1,r)); for(ri i=l+1;i&lt;=r;++i)if(!getsum(i,r,l,i-1)&amp;&amp;!getsum(l,l,l,i-1)) Add(f[l][r],mul(i==l+1?1:dfs(l+1,i-1),dfs(i,r))); return f[l][r];&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif for(ri tt=read();tt;--tt)&#123; ++tot; n=read(),m=read(); for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=n;++j)sum[i][j]=0; for(ri a,b,i=1;i&lt;=m;++i)&#123; a=read(),b=read(); sum[a][b]=1; &#125; for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=n;++j) sum[i][j]+=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]; bool ff=1; for(ri i=1;i&lt;=n;++i)if(getsum(i,i,i,i))&#123; ff=0; break; &#125; if(!ff)puts(\"0\"); else cout&lt;&lt;dfs(1,n)&lt;&lt;'\\n'; &#125; return 0;&#125; Dark Horse 解题思路： 把比赛的表倒着画出来，发现是一棵二叉树，这样看来不妨把 111 放在第一个叶子结点最后方案数再乘上 2n2^n2n ，然后现在要求的是从第一个叶子到根的路径上不能有非法点，不难想到从大到小枚举非法点在路径上出现的状态，则 fi,jf_{i,j}fi,j​ 表示当前走到第 iii 个点，从叶子到根的必输位置集合为 jjj 的方案数，最后容斥一下即可（也可以像我一样在转移的时候就带入容斥系数） CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;bits/stdc++.h&gt;#define ri register int#define csi const int&amp;#define fi first#define se second#define pb push_backusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;vector&lt;int&gt; &gt; vii;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(ch!='*'&amp;&amp;ch!='.')ch=gc(); while(ch=='*'||ch=='.')s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int x)&#123;return ksm(x,mod-2);&#125; inline void fix(int&amp;x)&#123;x=(x%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,const T&amp;b)&#123;a&gt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmax(T&amp;a,const T&amp;b)&#123;a&lt;b?a=b:0;&#125;const int N=1&lt;&lt;20|5;int n,m,all;int fac[N],ifac[N],pw[N],a[25],f[2][N],cur;inline void init()&#123; fac[0]=fac[1]=ifac[0]=ifac[1]=1; for(ri i=2;i&lt;=all;++i)&#123; fac[i]=mul(fac[i-1],i); ifac[i]=mul(ifac[mod-mod/i*i],mod-mod/i); &#125; for(ri i=2;i&lt;=all;++i)Mul(ifac[i],ifac[i-1]); pw[0]=1; for(ri i=1;i&lt;=n;++i)pw[i]=pw[i-1]&lt;&lt;1;&#125;inline int C(int n,int m)&#123;return n&lt;m||m&lt;0?0:mul(fac[n],mul(ifac[m],ifac[n-m]));&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),m=read(),all=1&lt;&lt;n; init(); for(ri i=1;i&lt;=m;++i)a[i]=read(); sort(a+1,a+m+1); f[cur=0][0]=1; for(ri ps=m;ps;--ps)&#123; cur^=1; for(ri s=0;s&lt;all;++s)f[cur][s]=f[cur^1][s]; for(ri s=0,trans;s&lt;all;++s)if(f[cur^1][s])&#123; trans=all-s-a[ps]; if(trans&gt;=0)for(ri i=0;i&lt;n;++i)if(!(s&amp;pw[i])) Dec(f[cur][s|pw[i]],mul(f[cur^1][s],mul(C(trans,pw[i]-1),fac[pw[i]]))); &#125; &#125; int res=0; for(ri s=0,t;s&lt;all;++s)Add(res,mul(f[cur][s],fac[all-s-1])); cout&lt;&lt;mul(res,all); return 0;&#125; Popping Balls 解题思路： 由于可以选 111 ，因为 s,ts,ts,t 只需要用于选出蓝球，这样可以考虑在 t,st,st,s 有用的时候才放置它俩上去（因为其余合法方案方案可以用这种方案选出），这样最后的序列一定长这样： 先有 xxx 个红球被选，然后在第一个蓝球位置处放下 ttt ，并选出这个蓝球 ，然后接下来选出的 是 aaa 个红球和 b−1b-1b−1 个蓝球随意排列（此时应满足 a+b=ma+b=ma+b=m 即使得 ttt 在之后的操作中失效），接着是 yyy 个红球被选出，然后在第一个蓝球位置处放下 sss ，并选出这个蓝球，然后接下来选出的是 ccc 个红球和 d−1d-1d−1 个蓝球随意排列（此时应满足 c+d=ac+d=ac+d=a 理由同 ttt 那部分），最后的 zzz 个球直接按照原序列放即可 然后可以考虑枚举 x,a,y,cx,a,y,cx,a,y,c 来计算贡献然后多半就TLE了 列出式子之后会发现这个四维的玩意儿后面两维的组合数和可以预处理二维前缀和优化，这样复杂度降为了 O(n2)O(n^2)O(n2) ，可以通过 CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;bits/stdc++.h&gt;#define ri register int#define csi const int&amp;#define fi first#define se second#define pb push_backusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;vector&lt;int&gt; &gt; vii;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(ch!='*'&amp;&amp;ch!='.')ch=gc(); while(ch=='*'||ch=='.')s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int x)&#123;return ksm(x,mod-2);&#125; inline void fix(int&amp;x)&#123;x=(x%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,const T&amp;b)&#123;a&gt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmax(T&amp;a,const T&amp;b)&#123;a&lt;b?a=b:0;&#125;const int N=2005;int n,m,C[N][N],g[N][N],f[N][N];inline void init(int up)&#123; for(ri i=0;i&lt;=up;++i)&#123; C[i][0]=1; for(ri j=1;j&lt;=i;++j) C[i][j]=add(C[i-1][j],C[i-1][j-1]); &#125; for(ri i=0;i&lt;=up;++i)&#123; g[i][0]=C[i][0]; for(ri j=1;j&lt;=up;++j)g[i][j]=add(g[i][j-1],C[i][j]); &#125; for(ri i=0;i&lt;=up;++i)&#123; f[0][i]=g[i][0]; for(ri j=1;j&lt;=up;++j)f[j][i]=add(f[j-1][i],g[i][j]); &#125;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),m=read(); init(max(n,m)); int res=0; for(ri t1,t2,x=0;x&lt;=n;++x)for(ri a=0;a+x&lt;=n;++a)&#123; t1=C[m-1][a]; t2=a?f[n-a-x][a-1]:1; Add(res,mul(t1,t2)); &#125; cout&lt;&lt;res&lt;&lt;'\\n'; return 0;&#125; Placing Squares 解题思路： 首先转化模型，看成有一个 nnn 个点的序列，你要在空隙中插入挡板，把序列分成若干段，每段要放一个红球和一个蓝球，现在还有 mmm 个坐标 {xm}\\{x_m\\}{xm​} ，限制你不能在 xi,xi+1x_i,x_i+1xi​,xi​+1 之间放挡板，问方案数 那么可以设计 fi,0/1/2/3f_{i,0/1/2/3}fi,0/1/2/3​ 表示当前扫到了第 iii 个点，它在的段内没放球/放了红球/放了蓝球/放了两种球的方案数，这个可以在有无限制的情况下轻松设置转移，由于第一维较大，用矩阵快速幂优化即可 CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;bits/stdc++.h&gt;#define ri register int#define csi const int&amp;#define fi first#define se second#define pb push_backusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;vector&lt;int&gt; &gt; vii;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int x)&#123;return ksm(x,mod-2);&#125; inline void fix(int&amp;x)&#123;x=(x%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,const T&amp;b)&#123;a&gt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmax(T&amp;a,const T&amp;b)&#123;a&lt;b?a=b:0;&#125;struct Mat&#123; int a[4][4]; Mat(int v=0)&#123;for(ri i=0;i&lt;=3;++i)for(ri j=0;j&lt;=3;++j)a[i][j]=i==j?v:0;&#125; inline int*operator[](const int&amp;k)&#123;return a[k];&#125; inline const int*operator[](const int&amp;k)const&#123;return a[k];&#125; friend inline Mat operator*(Mat a,Mat b)&#123; Mat c; for(ri i=0;i&lt;=3;++i)for(ri k=0;k&lt;=3;++k)if(a[i][k]) for(ri j=0;j&lt;=3;++j)if(b[k][j])Add(c[i][j],mul(a[i][k],b[k][j])); return c; &#125; friend inline Mat operator^(Mat a,int p)&#123; Mat ret(1); for(;p;p&gt;&gt;=1,a=a*a)if(p&amp;1)ret=ret*a; return ret; &#125;&#125;trans1,trans2,res(1);int n,m;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif trans1[0][0]=2,trans1[0][1]=1,trans1[0][2]=1,trans1[0][3]=1; trans1[1][0]=1,trans1[1][1]=1,trans1[1][2]=0,trans1[1][3]=1; trans1[2][0]=1,trans1[2][1]=0,trans1[2][2]=1,trans1[2][3]=1; trans1[3][0]=1,trans1[3][1]=0,trans1[3][2]=0,trans1[3][3]=1; trans2[0][0]=1,trans2[0][1]=1,trans2[0][2]=1,trans2[0][3]=1; trans2[1][0]=0,trans2[1][1]=1,trans2[1][2]=0,trans2[1][3]=1; trans2[2][0]=0,trans2[2][1]=0,trans2[2][2]=1,trans2[2][3]=1; trans2[3][0]=0,trans2[3][1]=0,trans2[3][2]=0,trans2[3][3]=1; n=read(),m=read(); int las=1; for(ri i=1,x;i&lt;=m;++i)&#123; x=read(); if(i&gt;1)&#123; res=(trans1^(x-las-1))*trans2*res; &#125; else res=(trans1^(x-las))*res; las=x; &#125; if(m)res=(trans1^(n-las-1))*trans2*res; else res=trans1^(n-1); cout&lt;&lt;add(add(res[0][0],res[0][1]),add(res[0][2],res[0][3])); return 0;&#125; 随机二分图 解题思路： 容易想到去求每种匹配出现的概率，那么答案即为概率之和，现在考虑每类边出现在完美匹配的一个方案中的概率： 第一类边： 50%50\\%50% 第二类边： 每条边单独出现在一个方案中的概率为 50%50\\%50% ，但这样的话两条边一起出现的概率降为了 25%25\\%25% ，于是加入一个能连接四个点的边，其出现概率为 25%25\\%25% 第三类边： 每条边单独出现在一个方案中的概率为 50%50\\%50% ，但这样的话两条边一起出现的概率升为了 25%25\\%25% ，于是加入一个能连接四个点的边，其出现概率为 −25%-25\\%−25% 然后考虑把左右图的匹配情况压成一个状态进行转移，由于图没有顺序，每次强制匹配 lowbitlowbitlowbit 来转移即可，从终态倒着记忆化搜索会访问到很少的有用状态，可以通过此题 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include&lt;bits/stdc++.h&gt;#include&lt;tr1/unordered_map&gt;#define ri register int#define csi const int&amp;#define fi first#define se second#define pb push_backusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;vector&lt;int&gt; &gt; vii;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int x)&#123;return ksm(x,mod-2);&#125; inline void fix(int&amp;x)&#123;x=(x%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,const T&amp;b)&#123;a&gt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmax(T&amp;a,const T&amp;b)&#123;a&lt;b?a=b:0;&#125;const int inv2=5e8+4,inv4=inv2&gt;&gt;1;const int mogic=1e7+7;int first[mogic+5];struct edge&#123;int next,ori,vl;&#125;;vector&lt;edge&gt;E;int cnt=0;inline void add_(int u,int v)&#123; int t=u%mogic+1; ++cnt; E.pb((edge)&#123;first[t],u,v&#125;); first[t]=cnt;&#125;inline int query(int x)&#123; int t=x%mogic+1; for(ri i=first[t];i;i=E[i].next)&#123; if(E[i].ori==x)return E[i].vl; &#125; return -1;&#125;int n,m,pw[31];vector&lt;pii&gt;e[1&lt;&lt;15|5];inline int dfs(int sta)&#123; if(!sta)return 1; int t=query(sta); if(~t)return t; int res=0; int st=sta&amp;-sta; for(ri i=0,s;i&lt;e[st].size();++i)&#123; s=e[st][i].fi; if((sta&amp;s)!=s)continue; Add(res,mul(dfs(sta^s),e[st][i].se)); &#125; return add_(sta,res),res;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),m=read(); E.pb((edge)&#123;0,0,0&#125;); for(ri i=0;i&lt;=2*n;++i)pw[i]=1&lt;&lt;i; for(ri op,x1,y1,x2,y2,i=1;i&lt;=m;++i)&#123; op=read(); x1=read()-1,y1=read()+n-1; switch(op)&#123; case 0:&#123; e[pw[x1]].pb(pii(pw[x1]^pw[y1],inv2)); break; &#125; case 1:&#123; e[pw[x1]].pb(pii(pw[x1]^pw[y1],inv2)); x2=read()-1,y2=read()+n-1; e[pw[x2]].pb(pii(pw[x2]^pw[y2],inv2)); if(x1!=x2&amp;&amp;y1!=y2)&#123; if(x1&gt;x2)swap(x1,x2),swap(y1,y2); e[pw[x1]].pb(pii(pw[x1]^pw[x2]^pw[y1]^pw[y2],inv4)); &#125; break; &#125; case 2:&#123; e[pw[x1]].pb(pii(pw[x1]^pw[y1],inv2)); x2=read()-1,y2=read()+n-1; e[pw[x2]].pb(pii(pw[x2]^pw[y2],inv2)); if(x1!=x2&amp;&amp;y1!=y2)&#123; if(x1&gt;x2)swap(x1,x2),swap(y1,y2); e[pw[x1]].pb(pii(pw[x1]^pw[x2]^pw[y1]^pw[y2],mod-inv4)); &#125; break; &#125; &#125; &#125; cout&lt;&lt;mul(dfs(pw[n+n]-1),pw[n]); return 0;&#125; Mod Mod Mod 解题思路： 一个数对一个比它小的数取模，最多取log次就会变成0。我们思考如何利用这个性质。 如果我们设 f[x][i]f[x][i]f[x][i] 表示题目中的 f(x,i)f(x,i)f(x,i) ，那么每次 iii 加一的时候我们都要更新所有的 fff 值。 但简单思考后可以发现答案容易表示成 i∗x+bi*x+bi∗x+b 的形式，那么可以设 Fi,numF_{i,num}Fi,num​ 就代表当 x≤numx\\le numx≤num 时，最大的 bbb 值。 下面考虑转移，对于 num≤ai−1num\\le a_i-1num≤ai​−1显然不用管，对于 num≥ainum\\ge a_inum≥ai​ ，有两种转移： Fi,num→Fi+1,num%aiF_{i,num}\\rightarrow F_{i+1,num\\%a_i}Fi,num​→Fi+1,num%ai​​ Fi,num→Fi+1,ai−1F_{i,num}\\rightarrow F_{i+1,a_i-1}Fi,num​→Fi+1,ai​−1​ 用 mapmapmap 维护转移即可，复杂度是 O(nlog⁡a1log⁡n)O(n\\log a_1\\log n)O(nloga1​logn) CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;#include&lt;tr1/unordered_map&gt;#define ri register int#define csi const int&amp;#define fi first#define se second#define pb push_backusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,ll&gt; pll;typedef vector&lt;int&gt; vi;typedef vector&lt;vector&lt;int&gt; &gt; vii;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int x)&#123;return ksm(x,mod-2);&#125; inline void fix(int&amp;x)&#123;x=(x%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,const T&amp;b)&#123;a&gt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmax(T&amp;a,const T&amp;b)&#123;a&lt;b?a=b:0;&#125;const int N=2e5+5;map&lt;ll,ll&gt;f;int n;ll x,num,vl;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); f[readl()-1]=0; for(ri i=2;i&lt;=n;++i)&#123; x=readl(); while(f.size())&#123; num=f.rbegin()-&gt;fi; vl=f.rbegin()-&gt;se; if(num&lt;x)break; f.erase(num); ckmax(f[x-1],vl+(num-num%x-x)*(i-1)); ckmax(f[num%x],vl+(num-num%x)*(i-1)); &#125; &#125; ll res=0; for(map&lt;ll,ll&gt;::iterator it=f.begin();it!=f.end();++it) res=max(res,it-&gt;fi*n+it-&gt;se); cout&lt;&lt;res; return 0;&#125;","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://ldxcaicai.github.io/tags/%E9%A2%98%E8%A7%A3/"}]}]}