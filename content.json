{"meta":{"title":"自由を渇望する","subtitle":"ひとりぼっち","description":"Konjak_ldx's blog","author":"ldxcaicai","url":"http://xdl030112.github.io","root":"/"},"pages":[{"title":"所有标签","date":"2020-01-14T07:50:12.870Z","updated":"2020-01-14T07:50:12.870Z","comments":true,"path":"tags/index.html","permalink":"http://xdl030112.github.io/tags/index.html","excerpt":"","text":""},{"title":"link","date":"2020-01-14T07:28:15.000Z","updated":"2020-01-14T07:43:32.952Z","comments":true,"path":"link/index.html","permalink":"http://xdl030112.github.io/link/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2020-01-14T07:48:39.218Z","updated":"2020-01-14T07:48:39.218Z","comments":true,"path":"categories/index.html","permalink":"http://xdl030112.github.io/categories/index.html","excerpt":"","text":""},{"title":"Friends!","date":"2019-12-27T06:17:17.523Z","updated":"2019-12-27T06:17:17.523Z","comments":true,"path":"friends/index.html","permalink":"http://xdl030112.github.io/friends/index.html","excerpt":"","text":""}],"posts":[{"title":"杂题乱做 Round15","slug":"sol15","date":"2020-01-14T05:34:02.000Z","updated":"2020-01-14T06:43:56.195Z","comments":true,"path":"sol15/","link":"","permalink":"http://xdl030112.github.io/sol15/","excerpt":"","text":"&#x4ECE;&#x672C;&#x7BC7;&#x535A;&#x5BA2;&#x5F00;&#x59CB;&#xFF0C;&#x5982;&#x679C;&#x4E0D;&#x662F;cf/atc/cc&#x8FD9;&#x79CD;&#x8BBF;&#x95EE;&#x6BD4;&#x8F83;&#x6162;&#x7684;&#x7F51;&#x7AD9;&#x6216;&#x8005;luogu&#x8FD9;&#x79CD;&#x6709;&#x8BBF;&#x95EE;&#x6743;&#x9650;&#x7684;&#x7F51;&#x7AD9;&#x4E0A;&#x7684;&#x9898;&#x76EE;&#x535A;&#x4E3B;&#x76F4;&#x63A5;&#x8D34;&#x4EE3;&#x7801;&#x94FE;&#x63A5; &#x4ED9;&#x4EBA;&#x638C;&#x8BA1;&#x6570; &#x89E3;&#x9898;&#x601D;&#x8DEF; &#x8BBE;&#x6709;&#x6807;&#x53F7;&#x6709;&#x6839;&#x4ED9;&#x4EBA;&#x638C;&#x7684;&#x751F;&#x6210;&#x51FD;&#x6570;&#x7684; EGF &#x4E3A; F(x)F(x)F(x) &#xFF0C;&#x7136;&#x540E;&#x7528;&#x6839;&#x90A3;&#x4E2A;&#x90E8;&#x5206;&#x6765;&#x5EFA;&#x7ACB;&#x65B9;&#x7A0B;&#xFF0C;&#x5047;&#x8BBE;&#x6839;&#x5728;&#x4E00;&#x4E2A;&#x6709; iii &#x4E2A;&#x70B9;&#x7684;&#x73AF;&#x4E0A;&#xFF0C;&#x90A3;&#x4E48;&#xFF0C;&#x8FD9;&#x4E2A;&#x73AF;&#x4E0A;&#x65AD;&#x6389;&#x6240;&#x6709;&#x8FB9;&#xFF0C;&#x7136;&#x540E;&#x53BB;&#x6389;&#x6839;&#xFF0C;&#x5269;&#x4E0B;&#x7684; i&#x2212;1i-1i&#x2212;1 &#x4E2A;&#x70B9;&#x4E3A;&#x6839;&#x7684;&#x8FDE;&#x901A;&#x5757;&#x90FD;&#x662F;&#x4ED9;&#x4EBA;&#x638C;&#xFF0C;&#x5BF9;&#x5E94;&#x751F;&#x6210;&#x51FD;&#x6570;&#x4E3A; F(x)i&#x2212;12\\frac{F(x)^{i-1}}22F(x)i&#x2212;1&#x200B;&#xFF0C;&#x5982;&#x679C;&#x8FDE;&#x7684;&#x662F;&#x4E00;&#x4E2A;&#x70B9;&#xFF0C;&#x90A3;&#x4E48;&#x65AD;&#x6389;&#x8FD9;&#x6761;&#x8FB9;&#x4E4B;&#x540E;&#x90A3;&#x4E2A;&#x70B9;&#x4E3A;&#x6839;&#x7684;&#x8FDE;&#x901A;&#x5757;&#x4E5F;&#x662F;&#x4ED9;&#x4EBA;&#x638C;&#xFF0C;&#x5BF9;&#x5E94;&#x751F;&#x6210;&#x51FD;&#x6570;&#x4E3A; F(x)F(x)F(x) &#xFF0C;&#x4E8E;&#x662F;&#x5C31;&#x6709;&#x5982;&#x4E0B;&#x65B9;&#x7A0B;&#xFF1A; F(x)=eF(x)+&#x2211;i&#x2265;2F(x)i2F(x)=e^{F(x)+\\sum\\limits_{i\\ge2}\\frac{F(x)^i}2} F(x)=eF(x)+i&#x2265;2&#x2211;&#x200B;2F(x)i&#x200B; &#x5269;&#x4E0B;&#x7684;&#x5C31;&#x662F;&#x725B;&#x987F;&#x8FED;&#x4EE3;&#x7206;&#x7B97;&#x4E86;&#xFF0C;&#x8FD9;&#x4E2A;&#x5404;&#x51ED;&#x672C;&#x4E8B; &#x7136;&#x540E;&#x5B9E;&#x73B0;&#x592A;&#x5DEE;&#x5DEE;&#x70B9;TLE&#x4E86;&#x3002; CODE &#x6709;&#x6807;&#x53F7;&#x8352;&#x6F20;&#x8BA1;&#x6570; &#x4E0A;&#x9762;&#x90A3;&#x9898;&#x52A0;&#x4E2A;&#x591A;&#x9879;&#x5F0F;exp &#x61D2;&#x5F97;&#x8D34;&#x4EE3;&#x7801;&#x4E86;&#x3002; &#x300C;&#x5730;&#x5E95;&#x8537;&#x8587;&#x300D; &#x89E3;&#x9898;&#x601D;&#x8DEF; &#x9700;&#x8981;&#x5148;&#x590D;&#x4E60;&#x4E00;&#x4E0B;&#x6C42;&#x70B9;&#x53CC;&#x8FDE;&#x901A;&#x56FE;&#x7684;&#x505A;&#x6CD5;&#xFF0C;&#x7136;&#x540E;&#x7B2C;&#x4E00;&#x90E8;&#x5206;&#x5C31;&#x662F;&#x628A;&#x7ED9;&#x7684;&#x70B9;&#x96C6; |S| &#x4E2D;&#x7684;&#x6BCF;&#x4E2A;&#x70B9;&#x90FD;&#x62FF;&#x6765;&#x8DD1;&#x4E00;&#x6B21; &#x73B0;&#x5728;&#x5047;&#x8BBE;&#x6709;&#x51FD;&#x6570; B(x)=&#x2211;i&#x2212;1&#x2208;Sbi&#x2212;1xii!B(x)=\\sum\\limits_{i-1\\in S}\\frac{b_{i-1}x^i}{i!}B(x)=i&#x2212;1&#x2208;S&#x2211;&#x200B;i!bi&#x2212;1&#x200B;xi&#x200B; &#x53EF;&#x4EE5;&#x7528;&#x7C7B;&#x4F3C;&#x70B9;&#x53CC;&#x7684;&#x505A;&#x6CD5;&#x63A8;&#x51FA;&#x6765;&#x4E00;&#x4E2A; F(x)=xeB&#x2218;F(x)F(x)=xe^{B\\circ{F(x)}}F(x)=xeB&#x2218;F(x) &#x518D;&#x7528;&#x4E00;&#x6B21;&#x62D3;&#x5C55;&#x62C9;&#x683C;&#x6717;&#x65E5;&#x53CD;&#x6F14;&#x5373;&#x53EF; CODE Tree &#x89E3;&#x9898;&#x601D;&#x8DEF; &#x5148;&#x5C06;&#x9898;&#x610F;&#x8FDB;&#x884C;&#x4E00;&#x4E2A;&#x8F6C;&#x5316;&#xFF0C;&#x53D1;&#x73B0;&#x7B49;&#x4EF7;&#x4E8E;&#x7ED9;&#x6BCF;&#x4E2A;&#x70B9;&#x8D4B;&#x4E00;&#x4E2A;&#x975E;&#x8D1F;&#x6743;&#x503C;&#xFF0C;&#x4F7F;&#x5F97;&#x6574;&#x68F5;&#x6811;&#x6743;&#x503C;&#x548C;&#x4E3A; xxx &#x7684;&#x65B9;&#x6848;&#x6570;&#xFF0C;&#x90A3;&#x4E48;&#x95EE;&#x9898;&#x53D8;&#x6210;&#x6C42;&#x7ED9;&#x4E00;&#x68F5;&#x6709;&#x6839;&#x6811;&#xFF0C;&#x95EE;&#x5305;&#x542B;&#x6839;&#x7684;&#x5927;&#x5C0F;&#x4E3A; 1,2,...,n1,2,...,n1,2,...,n &#x7684;&#x8FDE;&#x901A;&#x5757;&#x6570;&#xFF0C;&#x53EF;&#x4EE5;&#x7528;&#x94FE;&#x5206;&#x6CBB;+&#x5206;&#x6CBB; ntt &#x505A;&#xFF0C;&#x4E5F;&#x53EF;&#x4EE5;&#x70B9;&#x5206;&#x6CBB;+&#x5206;&#x6CBB; ntt CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly;#define pb push_back#define fi first#define se secondconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() { int ans=0; char ch=gc(); bool f=1; while(!isdigit(ch)) f^=ch==&apos;-&apos;,ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;}inline ll readl() { ll ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}namespace modular { const int mod=998244353; inline int add(int a,int b) { return a+b&lt;mod?a+b:a+b-mod; } inline int dec(int a,int b) { return a&lt;b?a-b+mod:a-b; } inline int mul(int a,int b) { return (ll)a*b%mod; } inline void Add(int&amp;a,int b) { a=a+b&lt;mod?a+b:a+b-mod; } inline void Dec(int&amp;a,int b) { a=a&lt;b?a-b+mod:a-b; } inline void Mul(int&amp;a,int b) { a=(ll)a*b%mod; } inline int ksm(int a,int p) { int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; } inline int Inv(int a) { return ksm(a,mod-2); }}using namespace modular;int lim,tim,invv[21];vector&lt;int&gt;rev[21],w[21];inline void init_ntt() { w[20].resize(1&lt;&lt;20),w[20][0]=1,w[20][1]=ksm(3,(mod-1)&gt;&gt;21); for(ri i=2,up=1&lt;&lt;20;i&lt;up;++i) w[20][i]=mul(w[20][i-1],w[20][1]); for(ri i=19;~i;--i) { w[i].resize(1&lt;&lt;i); for(ri j=0,up=1&lt;&lt;i;j&lt;up;++j) w[i][j]=w[i+1][j&lt;&lt;1]; } invv[0]=1; for(ri i=1,iv=mod+1&gt;&gt;1;i&lt;21;++i) invv[i]=mul(invv[i-1],iv);}inline void init(int up) { lim=1,tim=0; while(lim&lt;up) lim&lt;&lt;=1,++tim; if(rev[tim].size()) return; rev[tim].resize(lim); for(ri i=1;i&lt;lim;++i) rev[tim][i]=(rev[tim][i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(tim-1));}inline void ntt(poly&amp;a,int typ) { for(ri i=1;i&lt;lim;++i) if(i&lt;rev[tim][i]) swap(a[i],a[rev[tim][i]]); for(ri i=1,t=0,a0,a1;i&lt;lim;i&lt;&lt;=1,++t) for(ri j=0;j&lt;lim;j+=i&lt;&lt;1) for(ri k=0;k&lt;i;++k) { a0=a[j+k],a1=mul(a[j+k+i],w[t][k]); a[j+k]=add(a0,a1),a[j+k+i]=dec(a0,a1); } if(~typ) return; reverse(++a.begin(),a.end()); for(ri i=0;i&lt;lim;++i) Mul(a[i],invv[tim]);}inline poly operator*(poly a,poly b) { int n=(int)a.size(),m=(int)b.size(),t=n+m-1; if(t&lt;=128) { poly c(t); for(ri i=0;i&lt;n;++i) if(a[i]) for(ri j=0;j&lt;m;++j) Add(c[i+j],mul(a[i],b[j])); return c; } init(t); a.resize(lim),ntt(a,1); b.resize(lim),ntt(b,1); for(ri i=0;i&lt;lim;++i) Mul(a[i],b[i]); return ntt(a,-1),a.resize(t),a;}inline poly operator+(poly a,poly b) { int n=(int)b.size(); if((int)a.size()&lt;n) a.resize(n); for(ri i=0;i&lt;n;++i) Add(a[i],b[i]); return a;}const int N=1e5+5;vector&lt;int&gt;e[N],son[N];int fa[N],hson[N],dep[N],top[N],siz[N],pred[N],num[N],tot=0,bot[N];void dfs1(int p) { siz[p]=1; for(ri i=0,v;i&lt;(int)e[p].size();++i) { if((v=e[p][i])==fa[p]) continue; fa[v]=p,dep[v]=dep[p]+1,dfs1(v),siz[p]+=siz[v]; if(siz[v]&gt;siz[hson[p]]) hson[p]=v; }}void dfs2(int p,int tp) { pred[num[p]=++tot]=p,top[p]=tp; if(!hson[p]) { bot[p]=p;return; } dfs2(hson[p],p),bot[p]=bot[hson[p]]; for(ri i=0,v;i&lt;(int)e[p].size();++i) if((v=e[p][i])!=fa[p]&amp;&amp;v!=hson[p]) dfs2(v,v);}#define lc (ch[p][0])#define rc (ch[p][1])int n,rt,Fa[N],ch[N][2],fac[N],ifac[N];ll x;poly F[N],G[N];inline poly solve(int l,int r,vector&lt;poly&gt;&amp;a) { if(l&gt;r) return poly(1,1); if(l==r) return a[l]; int mid=l+r&gt;&gt;1; return solve(l,mid,a)*solve(mid+1,r,a);}inline void init_vl(int p) { vector&lt;poly&gt;t; for(ri i=0;i&lt;(int)son[p].size();++i) t.pb(F[son[p][i]]); G[p]=solve(0,(int)t.size()-1,t); G[p].pb(0); for(ri i=(int)G[p].size()-1;i;--i) G[p][i]=G[p][i-1]; F[p]=G[p],G[p][0]=0,F[p][0]=1;}inline void pushup(int p) { if(lc&amp;&amp;rc) { F[p]=F[lc]+G[lc]*G[p]*F[rc]; G[p]=G[lc]*G[p]*G[rc]; } else if(lc) { F[p]=F[lc]+G[lc]*G[p]; G[p]=G[lc]*G[p]; } else if(rc) { F[p]=G[p]*F[rc]; F[p][0]=1; G[p]=G[p]*G[rc]; }}inline int solve(int l,int r,int dt=0) { if(l&gt;r) return 0; if(l==r) return init_vl(pred[l]),pred[l]; for(ri p,i=r;i&gt;=l;--i) if(siz[pred[l]]+dt&lt;=2*siz[pred[i]]) { p=pred[i]; init_vl(p); lc=solve(l,i-1,siz[p]); rc=solve(i+1,r,dt); return pushup(p),p; } return 0;}inline int solve(int p) { for(ri x=p;x;x=hson[x]) for(ri i=0,v;i&lt;(int)e[x].size();++i) if((v=e[x][i])!=fa[x]&amp;&amp;v!=hson[x]) son[x].pb(solve(v)); return solve(num[p],num[bot[p]]);}inline void init() { fac[0]=fac[1]=ifac[0]=ifac[1]=1; for(ri i=2;i&lt;=n;++i) { fac[i]=mul(fac[i-1],i); ifac[i]=mul(ifac[mod-mod/i*i],mod-mod/i); } for(ri i=2;i&lt;=n;++i) Mul(ifac[i],ifac[i-1]);}int main() { #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(),x=readl(); init_ntt(); init(); for(ri i=1,u,v;i&lt;n;++i) { u=read(),v=read(); e[u].pb(v),e[v].pb(u); } dfs1(1),dfs2(1,1); rt=solve(1); int res=0; for(ri i=1,mt=1;i&lt;(int)F[rt].size();++i) { Add(res,mul(ifac[i-1],mul(mt,F[rt][i]))); Mul(mt,(x+i)%mod); } cout&lt;&lt;res; return 0;} &#x751F;&#x6210;&#x6811;&#x8BA1;&#x6570; &#x89E3;&#x9898;&#x601D;&#x8DEF; &#x6811;&#x4E0A;&#x8BA1;&#x6570;&#x4E0D;&#x592A;&#x597D;&#x505A;&#xFF0C;&#x8003;&#x8651;&#x8F6C; prufer &#x5E8F;&#x5217;&#xFF0C;&#x679A;&#x4E3E;&#x6BCF;&#x4E2A;&#x8FDE;&#x901A;&#x5757;&#x5728; prufer &#x5E8F;&#x5217;&#x4E2D;&#x51FA;&#x73B0;&#x6B21;&#x6570; did_idi&#x200B; &#xFF0C;&#x91CD;&#x65B0;&#x5217;&#x51FA;&#x8D21;&#x732E;&#xFF1A; Ans=&#x2211;&#x2211;d=n&#x2212;2(n&#x2212;2)!(&#x220F;i=1naidi+1di!(di+1)m)(&#x2211;i=1n(di+1)m)=(n&#x2212;2)!&#x220F;i=1nai&#x2211;&#x2211;d=n&#x2212;2(&#x220F;i=1naididi!(di+1)m)(&#x2211;i=1n(di+1)m)\\begin{aligned} Ans=&amp;\\sum\\limits_{\\sum d=n-2}(n-2)!(\\prod\\limits_{i=1}^n\\frac{a_i^{d_i+1}}{d_i!}(d_i+1)^m)(\\sum\\limits_{i=1}^n(d_i+1)^m)\\\\ =&amp;(n-2)!\\prod\\limits_{i=1}^na_i\\sum\\limits_{\\sum d=n-2}(\\prod\\limits_{i=1}^n\\frac{a_i^{d_i}}{d_i!}(d_i+1)^m)(\\sum\\limits_{i=1}^n(d_i+1)^m)\\\\ \\end{aligned} Ans==&#x200B;&#x2211;d=n&#x2212;2&#x2211;&#x200B;(n&#x2212;2)!(i=1&#x220F;n&#x200B;di&#x200B;!aidi&#x200B;+1&#x200B;&#x200B;(di&#x200B;+1)m)(i=1&#x2211;n&#x200B;(di&#x200B;+1)m)(n&#x2212;2)!i=1&#x220F;n&#x200B;ai&#x200B;&#x2211;d=n&#x2212;2&#x2211;&#x200B;(i=1&#x220F;n&#x200B;di&#x200B;!aidi&#x200B;&#x200B;&#x200B;(di&#x200B;+1)m)(i=1&#x2211;n&#x200B;(di&#x200B;+1)m)&#x200B; &#x5148;&#x4E0D;&#x7BA1;&#x540E;&#x9762;&#x7684; &#x2211;\\sum&#x2211; &#xFF0C;&#x8BBE; F(x)=&#x2211;i&#x2265;0(i+1)mxii!,F(x)=&#x2211;i&#x2265;0(i+1)2mxii!F(x)=\\sum\\limits_{i\\ge0}\\frac{(i+1)^mx^i}{i!},F(x)=\\sum\\limits_{i\\ge0}\\frac{(i+1)^{2m}x^i}{i!}F(x)=i&#x2265;0&#x2211;&#x200B;i!(i+1)mxi&#x200B;,F(x)=i&#x2265;0&#x2211;&#x200B;i!(i+1)2mxi&#x200B; &#x90A3;&#x4E48;&#x524D;&#x9762;&#x5C31;&#x662F; &#x220F;i=1nF(aix)\\prod\\limits_{i=1}^nF(a_ix)i=1&#x220F;n&#x200B;F(ai&#x200B;x) &#xFF0C;&#x8FD9;&#x4E2A;&#x7528; ln+expln+expln+exp &#x89E3;&#x51B3;&#xFF0C;&#x4E2D;&#x95F4;&#x9700;&#x8981;&#x6C42;&#x7B49;&#x5E42;&#x548C; &#x540E;&#x9762;&#x4E00;&#x5768;&#x53EF;&#x4EE5;&#x53D8;&#x6210; &#x2211;i=1nG(aix)F(aix)=&#x2211;i=1nGF(aix)\\sum\\limits_{i=1}^n\\frac{G(a_ix)}{F(a_ix)}=\\sum\\limits_{i=1}^n\\frac GF(a_ix)i=1&#x2211;n&#x200B;F(ai&#x200B;x)G(ai&#x200B;x)&#x200B;=i=1&#x2211;n&#x200B;FG&#x200B;(ai&#x200B;x) &#xFF0C;&#x4E5F;&#x80FD;&#x7528;&#x7B49;&#x5E42;&#x548C;&#x641E;&#x5B9A;&#xFF0C;&#x590D;&#x6742;&#x5EA6;&#x74F6;&#x9888;&#x5728;&#x6C42;&#x7B49;&#x5E42;&#x548C;&#x7684;&#x5206;&#x6CBB; nttnttntt &#x4E0A; &#x8FD8;&#x6709;&#x57FA;&#x4E8E; dp &#x7684;&#x505A;&#x6CD5;&#xFF0C;&#x5728;&#x6B64;&#x4E0D;&#x518D;&#x8D58;&#x8FF0;&#xFF0C;&#x590D;&#x6742;&#x5EA6;&#x8981;&#x5E26;&#x4E0A; m CODE &#x6570;&#x6811; &#x89E3;&#x9898;&#x601D;&#x8DEF; &#x96BE;&#x5EA6;&#xFF1A;subtask1&gt;subtask2&gt;subtask0 &#x9996;&#x5148;&#x5BF9;&#x4E8E;&#x4E24;&#x68F5;&#x6811;&#xFF0C;&#x8BBE;&#x5B83;&#x4EEC;&#x8FB9;&#x96C6;&#x4E3A; E1,E2E_1,E_2E1&#x200B;,E2&#x200B; &#xFF0C;&#x90A3;&#x4E48;&#x4EFB;&#x9009;&#x4E24;&#x68F5;&#x6811;&#x51FA;&#x6765;&#x5BF9;&#x7B54;&#x6848;&#x7684;&#x8D21;&#x732E;&#x662F; yn&#x2212;&#x2223;E1&#x2229;E2&#x2223;y^{n-|E_1\\cap E_2|}yn&#x2212;&#x2223;E1&#x200B;&#x2229;E2&#x200B;&#x2223; subtask0 &#x76F4;&#x63A5;&#x7528; map &#x6C42;&#x76F8;&#x540C;&#x7684;&#x8FB9;&#x6570; subtask1 &#x8BBE; f(S)f(S)f(S) &#x8868;&#x793A;&#x4E24;&#x68F5;&#x6811;&#x7684;&#x8FB9;&#x4EA4;&#x96C6;&#x6070;&#x597D;&#x4E3A; SSS &#x7684;&#x65B9;&#x6848;&#x6570;&#xFF0C; g(S)g(S)g(S) &#x8868;&#x793A;&#x4E24;&#x68F5;&#x6811;&#x7684;&#x8FB9;&#x4EA4;&#x96C6;&#x5305;&#x542B; SSS &#x7684;&#x65B9;&#x6848;&#x6570;&#xFF0C;&#x663E;&#x7136;&#x6709; f(S)=&#x2211;S&#x2286;T(&#x2212;1)&#x2223;T&#x2223;&#x2212;&#x2223;S&#x2223;g(S)f(S)=\\sum\\limits_{S\\subseteq T}(-1)^{|T|-|S|}g(S)f(S)=S&#x2286;T&#x2211;&#x200B;(&#x2212;1)&#x2223;T&#x2223;&#x2212;&#x2223;S&#x2223;g(S) &#x7136;&#x540E;&#x6839;&#x636E; prufer &#x5E8F;&#x5217;&#x7684;&#x6027;&#x8D28;&#xFF0C;&#x8BBE;&#x8FB9;&#x96C6; SSS &#x628A;&#x6811;&#x5206;&#x6210;&#x7684;&#x8FDE;&#x901A;&#x5757;&#x5927;&#x5C0F;&#x5206;&#x522B;&#x4E3A; a1,a2,...,an&#x2212;&#x2223;S&#x2223;a_1,a_2,...,a_{n-|S|}a1&#x200B;,a2&#x200B;,...,an&#x2212;&#x2223;S&#x2223;&#x200B; &#xFF0C;&#x90A3;&#x4E48; g(S)=nn&#x2212;2&#x2212;&#x2223;S&#x2223;&#x220F;i=1n&#x2212;&#x2223;S&#x2223;aig(S)=n^{n-2-|S|}\\prod\\limits_{i=1}^{n-|S|}a_ig(S)=nn&#x2212;2&#x2212;&#x2223;S&#x2223;i=1&#x220F;n&#x2212;&#x2223;S&#x2223;&#x200B;ai&#x200B; &#x90A3;&#x4E48;&#x5E26;&#x5165;&#x6C42;&#x603B;&#x8D21;&#x732E; Ans=&#x2211;Sf(S)yn&#x2212;&#x2223;S&#x2223;=&#x2211;S(&#x2211;S&#x2286;Tg(T))yn&#x2212;&#x2223;S&#x2223;=&#x2211;Tg(T)&#x2211;S&#x2286;Tyn&#x2212;&#x2223;S&#x2223;=yn&#x2211;Tg(T)(1y&#x2212;1)&#x2223;T&#x2223;=yn&#x2211;Snn&#x2212;&#x2223;S&#x2223;&#x2212;2(1y&#x2212;1)&#x2223;S&#x2223;&#x220F;i&#x2212;1n&#x2212;&#x2223;S&#x2223;ai=(1&#x2212;y)nn2&#x2211;S&#x220F;i=1n&#x2212;&#x2223;S&#x2223;ai(1y&#x2212;1)n\\begin{aligned} Ans=&amp;\\sum\\limits_{S}f(S)y^{n-|S|}\\\\ =&amp;\\sum\\limits_{S}(\\sum\\limits_{S\\subseteq T}g(T))y^{n-|S|}\\\\ =&amp;\\sum\\limits_{T}g(T)\\sum\\limits_{S\\subseteq T}y^{n-|S|}\\\\ =&amp;y^n\\sum\\limits_{T}g(T)(\\frac1y-1)^{|T|}\\\\ =&amp;y^n\\sum\\limits_{S}n^{n-|S|-2}(\\frac1y-1)^{|S|}\\prod\\limits_{i-1}^{n-|S|}a_i\\\\ =&amp;\\frac{(1-y)^n}{n^2}\\sum\\limits_{S}\\prod\\limits_{i=1}^{n-|S|}a_i(\\frac1y-1)n \\end{aligned} Ans======&#x200B;S&#x2211;&#x200B;f(S)yn&#x2212;&#x2223;S&#x2223;S&#x2211;&#x200B;(S&#x2286;T&#x2211;&#x200B;g(T))yn&#x2212;&#x2223;S&#x2223;T&#x2211;&#x200B;g(T)S&#x2286;T&#x2211;&#x200B;yn&#x2212;&#x2223;S&#x2223;ynT&#x2211;&#x200B;g(T)(y1&#x200B;&#x2212;1)&#x2223;T&#x2223;ynS&#x2211;&#x200B;nn&#x2212;&#x2223;S&#x2223;&#x2212;2(y1&#x200B;&#x2212;1)&#x2223;S&#x2223;i&#x2212;1&#x220F;n&#x2212;&#x2223;S&#x2223;&#x200B;ai&#x200B;n2(1&#x2212;y)n&#x200B;S&#x2211;&#x200B;i=1&#x220F;n&#x2212;&#x2223;S&#x2223;&#x200B;ai&#x200B;(y1&#x200B;&#x2212;1)n&#x200B; &#x540E;&#x9762;&#x4E00;&#x5768;&#x62C6;&#x7EC4;&#x5408;&#x610F;&#x4E49;&#xFF0C;&#x53D1;&#x73B0;&#x662F;&#x6BCF;&#x4E2A;&#x8FDE;&#x901A;&#x5757;&#x9700;&#x8981;&#x6311;&#x4E00;&#x4E2A;&#x70B9;&#x51FA;&#x6765;&#xFF0C;&#x8D21;&#x732E;&#x662F; (1y&#x2212;1)n(\\frac1y-1)n(y1&#x200B;&#x2212;1)n &#xFF0C;&#x90A3;&#x4E48;&#x6811;&#x5F62; dp &#x4E00;&#x4E0B;&#xFF0C;&#x8BBE; fi,0/1f_{i,0/1}fi,0/1&#x200B; &#x8868;&#x793A;&#x5904;&#x7406;&#x5B8C; i &#x4E3A;&#x6839;&#x7684;&#x5B50;&#x6811;&#xFF0C;&#x5F53;&#x524D; i &#x7684;&#x8FDE;&#x901A;&#x5757;&#x662F;&#x5426;&#x6709;&#x4EE3;&#x8868;&#x70B9;&#x7684;&#x8D21;&#x732E;&#x5373;&#x53EF; subtask2 &#x53D1;&#x73B0;&#x8D21;&#x732E;&#x7684;&#x5F0F;&#x5B50;&#x53D8;&#x6210;&#x4E86;&#x8FD9;&#x6837;&#xFF1A; Ans=yn&#x2211;Sg2(S)(1y&#x2212;1)&#x2223;S&#x2223;\\begin{aligned} Ans=&amp;y^n\\sum\\limits_{S}g^2(S)(\\frac1y-1)^{|S|}\\\\ \\end{aligned} Ans=&#x200B;ynS&#x2211;&#x200B;g2(S)(y1&#x200B;&#x2212;1)&#x2223;S&#x2223;&#x200B; &#x62C6;&#x5F00;&#x4E4B;&#x540E;&#x5BF9;&#x8FDE;&#x901A;&#x5757;&#x6784;&#x9020; EGF &#xFF0C;&#x591A;&#x9879;&#x5F0F; exp &#x4E00;&#x4E0B;&#x5C31;&#x662F;&#x7B54;&#x6848; CODE &#x65E0;&#x6807;&#x53F7;&#x65E0;&#x6839;&#x6811;&#x8BA1;&#x6570; &#x5BF9;&#x7740;&#x8FD9;&#x7BC7;blog&#x91CC;&#x7684;&#x65B9;&#x6CD5;&#x505A;&#x5373;&#x53EF; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly;#define pb push_back#define fi first#define se secondconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() { int ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}namespace modular { const int mod=998244353; inline int add(int a,int b) { return a+b&lt;mod?a+b:a+b-mod; } inline int dec(int a,int b) { return a&lt;b?a-b+mod:a-b; } inline int mul(int a,int b) { return (ll)a*b%mod; } inline void Add(int&amp;a,int b) { a=a+b&lt;mod?a+b:a+b-mod; } inline void Dec(int&amp;a,int b) { a=a&lt;b?a-b+mod:a-b; } inline void Mul(int&amp;a,int b) { a=(ll)a*b%mod; } inline int ksm(int a,int p) { int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; } inline int Inv(int a) { return ksm(a,mod-2); }}using namespace modular;int lim,tim,invv[21],inv[1&lt;&lt;20];vector&lt;int&gt;rev[21],w[21];inline void init_ntt() { w[20].resize(1&lt;&lt;20),inv[1]=w[20][0]=invv[0]=1,w[20][1]=ksm(3,(mod-1)&gt;&gt;21); for(ri i=2,up=1&lt;&lt;20;i&lt;up;++i) { w[20][i]=mul(w[20][i-1],w[20][1]); inv[i]=mul(inv[mod-mod/i*i],mod-mod/i); } for(ri i=19;~i;--i) { w[i].resize(1&lt;&lt;i); for(ri j=0,up=1&lt;&lt;i;j&lt;up;++j) w[i][j]=w[i+1][j&lt;&lt;1]; } for(ri i=1,iv=mod+1&gt;&gt;1;i&lt;21;++i) invv[i]=mul(invv[i-1],iv);}inline void init(int up) { lim=1,tim=0; while(lim&lt;up) lim&lt;&lt;=1,++tim; if(rev[tim].size()) return; rev[tim].resize(lim); for(ri i=1;i&lt;lim;++i) rev[tim][i]=(rev[tim][i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(tim-1));}inline void ntt(poly&amp;a,int typ) { for(ri i=1;i&lt;lim;++i) if(i&lt;rev[tim][i]) swap(a[i],a[rev[tim][i]]); for(ri i=1,t=0,a0,a1;i&lt;lim;i&lt;&lt;=1,++t) for(ri j=0;j&lt;lim;j+=i&lt;&lt;1) for(ri k=0;k&lt;i;++k) { a0=a[j+k],a1=mul(a[j+k+i],w[t][k]); a[j+k]=add(a0,a1),a[j+k+i]=dec(a0,a1); } if(~typ) return; reverse(++a.begin(),a.end()); for(ri i=0;i&lt;lim;++i) Mul(a[i],invv[tim]);}inline poly operator*(poly a,poly b) { int n=(int)a.size(),m=(int)b.size(),t=n+m-1; if(t&lt;=128) { poly c(t); for(ri i=0;i&lt;n;++i) if(a[i]) for(ri j=0;j&lt;m;++j) Add(c[i+j],mul(a[i],b[j])); return c; } init(t); a.resize(lim),ntt(a,1); b.resize(lim),ntt(b,1); for(ri i=0;i&lt;lim;++i) Mul(a[i],b[i]); return ntt(a,-1),a.resize(t),a;}const int N=2e5+5;int n;poly f,g;poly ta,tb,tc;inline void solve(int l,int r) { if(l==r) { if(l&gt;1) Mul(f[l],inv[l-1]); for(ri p=l,ad=mul(f[l],l);p&lt;=n;p+=l) Add(g[p],ad); return; } int mid=l+r&gt;&gt;1; solve(l,mid); if(l==1) { ta.resize(mid),tb.resize(mid); for(ri i=l;i&lt;=mid;++i) ta[i-l]=f[i],tb[i-l]=g[i]; tc=ta*tb; for(ri i=mid+1;i&lt;=r;++i) Add(f[i],tc[i-l-1]); } else { ta.resize(mid-l+1),tb.resize(r-l+1); for(ri i=l;i&lt;=mid;++i) ta[i-l]=f[i]; for(ri i=l;i&lt;=r;++i) tb[i-l]=g[i-l]; tc=ta*tb; for(ri i=mid+1;i&lt;=r;++i) Add(f[i],tc[i-l]); for(ri i=l;i&lt;=mid;++i) ta[i-l]=g[i]; for(ri i=l;i&lt;=r;++i) tb[i-l]=f[i-l]; tc=ta*tb; for(ri i=mid+1;i&lt;=r;++i) Add(f[i],tc[i-l]); } solve(mid+1,r);}int main() { #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(); init_ntt(); f.resize(n+1),g.resize(n+1); f[1]=1,solve(1,n); int res=f[n]; for(ri i=n/2+1;i&lt;n;++i) Dec(res,mul(f[i],f[n-i])); if(!(n&amp;1)) Dec(res,(ll)f[n/2]*(f[n/2]-1)/2%mod); cout&lt;&lt;res; return 0;} &#x9057;&#x5FD8;&#x7684;&#x96C6;&#x5408; &#x89E3;&#x9898;&#x601D;&#x8DEF; &#x663E;&#x7136;&#x6709; F(x)=&#x220F;i=1n1(1&#x2212;xi)[i&#x2208;S]F(x)=\\prod\\limits_{i=1}^n\\frac1{(1-x^i)^{[i\\in S]}}F(x)=i=1&#x220F;n&#x200B;(1&#x2212;xi)[i&#x2208;S]1&#x200B; &#x679C;&#x65AD;&#x4E0A; lnlnln ln&#x2061;F(x)=&#x2211;i=1n&#x2212;[i&#x2208;S]ln&#x2061;(1&#x2212;xi)=&#x2211;i&gt;0[i&#x2208;S]&#x2211;j&gt;0xijjfn=&#x2211;d&#x2223;n[d&#x2208;S]dnnfn=&#x2211;d&#x2223;n[d&#x2208;S]d\\begin{aligned} \\ln F(x)=&amp;\\sum\\limits_{i=1}^n-[i\\in S]\\ln (1-x^i)\\\\ =&amp;\\sum\\limits_{i&gt;0}[i\\in S]\\sum\\limits_{j&gt;0} \\frac{x^{ij}}{j}\\\\ f_n=&amp;\\sum\\limits_{d|n}[d\\in S]\\frac dn\\\\ nf_n=&amp;\\sum\\limits_{d|n}[d\\in S]d \\end{aligned} lnF(x)==fn&#x200B;=nfn&#x200B;=&#x200B;i=1&#x2211;n&#x200B;&#x2212;[i&#x2208;S]ln(1&#x2212;xi)i&gt;0&#x2211;&#x200B;[i&#x2208;S]j&gt;0&#x2211;&#x200B;jxij&#x200B;d&#x2223;n&#x2211;&#x200B;[d&#x2208;S]nd&#x200B;d&#x2223;n&#x2211;&#x200B;[d&#x2208;S]d&#x200B; &#x90A3;&#x4E48;&#x7528; mtt &#x5B9E;&#x73B0;&#x591A;&#x9879;&#x5F0F; ln &#x7136;&#x540E;&#x72C4;&#x5229;&#x514B;&#x96F7;&#x9006;&#x524D;&#x7F00;&#x548C;&#x5373;&#x53EF; CODE","categories":[{"name":"public","slug":"public","permalink":"http://xdl030112.github.io/categories/public/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://xdl030112.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"CS Academy Round 3 简要题解","slug":"CS3","date":"2020-01-09T07:36:56.000Z","updated":"2020-01-09T07:42:18.510Z","comments":true,"path":"CS3/","link":"","permalink":"http://xdl030112.github.io/CS3/","excerpt":"","text":"&#x4ED7;&#x7740;&#x9898;&#x7B80;&#x5355;&#x7EC8;&#x4E8E;&#x5728; vp &#x7684;&#x65F6;&#x5019;&#x963F;&#x514B;&#x4E86;&#x4E00;&#x6B21;&#xFF08;&#x4E0D;&#x4EC5;&#x9898;&#x7B80;&#x5355;&#x8FD8;&#x53EA;&#x6709; 5 &#x9053;&#xFF0C;&#x5C31;&#x8FD9;&#x6837;&#x6211;&#x8FD8;&#x505A;&#x4E86;1h+ A &#x66B4;&#x529B;&#x5373;&#x53EF;&#xFF0C;&#x4E3A;&#x5565;&#x4E0D;&#x9650;&#x5236;&#x6210; O(n) &#x7684;&#xFF1F;&#xFF1F;&#xFF1F; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly;#define pb push_back#define fi first#define se secondconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() { int ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline ll readl() { ll ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s) { int top=0; char ch=gc(); while(!isalpha(ch)) ch=gc(); while(isalpha(ch)) s[++top]=ch,ch=gc(); return top;}namespace modular { const int mod=998244353; inline int add(int a,int b) { return a+b&lt;mod?a+b:a+b-mod; } inline int dec(int a,int b) { return a&lt;b?a-b+mod:a-b; } inline int mul(int a,int b) { return (ll)a*b%mod; } inline void Add(int&amp;a,int b) { a=a+b&lt;mod?a+b:a+b-mod; } inline void Dec(int&amp;a,int b) { a=a&lt;b?a-b+mod:a-b; } inline void Mul(int&amp;a,int b) { a=(ll)a*b%mod; } inline int ksm(int a,int p) { int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; } inline int Inv(int a) { return ksm(a,mod-2); }}using namespace modular;const int N=5005;int n,a[N];int main() { #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(); int mx=0,len=0x3f3f3f3f; for(ri i=1;i&lt;=n;++i) { a[i]=read(); for(ri j=1;j&lt;=i;++j) { if(max(a[i],a[j])-min(a[i],a[j])&gt;mx) mx=max(a[i],a[j])-min(a[i],a[j]),len=i-j+1; else if(max(a[i],a[j])-min(a[i],a[j])==mx) len=min(len,i-j+1); } } cout&lt;&lt;len; return 0;} B sort &#x4E4B;&#x540E; dp &#x4E00;&#x4E0B; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly;#define pb push_back#define fi first#define se secondconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() { int ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline ll readl() { ll ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s) { int top=0; char ch=gc(); while(!isalpha(ch)) ch=gc(); while(isalpha(ch)) s[++top]=ch,ch=gc(); return top;}namespace modular { const int mod=998244353; inline int add(int a,int b) { return a+b&lt;mod?a+b:a+b-mod; } inline int dec(int a,int b) { return a&lt;b?a-b+mod:a-b; } inline int mul(int a,int b) { return (ll)a*b%mod; } inline void Add(int&amp;a,int b) { a=a+b&lt;mod?a+b:a+b-mod; } inline void Dec(int&amp;a,int b) { a=a&lt;b?a-b+mod:a-b; } inline void Mul(int&amp;a,int b) { a=(ll)a*b%mod; } inline int ksm(int a,int p) { int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; } inline int Inv(int a) { return ksm(a,mod-2); }}using namespace modular;const int N=2005;int n,a[N],f[N];int main() { #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(); for(ri i=1;i&lt;=n;++i) a[i]=read(); sort(a+1,a+n+1); int res=0; for(ri i=1;i&lt;=n;++i) { f[i]=1; for(ri j=1;j&lt;i;++j) if(a[i]%a[j]==0) f[i]=max(f[i],f[j]+1); res=max(res,f[i]); } cout&lt;&lt;res; return 0;} C &#x8003;&#x8651;&#x6700;&#x4F18;&#x503C;&#x4E00;&#x5B9A;&#x5728;&#x7AEF;&#x70B9;&#x53EF;&#x4EE5;&#x53D6;&#xFF0C;&#x90A3;&#x4E48;&#x679A;&#x4E3E;&#x7AEF;&#x70B9;&#x5373;&#x53EF; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly;#define pb push_back#define fi first#define se secondconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() { int ans=0; char ch=gc(); bool f=1; while(!isdigit(ch)) f^=ch==&apos;-&apos;,ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;}inline ll readl() { ll ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s) { int top=0; char ch=gc(); while(!isalpha(ch)) ch=gc(); while(isalpha(ch)) s[++top]=ch,ch=gc(); return top;}namespace modular { const int mod=998244353; inline int add(int a,int b) { return a+b&lt;mod?a+b:a+b-mod; } inline int dec(int a,int b) { return a&lt;b?a-b+mod:a-b; } inline int mul(int a,int b) { return (ll)a*b%mod; } inline void Add(int&amp;a,int b) { a=a+b&lt;mod?a+b:a+b-mod; } inline void Dec(int&amp;a,int b) { a=a&lt;b?a-b+mod:a-b; } inline void Mul(int&amp;a,int b) { a=(ll)a*b%mod; } inline int ksm(int a,int p) { int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; } inline int Inv(int a) { return ksm(a,mod-2); }}using namespace modular;const int N=1e5+5;int n,vl1[N],vl2[N],s1=0,s2=0,ct1[N],ct2[N];ll S1[N],S2[N];pii a[N];inline int find1(int x) { return lower_bound(vl1+1,vl1+s1+1,x)-vl1; }inline int find2(int x) { return lower_bound(vl2+1,vl2+s2+1,x)-vl2; }inline ll calc(int x) { int ps=find1(-x); if(vl1[ps]&gt;-x) --ps; ll res=-(ll)x*ct1[ps]-S1[ps]; ps=find2(x); if(vl2[ps]&gt;x) --ps; return res+(ll)x*ct2[ps]-S2[ps];}int main() { #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(); for(ri i=1;i&lt;=n;++i) { vl1[++s1]=-(a[i].fi=read()); vl2[++s2]=a[i].se=read(); } sort(vl1+1,vl1+s1+1),s1=unique(vl1+1,vl1+s1+1)-vl1-1; sort(vl2+1,vl2+s2+1),s2=unique(vl2+1,vl2+s2+1)-vl2-1; for(ri i=1,ps;i&lt;=n;++i) { ps=find1(-a[i].fi); ++ct1[ps],S1[ps]-=a[i].fi; ps=find2(a[i].se); ++ct2[ps],S2[ps]+=a[i].se; } for(ri i=1;i&lt;=s1;++i) ct1[i]+=ct1[i-1],S1[i]+=S1[i-1]; for(ri i=1;i&lt;=s2;++i) ct2[i]+=ct2[i-1],S2[i]+=S2[i-1]; ll res=1e18; for(ri i=1;i&lt;=n;++i) res=min(res,calc(a[i].fi)),res=min(res,calc(a[i].se)); cout&lt;&lt;res; return 0;} D &#x6253;&#x8868;&#x53D1;&#x73B0; SG &#x51FD;&#x6570;&#x5C31;&#x662F; sgi=isg_i=isgi&#x200B;=i &#xFF0C;&#x5F02;&#x6216;&#x4E00;&#x4E0B;&#x7B54;&#x6848;&#x7684; SG &#x51FD;&#x6570;&#x5373;&#x53EF; CODE cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly;#define pb push_back#define fi first#define se secondconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() { int ans=0; char ch=gc(); bool f=1; while(!isdigit(ch)) f^=ch==&apos;-&apos;,ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;}inline ll readl() { ll ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s) { int top=0; char ch=gc(); while(!isalpha(ch)) ch=gc(); while(isalpha(ch)) s[++top]=ch,ch=gc(); return top;}namespace modular { const int mod=998244353; inline int add(int a,int b) { return a+b&lt;mod?a+b:a+b-mod; } inline int dec(int a,int b) { return a&lt;b?a-b+mod:a-b; } inline int mul(int a,int b) { return (ll)a*b%mod; } inline void Add(int&amp;a,int b) { a=a+b&lt;mod?a+b:a+b-mod; } inline void Dec(int&amp;a,int b) { a=a&lt;b?a-b+mod:a-b; } inline void Mul(int&amp;a,int b) { a=(ll)a*b%mod; } inline int ksm(int a,int p) { int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; } inline int Inv(int a) { return ksm(a,mod-2); }}using namespace modular;const int N=1e5+5;int n;char s[N];int main() { #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=Read(s); int res=0,ct=0; int len=0; for(ri i=1;i&lt;=n;++i) { if(s[i]==&apos;A&apos;) ++ct,res^=len,len=0; else ++len; } res^=len; if(ct&amp;1) return puts(res?&quot;A&quot;:&quot;B&quot;),0; puts(&quot;-1&quot;); return 0;} E &#x679A;&#x4E3E;&#x4E24;&#x79CD;&#x60C5;&#x51B5;&#xFF0C;&#x7136;&#x540E;&#x6811;&#x5F62;&#x8D2A;&#x5FC3;&#x5339;&#x914D;&#x5C31;&#x884C;&#xFF0C;&#x6CE8;&#x610F;&#x4E00;&#x6761;&#x94FE;&#x7684;&#x8D21;&#x732E;&#x662F;&#x94FE;&#x4E0A;&#x7684;&#x8FB9;&#x6570; CODE cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly;#define pb push_back#define fi first#define se secondconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() { int ans=0; char ch=gc(); bool f=1; while(!isdigit(ch)) f^=ch==&apos;-&apos;,ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;}inline ll readl() { ll ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s) { int top=0; char ch=gc(); while(!isalpha(ch)) ch=gc(); while(isalpha(ch)) s[++top]=ch,ch=gc(); return top;}namespace modular { const int mod=998244353; inline int add(int a,int b) { return a+b&lt;mod?a+b:a+b-mod; } inline int dec(int a,int b) { return a&lt;b?a-b+mod:a-b; } inline int mul(int a,int b) { return (ll)a*b%mod; } inline void Add(int&amp;a,int b) { a=a+b&lt;mod?a+b:a+b-mod; } inline void Dec(int&amp;a,int b) { a=a&lt;b?a-b+mod:a-b; } inline void Mul(int&amp;a,int b) { a=(ll)a*b%mod; } inline int ksm(int a,int p) { int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; } inline int Inv(int a) { return ksm(a,mod-2); }}using namespace modular;const int N=1e5+5;const ll inf=1e18;int n,ct[N][2];int a[N];ll sum=0,res=inf;vector&lt;int&gt;e[N];char s[N];void dfs(int p,int ft,int col) { ct[p][0]=ct[p][1]=0; a[p]=s[p]==&apos;B&apos;; if(col!=a[p]) ++ct[p][col]; for(ri i=0,v;i&lt;(int)e[p].size();++i) { if((v=e[p][i])==ft) continue; dfs(v,p,col^1); ct[p][0]+=ct[v][0]; ct[p][1]+=ct[v][1]; } if(p==1&amp;&amp;ct[p][0]!=ct[p][1]) return; int mx=max(ct[p][0],ct[p][1]),mn=min(ct[p][0],ct[p][1]); ct[p][0]-=mn,ct[p][1]-=mn; sum+=(mx-mn); if(p==1) res=min(res,sum);}int main() { #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(); Read(s); for(ri i=1,u,v;i&lt;n;++i) { u=read(),v=read(); e[u].pb(v),e[v].pb(u); } sum=0; dfs(1,0,0); sum=0; dfs(1,0,1); cout&lt;&lt;(res==inf?-1:res); return 0;}","categories":[{"name":"public","slug":"public","permalink":"http://xdl030112.github.io/categories/public/"}],"tags":[{"name":"比赛题解","slug":"比赛题解","permalink":"http://xdl030112.github.io/tags/%E6%AF%94%E8%B5%9B%E9%A2%98%E8%A7%A3/"}]},{"title":"杂题乱做 Round14","slug":"sol14","date":"2020-01-03T04:00:14.000Z","updated":"2020-01-03T04:33:14.812Z","comments":true,"path":"sol14/","link":"","permalink":"http://xdl030112.github.io/sol14/","excerpt":"","text":"Jzzhu and Numbers &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x8003;&#x8651;&#x5148;&#x628A;&#x539F;&#x5E8F;&#x5217;&#x7ED9; fmt &#xFF0C;&#x7136;&#x540E;&#x53D1;&#x73B0;&#x5B9E;&#x9645;&#x4E0A;&#x6BCF;&#x4E00;&#x4F4D;&#x7684;&#x70B9;&#x503C;&#x5E94;&#x8BE5;&#x662F; 2ai2^{a_i}2ai&#x200B; &#xFF0C;&#x8FD8;&#x539F;&#x4E4B;&#x540E;&#x518D; ifmt &#x56DE;&#x53BB;&#x5373;&#x53EF; CODE cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef vector&lt;int&gt; poly;typedef pair&lt;int,int&gt; pii;#define fi first#define se second#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() { int ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}namespace modular { const int mod=1e9+7; inline int add(int a,int b) { return a+b&lt;mod?a+b:a+b-mod; } inline int dec(int a,int b) { return a&lt;b?a-b+mod:a-b; } inline int mul(int a,int b) { return (ll)a*b%mod; } inline void Add(int&amp;a,int b) { a=a+b&lt;mod?a+b:a+b-mod; } inline void Dec(int&amp;a,int b) { a=a&lt;b?a-b+mod:a-b; } inline void Mul(int&amp;a,int b) { a=(ll)a*b%mod; } inline int ksm(int a,int p) { int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; } inline int Inv(int a) { return ksm(a,mod-2); }}using namespace modular;const int N=2e6+5;int n,a[N],lim,mx=0,pw[N];int main() { #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(),pw[0]=1; for(ri i=1,x;i&lt;=n;++i) ++a[x=read()],mx=max(mx,x),pw[i]=add(pw[i-1],pw[i-1]); lim=1; while(lim&lt;=mx) lim&lt;&lt;=1; for(ri i=1;i&lt;lim;i&lt;&lt;=1) for(ri j=0;j&lt;lim;j+=i&lt;&lt;1) for(ri k=0;k&lt;i;++k) a[j+k]+=a[j+k+i]; for(ri i=0;i&lt;lim;++i) a[i]=pw[a[i]]; for(ri i=1;i&lt;lim;i&lt;&lt;=1) for(ri j=0;j&lt;lim;j+=i&lt;&lt;1) for(ri k=0;k&lt;i;++k) Dec(a[j+k],a[j+k+i]); cout&lt;&lt;a[0]-(a[0]==pw[n]); return 0;} Colored Forests &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x9996;&#x5148;&#x6C42;&#x51FA;&#x6811;&#x7684;&#x65B9;&#x6848;&#x6570;&#x7136;&#x540E; exp &#x4E00;&#x4E0B;&#x5C31;&#x662F;&#x68EE;&#x6797;&#x7684;&#x65B9;&#x6848;&#x6570;&#xFF0C;&#x8003;&#x8651;&#x600E;&#x4E48;&#x9012;&#x63A8;&#x6811;&#x7684;&#x65B9;&#x6848;&#x6570;&#xFF0C;&#x8BBE; fi,jf_{i,j}fi,j&#x200B; &#x8868;&#x793A; iii &#x4E2A;&#x70B9;&#x7684;&#x5E8F;&#x5217;&#x67D3; jjj &#x79CD;&#x989C;&#x8272;&#x65B9;&#x6848;&#x6570;&#xFF0C;&#x663E;&#x7136;&#x6709; fi,j=j(fi&#x2212;1,j&#x2212;1+fi&#x2212;1,j)f_{i,j}=j(f_{i-1,j-1}+f_{i-1,j})fi,j&#x200B;=j(fi&#x2212;1,j&#x2212;1&#x200B;+fi&#x2212;1,j&#x200B;) &#xFF0C;&#x90A3;&#x4E48;&#x76F4;&#x63A5;&#x66B4;&#x529B;&#x9012;&#x63A8;&#x5373;&#x53EF;&#xFF0C;&#x4E0D;&#x8FC7;&#x5982;&#x679C;&#x7EE7;&#x7EED;&#x89C2;&#x5BDF;&#x53EF;&#x4EE5;&#x53D1;&#x73B0;&#x8FD9;&#x4E2A; fi,j=Si,jj!f_{i,j}=\\frac{S_{i,j}}{j!}fi,j&#x200B;=j!Si,j&#x200B;&#x200B; &#xFF0C;&#x56E0;&#x6B64;&#x751F;&#x6210;&#x7684;&#x6811;&#x7684;&#x65B9;&#x6848;&#x6570;&#x5C31;&#x7B49;&#x4E8E; Si,jj!ii&#x2212;2\\frac{S_{i,j}}{j!}i^{i-2}j!Si,j&#x200B;&#x200B;ii&#x2212;2 &#xFF0C;&#xFF08;&#x597D;&#x7684;&#x53EF;&#x4EE5;&#x52A0;&#x5F3A;&#x6210;&#x9884;&#x5904;&#x7406;&#x65AF;&#x7279;&#x6797;&#x6570;+&#x591A;&#x9879;&#x5F0F; exp &#x5927;&#x677F;&#x9898;&#x4E86;&#xFF09; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef vector&lt;int&gt; poly;#define pb push_backnamespace modular { const int mod=924844033; inline int add(int a,int b) { return a+b&lt;mod?a+b:a+b-mod; } inline int dec(int a,int b) { return a&lt;b?a-b+mod:a-b; } inline int mul(int a,int b) { return (ll)a*b%mod; } inline void Add(int&amp;a,int b) { a=a+b&lt;mod?a+b:a+b-mod; } inline void Dec(int&amp;a,int b) { a=a&lt;b?a-b+mod:a-b; } inline void Mul(int&amp;a,int b) { a=(ll)a*b%mod; } inline int ksm(int a,int p) { int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; } inline int Inv(int a) { return ksm(a,mod-2); }}using namespace modular;int invv[21],inv[1&lt;&lt;20],lim,tim;vector&lt;int&gt;w[21],rev[21];inline void init_ntt() { invv[0]=1; for(ri i=1,iv=mod+1&gt;&gt;1;i&lt;21;++i) invv[i]=mul(invv[i-1],iv); inv[1]=1; for(ri i=2,up=1&lt;&lt;20;i&lt;up;++i) inv[i]=mul(inv[mod-mod/i*i],mod-mod/i); w[20].resize(1&lt;&lt;20),w[20][0]=1,w[20][1]=ksm(5,(mod-1)&gt;&gt;21); for(ri i=2,up=1&lt;&lt;20;i&lt;up;++i) w[20][i]=mul(w[20][i-1],w[20][1]); for(ri i=19;~i;--i) { w[i].resize(1&lt;&lt;i); for(ri j=0,up=1&lt;&lt;i;j&lt;up;++j) w[i][j]=w[i+1][j&lt;&lt;1]; }}inline void init(int up) { lim=1,tim=0; while(lim&lt;up) lim&lt;&lt;=1,++tim; if(rev[tim].size()) return; rev[tim].resize(lim); for(ri i=1;i&lt;lim;++i) rev[tim][i]=(rev[tim][i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(tim-1));}inline void ntt(poly&amp;a,int typ) { for(ri i=1;i&lt;lim;++i) if(i&lt;rev[tim][i]) swap(a[i],a[rev[tim][i]]); for(ri i=1,a0,a1,t=0;i&lt;lim;i&lt;&lt;=1,++t) for(ri j=0;j&lt;lim;j+=i&lt;&lt;1) for(ri k=0;k&lt;i;++k) { a0=a[j+k],a1=mul(a[j+k+i],w[t][k]); a[j+k]=add(a0,a1),a[j+k+i]=dec(a0,a1); } if(~typ) return; reverse(++a.begin(),a.end()); for(ri i=0;i&lt;lim;++i) Mul(a[i],invv[tim]);}inline poly operator*(poly a,poly b) { int n=(int)a.size(),m=(int)b.size(),t=n+m-1; if(t&lt;=128) { poly c(t); for(ri i=0;i&lt;n;++i) if(a[i]) for(ri j=0;j&lt;m;++j) Add(c[i+j],mul(a[i],b[j])); return c; } init(t); a.resize(lim),ntt(a,1); b.resize(lim),ntt(b,1); for(ri i=0;i&lt;lim;++i) Mul(a[i],b[i]); return ntt(a,-1),a.resize(t),a;}inline poly operator-(poly a,poly b) { int n=(int)b.size(); if((int)a.size()&lt;n) a.resize(n); for(ri i=0;i&lt;n;++i) Dec(a[i],b[i]); return a;}inline poly poly_inv(poly a,int K) { poly b(1,Inv(a[0])),c; for(ri i=1;i&lt;K;i&lt;&lt;=1) { init(i*3); c=a,c.resize(i&lt;&lt;1),c.resize(lim),ntt(c,1); b.resize(lim),ntt(b,1); for(ri j=0;j&lt;lim;++j) Mul(b[j],dec(2,mul(b[j],c[j]))); ntt(b,-1),b.resize(i&lt;&lt;1); } return b.resize(K),b;}inline poly poly_integ(poly a) { a.pb(0); for(ri i=(int)a.size()-1;i;--i) a[i]=mul(inv[i],a[i-1]); return a[0]=0,a;}inline poly poly_deriv(poly a) { for(ri i=1,up=(int)a.size();i&lt;up;++i) a[i-1]=mul(a[i],i); return a.pop_back(),a;}inline poly poly_ln(poly a,int K) { return a=poly_inv(a,K)*poly_deriv(a),a.resize(K-1),poly_integ(a); }inline poly poly_exp(poly a,int K) { poly b(1,1),c; for(ri i=1;i&lt;K;i&lt;&lt;=1) { c=a,c.resize(i&lt;&lt;1),Add(c[0],1); b=b*(c-poly_ln(b,i&lt;&lt;1)),b.resize(i&lt;&lt;1); } return b.resize(K),b;}const int N=1e5+5;int fac[N],ifac[N],n,m,f[N][55];inline void init() { fac[0]=fac[1]=ifac[0]=ifac[1]=1; for(ri i=2;i&lt;=n;++i) { fac[i]=mul(fac[i-1],i); ifac[i]=mul(ifac[i-1],inv[i]); } f[0][0]=1; for(ri i=1;i&lt;=n;++i) for(ri j=1;j&lt;=i&amp;&amp;j&lt;=m;++j) f[i][j]=mul(j,add(f[i-1][j-1],f[i-1][j]));}int main() { #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif cin&gt;&gt;n&gt;&gt;m; init_ntt(); init(); poly F(n+1); for(ri i=1;i&lt;=n;++i) F[i]=mul(ifac[i],mul(f[i][m],i==1?1:ksm(i,i-2))); F=poly_exp(F,n+1); for(ri i=1;i&lt;=n;++i) cout&lt;&lt;mul(F[i],fac[i])&lt;&lt;&apos;\\n&apos;; return 0;} Tree Game &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x8003;&#x8651;&#x8BBE; fi,0/1/2f_{i,0/1/2}fi,0/1/2&#x200B; &#x8868;&#x793A;&#x5982;&#x4E0B;&#x4E09;&#x79CD;&#x72B6;&#x6001;&#xFF1A; &#x6811;&#x6839; i &#x653E;&#x7F6E; B &#x7C7B;&#x70B9; &#x6811;&#x6839; i &#x653E;&#x7F6E; A &#x7C7B;&#x70B9; &#x6811;&#x6839; i &#x6682;&#x65F6;&#x4E0D;&#x653E;&#x7F6E;&#x70B9;&#xFF0C;&#x6700;&#x591A;&#x6709;&#x4E00;&#x4E2A; i &#x5B50;&#x6811;&#x5185;&#x7684; A &#x7C7B;&#x70B9;&#x5230; i &#x7684;&#x8DEF;&#x5F84;&#x4E0A;&#x6CA1;&#x6709; B &#x7C7B;&#x70B9; &#x7136;&#x540E;&#x8F6C;&#x79FB;&#x7684;&#x65F6;&#x5019;&#x8981;&#x8003;&#x8651;&#x600E;&#x6837;&#x505A; B &#x662F;&#x6700;&#x4F18;&#x7684; CODE cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() { int ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}const int N=1e5+5,inf=1e9;int n,f[N][3];vector&lt;int&gt;e[N];void dfs(int p,int ft) { int s1=0,s2=0,mn1=inf,mn2=inf; for(ri i=0,v;i&lt;(int)e[p].size();++i) { if((v=e[p][i])==ft) continue; dfs(v,p); f[p][1]+=max(f[v][0],f[v][2]+1); int dt=max(max(f[v][0],f[v][1]),f[v][2])-max(f[v][1],f[v][2]); if(mn1&gt;dt) mn2=mn1,mn1=dt; else if(mn2&gt;dt) mn2=dt; s1+=max(max(f[v][0],f[v][1]),f[v][2]); s2+=f[v][0]; } f[p][2]=-inf; for(ri i=0,v;i&lt;(int)e[p].size();++i) { if((v=e[p][i])==ft) continue; f[p][2]=max(f[p][2],s2-f[v][0]+max(f[v][1],f[v][2])); } f[p][0]=max(s1-mn1-mn2+1,s2);}int main() { #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(); for(ri i=1,u,v;i&lt;n;++i) { u=read(),v=read(); e[u].pb(v),e[v].pb(u); } dfs(1,0); cout&lt;&lt;max(f[1][0],f[1][1]); return 0;} Matrix Coloring &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x8DDF;&#x6211;&#x4E4B;&#x524D;&#x505A;&#x8FC7;&#x7684;&#x4E00;&#x9053;&#x9898;&#x5F88;&#x50CF;&#xFF0C;&#x4F46;&#x7528;&#x6211;&#x4E4B;&#x524D;&#x7684;&#x8FA3;&#x9E21;&#x505A;&#x6CD5;&#x4F1A; TLE &#x4E8E;&#x662F;&#x5B66;&#x4E86;&#x4E00;&#x4E0B;&#x6807;&#x7B97; &#x5927;&#x6982;&#x662F;&#x53D1;&#x73B0;&#x5982;&#x679C;&#x65B9;&#x6848;&#x5408;&#x6CD5;&#x7684;&#x8BDD;&#x6700;&#x591A;&#x67D3;&#x8272; n+m&#x2212;1n+m-1n+m&#x2212;1 &#x6B21;&#xFF0C;&#x6709;&#x4E00;&#x884C;/&#x4E00;&#x5217;&#x53EF;&#x4EE5;&#x5F3A;&#x5236;&#x4E00;&#x76F4;&#x4E0D;&#x67D3;&#x8272;&#xFF0C;&#x7136;&#x540E;&#x53EF;&#x4EE5;&#x4F9D;&#x6B21;&#x5EFA;&#x51FA;&#x4E00;&#x4E2A;&#x884C;&#x5217;&#x95F4;&#x7684; topsort &#x5173;&#x7CFB;&#xFF0C;&#x8FD9;&#x6837;&#x7684;&#x8BDD;&#x53EF;&#x4EE5;&#x8BA9;&#x6240;&#x6709;&#x8DDF;&#x5F53;&#x524D;&#x94A6;&#x5B9A;&#x884C;/&#x5217;&#x76F8;&#x540C;&#x7684;&#x884C;/&#x5217;&#x4E5F;&#x4E0D;&#x8FDB;&#x884C;&#x64CD;&#x4F5C;&#xFF0C;&#x4E8E;&#x662F;&#x6700;&#x5C0F;&#x65B9;&#x6848;&#x6570;=n+m-&#x76F8;&#x540C;&#x884C;/&#x5217;&#x6700;&#x5927;&#x503C; CODE cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline void read(int*a) { int top=0; char ch=gc(); while(!isalpha(ch)) ch=gc(); while(isalpha(ch)) a[++top]=ch==&apos;R&apos;?1:2,ch=gc();}const int N=3005;int n,res=0,m,a[N][N];map&lt;vector&lt;int&gt;,int&gt;cnt;int main() { #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif cin&gt;&gt;n&gt;&gt;m; for(ri i=1;i&lt;=n;++i) read(a[i]); vector&lt;int&gt;psx,psy,nx,ny; for(ri i=1;i&lt;=n;++i) psx.pb(i); for(ri i=1;i&lt;=m;++i) psy.pb(i); while((int)psx.size()&amp;&amp;(int)psy.size()) { nx.resize(0),ny.resize(0); bool chg=0; for(ri i=0;i&lt;(int)psx.size();++i) { bool ff=1; for(ri j=0,t=-1;j&lt;(int)psy.size();++j) { if(~t&amp;&amp;a[psx[i]][psy[j]]!=t) { ff=0; break; } t=a[psx[i]][psy[j]]; } if(ff) chg=1; else nx.pb(psx[i]); } for(ri i=0;i&lt;(int)psy.size();++i) { bool ff=1; for(ri j=0,t=-1;j&lt;(int)psx.size();++j) { if(~t&amp;&amp;a[psx[j]][psy[i]]!=t) { ff=0; break; } t=a[psx[j]][psy[i]]; } if(ff) chg=1; else ny.pb(psy[i]); } if(!chg) return puts(&quot;-1&quot;),0; psx=nx,psy=ny; } vector&lt;int&gt;tmp; int mx1=0,mx2=0; for(ri i=1;i&lt;=n;++i) { tmp.clear(); for(ri j=1;j&lt;=m;++j) tmp.pb(a[i][j]); mx1=max(mx1,++cnt[tmp]); } for(ri i=1;i&lt;=m;++i) { tmp.clear(); for(ri j=1;j&lt;=n;++j) tmp.pb(a[j][i]); mx2=max(mx2,++cnt[tmp]); } cout&lt;&lt;n+m-max(mx1,mx2); return 0;} Jetpack &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x8003;&#x8651;&#x8BBE; fif_ifi&#x200B; &#x8868;&#x793A;&#x4ECE; (0,0)(0,0)(0,0) &#x51FA;&#x53D1;&#xFF0C;&#x6700;&#x540E;&#x4E00;&#x6B65;&#x662F;&#x901A;&#x8FC7; fi&#x2212;1,1f_{i-1,1}fi&#x2212;1,1&#x200B; &#x8D70;&#x5230; (i,0)(i,0)(i,0) &#x7684;&#x65B9;&#x6848;&#x6570;&#xFF0C;&#x8BB0; Sumn=&#x2211;i=0nfiSum_n=\\sum\\limits_{i=0}^nf_{i}Sumn&#x200B;=i=0&#x2211;n&#x200B;fi&#x200B; &#xFF0C;&#x90A3;&#x4E48; Sum(i)Sum(i)Sum(i) &#x8868;&#x793A;&#x4ECE; (0,0)(0,0)(0,0) &#x5230; (i,0)(i,0)(i,0) &#x7684;&#x65B9;&#x6848;&#x6570;&#xFF0C;&#x8FD9;&#x6837;&#x7684;&#x8BDD;&#x6211;&#x4EEC;&#x679A;&#x4E3E;&#x4E0A;&#x4E00;&#x6B21;&#x7740;&#x9646;&#x70B9;&#x8DDD;&#x79BB; iii &#x70B9;&#x7684;&#x8DDD;&#x79BB; jjj &#xFF0C;&#x663E;&#x7136; fi=&#x2211;j=0ngjsumi&#x2212;jf_{i}=\\sum\\limits_{j=0}^ng_jsum_{i-j}fi&#x200B;=j=0&#x2211;n&#x200B;gj&#x200B;sumi&#x2212;j&#x200B; &#xFF0C;&#x5BB9;&#x6613;&#x5F97;&#x5230;&#x7CFB;&#x6570; gi=[i&#x4E3A;&#x5076;&#x6570;&#x4E14;i&#x2265;K]Cat(i/2&#x2212;1)g_i=[i&#x4E3A;&#x5076;&#x6570;&#x4E14;i\\ge K]Cat(i/2-1)gi&#x200B;=[i&#x4E3A;&#x5076;&#x6570;&#x4E14;i&#x2265;K]Cat(i/2&#x2212;1) &#x7136;&#x540E;&#x5206;&#x6CBB; nttnttntt &#x4F18;&#x5316;&#x5373;&#x53EF; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef vector&lt;int&gt; poly;#define pb push_backstruct cp { double x,y; cp(double x=0,double y=0):x(x),y(y) {} friend inline cp operator+(cp a,cp b) { return cp(a.x+b.x,a.y+b.y); } friend inline void operator+=(cp&amp;a,cp b) { a=a+b; } friend inline cp operator-(cp a,cp b) { return cp(a.x-b.x,a.y-b.y); } friend inline void operator-=(cp&amp;a,cp b) { a=a-b; } friend inline cp operator*(cp a,cp b) { return cp(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x); } friend inline void operator*=(cp&amp;a,cp b) { a=a*b; } friend inline cp operator*(cp a,double b) { return cp(a.x*b,a.y*b); } friend inline void operator*=(cp&amp;a,double b) { a=a*b; } friend inline cp operator/(cp a,double b) { return cp(a.x/b,a.y/b); } friend inline void operator/=(cp&amp;a,double b) { a=a/b; } inline cp operator~() const { return cp(x,-y); }};namespace modular { const int mod=1e9+7; inline int add(int a,int b) { return a+b&lt;mod?a+b:a+b-mod; } inline int dec(int a,int b) { return a&lt;b?a-b+mod:a-b; } inline int mul(int a,int b) { return (ll)a*b%mod; } inline void Add(int&amp;a,int b) { a=a+b&lt;mod?a+b:a+b-mod; } inline void Dec(int&amp;a,int b) { a=a&lt;b?a-b+mod:a-b; } inline void Mul(int&amp;a,int b) { a=(ll)a*b%mod; }}using namespace modular;const int blo=(1&lt;&lt;15)-1;typedef vector&lt;cp&gt; moly;int lim,tim,inv[1&lt;&lt;20];vector&lt;int&gt;rev[21];vector&lt;cp&gt;w[21];const double pi=acos(-1.0);inline void init_fft() { inv[1]=1; w[20].resize(1&lt;&lt;20),w[20][0]=cp(1,0),w[20][1]=cp(cos(pi/(1&lt;&lt;20)),sin(pi/(1&lt;&lt;20))); for(ri i=2,up=1&lt;&lt;20;i&lt;up;++i) { w[20][i]=cp(cos(pi/up*i),sin(pi/up*i)); inv[i]=mul(inv[mod-mod/i*i],mod-mod/i); } for(ri i=19;~i;--i) { w[i].resize(1&lt;&lt;i); for(ri j=0,up=1&lt;&lt;i;j&lt;up;++j) w[i][j]=w[i+1][j&lt;&lt;1]; }}inline void init(int up) { lim=1,tim=0; while(lim&lt;up) lim&lt;&lt;=1,++tim; if(rev[tim].size()) return; rev[tim].resize(lim); for(ri i=1;i&lt;lim;++i) rev[tim][i]=(rev[tim][i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(tim-1));}inline void fft(moly&amp;a,int typ) { for(ri i=1;i&lt;lim;++i) if(i&lt;rev[tim][i]) swap(a[i],a[rev[tim][i]]); cp a0,a1; for(ri i=1,t=0;i&lt;lim;i&lt;&lt;=1,++t) for(ri j=0;j&lt;lim;j+=i&lt;&lt;1) for(ri k=0;k&lt;i;++k) { a0=a[j+k],a1=a[j+k+i]*w[t][k]; a[j+k]=a0+a1,a[j+k+i]=a0-a1; } if(~typ) return; reverse(++a.begin(),a.end()); for(ri i=0;i&lt;lim;++i) a[i]/=lim;}inline poly poly_mul(poly a,poly b){ int n=(int)a.size(),m=(int)b.size(),t=n+m-1; poly c(t); init(t); moly P(lim),Q(lim),A(lim),B(lim); for(ri i=0;i&lt;n;++i) P[i]=cp(a[i]&gt;&gt;15,a[i]&amp;blo); for(ri i=0;i&lt;m;++i) Q[i]=cp(b[i]&gt;&gt;15,b[i]&amp;blo); fft(P,1),fft(Q,1); cp cur[4]; for(ri i=0,j=0;i&lt;lim;++i,j=j?j-1:lim-1) { cur[0]=(P[i]+(~P[j]))*cp(0.5,0); cur[1]=((~P[j])-P[i])*cp(0,0.5); cur[2]=(Q[i]+(~Q[j]))*cp(0.5,0); cur[3]=((~Q[j])-Q[i])*cp(0,0.5); A[i]=cur[0]*cur[2]+cp(0,1)*cur[1]*cur[3]; B[i]=cur[0]*cur[3]+cp(0,1)*cur[1]*cur[2]; } fft(A,-1),fft(B,-1); ll cr[4]; for(ri i=0;i&lt;t;++i) { cr[0]=(ll)(A[i].x+0.5)%mod; cr[1]=(ll)(A[i].y+0.5)%mod; cr[2]=(ll)(B[i].x+0.5)%mod; cr[3]=(ll)(B[i].y+0.5)%mod; c[i]=((cr[0]&lt;&lt;30)+((cr[2]+cr[3])&lt;&lt;15)+cr[1])%mod; } return c;}inline poly operator*(poly a,poly b) { int n=(int)a.size(),m=(int)b.size(),t=n+m-1; if(t&lt;=128) { poly c(t); for(ri i=0;i&lt;n;++i) if(a[i]) for(ri j=0;j&lt;m;++j) Add(c[i+j],mul(a[i],b[j])); return c; } return poly_mul(a,b);}poly F,cat,Sum,a,b;const int N=2e5+5;int fac[N],ifac[N],n,K;inline void solve(int l,int r) { if(l==r) { Sum[l]=add(l?Sum[l-1]:0,F[l]); return; } int mid=l+r&gt;&gt;1; solve(l,mid); a.resize(mid-l+1),b.resize(r-l+1); for(ri i=l;i&lt;=mid;++i) a[i-l]=Sum[i]; for(ri i=0;i&lt;=r-l;++i) b[i]=cat[i]; a=a*b; for(ri i=mid+1;i&lt;=r;++i) Add(F[i],a[i-l]); solve(mid+1,r);}inline int C(int n,int m) { return n&lt;m||m&lt;0?0:mul(fac[n],mul(ifac[m],ifac[n-m])); }inline int calc(int n) { return mul(inv[n+1],C(n&lt;&lt;1,n)); }inline void init() { fac[0]=fac[1]=ifac[0]=ifac[1]=1; for(ri i=2;i&lt;=n;++i) { fac[i]=mul(fac[i-1],i); ifac[i]=mul(ifac[i-1],inv[i]); } cat.resize(n+1),Sum.resize(n+1),F.resize(n+1); K&lt;&lt;=1; for(ri i=2;i&lt;=K&amp;&amp;i&lt;=n;i+=2) cat[i]=calc((i&gt;&gt;1)-1);}int main() { #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif init_fft(); cin&gt;&gt;n&gt;&gt;K; init(); F[0]=1; solve(0,n); cout&lt;&lt;Sum[n]; return 0;} Sliding Product Sum &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x6765;&#x63D0;&#x4F9B;&#x4E00;&#x4E2A;&#x7206;&#x8E29;&#x6807;&#x7B97;&#x7684;&#x505A;&#x6CD5;&#xFF1A; Ans=&#x2211;i=1K&#x2211;x=1nxi&#x203E;=&#x2211;i=1K&#x2211;k=0iSs&#xA0;i,k&#x2211;x=1nxk\\begin{aligned} Ans=&amp;\\sum\\limits_{i=1}^K\\sum\\limits_{x=1}^nx^{\\underline i}\\\\ =&amp;\\sum\\limits_{i=1}^K\\sum\\limits_{k=0}^iS_{s\\ i,k}\\sum\\limits_{x=1}^nx^k \\end{aligned} Ans==&#x200B;i=1&#x2211;K&#x200B;x=1&#x2211;n&#x200B;xi&#x200B;i=1&#x2211;K&#x200B;k=0&#x2211;i&#x200B;Ss&#xA0;i,k&#x200B;x=1&#x2211;n&#x200B;xk&#x200B; &#x7136;&#x540E;&#x968F;&#x4FBF;&#x9884;&#x5904;&#x7406;&#x4E00;&#x4E0B;&#x5C31;&#x80FD;&#x8FC7;&#x4E86;&#xFF0C;&#x590D;&#x6742;&#x5EA6; O(K2)O(K^2)O(K2) CODE cpp1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;#define pb push_back#define fi first#define se secondconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)const int N=605;ll mod,n,s[N][N],S[N];int K;inline ll add(ll a,ll b) { return a+b&lt;mod?a+b:a+b-mod; }inline ll dec(ll a,ll b) { return a&lt;b?a-b+mod:a-b; }inline ll mul(ll a,ll b) { return a*b-(ll)((long double)a/mod*b+1e-8)*mod; }inline void init() { s[0][0]=1; for(ri i=1;i&lt;=K;++i) for(ri j=1;j&lt;=i;++j) s[i][j]=dec(s[i-1][j-1],mul(i-1,s[i-1][j])); S[1]=n&amp;1?mul((n+1&gt;&gt;1)%mod,n%mod):mul((n&gt;&gt;1)%mod,(n+1)%mod); for(ri k=2;k&lt;=K;++k) { S[k]=1; for(ri i=0;i&lt;k+1;++i) { if((ll)(n-i+1)%(k+1)==0) S[k]=mul(S[k],(n-i+1)/(k+1)%mod); else S[k]=mul(S[k],(n-i+1)%mod); } for(ri i=1;i&lt;k;++i) S[k]=dec(S[k],mul(S[i],s[k][i])); }}int main() { #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif cin&gt;&gt;n&gt;&gt;K&gt;&gt;mod; init(); ll res=0; for(ri i=1;i&lt;=K;++i) for(ri k=1;k&lt;=i;++k) res=add(res,mul(s[i][k],S[k])); cout&lt;&lt;res; return 0;} K-consecutive &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x505A;&#x4E24;&#x4E2A; dp &#x9996;&#x5148; dp &#x51FA; gi,jg_{i,j}gi,j&#x200B; &#x8868;&#x793A;&#x6EE1;&#x8DB3;&#x5F62;&#x5982; (x,x+1)(x,x+1)(x,x+1) &#x7684;&#x7A7A;&#x9699;&#x4E2A;&#x6570;&#x4E3A; jjj &#x7684; iii &#x4E2A;&#x6570;&#x7684;&#x6392;&#x5217;&#x6570; &#x7136;&#x540E;&#x518D; dp fi,jf_{i,j}fi,j&#x200B; &#x8868;&#x793A;&#x628A; iii &#x4E2A;&#x6570;&#x5206;&#x6210; jjj &#x7EC4;&#xFF0C;&#x6BCF;&#x7EC4;&#x4EBA;&#x6570;&#x4E0D;&#x8D85;&#x8FC7; KKK &#x7684;&#x65B9;&#x6848;&#x6570;&#xFF0C;&#x7136;&#x540E;&#x52A0;&#x4E00;&#x52A0;&#x5C31;&#x5B8C;&#x4E86; &#x4E0D;&#x4F1A;&#x4E0A;&#x8FF0; dp &#x7684;&#x53EF;&#x4EE5;&#x9000;&#x5F79;&#x4E86;&#xFF08; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;#define pb push_back#define fi first#define se secondnamespace modular { const int mod=1e9+7; inline int add(int a,int b) { return a+b&lt;mod?a+b:a+b-mod; } inline int dec(int a,int b) { return a&lt;b?a-b+mod:a-b; } inline int mul(int a,int b) { return (ll)a*b%mod; } inline void Add(int&amp;a,int b) { a=a+b&lt;mod?a+b:a+b-mod; } inline void Dec(int&amp;a,int b) { a=a&lt;b?a-b+mod:a-b; } inline void Mul(int&amp;a,int b) { a=(ll)a*b%mod; } inline int ksm(int a,int p) { int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; }}using namespace modular;const int N=5005;int cur,f[2][N],g[N][N],cr,ss[N],n,K;inline int query(int l,int r) { return dec(ss[r],ss[l-1]); }inline void init() { g[1][0]=1; for(ri i=1;i&lt;n;++i) { for(ri j=0;j&lt;=i;++j) if(g[i][j]) { Add(g[i+1][j+1],g[i][j]); Add(g[i+1][j-1],mul(g[i][j],j)); Add(g[i+1][j],mul(g[i][j],i-j)); } }}int main() { #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif cin&gt;&gt;n&gt;&gt;K; f[cur=0][0]=ss[0]=1; for(ri i=1;i&lt;=n;++i) ss[i]=1; init(); int res=0; for(ri i=1;i&lt;=n;++i) { cur^=1; for(ri j=1;j&lt;=n;++j) f[cur][j]=query(max(0,j-K),j-1); ss[0]=0; for(ri j=1;j&lt;=n;++j) ss[j]=add(ss[j-1],f[cur][j]); Add(res,mul(f[cur][n],g[i][0])); } cout&lt;&lt;res; return 0;}","categories":[{"name":"public","slug":"public","permalink":"http://xdl030112.github.io/categories/public/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://xdl030112.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"CS Academy Round 6 简要题解","slug":"CS6","date":"2020-01-03T00:42:08.000Z","updated":"2020-01-03T01:07:59.740Z","comments":true,"path":"CS6/","link":"","permalink":"http://xdl030112.github.io/CS6/","excerpt":"","text":"A &#x4E00;&#x9053;&#x7531;&#x4E8E;&#x6211;&#x8FC7;&#x4E8E;&#x6C99;&#x96D5;&#x8C03;&#x4E86;&#x5F88;&#x4E45;&#x7684;&#x6A21;&#x62DF;&#x9898; CODE cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef vector&lt;int&gt; poly;#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() { int ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}namespace modular { const int mod=1e9+7; inline int add(int a,int b) { return a+b&lt;mod?a+b:a+b-mod; } inline int dec(int a,int b) { return a&lt;b?a-b+mod:a-b; } inline int mul(int a,int b) { return (ll)a*b%mod; } inline void Add(int&amp;a,int b) { a=a+b&lt;mod?a+b:a+b-mod; } inline void Dec(int&amp;a,int b) { a=a&lt;b?a-b+mod:a-b; } inline void Mul(int&amp;a,int b) { a=(ll)a*b%mod; }}using namespace modular;const int N=1e5+5;int n,lens;bool okpre[N],oksuf[N];char s[N],t[N];int main() { #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif scanf(&quot;%d&quot;,&amp;n); scanf(&quot;%s&quot;,s+1),lens=strlen(s+1); int res=0; for(ri len,tt=1;tt&lt;=n;++tt) { scanf(&quot;%s&quot;,t+1); len=strlen(t+1); if(max(lens,len)-min(lens,len)&gt;1) continue; okpre[0]=oksuf[len+1]=1; for(ri i=1;i&lt;=len;++i) okpre[i]=oksuf[i]=0; for(ri i=1;i&lt;=len&amp;&amp;i&lt;=lens;++i) okpre[i]=okpre[i-1]&amp;&amp;(s[i]==t[i]); for(ri i=len,j=lens;i&amp;&amp;j;--i,--j) oksuf[i]=oksuf[i+1]&amp;&amp;(s[j]==t[i]); if(len==lens) { bool ff=0; for(ri i=1;i&lt;=len;++i) if(okpre[i-1]&amp;&amp;oksuf[i+1]) { ff=1; break; } if(ff) ++res; } else if(len==lens-1) { bool ff=0; for(ri i=1;i&lt;=len+1;++i) if(okpre[i-1]&amp;&amp;oksuf[i]) { ff=1; break; } if(ff) ++res; } else { bool ff=0; for(ri i=1;i&lt;=len;++i) if(okpre[i-1]&amp;&amp;oksuf[i+1]) { ff=1; break; } if(ff) ++res; } } cout&lt;&lt;res; return 0;} B &#x53CC;&#x6307;&#x9488;&#x626B;&#x4E00;&#x4E0B; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef vector&lt;int&gt; poly;#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() { int ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}namespace modular { const int mod=1e9+7; inline int add(int a,int b) { return a+b&lt;mod?a+b:a+b-mod; } inline int dec(int a,int b) { return a&lt;b?a-b+mod:a-b; } inline int mul(int a,int b) { return (ll)a*b%mod; } inline void Add(int&amp;a,int b) { a=a+b&lt;mod?a+b:a+b-mod; } inline void Dec(int&amp;a,int b) { a=a&lt;b?a-b+mod:a-b; } inline void Mul(int&amp;a,int b) { a=(ll)a*b%mod; }}using namespace modular;const int N=1e5+5;int n,k,ps[N];int main() { #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(),k=read(); for(ri i=1;i&lt;=n;++i) ps[i]=read(); sort(ps+1,ps+n+1); ps[++n]=0x3f3f3f3f; int res=0; for(ri pre=0,l=1,r=0;r&lt;=n;++l,pre-=ps[l]-ps[l-1]-1) { if(l&gt;r) { pre=0; r=l; } while(r&lt;n&amp;&amp;pre+ps[r+1]-ps[r]-1&lt;=k) ++r,pre+=ps[r]-ps[r-1]-1; res=max(res,ps[r]-ps[l]+1+(k-pre)); } cout&lt;&lt;res; return 0;} C &#x778E;&#x731C;&#x4E86;&#x4E00;&#x4E2A;&#x9519;&#x7684;&#x7ED3;&#x8BBA;&#x7ED3;&#x679C;&#x8FD8;&#x8FC7;&#x4E86; MD&#x7EDD;&#x4E86; &#x8FD9;&#x91CC;&#x653E;&#x4E00;&#x4E2A;&#x9519;&#x4E86;&#x7684;&#x4EE3;&#x7801; CODE cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef vector&lt;int&gt; poly;#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() { int ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}namespace modular { const int mod=1e9+7; inline int add(int a,int b) { return a+b&lt;mod?a+b:a+b-mod; } inline int dec(int a,int b) { return a&lt;b?a-b+mod:a-b; } inline int mul(int a,int b) { return (ll)a*b%mod; } inline void Add(int&amp;a,int b) { a=a+b&lt;mod?a+b:a+b-mod; } inline void Dec(int&amp;a,int b) { a=a&lt;b?a-b+mod:a-b; } inline void Mul(int&amp;a,int b) { a=(ll)a*b%mod; }}using namespace modular;const int N=1e5+5;int n,ct1,ct2,ss;int main() { #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif for(ri tt=read();tt;--tt) { n=read(); ct1=0,ct2=0,ss=0; for(ri i=1,x;i&lt;=n;++i) { if((x=read())==1) ++ct1; else ++ct2,ss^=x; } if(!ct2) cout&lt;&lt;(ct1&amp;1?&quot;A\\n&quot;:&quot;B\\n&quot;); else cout&lt;&lt;(ss?&quot;A\\n&quot;:&quot;B\\n&quot;); } return 0;} &#x7136;&#x540E;&#x6B63;&#x89E3;&#x5C31;&#x662F;&#x770B;&#x6709;&#x6CA1;&#x6709;&#x51FA;&#x73B0;&#x5947;&#x6570;&#x6B21;&#x7684;&#x5143;&#x7D20;&#xFF0C;&#x6709;&#x7684;&#x8BDD;&#x5C31; winwinwin &#x4E86; &#x6CA1;&#x6709;&#x4EE3;&#x7801; D &#x8BF4;&#x6765;&#x60ED;&#x6127;&#xFF0C;&#x6211;&#x4F1A; E,F &#x4E0D;&#x4F1A; D &#x624D;&#x4E0D;&#x4F1A;&#x544A;&#x8BC9;&#x4F60;&#x662F;&#x56E0;&#x4E3A;&#x628A;&#x9898;&#x770B;&#x9519;&#x4E86;&#x4EE5;&#x4E3A;&#x662F; fft &#x9898;&#x4E8E;&#x662F;&#x4E0D;&#x60F3;&#x5199;&#x4E86;&#x5462;&#xFF0C;&#x9996;&#x5148;&#x662F;&#x5F97;&#x8003;&#x8651;&#x5230;&#x6BCF;&#x4E24;&#x884C;&#x4E4B;&#x95F4;&#x6CA1;&#x5565;&#x5173;&#x7CFB;&#xFF0C;&#x56E0;&#x6B64;&#x53EA;&#x7528;&#x8003;&#x8651; n=2n=2n=2 &#x7684;&#x60C5;&#x51B5;&#xFF0C;&#x53D1;&#x73B0;&#x8FD9;&#x4E2A;&#x65F6;&#x5019;&#x5982;&#x679C;&#x6709;&#x4E00;&#x4E2A;&#x5143;&#x7D20;&#x51FA;&#x73B0;&#x8D85;&#x8FC7; mmm &#x6B21;&#x4E00;&#x5B9A;&#x4E0D;&#x5408;&#x6CD5;&#xFF0C;&#x5426;&#x5219;&#x4E00;&#x5B9A;&#x80FD;&#x8D2A;&#x5FC3;+&#x5806;&#x6784;&#x9020;&#x4E00;&#x6CE2;&#x5408;&#x6CD5;&#x7B54;&#x6848;&#xFF0C;&#x7136;&#x540E;&#x62D3;&#x5C55;&#x5230;&#x591A;&#x884C;&#x5373;&#x53EF; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef vector&lt;int&gt; poly;typedef pair&lt;int,int&gt; pii;#define pb push_back#define fi first#define se secondconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() { int ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline ll readl() { ll ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}namespace modular { const int mod=1e9+7; inline int add(int a,int b) { return a+b&lt;mod?a+b:a+b-mod; } inline int dec(int a,int b) { return a&lt;b?a-b+mod:a-b; } inline int mul(int a,int b) { return (ll)a*b%mod; } inline void Add(int&amp;a,int b) { a=a+b&lt;mod?a+b:a+b-mod; } inline void Dec(int&amp;a,int b) { a=a&lt;b?a-b+mod:a-b; } inline void Mul(int&amp;a,int b) { a=(ll)a*b%mod; }}using namespace modular;const int N=1e6+5;vector&lt;int&gt;a[N],L[N],R[N];int n,m;int main() { #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(),m=read(); for(ri i=1;i&lt;=n;++i) { a[i].resize(m+1); for(ri j=1;j&lt;=m;++j) a[i][j]=read(); } for(ri i=2,ps;i&lt;=n;++i) { vector&lt;int&gt;vl; for(ri j=1;j&lt;=m;++j) { vl.pb(a[i-1][j]); L[a[i-1][j]].pb(j); vl.pb(a[i][j]); R[a[i][j]].pb(j); } sort(vl.begin(),vl.end()); vl.erase(unique(vl.begin(),vl.end()),vl.end()); set&lt;pii&gt;A,B; for(ri j=0,_vl;j&lt;(int)vl.size();++j) { _vl=vl[j]; if((int)L[_vl].size()+(int)R[_vl].size()&gt;m) return puts(&quot;-1&quot;),0; if((int)L[_vl].size()) A.insert(pii((int)L[_vl].size()+(int)R[_vl].size(),_vl)); if((int)R[_vl].size()) B.insert(pii((int)L[_vl].size()+(int)R[_vl].size(),_vl)); } while((int)A.size()) { pii vlx=*A.rbegin(),vly; A.erase(vlx); B.erase(vlx); vly=*B.rbegin(); A.erase(vly); B.erase(vly); a[i][L[vlx.se].back()]=vly.se; L[vlx.se].pop_back(); R[vly.se].pop_back(); if((int)L[vlx.se].size()) A.insert(pii((int)L[vlx.se].size()+(int)R[vlx.se].size(),vlx.se)); if((int)R[vlx.se].size()) B.insert(pii((int)L[vlx.se].size()+(int)R[vlx.se].size(),vlx.se)); if((int)L[vly.se].size()) A.insert(pii((int)L[vly.se].size()+(int)R[vly.se].size(),vly.se)); if((int)R[vly.se].size()) B.insert(pii((int)L[vly.se].size()+(int)R[vly.se].size(),vly.se)); } } for(ri i=1;i&lt;=n;++i,puts(&quot;&quot;)) for(ri j=1;j&lt;=m;++j) cout&lt;&lt;a[i][j]&lt;&lt;&apos; &apos;; return 0;} E &#x4E00;&#x5F00;&#x59CB;&#x6CA1;&#x770B;&#x5230;&#x6700;&#x957F;&#x4E24;&#x4E2A;&#x5B57;&#x611F;&#x89C9;&#x662F; sbt &#x7ED3;&#x679C;&#x5199;&#x5B8C;&#x4EA4;&#x4E0A;&#x53BB;&#x53D1;&#x73B0;&#x6CA1;&#x8FC7;&#x6837;&#x4F8B; &#x51B7;&#x9759;&#x4E86;&#x4E00;&#x4E0B;&#x53D1;&#x73B0; lis &#x7684;&#x8BDD;&#x968F;&#x4FBF;&#x6784;&#x9020;&#x4E00;&#x4E0B;&#x5C31;&#x8FC7;&#x4E86;&#x3002; CODE cpp1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef vector&lt;int&gt; poly;#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() { int ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}namespace modular { const int mod=1e9+7; inline int add(int a,int b) { return a+b&lt;mod?a+b:a+b-mod; } inline int dec(int a,int b) { return a&lt;b?a-b+mod:a-b; } inline int mul(int a,int b) { return (ll)a*b%mod; } inline void Add(int&amp;a,int b) { a=a+b&lt;mod?a+b:a+b-mod; } inline void Dec(int&amp;a,int b) { a=a&lt;b?a-b+mod:a-b; } inline void Mul(int&amp;a,int b) { a=(ll)a*b%mod; }}using namespace modular;const int N=105;int K;int main() { #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif cin&gt;&gt;K; for(ri t,ct=1;K;K/=10,++ct) { t=K%10; for(ri i=1;i&lt;=t;++i) cout&lt;&lt;ct&lt;&lt;&apos; &apos;; if(K&gt;9)cout&lt;&lt;500000000+ct&lt;&lt;&apos; &apos;; for(ri i=t+1;i&lt;=min(K,10);++i) cout&lt;&lt;ct&lt;&lt;&apos; &apos;; } return 0;} F &#x628A;&#x6240;&#x6709;&#x73AF;&#x7684;&#x5F02;&#x6216;&#x503C;&#x63D0;&#x51FA;&#x6765;&#x505A;&#x7EBF;&#x6027;&#x57FA;&#x5373;&#x53EF;&#xFF0C;&#x5F15;&#x8D77;&#x6211;&#x6781;&#x5EA6;&#x8212;&#x9002; CODE cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef vector&lt;int&gt; poly;#define pb push_back#define fi first#define se secondconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() { int ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline ll readl() { ll ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}namespace modular { const int mod=1e9+7; inline int add(int a,int b) { return a+b&lt;mod?a+b:a+b-mod; } inline int dec(int a,int b) { return a&lt;b?a-b+mod:a-b; } inline int mul(int a,int b) { return (ll)a*b%mod; } inline void Add(int&amp;a,int b) { a=a+b&lt;mod?a+b:a+b-mod; } inline void Dec(int&amp;a,int b) { a=a&lt;b?a-b+mod:a-b; } inline void Mul(int&amp;a,int b) { a=(ll)a*b%mod; }}using namespace modular;const int N=1e5+5;int n,m;ll dis[N],a[105];vector&lt;pair&lt;int,ll&gt; &gt;e[N];bool vs[N];inline void insert(ll x) { for(ri i=63;~i;--i) { if(!x) break; if(x&gt;&gt;i&amp;1) { if(a[i]) x^=a[i]; else { a[i]=x; break; } } }}inline ll query() { ll res=0; for(ri i=63;~i;--i) res=max(res,res^a[i]); return res;}inline void dfs(int p) { vs[p]=1; for(ri i=0,v;i&lt;(int)e[p].size();++i) { if(vs[v=e[p][i].fi]) { insert(dis[p]^dis[v]^e[p][i].se); continue; } dis[v]=dis[p]^e[p][i].se; dfs(v); }}int main() { #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(),m=read(); ll w; for(ri i=1,u,v;i&lt;=m;++i) { u=read(),v=read(),w=readl(); e[u].pb(make_pair(v,w)); e[v].pb(make_pair(u,w)); } dfs(1); cout&lt;&lt;query(); return 0;}","categories":[{"name":"public","slug":"public","permalink":"http://xdl030112.github.io/categories/public/"}],"tags":[{"name":"比赛题解","slug":"比赛题解","permalink":"http://xdl030112.github.io/tags/%E6%AF%94%E8%B5%9B%E9%A2%98%E8%A7%A3/"}]},{"title":"CS Academy Round 5 简要题解","slug":"CS5","date":"2020-01-03T00:40:51.000Z","updated":"2020-01-03T00:58:13.797Z","comments":true,"path":"CS5/","link":"","permalink":"http://xdl030112.github.io/CS5/","excerpt":"","text":"A &#x6A21;&#x62DF;&#x9898; CODE cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef vector&lt;int&gt; poly;typedef pair&lt;int,int&gt; pii;#define pb push_back#define fi first#define se secondconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() { int ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline ll readl() { ll ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}namespace modular { const int mod=1e9+7; inline int add(int a,int b) { return a+b&lt;mod?a+b:a+b-mod; } inline int dec(int a,int b) { return a&lt;b?a-b+mod:a-b; } inline int mul(int a,int b) { return (ll)a*b%mod; } inline void Add(int&amp;a,int b) { a=a+b&lt;mod?a+b:a+b-mod; } inline void Dec(int&amp;a,int b) { a=a&lt;b?a-b+mod:a-b; } inline void Mul(int&amp;a,int b) { a=(ll)a*b%mod; }}using namespace modular;const int N=105;int n,a[N][N];int main() { #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(); for(ri i=1;i&lt;=n;++i) for(ri j=1;j&lt;=n;++j) a[i][j]=read(); for(ri i=1;i&lt;=n;++i,puts(&quot;&quot;)) for(ri j=1;j&lt;=n;++j) { bool ff=0; if(a[i][j]) ff=1; if(a[j][n-i+1]) ff=1; if(a[n-i+1][n-j+1]) ff=1; if(a[n-j+1][i]) ff=1; if(ff) cout&lt;&lt;1; else cout&lt;&lt;0; cout&lt;&lt;&apos; &apos;; } return 0;} B bfs &#x6253;&#x4E00;&#x4E0B;&#x6807;&#x8BB0;&#x5373;&#x53EF; CODE cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef vector&lt;int&gt; poly;typedef pair&lt;int,int&gt; pii;#define pb push_back#define fi first#define se secondconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() { int ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline ll readl() { ll ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}namespace modular { const int mod=1e9+7; inline int add(int a,int b) { return a+b&lt;mod?a+b:a+b-mod; } inline int dec(int a,int b) { return a&lt;b?a-b+mod:a-b; } inline int mul(int a,int b) { return (ll)a*b%mod; } inline void Add(int&amp;a,int b) { a=a+b&lt;mod?a+b:a+b-mod; } inline void Dec(int&amp;a,int b) { a=a&lt;b?a-b+mod:a-b; } inline void Mul(int&amp;a,int b) { a=(ll)a*b%mod; }}using namespace modular;const int N=1e5+5;int n,m,S,A,B,dis[N];bool ff1[N],ff2[N];vector&lt;int&gt;e[N];int main() { #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(),m=read(); S=read(),A=read(),B=read(); for(ri u,v,i=1;i&lt;=m;++i) { u=read(),v=read(); e[u].pb(v),e[v].pb(u); } queue&lt;int&gt;q; q.push(S),dis[S]=1; while((int)q.size()) { int x=q.front(); q.pop(); for(ri i=0,v;i&lt;(int)e[x].size();++i) { if(dis[v=e[x][i]]) continue; dis[v]=dis[x]+1; q.push(v); } } q.push(A); while((int)q.size()) { int x=q.front(); q.pop(); for(ri i=0,v;i&lt;(int)e[x].size();++i) { if(dis[v=e[x][i]]!=dis[x]-1) continue; ff1[v]=1; q.push(v); } } q.push(B); while((int)q.size()) { int x=q.front(); q.pop(); for(ri i=0,v;i&lt;(int)e[x].size();++i) { if(dis[v=e[x][i]]!=dis[x]-1) continue; ff2[v]=1; q.push(v); } } int res=0; for(ri i=1;i&lt;=n;++i) if(ff1[i]&amp;&amp;ff2[i]) res=max(res,dis[i]-1); cout&lt;&lt;res; return 0;} C &#x8C8C;&#x4F3C;&#x662F;&#x8DDF; CSP-S day1t1 &#x7C7B;&#x4F3C;&#x7684;&#x9898;&#x5C31;&#x8FD9;&#x6837;&#x6211;&#x5C45;&#x7136;vp&#x7684;&#x65F6;&#x5019;&#x4E5F;&#x6302;&#x4E86;&#x4E00;&#x6B21; &#x628A;&#x6BCF;&#x4E2A;&#x6570; reverse &#x4E4B;&#x540E;&#x7684;&#x786E;&#x5207;&#x4E0B;&#x6807;&#x6C42;&#x51FA;&#x6765;&#x6BD4;&#x5927;&#x5C0F;&#x5C31;&#x53EF;&#x4EE5;&#x4E86; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef vector&lt;int&gt; poly;typedef pair&lt;int,int&gt; pii;#define pb push_back#define fi first#define se secondconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() { int ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline ll readl() { ll ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}namespace modular { const int mod=1e9+7; inline int add(int a,int b) { return a+b&lt;mod?a+b:a+b-mod; } inline int dec(int a,int b) { return a&lt;b?a-b+mod:a-b; } inline int mul(int a,int b) { return (ll)a*b%mod; } inline void Add(int&amp;a,int b) { a=a+b&lt;mod?a+b:a+b-mod; } inline void Dec(int&amp;a,int b) { a=a&lt;b?a-b+mod:a-b; } inline void Mul(int&amp;a,int b) { a=(ll)a*b%mod; }}using namespace modular;const int N=1e5+5;int n,m,a[N];inline int calc(int x,int l,int r,int pw) { if(l==r) return l; int mid=(l+r-1)&gt;&gt;1; if(!(x/pw%2)) return calc(x,mid+1,r,pw&lt;&lt;1); return calc(x,l,mid,pw&lt;&lt;1);}int main() { #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(),m=read(); for(ri i=1;i&lt;=m;++i) a[i]=calc(read()-1,0,n-1,1); for(ri i=1;i&lt;m;++i) if(a[i]&gt;a[i+1]) { puts(&quot;0&quot;); return 0; } puts(&quot;1&quot;); return 0;} D &#x6A21;&#x62DF;&#x9898; &#x770B;&#x5B8C;&#x9898;&#x9762;&#x611F;&#x89C9;&#x662F;&#x4EC0;&#x4E48;&#x7269;&#x7406;&#x795E;&#x9898;&#x5C31;&#x8DD1;&#x53BB;&#x770B;&#x540E;&#x9762;&#x7684;&#x7ED3;&#x679C;&#x540E;&#x6765;&#x53D1;&#x73B0;&#x88AB;&#x9A97;&#x4E86;&#x3002; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef vector&lt;int&gt; poly;typedef pair&lt;int,int&gt; pii;#define pb push_back#define fi first#define se secondconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() { int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch)) f^=ch==&apos;-&apos;,ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;}inline ll readl() { ll ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}namespace modular { const int mod=1e9+7; inline int add(int a,int b) { return a+b&lt;mod?a+b:a+b-mod; } inline int dec(int a,int b) { return a&lt;b?a-b+mod:a-b; } inline int mul(int a,int b) { return (ll)a*b%mod; } inline void Add(int&amp;a,int b) { a=a+b&lt;mod?a+b:a+b-mod; } inline void Dec(int&amp;a,int b) { a=a&lt;b?a-b+mod:a-b; } inline void Mul(int&amp;a,int b) { a=(ll)a*b%mod; }}using namespace modular;const int N=1e6+5;int n,m,f1,f2;vector&lt;int&gt;e[N];pii a[N];int vlx[N],vly[N],sx=0,sy=0;ll ssx,ssy;int main() { #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(),m=read(),f1=read(),f2=read(); for(ri i=1,u,v;i&lt;=m;++i) { u=read(),v=read(); e[u].pb(v); e[v].pb(u); } for(ri i=1;i&lt;=n;++i) ssx+=(a[i].fi=read()),ssy+=(a[i].se=read()); for(ri i=1;i&lt;=n;++i) { ll resx,resy; resx=(ll)f2*((ll)n*a[i].fi-ssx); resy=(ll)f2*((ll)n*a[i].se-ssy); for(ri j=0;j&lt;(int)e[i].size();++j) { resx+=(ll)(f1-f2)*(a[i].fi-a[e[i][j]].fi); resy+=(ll)(f1-f2)*(a[i].se-a[e[i][j]].se); } cout&lt;&lt;resx&lt;&lt;&apos; &apos;&lt;&lt;resy&lt;&lt;&apos;\\n&apos;; } return 0;} E &#x8FD9;&#x9898;&#x5C45;&#x7136; vp &#x7684;&#x65F6;&#x5019;&#x6CA1;&#x5207;&#x3002; &#x4E0D;&#x8FC7;&#x7684;&#x786E;&#x6709;&#x4E2A;&#x6838;&#x5FC3;&#x7684;&#x4E1C;&#x897F;&#x6CA1;&#x6709;&#x8003;&#x8651;&#x5230;&#xFF0C;&#x5C31;&#x662F;&#x5047;&#x8BBE;&#x6211;&#x4EEC;&#x6700;&#x540E;&#x653E;&#x7F6E; 000 &#x7684;&#x4F4D;&#x7F6E;&#x5E8F;&#x5217;&#x4E3A; a1,a2,...,aka_1,a_2,...,a_ka1&#x200B;,a2&#x200B;,...,ak&#x200B; &#xFF0C;&#x539F;&#x672C;&#x7684;&#x4F4D;&#x7F6E;&#x4E3A; ps1,ps2,...,pskps_1,ps_2,...,ps_kps1&#x200B;,ps2&#x200B;,...,psk&#x200B; &#x90A3;&#x4E48;&#x6B64;&#x65F6;&#x6700;&#x5C0F;&#x79FB;&#x52A8;&#x6B21;&#x6570;&#x4E3A; &#x2223;a1&#x2212;ps1&#x2223;+&#x2223;a2&#x2212;ps2&#x2223;+&#x22EF;+&#x2223;ak&#x2212;psk&#x2223;|a_1-ps_1|+|a_2-ps_2|+\\cdots+|a_k-ps_k|&#x2223;a1&#x200B;&#x2212;ps1&#x200B;&#x2223;+&#x2223;a2&#x200B;&#x2212;ps2&#x200B;&#x2223;+&#x22EF;+&#x2223;ak&#x200B;&#x2212;psk&#x200B;&#x2223; &#x8003;&#x8651;&#x8BBE; fi,j,k=(a,b)f_{i,j,k}=(a,b)fi,j,k&#x200B;=(a,b) &#x8868;&#x793A;&#x524D; iii &#x4E2A;&#x4F4D;&#x7F6E;&#x91CC;&#x9762;&#x653E;&#x4E86; jjj &#x4E2A; 000 &#xFF0C;&#x5DF2;&#x7ECF;&#x5339;&#x914D;&#x5230;&#x7B2C; jjj &#x4E2A;&#x4F4D;&#x7F6E;&#x7684;&#x65F6;&#x5019;&#x7684;&#xFF08;&#x5339;&#x914D;&#x6570;&#x6700;&#x5927;&#x503C;&#xFF0C;&#x79FB;&#x52A8;&#x6B21;&#x6570;&#x6700;&#x5C0F;&#x503C;&#xFF09;&#x8FD9;&#x4E2A;&#x4E8C;&#x5143;&#x7EC4;&#x4FE1;&#x606F;&#xFF08;&#x4F18;&#x5148;&#x7B2C;&#x4E00;&#x5143;&#xFF09;&#xFF0C;&#x7ED3;&#x5408;&#x4E0A;&#x9762;&#x7684;&#x90A3;&#x4E2A;&#x5BB9;&#x6613;&#x5FD8;&#x6389;&#x7684;&#x6761;&#x4EF6;&#x5C31;&#x80FD;&#x5F88;&#x65B9;&#x4FBF;&#x7684;&#x8F6C;&#x79FB;&#x4E86; CODE cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef pair&lt;int,int&gt; pii;#define fi first#define se secondconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(int*s) { int top=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) s[++top]=ch^48,ch=gc(); return top;}const int N=505,inf=1e9;int n,m,trans[N][2],cur,fail[N],s[N],t[N],ps[N],top=0;pii f[2][N][N];inline bool operator&lt;(pii a,pii b) { return a.fi^b.fi?a.fi&lt;b.fi:a.se&gt;b.se; }inline void ckmax(pii&amp;a,pii b) { if(a&lt;b) a=b; }int main() { #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(s),m=read(t); for(ri i=1,j=0;i&lt;m;++i) { while(j&amp;&amp;t[i+1]!=t[j+1]) j=fail[j]; fail[i+1]=t[i+1]==t[j+1]?++j:0; } for(ri k,i=0;i&lt;=m;++i) { for(ri j=0;j&lt;2;++j) { k=i==m?fail[i]:i; while(k&amp;&amp;j!=t[k+1]) k=fail[k]; trans[i][j]=j==t[k+1]?++k:0; } } for(ri i=1;i&lt;=n;++i) if(!s[i]) ps[++top]=i; for(ri i=0;i&lt;2;++i) for(ri j=0;j&lt;=m;++j) for(ri k=0;k&lt;=top;++k) f[i][j][k]=pii(-inf,inf); f[cur=0][0][0]=pii(0,0); pii res=pii(-inf,inf); for(ri i=1;i&lt;=n+1;++i) { cur^=1; for(ri j=0;j&lt;=m;++j) for(ri k=0;k&lt;=top;++k) f[cur][j][k]=pii(-inf,inf); for(ri j=0;j&lt;=m;++j) for(ri k=0;k&lt;=top;++k) if(f[cur^1][j][k].fi!=-inf) { if(i==n+1) { ckmax(res,f[cur^1][j][k]);continue; } if(k^top) ckmax(f[cur][trans[j][0]][k+1],pii(f[cur^1][j][k].fi+(trans[j][0]==m),f[cur^1][j][k].se+abs(ps[k+1]-i))); if(n-i+1!=top-k) ckmax(f[cur][trans[j][1]][k],pii(f[cur^1][j][k].fi+(trans[j][1]==m),f[cur^1][j][k].se)); } } cout&lt;&lt;res.fi&lt;&lt;&apos; &apos;&lt;&lt;res.se; return 0;} F &#x4E4B;&#x524D;&#x6284;&#x505A;&#x8FC7;&#x7684;&#x795E;&#x4ED9;&#x9898; vp&#x7684;&#x65F6;&#x5019;&#x76F4;&#x63A5;&#x8D34;&#x4E86;&#x4E4B;&#x524D;&#x7684;&#x4EE3;&#x7801;&#xFF0C;&#x7136;&#x540E; vp &#x5B8C;&#x4E4B;&#x540E;&#x53C8;&#x6284;&#x5199;&#x4E86;&#x4E00;&#x53D1;&#x4FEE;&#x4E86;&#x4FEE;&#x9505; &#x8003;&#x8651;&#x5047;&#x5982;&#x53EA;&#x6709;&#x4E24;&#x4E2A;&#x73AF;&#xFF0C;&#x90A3;&#x4E48;&#x4E00;&#x5B9A;&#x53EA;&#x6709;&#x73AF;&#x4EA4;&#x5904;&#x9700;&#x8981;&#x8BA8;&#x8BBA; &#x7136;&#x540E;&#x53D1;&#x73B0;&#x591A;&#x4E2A;&#x73AF;&#x7684;&#x65F6;&#x5019;&#x4E5F;&#x53EA;&#x6709;&#x73AF;&#x4EA4;&#x9700;&#x8981;&#x8BA8;&#x8BBA;&#xFF0C;&#x90A3;&#x4E48;&#x8003;&#x8651;&#x627E;&#x73AF;&#x4EA4;&#x7684;&#x65B9;&#x6CD5;&#xFF0C;&#x53D1;&#x73B0;&#x53EF;&#x4EE5;&#x6BCF;&#x6B21;&#x627E;&#x4E00;&#x4E2A;&#x5EA6;&#x4E3A; 222 &#x7684;&#x70B9;&#x628A;&#x5B83;&#x5220;&#x6389;&#xFF0C;&#x7136;&#x540E;&#x628A;&#x5B83;&#x4E24;&#x8FB9;&#x7684;&#x70B9;&#x7528;&#x865A;&#x8FB9;&#x8FDE;&#x8D77;&#x6765;&#xFF0C;&#x6700;&#x540E;&#x73AF;&#x4EA4;&#x5904;&#x4E00;&#x5B9A;&#x662F;&#x4E8C;&#x5143;&#x73AF;&#xFF0C;&#x7136;&#x540E;&#x8BBE; fi,0/1,0/1f_{i,0/1,0/1}fi,0/1,0/1&#x200B; &#x8868;&#x793A;&#x7B2C; iii &#x6761;&#x8FB9;&#x8FDE;&#x63A5;&#x7684; u,vu,vu,v &#x662F;&#x5426;&#x9009;&#x62E9;&#x7684;&#x65F6;&#x5019;&#x7684;&#x6700;&#x4F18;&#x503C;&#xFF0C;&#x7136;&#x540E;&#x5206;&#x60C5;&#x51B5;&#x8F6C;&#x79FB;&#x5C31;&#x884C;&#x4E86; CODE cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef pair&lt;int,int&gt; pii;#define fi first#define se secondconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() { int ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}const int N=1e5+5,inf=1e9;pii E[N&lt;&lt;1];map&lt;int,int&gt;trans[N];set&lt;int&gt;e[N];int n,m,f[N&lt;&lt;1][2][2],tmp[2][2];bool ban[N&lt;&lt;1],vs[N];int main() { #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(),m=read(); for(ri i=1;i&lt;=m;++i) { E[i].fi=read(),E[i].se=read(); if(E[i].fi&gt;E[i].se) swap(E[i].fi,E[i].se); f[i][0][1]=f[i][1][0]=1; f[i][1][1]=-inf; trans[E[i].fi][E[i].se]=i; e[E[i].fi].insert(i),e[E[i].se].insert(i); } queue&lt;int&gt;q; for(ri i=1;i&lt;=n;++i) if((int)e[i].size()==2) vs[i]=1,q.push(i); while((int)q.size()) { int x=q.front(),pre,suf,A,B,id; q.pop(); if((int)e[x].size()!=2) continue; A=*e[x].begin(),e[x].erase(A); B=*e[x].begin(),e[x].erase(B); pre=E[A].fi^E[A].se^x; suf=E[B].fi^E[B].se^x; if(pre&gt;suf) swap(A,B),swap(pre,suf); e[pre].erase(A),e[suf].erase(B); if(E[A].fi^pre) swap(E[A].fi,E[A].se),swap(f[A][0][1],f[A][1][0]); if(E[B].se^suf) swap(E[B].fi,E[B].se),swap(f[B][0][1],f[B][1][0]); for(ri i=0;i&lt;2;++i) for(ri j=0;j&lt;2;++j) tmp[i][j]=max(f[A][i][0]+f[B][0][j],f[A][i][1]+f[B][1][j]-1); if(trans[pre].count(suf)) { ban[A]=ban[B]=1; id=trans[pre][suf]; for(ri i=0;i&lt;2;++i) for(ri j=0;j&lt;2;++j) f[id][i][j]+=tmp[i][j]-i-j; } else { ban[B]=1; trans[pre][suf]=id=A; E[A]=pii(pre,suf); for(ri i=0;i&lt;2;++i) for(ri j=0;j&lt;2;++j) f[id][i][j]=tmp[i][j]; } e[pre].insert(id),e[suf].insert(id); if(!vs[pre]&amp;&amp;(int)e[pre].size()==2) q.push(pre),vs[pre]=1; if(!vs[suf]&amp;&amp;(int)e[suf].size()==2) q.push(suf),vs[suf]=1; } int res=0; for(ri i=1;i&lt;=m;++i) if(!ban[i]) for(ri j=0;j&lt;2;++j) for(ri k=0;k&lt;2;++k) res=max(res,f[i][j][k]); cout&lt;&lt;res; return 0;}","categories":[{"name":"public","slug":"public","permalink":"http://xdl030112.github.io/categories/public/"}],"tags":[{"name":"比赛题解","slug":"比赛题解","permalink":"http://xdl030112.github.io/tags/%E6%AF%94%E8%B5%9B%E9%A2%98%E8%A7%A3/"}]},{"title":"CS Academy Round 4 简要题解","slug":"CS4","date":"2020-01-03T00:27:10.000Z","updated":"2020-01-03T00:39:36.697Z","comments":true,"path":"CS4/","link":"","permalink":"http://xdl030112.github.io/CS4/","excerpt":"","text":"Anagrams STL &#x64CD;&#x4F5C;&#x9898; CODE cpp123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef pair&lt;int,int&gt; pii;#define fi first#define se secondconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() { int ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}map&lt;string,int&gt;S;int n;string s;int main() { #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif cin&gt;&gt;n; for(ri i=1;i&lt;=n;++i) cin&gt;&gt;s,sort(s.begin(),s.end()),++S[s]; int res=0; for(map&lt;string,int&gt;::iterator it=S.begin();it!=S.end();++it) res=max(res,it-&gt;se); cout&lt;&lt;res; return 0;} B &#x6A21;&#x62DF;&#x9898; &#x76EE;&#x524D;&#x8C8C;&#x4F3C;&#x53EA;&#x4F1A; O(log&#x2061;n)O(\\log n)O(logn) &#x505A;&#x6CD5;&#xFF0C;&#x5982;&#x679C;&#x6709; O(1)O(1)O(1) &#x505A;&#x6CD5;&#x6B22;&#x8FCE;&#x6765;&#x66B4;&#x6253;&#x535A;&#x4E3B; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;#define fi first#define se secondconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() { int ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline ll calc(int x) { if(!x) return 0; int tm=1,lm; ll res=0; while(tm&lt;=x) { lm=x/tm; if(!(lm&amp;1)) --lm; res+=(ll)(lm+1)*(lm+1)/4; tm&lt;&lt;=1; } return res;}int main() { #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif for(ri l,r,tt=read();tt;--tt) { l=read(),r=read(); cout&lt;&lt;calc(r)-calc(l-1)&lt;&lt;&apos;\\n&apos;; } return 0;} C &#x624B;&#x73A9;&#x4E24;&#x4E0B;&#x53D1;&#x73B0;&#x76F4;&#x63A5;&#x50CF;&#x6837;&#x4F8B;&#x4E00;&#x6837;&#x8D2A;&#x5FC3;&#x6B63;&#x786E;&#x6027;&#x6709;&#x4FDD;&#x8BC1;&#xFF0C;&#x7528;&#x4E2A; bitbitbit &#x7EF4;&#x62A4;&#x4E0B;&#x5373;&#x53EF; CODE cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;#define fi first#define se secondconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() { int ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}const int N=1e5+5;int n,a[N],bit[N],mch[N];map&lt;int,int&gt; ps;bool vs[N];inline int lowbit(int x) { return x&amp;-x; }inline void update(int x,int v) { for(;x&lt;=n;x+=lowbit(x)) bit[x]+=v; }inline int query(int x) { int ret=0;for(;x;x^=lowbit(x)) ret+=bit[x];return ret; }inline int query(int l,int r) { return query(r)-query(l-1); }int main() { #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(); for(ri i=1;i&lt;=n;++i) { a[i]=read(),update(i,1); if(ps.count(a[i])) mch[ps[a[i]]]=i; else ps[a[i]]=i; } ll res=0; for(ri i=1;i&lt;=n;++i) if(!vs[i]) { vs[i]=vs[mch[i]]=1; res+=query(i+1,mch[i]-1); update(i,-1),update(mch[i],-1); } cout&lt;&lt;res; return 0;} D &#x62C6;&#x6210;&#x524D;&#x7F00;&#x5F02;&#x6216;&#x548C;&#x7684;&#x5F02;&#x6216;&#x540E;&#x53D1;&#x73B0;&#x53EF;&#x4EE5;&#x76F4;&#x63A5;&#x542F;&#x53D1;&#x5F0F;&#x5408;&#x5E76;+ 01trie01trie01trie &#x7EF4;&#x62A4; vp&#x7684;&#x65F6;&#x5019;&#x5C45;&#x7136;&#x8FD8;&#x88AB;&#x5361;&#x7A7A;&#x95F4;&#x5199;&#x4E86;&#x5185;&#x5B58;&#x56DE;&#x6536;&#x624D;&#x8FC7;&#x5FC3;&#x6001;&#x70B8;&#x4E86; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;#define fi first#define se second#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() { int ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}const int N=1e5+5;int n,a[N],rt1[N],rt2[N],res[N],ps[N],ft[N];inline int find(int x) { return x^ft[x]?ft[x]=find(ft[x]):x; }bool ok[N];vector&lt;int&gt;S[N];namespace trie { int tot=0,son[30000005][2]; vector&lt;int&gt;stk; inline int newnode() { int res; if((int)stk.size()) res=stk.back(),stk.pop_back(); else res=++tot; return son[res][0]=son[res][1]=0,res; } inline void insert(int&amp;x,int vl) { if(!x) x=newnode(); int p=x; for(ri t,i=30;~i;--i) { t=vl&gt;&gt;i&amp;1; if(!son[p][t]) son[p][t]=newnode(); p=son[p][t]; } } inline int query(int x,int vl) { int res=0; for(ri t,i=30;~i;--i) { t=(vl&gt;&gt;i&amp;1)^1; if(son[x][t]) x=son[x][t],res|=1&lt;&lt;i; else x=son[x][t^1]; } return res; } inline void clear(int x) { if(son[x][0]) clear(son[x][0]); if(son[x][1]) clear(son[x][1]); stk.pb(x); }}inline int merge1(int x,int y) { x=find(x),y=find(y); int res=0; if((int)S[x].size()&lt;(int)S[y].size()) { for(ri i=0;i&lt;(int)S[x].size();++i) { res=max(res,trie::query(rt1[y],a[S[x][i]-1])); trie::insert(rt2[y],a[S[x][i]-1]); trie::insert(rt1[y],a[S[x][i]]); S[y].pb(S[x][i]); } } else { for(ri i=0;i&lt;(int)S[y].size();++i) { res=max(res,trie::query(rt2[x],a[S[y][i]])); trie::insert(rt2[x],a[S[y][i]-1]); trie::insert(rt1[x],a[S[y][i]]); S[x].pb(S[y][i]); } swap(S[x],S[y]); swap(rt1[y],rt1[x]); swap(rt2[x],rt2[y]); } ft[x]=y; trie::clear(rt1[x]); trie::clear(rt2[x]); return res;}inline int merge2(int x,int y) { x=find(x),y=find(y); int res=0; if((int)S[x].size()&lt;(int)S[y].size()) { for(ri i=0;i&lt;(int)S[x].size();++i) { res=max(res,trie::query(rt1[y],a[S[x][i]-1])); trie::insert(rt2[y],a[S[x][i]-1]); trie::insert(rt1[y],a[S[x][i]]); S[y].pb(S[x][i]); } swap(S[x],S[y]); swap(rt1[x],rt1[y]); swap(rt2[x],rt2[y]); } else { for(ri i=0;i&lt;(int)S[y].size();++i) { res=max(res,trie::query(rt2[x],a[S[y][i]])); trie::insert(rt2[x],a[S[y][i]-1]); trie::insert(rt1[x],a[S[y][i]]); S[x].pb(S[y][i]); } } ft[y]=x; trie::clear(rt1[y]); trie::clear(rt2[y]); return res;}int main() { #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(); for(ri i=1;i&lt;=n;++i) a[i]=read()^a[i-1],ft[i]=i; for(ri i=1;i&lt;=n;++i) ps[i]=read(); for(ri i=n;i;--i) { ok[ps[i]]=1; res[i]=res[i+1]; res[i]=max(res[i],a[ps[i]]^a[ps[i]-1]); S[ps[i]].pb(ps[i]); trie::insert(rt1[ps[i]],a[ps[i]]),trie::insert(rt2[ps[i]],a[ps[i]-1]); if(ok[ps[i]-1]) res[i]=max(res[i],merge1(ps[i]-1,ps[i])); if(ok[ps[i]+1]) res[i]=max(res[i],merge2(ps[i],ps[i]+1)); } for(ri i=1;i&lt;=n;++i) cout&lt;&lt;res[i]&lt;&lt;&apos;\\n&apos;; return 0;} E &#x8003;&#x8651;&#x628A;&#x5B66;&#x751F;&#x533A;&#x95F4;&#x6309;&#x7167;&#x5355;&#x8C03;&#x6027;&#x53BB;&#x6389;&#x4E00;&#x4E9B;&#x80AF;&#x5B9A;&#x4E0D;&#x4F18;&#x7684;&#xFF08;&#x5373;&#x5982;&#x679C;&#x5176;&#x4E24;&#x7EF4;&#x90FD;&#x5C0F;&#x4E8E;&#x7B49;&#x4E8E;&#x67D0;&#x4E2A;&#x5176;&#x540E;&#x9762;&#x7684;&#x5B66;&#x751F;&#x90A3;&#x4E48;&#x76F4;&#x63A5;&#x5220;&#x6389;&#x8FD9;&#x4E2A;&#x5B66;&#x751F;&#xFF09; &#x7136;&#x540E;&#x7528; fi,jf_{i,j}fi,j&#x200B; &#x8868;&#x793A;&#x5F53;&#x524D;&#x5904;&#x7406;&#x4E86;&#x524D; iii &#x4E2A;&#x6559;&#x6388;&#xFF0C;&#x524D; jjj &#x4E2A;&#x5B66;&#x751F;&#x7684;&#x6700;&#x4F18;&#x60C5;&#x51B5; &#x76F4;&#x63A5;&#x8F6C;&#x662F; O(nm2)O(nm^2)O(nm2) &#x7684;&#xFF0C;&#x4F46;&#x53D1;&#x73B0;&#x5B66;&#x751F;&#x8F6C;&#x79FB;&#x7684;&#x6709;&#x4E2A;&#x4E1C;&#x897F;&#x53EF;&#x4EE5;&#x524D;&#x7F00;&#x4F18;&#x5316;&#xFF0C;&#x7136;&#x540E;&#x53D8;&#x6210; O(nm)O(nm)O(nm) &#x7684;&#x4E86; cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;#define fi first#define se second#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() { int ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}const int N=1e5+5;pii a[N],b[N];int n,m,sig=0,f[2][N],cur=0;int main() { #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(),m=read(); for(ri i=1;i&lt;=n;++i) a[i].fi=read(),a[i].se=read(); for(ri i=1;i&lt;=m;++i) b[i].fi=read(),b[i].se=read(); sort(a+1,a+n+1); sort(b+1,b+m+1),reverse(b+1,b+m+1); for(ri i=1;i&lt;=m;++i) if(!sig||b[i].se&gt;b[sig].se) b[++sig]=b[i]; m=sig,reverse(b+1,b+m+1); cur=0; for(ri i=0;i&lt;=n;++i) { cur^=1; f[cur][0]=i?max(f[cur^1][0],a[i].fi)+a[i].se:0; for(ri pre=0x3f3f3f3f,j=1;j&lt;=m;++j) { f[cur][j]=0x3f3f3f3f; if(i) f[cur][j]=min(f[cur][j],max(f[cur^1][j],a[i].fi)+a[i].se); f[cur][j]=min(f[cur][j],max(f[cur][j-1],b[j].fi)+b[j].se); pre=max(pre,b[j].fi+b[j].se); f[cur][j]=min(f[cur][j],pre); pre=min(pre,max(f[cur][j-1],b[j].fi)+b[j].se); } } cout&lt;&lt;f[cur][m]; return 0;} F &#x795E;&#x4ED9;&#x5206;&#x7C7B;&#x8BA8;&#x8BBA;&#x9898; &#x5148;&#x627E;&#x51FA;&#x6700;&#x5C0F;&#x503C;&#xFF0C;&#x5047;&#x8BBE;&#x5206;&#x5728; AAA &#x7EC4;&#xFF0C;&#x7136;&#x540E;&#x8FED;&#x4EE3;&#x6784;&#x9020;&#x4E00;&#x7EC4;&#x53EF;&#x884C;&#x89E3;&#x51FA;&#x6765;&#xFF0C;&#x5177;&#x4F53;&#x7EC6;&#x8282;&#x53EF;&#x4EE5;&#x770B;&#x770B;&#x9898;&#x89E3;&#xFF0C;&#x5927;&#x6982;&#x5C31;&#x662F;&#x5224;&#x4E00;&#x5806;&#x4E1C;&#x897F; &#x7EC6;&#x8282;&#x591A;&#x7684;&#x53BB;&#x4E16;&#xFF0C;&#x535A;&#x4E3B;&#x6709;&#x4E2A;&#x5C0F;&#x7EC6;&#x8282;&#x8C03;&#x4E86;&#x8D3C;&#x4E45; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;#define pb push_back#define fi first#define se secondconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() { int ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}namespace modular { const int mod=1e9+7; inline int add(int a,int b) { return a+b&lt;mod?a+b:a+b-mod; } inline int dec(int a,int b) { return a&lt;b?a-b+mod:a-b; } inline int mul(int a,int b) { return (ll)a*b%mod; } inline void Add(int&amp;a,int b) { a=a+b&lt;mod?a+b:a+b-mod; } inline void Dec(int&amp;a,int b) { a=a&lt;b?a-b+mod:a-b; } inline void Mul(int&amp;a,int b) { a=(ll)a*b%mod; } inline int ksm(int a,int p) { int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; }}using namespace modular;const int N=2e5+5;int all,res[N],swp[N];map&lt;pii,vector&lt;int&gt; &gt;S;typedef map&lt;pii,vector&lt;int&gt; &gt;::iterator It;vector&lt;vector&lt;int&gt; &gt;seq;int main() { #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif for(ri tt=read();tt;--tt) { all=read(); for(ri i=1;i&lt;=all;++i) swp[i]=res[i]=0; S.clear(),seq.clear(); int ans=2; pii tmp=pii(-0x3f3f3f3f,0x3f3f3f3f); int id=0; for(ri i=1,x,y;i&lt;=all;++i) { x=read(),y=read(); if(tmp.se&gt;y||(y==tmp.se&amp;&amp;x&gt;tmp.fi)) tmp=pii(x,y),id=i; S[pii(x,y)].pb(i); if((int)S[pii(x,y)].size()==2) swp[S[pii(x,y)][0]]=i,Mul(ans,2); } int n=tmp.fi+1,m=all-n,A=1,B=0; seq.pb(vector&lt;int&gt;(1,id)); S[tmp].pop_back(); if((int)S[tmp].size()==0) S.erase(tmp); while(A&lt;n||B&lt;m) { int id1=0,id2=0; if(S.count(pii(n-A-1,B))) id1=S[pii(n-A-1,B)].back(); if(S.count(pii(m-B-1,A))) id2=S[pii(m-B-1,A)].back(); if(id1&amp;&amp;id2) { if(A&lt;B) { res[id2]=1,S[pii(m-B-1,A)].pop_back(); if(!(int)S[pii(m-B-1,A)].size()) S.erase(pii(m-B-1,A)); ++B; seq.back().pb(id2); continue; } else if(A&gt;B) { res[id1]=0,S[pii(n-A-1,B)].pop_back(); if(!(int)S[pii(n-A-1,B)].size()) S.erase(pii(n-A-1,B)); ++A; seq.back().pb(id1); continue; } else { if(n==m) Mul(ans,2),seq.pb(vector&lt;int&gt;(0)); if(n&gt;=m) { res[id1]=0,S[pii(n-A-1,B)].pop_back(); if(!(int)S[pii(n-A-1,B)].size()) S.erase(pii(n-A-1,B)); ++A; seq.back().pb(id1); continue; } else { res[id2]=1,S[pii(m-B-1,A)].pop_back(); if(!(int)S[pii(m-B-1,A)].size()) S.erase(pii(m-B-1,A)); ++B; seq.back().pb(id2); continue; } } } else if(id1) { res[id1]=0,S[pii(n-A-1,B)].pop_back(); if(!(int)S[pii(n-A-1,B)].size()) S.erase(pii(n-A-1,B)); ++A; seq.back().pb(id1); continue; } else { res[id2]=1,S[pii(m-B-1,A)].pop_back(); if(!(int)S[pii(m-B-1,A)].size()) S.erase(pii(m-B-1,A)); ++B; seq.back().pb(id2); continue; } } for(ri i=0;i&lt;(int)seq.size();++i) { sort(seq[i].begin(),seq[i].end()); int ps=0; while(ps&lt;(int)seq[i].size()&amp;&amp;swp[seq[i][ps]]) ++ps; if(ps&lt;(int)seq[i].size()&amp;&amp;res[seq[i][ps]]) for(ri j=0;j&lt;(int)seq[i].size();++j) res[seq[i][j]]^=1; } for(ri i=1;i&lt;=all;++i) if(swp[i]) res[i]=0,res[swp[i]]=1; cout&lt;&lt;ans&lt;&lt;&apos;\\n&apos;; for(ri i=1;i&lt;=all;++i) cout&lt;&lt;res[i]; puts(&quot;&quot;); } return 0;}","categories":[{"name":"public","slug":"public","permalink":"http://xdl030112.github.io/categories/public/"}],"tags":[{"name":"比赛题解","slug":"比赛题解","permalink":"http://xdl030112.github.io/tags/%E6%AF%94%E8%B5%9B%E9%A2%98%E8%A7%A3/"}]},{"title":"CodeForces 1270 简要题解","slug":"CF1270","date":"2019-12-30T08:06:23.000Z","updated":"2019-12-30T08:35:15.178Z","comments":true,"path":"CF1270/","link":"","permalink":"http://xdl030112.github.io/CF1270/","excerpt":"","text":"A &#x6A21;&#x62DF; CODE cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef vector&lt;int&gt; poly;typedef pair&lt;int,int&gt; pii;#define fi first#define se second#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() { int ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline ll readl() { ll ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s) { int top=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) s[++top]=ch,ch=gc(); return top;}namespace modular { const int mod=1e9+7; inline int add(int a,int b) { return a+b&lt;mod?a+b:a+b-mod; } inline int dec(int a,int b) { return a&lt;b?a-b+mod:a-b; } inline int mul(int a,int b) { return (ll)a*b%mod; } inline void Add(int&amp;a,int b) { a=a+b&lt;mod?a+b:a+b-mod; } inline void Dec(int&amp;a,int b) { a=a&lt;b?a-b+mod:a-b; } inline void Mul(int&amp;a,int b) { a=(ll)a*b%mod; } inline int ksm(int a,int p) { int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; } inline int Inv(int a) { return ksm(a,mod-2); }}using namespace modular;int main() { #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif for(ri tt=read();tt;--tt) { int mx1=0,mx2=0,n,a,b; n=read(),a=read(),b=read(); for(ri i=1;i&lt;=a;++i) mx1=max(mx1,read()); for(ri i=1;i&lt;=b;++i) mx2=max(mx2,read()); cout&lt;&lt;(mx1&gt;mx2?&quot;YES&quot;:&quot;NO&quot;)&lt;&lt;&apos;\\n&apos;; } return 0;} B &#x60F3;&#x590D;&#x6742;&#x4E86;&#x3002;&#x3002;&#x3002; &#x76F4;&#x63A5;&#x770B;&#x662F;&#x5426;&#x6709; &#x2223;ai&#x2212;ai+1&#x2223;&gt;1|a_i-a_{i+1}|&gt;1&#x2223;ai&#x200B;&#x2212;ai+1&#x200B;&#x2223;&gt;1 &#x5373;&#x53EF; &#x6211;&#x662F;&#x7528;&#x4E86;&#x4E2A; sb &#x505A;&#x6CD5;&#xFF0C;&#x5927;&#x6982;&#x662F;&#x62C6;&#x5F0F;&#x5B50;&#x62C6;&#x6210; ar&#x2212;r+l&#x2212;al&#x2265;1a_r-r+l-a_l\\ge1ar&#x200B;&#x2212;r+l&#x2212;al&#x200B;&#x2265;1 &#xFF0C;&#x7136;&#x540E; O(n)O(n)O(n) &#x7EF4;&#x62A4;&#x524D;&#x7F00; max &#xFF0C; reverse &#x4E4B;&#x540E;&#x518D;&#x505A;&#x4E00;&#x6B21;&#xFF08;&#x7136;&#x800C;&#x6BD4;&#x8D5B;&#x4EA4;&#x4EE3;&#x7801;&#x7684;&#x65F6;&#x5019;&#x4E0D;&#x5C0F;&#x5FC3;&#x628A; reverse &#x4E00;&#x8D77;&#x5220;&#x4E86;&#x3002; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef vector&lt;int&gt; poly;typedef pair&lt;int,int&gt; pii;#define fi first#define se second#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() { int ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline ll readl() { ll ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s) { int top=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) s[++top]=ch,ch=gc(); return top;}namespace modular { const int mod=1e9+7; inline int add(int a,int b) { return a+b&lt;mod?a+b:a+b-mod; } inline int dec(int a,int b) { return a&lt;b?a-b+mod:a-b; } inline int mul(int a,int b) { return (ll)a*b%mod; } inline void Add(int&amp;a,int b) { a=a+b&lt;mod?a+b:a+b-mod; } inline void Dec(int&amp;a,int b) { a=a&lt;b?a-b+mod:a-b; } inline void Mul(int&amp;a,int b) { a=(ll)a*b%mod; } inline int ksm(int a,int p) { int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; } inline int Inv(int a) { return ksm(a,mod-2); }}using namespace modular;const int N=2e5+5;int n;ll a[N];int main() { #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif for(ri tt=read();tt;--tt) { n=read(); for(ri i=1;i&lt;=n;++i) a[i]=read(); ll mx=0,mxps=0,l=0,r=0; bool ff=0; for(ri i=1;i&lt;=n;++i) { if(mxps==0||i-a[i]&gt;mx) mx=i-a[i],mxps=i; if(mx+a[i]-i&gt;=1) { l=mxps,r=i; ff=1; break; } } if(ff) { puts(&quot;YES&quot;); cout&lt;&lt;l&lt;&lt;&apos; &apos;&lt;&lt;r&lt;&lt;&apos;\\n&apos;; continue; } mxps=0; ff=0; reverse(a+1,a+n+1); for(ri i=1;i&lt;=n;++i) { if(mxps==0||i-a[i]&gt;mx) mx=i-a[i],mxps=i; if(mx+a[i]-i&gt;=1) { l=n-i+1,r=n-mxps+1; ff=1; break; } } if(ff) { puts(&quot;YES&quot;); cout&lt;&lt;l&lt;&lt;&apos; &apos;&lt;&lt;r&lt;&lt;&apos;\\n&apos;; continue; } puts(&quot;NO&quot;); } return 0;} C &#x53C8;&#x60F3;&#x590D;&#x6742;&#x4E86;&#x3002;&#x3002;&#x3002; &#x8C8C;&#x4F3C;&#x76F4;&#x63A5;&#x8F93;&#x51FA; sum+xorsum+xorsum+xor &#x548C; xorxorxor &#x5C31;&#x79D2;&#x4E86;&#x3002; &#x7136;&#x540E;&#x6211;&#x83BD;&#x4E86;&#x4E2A;&#x6570;&#x4F4D;&#x505A;&#x6CD5;&#xFF0C;&#x4E0D;&#x60F3;&#x770B;&#x7684;&#x7528;&#x4E0A;&#x9762;&#x7684;&#x505A;&#x6CD5;&#x5427; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef vector&lt;int&gt; poly;typedef pair&lt;int,int&gt; pii;#define fi first#define se second#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() { int ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline ll readl() { ll ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s) { int top=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) s[++top]=ch,ch=gc(); return top;}namespace modular { const int mod=1e9+7; inline int add(int a,int b) { return a+b&lt;mod?a+b:a+b-mod; } inline int dec(int a,int b) { return a&lt;b?a-b+mod:a-b; } inline int mul(int a,int b) { return (ll)a*b%mod; } inline void Add(int&amp;a,int b) { a=a+b&lt;mod?a+b:a+b-mod; } inline void Dec(int&amp;a,int b) { a=a&lt;b?a-b+mod:a-b; } inline void Mul(int&amp;a,int b) { a=(ll)a*b%mod; } inline int ksm(int a,int p) { int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; } inline int Inv(int a) { return ksm(a,mod-2); }}using namespace modular;const int N=1e5+5;int n;ll vl[N],x,y,a,b,c;int main() { #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif for(ri tt=read();tt;--tt) { n=read(); x=y=a=b=c=0; for(ri i=1;i&lt;=n;++i) vl[i]=read(),x+=vl[i],y^=vl[i]; ll _x=x,_y=y; for(ri v1,v2,i=0;i&lt;63;++i) { v1=x&gt;&gt;i&amp;1,v2=y&gt;&gt;i&amp;1; if(v1) { if(v2) { x+=1ll&lt;&lt;(i+2); x-=1ll&lt;&lt;i; a^=1ll&lt;&lt;i; b^=1ll&lt;&lt;i; c^=1ll&lt;&lt;i; continue; } else { a^=1ll&lt;&lt;i; continue; } } else { if(!v2) continue; a^=1ll&lt;&lt;i; b^=1ll&lt;&lt;i; } } cout&lt;&lt;3&lt;&lt;&apos;\\n&apos;; cout&lt;&lt;a&lt;&lt;&apos; &apos;&lt;&lt;b&lt;&lt;&apos; &apos;&lt;&lt;c&lt;&lt;&apos;\\n&apos;; } return 0;} D &#x8003;&#x8651;&#x5148;&#x95EE;&#x51FA; [1,k] &#x4E2D;&#x7684;&#x7B2C; m &#x5927;&#xFF0C;&#x7136;&#x540E;&#x6309;&#x7167;&#x7C7B;&#x4F3C;&#x4E8E;&#x7EF4;&#x62A4;&#x52A8;&#x6001;&#x91CD;&#x5FC3;&#x7684;&#x65B9;&#x5F0F;&#x5373;&#x53EF;&#x67E5;&#x51FA;&#x7B54;&#x6848; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef vector&lt;int&gt; poly;typedef pair&lt;int,int&gt; pii;#define fi first#define se second#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() getchar()inline int read() { int ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline ll readl() { ll ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s) { int top=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) s[++top]=ch,ch=gc(); return top;}namespace modular { const int mod=1e9+7; inline int add(int a,int b) { return a+b&lt;mod?a+b:a+b-mod; } inline int dec(int a,int b) { return a&lt;b?a-b+mod:a-b; } inline int mul(int a,int b) { return (ll)a*b%mod; } inline void Add(int&amp;a,int b) { a=a+b&lt;mod?a+b:a+b-mod; } inline void Dec(int&amp;a,int b) { a=a&lt;b?a-b+mod:a-b; } inline void Mul(int&amp;a,int b) { a=(ll)a*b%mod; } inline int ksm(int a,int p) { int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; } inline int Inv(int a) { return ksm(a,mod-2); }}using namespace modular;const int N=505;int n,K,ps,vl,cnt1,cnt2;bool ok[N];int main() { #ifdef ldxcaicai #endif n=read(),K=read(); if(K==1) { cout&lt;&lt;&quot;! 1&quot;; cout&lt;&lt;endl&lt;&lt;endl; return 0; } cout&lt;&lt;&quot;? &quot;; for(ri i=1;i&lt;=K;++i) { cout&lt;&lt;i; if(i!=K) cout&lt;&lt;&apos; &apos;; } cout&lt;&lt;endl&lt;&lt;endl; ps=read(),vl=read(); int _ps=ps==1?2:1,chk=-1; cnt1=0,cnt2=0; for(ri t,v,x=K+1;x&lt;=n;++x) { cout&lt;&lt;&quot;? &quot;; for(ri i=1;i&lt;=K;++i) if(i!=_ps) cout&lt;&lt;i&lt;&lt;&apos; &apos;; cout&lt;&lt;x; cout&lt;&lt;endl&lt;&lt;endl; t=read(),v=read(); if(t==ps) { ok[x]=1; continue; } else { if(v&gt;vl) chk=0; else chk=1; continue; } } cnt1=1; for(ri t,v,x=1;x&lt;=K;++x) { if(x==_ps||x==ps) continue; cout&lt;&lt;&quot;? &quot;; for(ri i=1;i&lt;=K;++i) if(i!=x) cout&lt;&lt;i&lt;&lt;&apos; &apos;; cout&lt;&lt;K+1; cout&lt;&lt;endl&lt;&lt;endl; t=read(),v=read(); if(ok[K+1]) { if(t==ps) { ++cnt1; } else { ++cnt2; if(v&lt;vl) chk=0; else chk=1; } } else { if(t==ps) { ++cnt2; } else { ++cnt1; if(v&gt;vl) chk=0; else chk=1; } } } int t,v; if(chk==-1) { if(ok[K+1]) { int pss=0; for(ri i=K+1;i&lt;=n;++i) if(!ok[i]) { pss=i; break; } if(!pss) { cout&lt;&lt;&quot;? &quot;; for(ri i=1;i&lt;=K;++i) if(i!=ps) cout&lt;&lt;i&lt;&lt;&apos; &apos;; cout&lt;&lt;K+1&lt;&lt;&apos; &apos;; cout&lt;&lt;endl&lt;&lt;endl; t=read(),v=read(); if(v&lt;vl) chk=0; else chk=1; } else { for(ri i=1;i&lt;=K;++i) if(i!=ps) cout&lt;&lt;i&lt;&lt;&apos; &apos;; cout&lt;&lt;ps&lt;&lt;&apos; &apos;; cout&lt;&lt;endl&lt;&lt;endl; t=read(),v=read(); if(v&gt;vl) chk=0; else chk=1; } } } cout&lt;&lt;&quot;! &quot;&lt;&lt;(chk?K-cnt1:cnt1+1); cout&lt;&lt;endl&lt;&lt;endl; return 0;} E &#x60F3;&#x4E86;&#x4E2A;&#x5F88;&#x54B8;&#x7684;&#x505A;&#x6CD5;&#xFF0C;&#x7531;&#x4E8E;&#x592A;&#x590D;&#x6742;&#x6BD4;&#x8D5B;&#x7684;&#x65F6;&#x5019;&#x6CA1;&#x5B9E;&#x73B0;&#x5B8C;&#x73B0;&#x5728;&#x4E5F;&#x6CA1;&#x5FC3;&#x601D;&#x4FEE;&#x9505;&#x4E86; &#x8003;&#x8651;&#x6B63;&#x89E3;&#xFF0C;&#x663E;&#x7136;&#x6309;&#x7167;&#x8DDD;&#x79BB;&#x5E73;&#x65B9;&#x7684;&#x5947;&#x5076;&#x5206;&#x7EC4;&#xFF0C;&#x5982;&#x679C;&#x4E24;&#x70B9;&#x7684;&#x6A2A;&#x7EB5;&#x5750;&#x6807;&#x548C;&#x5947;&#x5076;&#x6027;&#x76F8;&#x540C;&#x5C31;&#x80FD;&#x5206;&#x5230;&#x4E00;&#x7EC4;&#xFF0C;&#x8FD9;&#x6837;&#x4E00;&#x5B9A;&#x5408;&#x6CD5; &#x4F46;&#x53EF;&#x80FD;&#x662F;&#x6240;&#x6709;&#x70B9;&#x7684;&#x5947;&#x5076;&#x6027;&#x90FD;&#x4E00;&#x6837;&#xFF0C;&#x56E0;&#x6B64;&#x5982;&#x679C;&#x5168;&#x90E8;&#x70B9;&#x6A2A;&#x7EB5;&#x5750;&#x6807;&#x548C;&#x90FD;&#x76F8;&#x540C;&#x7684;&#x65F6;&#x5019;&#x8FDB;&#x884C;&#x5982;&#x4E0B;&#x8C03;&#x6574;&#xFF1A; &#x540C;&#x4E3A;&#x5947;&#x6570;&#xFF0C;&#x90A3;&#x4E48;&#x6574;&#x4F53;&#x7ED9;&#x6A2A;&#x5750;&#x6807;/&#x7EB5;&#x5750;&#x6807;-1 &#x540C;&#x4E3A;&#x5076;&#x6570;&#xFF0C;&#x90A3;&#x4E48;&#x6574;&#x4F53;&#x628A; (x,y)(x,y)(x,y) &#x53D8;&#x6210; (x+y2,x&#x2212;y2)(\\frac{x+y}2,\\frac{x-y}2)(2x+y&#x200B;,2x&#x2212;y&#x200B;) &#x8FD9;&#x6837;&#x7B49;&#x4E8E;&#x5173;&#x7CFB;&#x6CA1;&#x6709;&#x53D8;&#x5316;&#xFF0C;&#x4F46;&#x4E00;&#x5B9A;&#x80FD;&#x8C03;&#x6574;&#x51FA;&#x7ED3;&#x679C; &#x590D;&#x6742;&#x5EA6; O(n)O(n)O(n) &#x4F46;&#x7531;&#x4E8E; spj &#x6CA1;&#x6CD5; O(n)O(n)O(n) &#x56E0;&#x6B64;&#x51FA;&#x4E86; O(n2)O(n^2)O(n2) &#x7684;&#x6570;&#x636E;&#x8303;&#x56F4;&#xFF0C;&#x5373;&#x4F7F;&#x8FD9;&#x6837;&#x6211;&#x4E5F;&#x88AB;&#x533A;&#x5206;&#x4E86;&#x3002; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef vector&lt;int&gt; poly;typedef pair&lt;int,int&gt; pii;#define fi first#define se second#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() getchar()inline int read() { int ans=0; char ch=gc(); bool f=1; while(!isdigit(ch)) f^=ch==&apos;-&apos;,ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;}inline ll readl() { ll ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}namespace modular { const int mod=1e9+7; inline int add(int a,int b) { return a+b&lt;mod?a+b:a+b-mod; } inline int dec(int a,int b) { return a&lt;b?a-b+mod:a-b; } inline int mul(int a,int b) { return (ll)a*b%mod; } inline void Add(int&amp;a,int b) { a=a+b&lt;mod?a+b:a+b-mod; } inline void Dec(int&amp;a,int b) { a=a&lt;b?a-b+mod:a-b; } inline void Mul(int&amp;a,int b) { a=(ll)a*b%mod; } inline int ksm(int a,int p) { int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; } inline int Inv(int a) { return ksm(a,mod-2); }}const int N=1005;pii a[N];int n;int main() { #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(); for(ri i=1;i&lt;=n;++i) a[i].fi=read(),a[i].se=read(); while(1) { bool ff1=1,ff2=1; for(ri i=1;i&lt;=n;++i) if((a[i].fi^a[i].se)&amp;1) ff1=0;else ff2=0; if(!(ff1||ff2)) break; if(ff1) for(ri i=1;i&lt;=n;++i) --a[i].fi; else for(ri i=1,a0,a1;i&lt;=n;++i) a0=a[i].fi,a1=a[i].se,a[i].fi=(a0+a1)&gt;&gt;1,a[i].se=(a0-a1)&gt;&gt;1; } vector&lt;int&gt;res; for(ri i=1;i&lt;=n;++i) if((a[i].fi^a[i].se)&amp;1) res.pb(i); cout&lt;&lt;(int)res.size()&lt;&lt;&apos;\\n&apos;; for(ri i=0;i&lt;(int)res.size();++i) cout&lt;&lt;res[i]&lt;&lt;&apos; &apos;; return 0;} F &#x8003;&#x8651;&#x8981;&#x6C42;&#x7684;&#x662F; &#x2211;l=1n&#x2211;r=ln[r&#x2212;(l&#x2212;1)=K(cntr&#x2212;cntl&#x2212;1)]\\sum\\limits_{l=1}^n\\sum\\limits_{r=l}^n[r-(l-1)=K(cnt_r-cnt_{l-1})]l=1&#x2211;n&#x200B;r=l&#x2211;n&#x200B;[r&#x2212;(l&#x2212;1)=K(cntr&#x200B;&#x2212;cntl&#x2212;1&#x200B;)] &#x542C;U&#x7FA4;&#x795E;&#x4ED9;&#x8BB2;&#x8BC4;&#x540E;&#x53D1;&#x73B0;&#x8FD9;&#x73A9;&#x610F;&#x513F;&#x80FD;&#x6839;&#x53F7;&#x5206;&#x6CBB;&#xFF0C;&#x4E8E;&#x662F;&#x505A;&#x5B8C;&#x4E86; CODE cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;#include&lt;tr1/unordered_map&gt;#define ri register intusing namespace std;typedef long long ll;typedef vector&lt;int&gt; poly;typedef pair&lt;int,int&gt; pii;#define fi first#define se second#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() getchar()inline int read() { int ans=0; char ch=gc(); bool f=1; while(!isdigit(ch)) f^=ch==&apos;-&apos;,ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;}inline ll readl() { ll ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s) { int top=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) s[++top]=ch,ch=gc(); return top;}namespace modular { const int mod=1e9+7; inline int add(int a,int b) { return a+b&lt;mod?a+b:a+b-mod; } inline int dec(int a,int b) { return a&lt;b?a-b+mod:a-b; } inline int mul(int a,int b) { return (ll)a*b%mod; } inline void Add(int&amp;a,int b) { a=a+b&lt;mod?a+b:a+b-mod; } inline void Dec(int&amp;a,int b) { a=a&lt;b?a-b+mod:a-b; } inline void Mul(int&amp;a,int b) { a=(ll)a*b%mod; } inline int ksm(int a,int p) { int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; } inline int Inv(int a) { return ksm(a,mod-2); }}const int N=2e5+5;char s[N];int n,nxt[N],blo,pre[N];tr1::unordered_map&lt;ll,int&gt; cnt;inline ll C2(int x) { return (ll)x*(x-1)&gt;&gt;1; }int main() { #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=Read(s),blo=min(n,150); for(ri i=n,nxt_=n+1;i;--i) { if(s[i]==&apos;1&apos;) nxt_=i; nxt[i]=nxt_; } for(ri i=1;i&lt;=n;++i) pre[i]=pre[i-1]+(s[i]==&apos;1&apos;); ll res=0; for(ri t=1;t&lt;=blo;++t) { cnt.clear(); for(ri i=0;i&lt;=n;++i) ++cnt[i-pre[i]*t]; for(tr1::unordered_map&lt;ll,int&gt;::iterator it=cnt.begin();it!=cnt.end();++it) res+=C2(it-&gt;se); } for(ri r,len,l=1,tm;l&lt;=n;++l) { tm=1; r=nxt[l]; while(r&lt;=n&amp;&amp;l-1+tm*blo&lt;=n) { len=(nxt[r+1]-l)/tm; res+=max(0,len-max(blo,(r-l)/tm)); r=nxt[r+1],++tm; } } cout&lt;&lt;res; return 0;} G &#x8FD9;&#x9898;&#x660E;&#x663E;&#x6BD4;E&#x7B80;&#x5355; &#x53D1;&#x73B0;&#x53EF;&#x4EE5;&#x62C6;&#x6210;&#x4E24;&#x4E2A;&#x6570;&#x5217; A=(1,2,...,n)A=(1,2,...,n)A=(1,2,...,n) &#x548C; B=(1&#x2212;a1,2&#x2212;a2,...,n&#x2212;an)B=(1-a_1,2-a_2,...,n-a_n)B=(1&#x2212;a1&#x200B;,2&#x2212;a2&#x200B;,...,n&#x2212;an&#x200B;) &#x8FD9;&#x6837; Bi&#x2208;[1,n]B_i\\in[1,n]Bi&#x200B;&#x2208;[1,n] &#x7136;&#x540E;&#x8981;&#x9009;&#x51FA;&#x82E5;&#x5E72;&#x4E0B;&#x6807;&#x4F7F;&#x5F97; &#x2211;Ai=&#x2211;Bi\\sum\\limits A_i=\\sum\\limits B_i&#x2211;Ai&#x200B;=&#x2211;Bi&#x200B; &#x90A3;&#x4E48;&#x5047;&#x5982;&#x9009;&#x4E86;&#x7B2C; iii &#x4E2A;&#x4F4D;&#x7F6E;&#xFF0C;&#x8003;&#x8651;&#x9009;&#x7B2C; BiB_iBi&#x200B; &#x4E2A;&#x4F4D;&#x7F6E;&#x4F7F;&#x5F97; ABiA_{B_i}ABi&#x200B;&#x200B; &#x8DDF; BiB_iBi&#x200B; &#x62B5;&#x6D88;&#xFF0C;&#x8FD9;&#x6837;&#x6211;&#x4EEC;&#x53C8;&#x8981;&#x9009; BABiB_{A_{B_i}}BABi&#x200B;&#x200B;&#x200B; &#x8FD9;&#x4E2A;&#x4F4D;&#x7F6E;&#xFF0C;&#x8FD9;&#x6837;&#x9009;&#x4E0B;&#x53BB;&#x5C31;&#x4F1A;&#x5F62;&#x6210;&#x4E00;&#x4E2A;&#x6EE1;&#x8DB3;&#x9898;&#x610F;&#x7684;&#x73AF; CODE cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;#include&lt;tr1/unordered_map&gt;#define ri register intusing namespace std;typedef long long ll;typedef vector&lt;int&gt; poly;typedef pair&lt;int,int&gt; pii;#define fi first#define se second#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() getchar()inline int read() { int ans=0; char ch=gc(); bool f=1; while(!isdigit(ch)) f^=ch==&apos;-&apos;,ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;}inline ll readl() { ll ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s) { int top=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) s[++top]=ch,ch=gc(); return top;}namespace modular { const int mod=1e9+7; inline int add(int a,int b) { return a+b&lt;mod?a+b:a+b-mod; } inline int dec(int a,int b) { return a&lt;b?a-b+mod:a-b; } inline int mul(int a,int b) { return (ll)a*b%mod; } inline void Add(int&amp;a,int b) { a=a+b&lt;mod?a+b:a+b-mod; } inline void Dec(int&amp;a,int b) { a=a&lt;b?a-b+mod:a-b; } inline void Mul(int&amp;a,int b) { a=(ll)a*b%mod; } inline int ksm(int a,int p) { int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; } inline int Inv(int a) { return ksm(a,mod-2); }}const int N=1e6+5;int n,nxt[N],du[N],que[N],hd,tl;bool vs[N];int main() { #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif for(ri tt=read();tt;--tt) { n=read(); for(ri i=1;i&lt;=n;++i) du[i]=vs[i]=0; for(ri i=1;i&lt;=n;++i) nxt[i]=i-read(),++du[nxt[i]]; for(ri i=1;i&lt;=n;++i) if(!du[i]) que[++tl]=i; while(hd&lt;=tl) { int x=que[hd++]; vs[x]=1; --du[nxt[x]]; if(!du[nxt[x]]) que[++tl]=nxt[x]; } for(ri i=1;i&lt;=n;++i) if(!vs[i]) { vector&lt;int&gt;res; while(!vs[i]) { res.pb(i); vs[i]=1; i=nxt[i]; } cout&lt;&lt;(int)res.size()&lt;&lt;&apos;\\n&apos;; for(ri i=0;i&lt;(int)res.size();++i) cout&lt;&lt;res[i]&lt;&lt;&apos; &apos;; puts(&quot;&quot;); break; } } return 0;} H &#x60F3;&#x4E86;&#x8D3C;&#x4E45;&#x90FD;&#x4E0D;&#x4F1A;&#x505A;&#x7684;&#x795E;&#x4ED9;&#x9898; &#x8003;&#x8651;&#x6BCF;&#x4E2A;&#x8FDE;&#x901A;&#x5757;&#x4E00;&#x5B9A;&#x662F;&#x4E00;&#x4E2A;&#x5B50;&#x533A;&#x95F4;&#xFF0C;&#x5047;&#x8BBE;&#x6700;&#x540E;&#x5212;&#x5206;&#x6210;&#x4E86; [l1,r1],[l2,r2],...,[ln,rn][l_1,r_1],[l_2,r_2],...,[l_n,r_n][l1&#x200B;,r1&#x200B;],[l2&#x200B;,r2&#x200B;],...,[ln&#x200B;,rn&#x200B;] &#x90A3;&#x4E48;&#x6EE1;&#x8DB3; max1&#x2265;min1&#x2265;max2&#x2265;min2&#x2265;&#x22EF;&#x2265;maxn&#x2265;minnmax_1 \\ge min_1\\ge max_2\\ge min_2\\ge\\cdots\\ge max_n\\ge min_nmax1&#x200B;&#x2265;min1&#x200B;&#x2265;max2&#x200B;&#x2265;min2&#x200B;&#x2265;&#x22EF;&#x2265;maxn&#x200B;&#x2265;minn&#x200B; &#x4E5F;&#x5C31;&#x662F;&#x8BF4;&#xFF0C;&#x6700;&#x540E;&#x7684;&#x6BB5;&#x6570;&#x7B49;&#x4E8E;&#x6EE1;&#x8DB3; min&#x2061;[1,i]&#x2265;max&#x2061;[i+1,n]\\min[1,i]\\ge\\max[i+1,n]min[1,i]&#x2265;max[i+1,n] &#x7684; iii &#x7684;&#x6570;&#x91CF; &#x7136;&#x540E;&#x518D;&#x8FDB;&#x884C;&#x4E00;&#x4E2A;&#x795E;&#x4ED9;&#x8F6C;&#x5316;&#xFF0C;&#x53D1;&#x73B0;&#x5BF9;&#x4E8E;&#x4E00;&#x4E2A;&#x6570; HHH &#xFF0C;&#x6211;&#x4EEC;&#x6784;&#x9020;&#x4E00;&#x4E2A;&#x6570;&#x5217; b=(a1&#x2265;H,a2&#x2265;H,...,an&#x2265;H)b=(a_1\\ge H,a_2\\ge H,...,a_n\\ge H)b=(a1&#x200B;&#x2265;H,a2&#x200B;&#x2265;H,...,an&#x200B;&#x2265;H) &#xFF0C;&#x90A3;&#x4E48;&#x6700;&#x540E;&#x5982;&#x679C;&#x8FD9;&#x4E2A;&#x6570;&#x5217;&#x6EE1;&#x8DB3;&#x6761;&#x4EF6;&#x90A3;&#x4E48;&#x4E00;&#x5B9A;&#x662F; 11&#x22EF;100&#x22EF;011\\cdots100\\cdots011&#x22EF;100&#x22EF;0 &#x8FD9;&#x6837;&#x7684;&#xFF0C;&#x4E8E;&#x662F;&#x6211;&#x4EEC;&#x5BF9;&#x4E8E;&#x6240;&#x6709; HHH &#x7EF4;&#x62A4;&#x5176;&#x5BF9;&#x5E94; bbb &#x6570;&#x5217;&#x7684; bi=&#x338;bi+1b_i\\not=b_{i+1}bi&#x200B;&#xE020;&#x200B;=bi+1&#x200B; &#x6570;&#x91CF;&#xFF0C;&#x53D1;&#x73B0;&#x6BCF;&#x6B21;&#x4FEE;&#x6539; aia_iai&#x200B; &#x4F1A;&#x5BF9;&#x4E00;&#x6BB5;&#x8FDE;&#x7EED;&#x7684; HHH &#x4EA7;&#x751F; &#xB1;1\\pm1&#xB1;1 &#x7684;&#x5F71;&#x54CD;&#xFF0C;&#x7528;&#x7EBF;&#x6BB5;&#x6811;&#x7EF4;&#x62A4;&#x5373;&#x53EF; CODE cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;bits/stdc++.h&gt;#include&lt;tr1/unordered_map&gt;#define ri register intusing namespace std;typedef long long ll;typedef vector&lt;int&gt; poly;typedef pair&lt;int,int&gt; pii;#define fi first#define se second#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() getchar()inline int read() { int ans=0; char ch=gc(); bool f=1; while(!isdigit(ch)) f^=ch==&apos;-&apos;,ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;}inline ll readl() { ll ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}namespace modular { const int mod=1e9+7; inline int add(int a,int b) { return a+b&lt;mod?a+b:a+b-mod; } inline int dec(int a,int b) { return a&lt;b?a-b+mod:a-b; } inline int mul(int a,int b) { return (ll)a*b%mod; } inline void Add(int&amp;a,int b) { a=a+b&lt;mod?a+b:a+b-mod; } inline void Dec(int&amp;a,int b) { a=a&lt;b?a-b+mod:a-b; } inline void Mul(int&amp;a,int b) { a=(ll)a*b%mod; } inline int ksm(int a,int p) { int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; } inline int Inv(int a) { return ksm(a,mod-2); }}const int N=1e6+5;int n,m,a[N];bool vs[N];namespace sgt { #define lc (p&lt;&lt;1) #define rc (p&lt;&lt;1|1) #define mid (l+r&gt;&gt;1) int mn[N&lt;&lt;2],ct[N&lt;&lt;2],tg[N&lt;&lt;2]; inline void pushnow(int p,int v) { tg[p]+=v,mn[p]+=v; } inline void pushdown(int p) { if(tg[p]) pushnow(lc,tg[p]),pushnow(rc,tg[p]),tg[p]=0; } inline void pushup(int p) { mn[p]=min(mn[lc],mn[rc]); ct[p]=(mn[lc]==mn[p]?ct[lc]:0)+(mn[rc]==mn[p]?ct[rc]:0); } inline void build(int p,int l,int r) { mn[p]=0x3f3f3f3f,ct[p]=tg[p]=0; if(l==r) { if(vs[l]) mn[p]=0; ct[p]=1; return; } build(lc,l,mid),build(rc,mid+1,r); pushup(p); } inline void update(int p,int l,int r,int ql,int qr,int v) { if(ql&lt;=l&amp;&amp;r&lt;=qr) return pushnow(p,v); pushdown(p); if(qr&lt;=mid) update(lc,l,mid,ql,qr,v); else if(ql&gt;mid) update(rc,mid+1,r,ql,qr,v); else update(lc,l,mid,ql,qr,v),update(rc,mid+1,r,ql,qr,v); pushup(p); } #undef lc #undef rc #undef mid}const int L=0,R=1e6;inline void update(int ps,int coe) { sgt::update(1,L,R,min(a[ps],a[ps-1]),max(a[ps],a[ps-1])-1,coe); }int main() { #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(),m=read(); a[0]=1000001,a[n+1]=0; for(ri i=1;i&lt;=n;++i) a[i]=read(),vs[a[i]]=1; sgt::build(1,L,R); for(ri i=1;i&lt;=n+1;++i) update(i,1); for(ri i=1,ps,vl;i&lt;=m;++i) { ps=read(),vl=read(); update(ps,-1),update(ps+1,-1); sgt::update(1,L,R,a[ps],a[ps],0x3f3f3f3f); a[ps]=vl; sgt::update(1,L,R,a[ps],a[ps],-0x3f3f3f3f); update(ps,1),update(ps+1,1); cout&lt;&lt;sgt::ct[1]&lt;&lt;&apos;\\n&apos;; } return 0;} I &#x795E;&#x4ED9;&#x6784;&#x9020;&#x9898;&#xFF01; &#x5047;&#x8BBE;&#x5F53;&#x524D;&#x5BF9; (x,y)(x,y)(x,y) &#x64CD;&#x4F5C;&#x4F1A;&#x5F71;&#x54CD; (x+xi&#x2212;x1,x+yi&#x2212;y1)(x+x_i-x_1,x+y_i-y_1)(x+xi&#x200B;&#x2212;x1&#x200B;,x+yi&#x200B;&#x2212;y1&#x200B;) &#x7684; aaa &#x503C;&#xFF0C;&#x90A3;&#x4E48;&#x6784;&#x9020;&#x51FD;&#x6570; fx,y=&#x2295;ax&#x2212;(xi&#x2212;x1),y&#x2212;(yi&#x2212;y1)f_{x,y}=\\oplus a_{x-(x_i-x_1),y-(y_i-y_1)}fx,y&#x200B;=&#x2295;ax&#x2212;(xi&#x200B;&#x2212;x1&#x200B;),y&#x2212;(yi&#x200B;&#x2212;y1&#x200B;)&#x200B; &#xFF0C;&#x8FD9;&#x6837;&#x5982;&#x679C;&#x5BF9; (x,y)(x,y)(x,y) &#x64CD;&#x4F5C;&#x5C31;&#x7B49;&#x4EF7;&#x4E8E;&#x5F71;&#x54CD; (x+2(xi&#x2212;x1),y+2(yi&#x2212;y1))(x+2(x_i-x_1),y+2(y_i-y_1))(x+2(xi&#x200B;&#x2212;x1&#x200B;),y+2(yi&#x200B;&#x2212;y1&#x200B;)) &#x7684; fff &#x503C;&#xFF0C;&#x90A3;&#x4E48;&#x5C31;&#x76F8;&#x5F53;&#x4E8E;&#x6784;&#x9020;&#x51FA;&#x4E86;&#x65B0;&#x56FE;&#xFF0C;&#x6BCF;&#x6B21;&#x4F4D;&#x79FB;&#x7684;&#x5411;&#x91CF;&#x4ECE; (xi&#x2212;x1,yi&#x2212;y1)(x_i-x_1,y_i-y_1)(xi&#x200B;&#x2212;x1&#x200B;,yi&#x200B;&#x2212;y1&#x200B;) &#x53D8;&#x6210;&#x4E86; (2(xi&#x2212;x1),2(yi,y1))(2(x_i-x_1),2(y_i,y_1))(2(xi&#x200B;&#x2212;x1&#x200B;),2(yi&#x200B;,y1&#x200B;)) &#xFF0C;&#x663E;&#x7136;&#x5728; kkk &#x8F6E;&#x4E4B;&#x540E;&#x6240;&#x6709;&#x5411;&#x91CF;&#x5728;&#x6A21;&#x610F;&#x4E49;&#x4E0B;&#x662F;&#x7B49;&#x4EF7;&#x7684;&#xFF0C;&#x56E0;&#x6B64;&#x53EA;&#x9700;&#x8981;&#x770B; kkk &#x8F6E;&#x4E4B;&#x540E;&#x9700;&#x8981;&#x88AB;&#x5F02;&#x6216;&#x7684;&#x4F4D;&#x7F6E;&#x7684;&#x6570;&#x91CF;&#x5373;&#x53EF; CODE cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;#include&lt;tr1/unordered_map&gt;#define ri register intusing namespace std;typedef long long ll;typedef vector&lt;int&gt; poly;typedef pair&lt;int,int&gt; pii;#define fi first#define se second#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() getchar()inline ll readl() { ll ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}namespace modular { const int mod=1e9+7; inline int add(int a,int b) { return a+b&lt;mod?a+b:a+b-mod; } inline int dec(int a,int b) { return a&lt;b?a-b+mod:a-b; } inline int mul(int a,int b) { return (ll)a*b%mod; } inline void Add(int&amp;a,int b) { a=a+b&lt;mod?a+b:a+b-mod; } inline void Dec(int&amp;a,int b) { a=a&lt;b?a-b+mod:a-b; } inline void Mul(int&amp;a,int b) { a=(ll)a*b%mod; } inline int ksm(int a,int p) { int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; } inline int Inv(int a) { return ksm(a,mod-2); }}int n,m;int main() { #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=1&lt;&lt;readl(); vector&lt;vector&lt;ll&gt; &gt;a(n,vector&lt;ll&gt;(n)); for(ri i=0;i&lt;n;++i) for(ri j=0;j&lt;n;++j) a[i][j]=readl(); m=readl(); vector&lt;pii&gt;dt(m); for(ri i=0;i&lt;m;++i) dt[i].fi=readl(),dt[i].se=readl(); for(ri i=1;i&lt;m;++i) dt[i].fi-=dt[0].fi,dt[i].se-=dt[0].se; dt[0]=pii(0,0); for(ri t=1;t&lt;=n;t&lt;&lt;=1) { vector&lt;vector&lt;ll&gt; &gt;cur(n,vector&lt;ll&gt;(n)); for(ri i=0;i&lt;n;++i) for(ri j=0;j&lt;n;++j) { cur[i][j]=0; for(ri k=0;k&lt;m;++k) cur[i][j]^=a[((i-dt[k].fi)%n+n)%n][((j-dt[k].se)%n+n)%n]; } a=cur; for(ri i=0;i&lt;m;++i) dt[i].fi&lt;&lt;=1,dt[i].se&lt;&lt;=1; } int res=0; for(ri i=0;i&lt;n;++i) for(ri j=0;j&lt;n;++j) if(a[i][j]) ++res; cout&lt;&lt;res; return 0;}","categories":[{"name":"public","slug":"public","permalink":"http://xdl030112.github.io/categories/public/"}],"tags":[{"name":"比赛题解","slug":"比赛题解","permalink":"http://xdl030112.github.io/tags/%E6%AF%94%E8%B5%9B%E9%A2%98%E8%A7%A3/"}]},{"title":"杂题乱做 Round13","slug":"sol13","date":"2019-12-28T08:51:17.000Z","updated":"2019-12-28T09:27:43.158Z","comments":true,"path":"sol13/","link":"","permalink":"http://xdl030112.github.io/sol13/","excerpt":"","text":"Transforming Sequence &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x9996;&#x5148;&#x5047;&#x5982; n&gt;kn&gt;kn&gt;k &#x4E00;&#x5B9A;&#x4E0D;&#x5408;&#x6CD5;&#xFF0C;&#x90A3;&#x4E48;&#x5224;&#x65AD;&#x4E4B;&#x540E;&#x4E00;&#x5B9A;&#x6709; n&#x2264;kn\\le kn&#x2264;k &#x8003;&#x8651;&#x8BBE; fi,jf_{i,j}fi,j&#x200B; &#x8868;&#x793A;&#x524D; iii &#x4E2A;&#x6570;&#x5360;&#x7528;&#x4E86; jjj &#x4E2A;&#x6574;&#x6570;&#x4F4D;&#x7684;&#x65B9;&#x6848;&#x6570;&#xFF0C;&#x8FD9;&#x6837;&#x53EF;&#x4EE5;&#x5217;&#x51FA;&#x8F6C;&#x79FB;&#x5F0F;&#xFF1A; fi,j=&#x2211;k&#x2264;jfi&#x2212;1,k(jk)2kf_{i,j}=\\sum\\limits_{k\\le j}f_{i-1,k}\\binom{j}{k}2^{k}fi,j&#x200B;=k&#x2264;j&#x2211;&#x200B;fi&#x2212;1,k&#x200B;(kj&#x200B;)2k &#x7136;&#x540E;&#x5C31;&#x53EF;&#x4EE5; dp &#x9012;&#x63A8;&#x5566;&#xFF01; &#x7136;&#x540E;&#x4F60;&#x5C31; TLE &#x4E86;&#x3002; &#x4ED4;&#x7EC6;&#x89C2;&#x5BDF;&#x53D1;&#x73B0;&#x8FD9;&#x4E2A;&#x8F6C;&#x79FB;&#x8DDF;&#x7B2C;&#x4E00;&#x7EF4;&#x5173;&#x7CFB;&#x4E0D;&#x5927;&#xFF0C;&#x56E0;&#x6B64;&#x53EF;&#x4EE5;&#x8003;&#x8651;&#x500D;&#x589E;&#x4F18;&#x5316; DP &#xFF0C;&#x5047;&#x8BBE; X+Y=iX+Y=iX+Y=i &#x90A3;&#x4E48; fi,j=&#x2211;k&lt;jfX,k(jk)2kXfY,j&#x2212;kf_{i,j}=\\sum\\limits_{k&lt;j}f_{X,k}\\binom{j}{k}2^{kX}f_{Y,j-k}fi,j&#x200B;=k&lt;j&#x2211;&#x200B;fX,k&#x200B;(kj&#x200B;)2kXfY,j&#x2212;k&#x200B; &#xFF0C;&#x7136;&#x540E;&#x8FD9;&#x4E2A;&#x53EF;&#x4EE5;&#x76F4;&#x63A5; fft &#x641E;&#xFF0C;&#x7531;&#x4E8E;&#x6A21;&#x6570;&#x7684;&#x539F;&#x56E0;&#x83BD;&#x4E00;&#x53D1; mtt &#x5373;&#x53EF; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef vector&lt;int&gt; poly;namespace modular { const int mod=1e9+7; inline int add(int a,int b) { return a+b&lt;mod?a+b:a+b-mod; } inline int dec(int a,int b) { return a&lt;b?a-b+mod:a-b; } inline int mul(int a,int b) { return (ll)a*b%mod; } inline void Add(int&amp;a,int b) { a=a+b&lt;mod?a+b:a+b-mod; } inline void Dec(int&amp;a,int b) { a=a&lt;b?a-b+mod:a-b; } inline void Mul(int&amp;a,int b) { a=(ll)a*b%mod; } inline int ksm(int a,int p) { int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; } inline int Inv(int a) { return ksm(a,mod-2); }}using namespace modular;struct cp { double x,y; cp(double x=0,double y=0):x(x),y(y) {} friend inline cp operator+(cp a,cp b) { return cp(a.x+b.x,a.y+b.y); } friend inline void operator+=(cp&amp;a,cp b) { a=a+b; } friend inline cp operator-(cp a,cp b) { return cp(a.x-b.x,a.y-b.y); } friend inline void operator-=(cp&amp;a,cp b) { a=a-b; } friend inline cp operator*(cp a,cp b) { return cp(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x); } friend inline void operator*=(cp&amp;a,cp b) { a=a*b; } friend inline cp operator*(cp a,double b) { return cp(a.x*b,a.y*b); } friend inline void operator*=(cp&amp;a,double b) { a=a*b; } friend inline cp operator/(cp a,double b) { return cp(a.x/b,a.y/b); } friend inline void operator/=(cp&amp;a,double b) { a=a/b; } inline cp operator~() const { return cp(x,-y); }};typedef vector&lt;cp&gt; polyr;const int blo=(1&lt;&lt;15)-1;int lim,tim;vector&lt;cp&gt; w[20];vector&lt;int&gt; rev[20];const double pi=acos(-1.0);inline void init_fft() { w[19].resize(1&lt;&lt;19); for(ri i=0,lm=1&lt;&lt;19;i&lt;lm;++i) w[19][i]=cp(cos(pi/lm*i),sin(pi/lm*i)); for(ri i=18;~i;--i) { w[i].resize(1&lt;&lt;i); for(ri j=0,lm=1&lt;&lt;i;j&lt;lm;++j) w[i][j]=w[i+1][j&lt;&lt;1]; }}inline void init(int up) { lim=1,tim=0; while(lim&lt;up) lim&lt;&lt;=1,++tim; if(rev[tim].size()) return; rev[tim].resize(lim); for(ri i=1;i&lt;lim;++i) rev[tim][i]=(rev[tim][i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(tim-1));}inline void fft(polyr&amp;a,int typ) { for(ri i=1;i&lt;lim;++i) if(i&lt;rev[tim][i]) swap(a[i],a[rev[tim][i]]); cp a0,a1; for(ri i=1,t=0;i&lt;lim;i&lt;&lt;=1,++t) for(ri j=0;j&lt;lim;j+=i&lt;&lt;1) for(ri k=0;k&lt;i;++k) { a0=a[j+k],a1=a[j+k+i]*w[t][k]; a[j+k]=a0+a1,a[j+k+i]=a0-a1; } if(~typ) return; reverse(++a.begin(),a.end()); for(ri i=0;i&lt;lim;++i) a[i]/=lim;}inline poly operator*(poly a,poly b) { int n=(int)a.size(),m=(int)b.size(),t=n+m-1; poly c(t); init(t); polyr A(lim),B(lim),P(lim),Q(lim); for(ri i=0;i&lt;n;++i) A[i]=cp(a[i]&gt;&gt;15,a[i]&amp;blo); for(ri i=0;i&lt;m;++i) B[i]=cp(b[i]&gt;&gt;15,b[i]&amp;blo); fft(A,1),fft(B,1); cp cur[4]; for(ri i=0,j=0;i&lt;lim;++i,j=j?j-1:lim-1) { cur[0]=(A[i]+(~A[j]))*cp(0.5,0); cur[1]=((~A[j])-A[i])*cp(0,0.5); cur[2]=(B[i]+(~B[j]))*cp(0.5,0); cur[3]=((~B[j])-B[i])*cp(0,0.5); P[i]=cur[0]*cur[2]+cp(0,1)*cur[1]*cur[3]; Q[i]=cur[0]*cur[3]+cp(0,1)*cur[1]*cur[2]; } fft(P,-1),fft(Q,-1); ll cr[4]; for(ri i=0;i&lt;t;++i) { cr[0]=(ll)(P[i].x+0.5)%mod; cr[1]=(ll)(P[i].y+0.5)%mod; cr[2]=(ll)(Q[i].x+0.5)%mod; cr[3]=(ll)(Q[i].y+0.5)%mod; c[i]=((cr[0]&lt;&lt;30)+(cr[2]+cr[3]&lt;&lt;15)+cr[1])%mod; } return c;}const int N=30005;ll n;int fac[N],ifac[N],K,pw1[N&lt;&lt;1],pw2[N&lt;&lt;1];inline int getpw(int x) { return mul(pw1[x%blo],pw2[x/blo]); };inline void init() { fac[0]=fac[1]=ifac[0]=ifac[1]=1; for(ri i=2;i&lt;=K;++i) { fac[i]=mul(fac[i-1],i); ifac[i]=mul(ifac[mod-mod/i*i],mod-mod/i); } for(ri i=2;i&lt;=K;++i) Mul(ifac[i],ifac[i-1]); pw1[0]=pw2[0]=1; for(ri i=1;i&lt;=blo;++i) pw1[i]=add(pw1[i-1],pw1[i-1]); for(ri i=1;i&lt;=blo;++i) pw2[i]=mul(pw2[i-1],pw1[blo]);}inline int C(int n,int m) { return n&lt;m||m&lt;0?0:mul(fac[n],mul(ifac[m],ifac[n-m])); }inline poly poly_mul(poly a,poly b,int len) { for(ri i=0,n=(int)a.size();i&lt;n;++i) Mul(a[i],getpw((ll)i*len%(mod-1))); return a*b;}int main() { #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif cin&gt;&gt;n&gt;&gt;K; if(n&gt;K) return cout&lt;&lt;0,0; init(),init_fft(); poly res,a(K+1); for(ri i=1;i&lt;=K;++i) a[i]=ifac[i]; res=a,--n; for(ri len=1;n;n&gt;&gt;=1,a=poly_mul(a,a,len),a.resize(K+1),len&lt;&lt;=1) if(n&amp;1) { res=poly_mul(res,a,len); res.resize(K+1); } int ss=0; for(ri i=0;i&lt;=K;++i) Add(ss,mul(res[i],ifac[K-i])); cout&lt;&lt;mul(ss,fac[K]); return 0;} &#x5C04;&#x547D;&#x4E38;&#x6587;&#x7684;&#x7B14;&#x8BB0; &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x8003;&#x8651;&#x7ADE;&#x8D5B;&#x56FE;&#x7684;&#x6027;&#x8D28;&#xFF0C;&#x7531;&#x4E8E;&#x7F29;&#x4E86;&#x56FE;&#x4E4B;&#x540E;&#x4E00;&#x5B9A;&#x662F;&#x94FE;&#x72B6;&#xFF0C;&#x56E0;&#x6B64;&#x8003;&#x8651;&#x679A;&#x4E3E;&#x94FE;&#x5C3E;&#x7684;&#x96C6;&#x5408;&#x5373;&#x53EF;&#x8BA1;&#x7B97;&#x7B54;&#x6848;&#xFF0C;&#x8BBE; fif_ifi&#x200B; &#x8868;&#x793A; iii &#x4E2A;&#x70B9;&#x7B54;&#x6848;&#xFF0C;&#x90A3;&#x4E48;&#x6709; fi=2(i2)&#x2212;&#x2211;j=1ifj(ij)2(j2)f_i=2^{\\binom{i}2}-\\sum\\limits_{j=1}^if_j\\binom{i}{j}2^{\\binom j2}fi&#x200B;=2(2i&#x200B;)&#x2212;j=1&#x2211;i&#x200B;fj&#x200B;(ji&#x200B;)2(2j&#x200B;) &#xFF0C;&#x591A;&#x9879;&#x5F0F;&#x6C42;&#x9006;&#x5373;&#x53EF; CODE cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef vector&lt;int&gt; poly;namespace modular { const int mod=998244353; inline int add(int a,int b) { return a+b&lt;mod?a+b:a+b-mod; } inline int dec(int a,int b) { return a&lt;b?a-b+mod:a-b; } inline int mul(int a,int b) { return (ll)a*b%mod; } inline void Add(int&amp;a,int b) { a=a+b&lt;mod?a+b:a+b-mod; } inline void Dec(int&amp;a,int b) { a=a&lt;b?a-b+mod:a-b; } inline void Mul(int&amp;a,int b) { a=(ll)a*b%mod; } inline int ksm(int a,int p) { int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; } inline int Inv(int a) { return ksm(a,mod-2); }}using namespace modular;int lim,tim,invv[23],w[23];vector&lt;int&gt;rev[23];inline void init_ntt() { invv[0]=1; for(ri i=1,iv=mod+1&gt;&gt;1;i&lt;23;++i) invv[i]=mul(invv[i-1],iv); w[22]=ksm(3,(mod-1)&gt;&gt;23); for(ri i=21;~i;--i) w[i]=mul(w[i+1],w[i+1]);}inline void init(int up) { lim=1,tim=0; while(lim&lt;up) lim&lt;&lt;=1,++tim; if(rev[tim].size()) return; rev[tim].resize(lim); for(ri i=1;i&lt;lim;++i) rev[tim][i]=(rev[tim][i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(tim-1));}inline void ntt(poly&amp;a,int typ) { for(ri i=1;i&lt;lim;++i) if(i&lt;rev[tim][i]) swap(a[i],a[rev[tim][i]]); for(ri i=1,t=0,a0,a1,mt;i&lt;lim;i&lt;&lt;=1,++t) for(ri j=0;j&lt;lim;j+=i&lt;&lt;1) { mt=1; for(ri k=0;k&lt;i;++k,Mul(mt,w[t])) { a0=a[j+k],a1=mul(a[j+k+i],mt); a[j+k]=add(a0,a1),a[j+k+i]=dec(a0,a1); } } if(~typ) return; reverse(++a.begin(),a.end()); for(ri i=0;i&lt;lim;++i) Mul(a[i],invv[tim]); }inline poly poly_inv(poly a,int K) { poly b(1,Inv(a[0])),c; for(ri i=1;i&lt;K;i&lt;&lt;=1) { init(i&lt;&lt;2); b.resize(lim),ntt(b,1); c=a,c.resize(i&lt;&lt;1),c.resize(lim),ntt(c,1); for(ri j=0;j&lt;lim;++j) Mul(b[j],dec(2,mul(b[j],c[j]))); ntt(b,-1),b.resize(i&lt;&lt;1); } return b.resize(K),b;}const int N=100005;int n,fac[N],ifac[N],pw1[1&lt;&lt;15|5],pw2[1&lt;&lt;15|5],md=(1&lt;&lt;15)-1;inline int getpw(int x) { return mul(pw1[x&amp;md],pw2[x&gt;&gt;15]); }inline void init() { fac[0]=fac[1]=ifac[0]=ifac[1]=1; for(ri i=2;i&lt;=n;++i) { fac[i]=mul(fac[i-1],i); ifac[i]=mul(ifac[mod-mod/i*i],mod-mod/i); } for(ri i=2;i&lt;=n;++i) Mul(ifac[i],ifac[i-1]); pw1[0]=pw2[0]=1; for(ri i=1;i&lt;=md+1;++i) pw1[i]=add(pw1[i-1],pw1[i-1]); for(ri i=1;i&lt;=md+1;++i) pw2[i]=mul(pw2[i-1],pw1[md+1]);}int main() { #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif init_ntt(); cin&gt;&gt;n; init(); poly f(n+1); for(ri i=0;i&lt;=n;++i) f[i]=mul(ifac[i],getpw((ll)i*(i-1)/2%(mod-1))); f=poly_inv(f,n+1); for(ri i=0;i&lt;=n;++i) f[i]=mul(dec(!i,f[i]),fac[i]); if(n&gt;=1) puts(&quot;1&quot;); if(n&gt;=2) puts(&quot;-1&quot;); for(ri i=3;i&lt;=n;++i) cout&lt;&lt;mul(mul(fac[i-1],getpw(((ll)i*(i-1)/2-i)%(mod-1))),Inv(f[i]))&lt;&lt;&apos;\\n&apos;; return 0;} &#x8FB9;&#x53CC;&#x8FDE;&#x901A;&#x56FE;&#x8BA1;&#x6570; &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x4E0D;&#x4F1A;&#x7684;&#x8BF7;&#x81EA;&#x884C;&#x67E5;&#x9605; jcvb &#x7684;&#x56FD;&#x96C6;&#x961F;&#x8BBA;&#x6587;&#x6216;&#x8005;&#x76F4;&#x63A5;&#x627E;&#x535A;&#x4E3B;&#x672C;&#x4EBA;&#x8BE2;&#x95EE; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef vector&lt;int&gt; poly;#define pb push_backnamespace modular { const int mod=998244353; inline int add(int a,int b) { return a+b&lt;mod?a+b:a+b-mod; } inline int dec(int a,int b) { return a&lt;b?a-b+mod:a-b; } inline int mul(int a,int b) { return (ll)a*b%mod; } inline void Add(int&amp;a,int b) { a=a+b&lt;mod?a+b:a+b-mod; } inline void Dec(int&amp;a,int b) { a=a&lt;b?a-b+mod:a-b; } inline void Mul(int&amp;a,int b) { a=(ll)a*b%mod; } inline int ksm(int a,int p) { int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; } inline int Inv(int a) { return ksm(a,mod-2); }}using namespace modular;int lim,tim,invv[23],w[23],inv[1&lt;&lt;18],n;vector&lt;int&gt;rev[23];inline void init_ntt() { w[22]=ksm(3,(mod-1)&gt;&gt;23); for(ri i=21;~i;--i) w[i]=mul(w[i+1],w[i+1]); invv[0]=1; for(ri i=1,iv=mod+1&gt;&gt;1;i&lt;23;++i) invv[i]=mul(invv[i-1],iv); inv[1]=1; for(ri i=2,up=1&lt;&lt;18;i&lt;up;++i) inv[i]=mul(inv[mod-mod/i*i],mod-mod/i);}inline void init(int up) { lim=1,tim=0; while(lim&lt;up) lim&lt;&lt;=1,++tim; if(rev[tim].size()) return; rev[tim].resize(lim); for(ri i=1;i&lt;lim;++i) rev[tim][i]=(rev[tim][i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(tim-1));}inline void ntt(poly&amp;a,int typ) { for(ri i=1;i&lt;lim;++i) if(i&lt;rev[tim][i]) swap(a[i],a[rev[tim][i]]); for(ri i=1,t=0,a0,a1,mt;i&lt;lim;i&lt;&lt;=1,++t) for(ri j=0;j&lt;lim;j+=i&lt;&lt;1) { mt=1; for(ri k=0;k&lt;i;++k,Mul(mt,w[t])) { a0=a[j+k],a1=mul(a[j+k+i],mt); a[j+k]=add(a0,a1),a[j+k+i]=dec(a0,a1); } } if(~typ) return; reverse(++a.begin(),a.end()); for(ri i=0;i&lt;lim;++i) Mul(a[i],invv[tim]);}inline poly operator*(poly a,poly b) { int n=(int)a.size(),m=(int)b.size(),t=n+m-1; if(t&lt;=128) { poly c(t); for(ri i=0;i&lt;n;++i) if(a[i]) for(ri j=0;j&lt;m;++j) Add(c[i+j],mul(a[i],b[j])); return c; } init(t); a.resize(lim),ntt(a,1); b.resize(lim),ntt(b,1); for(ri i=0;i&lt;lim;++i) Mul(a[i],b[i]); return ntt(a,-1),a.resize(t),a;}inline poly operator-(poly a,poly b) { int n=(int)b.size(); if((int)a.size()&lt;n) a.resize(n); for(ri i=0;i&lt;n;++i) Dec(a[i],b[i]); return a;}inline poly poly_inv(poly a,int K) { poly b(1,Inv(a[0])),c; for(ri i=1;i&lt;K;i&lt;&lt;=1) { init(i&lt;&lt;2); b.resize(lim),ntt(b,1); c=a,c.resize(i&lt;&lt;1),c.resize(lim),ntt(c,1); for(ri j=0;j&lt;lim;++j) Mul(b[j],dec(2,mul(b[j],c[j]))); ntt(b,-1),b.resize(i&lt;&lt;1); } return b.resize(K),b;}inline poly poly_deriv(poly a) { for(ri i=1,up=(int)a.size();i&lt;up;++i) a[i-1]=mul(a[i],i); return a.pop_back(),a;}inline poly poly_integ(poly a) { a.pb(0); for(ri i=(int)a.size()-1;i;--i) a[i]=mul(inv[i],a[i-1]); return a[0]=0,a;}inline poly poly_ln(poly a,int K) { return a=poly_integ(poly_deriv(a)*poly_inv(a,K)),a.resize(K),a; }inline poly poly_exp(poly a,int K) { poly b(1,1),c; for(ri i=1;i&lt;K;i&lt;&lt;=1) { c=a,c.resize(i&lt;&lt;1),Add(c[0],1); c=c-poly_ln(b,i&lt;&lt;1),b=b*c,b.resize(i&lt;&lt;1); } return b.resize(K),b;}inline poly poly_ksm(poly a,int pw,int K) { a.resize(K); a=poly_ln(a,K); for(ri i=0;i&lt;K;++i) Mul(a[i],pw); a=poly_exp(a,K); return a;}int fac[100005],ifac[100005],pw1[1&lt;&lt;15|5],pw2[1&lt;&lt;15|5];const int sqr=(1&lt;&lt;15)-1;inline int getpw(int x) { return mul(pw1[x&amp;sqr],pw2[x&gt;&gt;15]); }inline int C(int n,int m) { return n&lt;m||m&lt;0?0:mul(fac[n],mul(ifac[m],ifac[n-m])); }poly F,G,cur1,cur2;inline void init() { fac[0]=fac[1]=ifac[0]=ifac[1]=1; for(ri i=2;i&lt;=100001;++i) { fac[i]=mul(fac[i-1],i); ifac[i]=mul(ifac[i-1],inv[i]); } pw1[0]=pw2[0]=1; for(ri i=1;i&lt;=sqr+1;++i) pw1[i]=add(pw1[i-1],pw1[i-1]); for(ri i=1;i&lt;=sqr+1;++i) pw2[i]=mul(pw2[i-1],pw1[sqr+1]); F.resize(100002),G; for(ri i=0;i&lt;=100001;++i) F[i]=mul(getpw((ll)i*(i-1)/2%(mod-1)),ifac[i]); F=poly_ln(F,100002); for(ri i=0;i&lt;100002;++i) Mul(F[i],i); G=F,F=poly_deriv(F); G=poly_inv(poly_exp(G,100002),100002);}int main() { #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif init_ntt(); init(); for(ri tt=5;tt;--tt) { cin&gt;&gt;n; cur1=F,cur1.resize(n+1); cur2=poly_ksm(G,n,n+1); cur1=cur1*cur2; cout&lt;&lt;mul(mul(fac[n-1],inv[n]),cur1[n-1])&lt;&lt;&apos;\\n&apos;; } return 0;} &#x70B9;&#x53CC;&#x8FDE;&#x901A;&#x56FE;&#x8BA1;&#x6570; &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x540C;&#x4E0A;&#x9898; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef vector&lt;int&gt; poly;#define pb push_backnamespace modular { const int mod=998244353; inline int add(int a,int b) { return a+b&lt;mod?a+b:a+b-mod; } inline int dec(int a,int b) { return a&lt;b?a-b+mod:a-b; } inline int mul(int a,int b) { return (ll)a*b%mod; } inline void Add(int&amp;a,int b) { a=a+b&lt;mod?a+b:a+b-mod; } inline void Dec(int&amp;a,int b) { a=a&lt;b?a-b+mod:a-b; } inline void Mul(int&amp;a,int b) { a=(ll)a*b%mod; } inline int ksm(int a,int p) { int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; } inline int Inv(int a) { return ksm(a,mod-2); } inline int fix(int a) { return (a%mod+mod)%mod; }}using namespace modular;int invv[23],w[23],lim,tim,inv[1&lt;&lt;20];vector&lt;int&gt;rev[23];inline void init_ntt() { invv[0]=1; for(ri i=1,iv=mod+1&gt;&gt;1;i&lt;23;++i) invv[i]=mul(invv[i-1],iv); w[22]=ksm(3,(mod-1)&gt;&gt;23); for(ri i=21;~i;--i) w[i]=mul(w[i+1],w[i+1]); inv[1]=1; for(ri i=2,up=1&lt;&lt;20;i&lt;up;++i) inv[i]=mul(inv[mod-mod/i*i],mod-mod/i);}inline void init(int up) { lim=1,tim=0; while(lim&lt;up) lim&lt;&lt;=1,++tim; if(rev[tim].size()) return; rev[tim].resize(lim); for(ri i=1;i&lt;lim;++i) rev[tim][i]=(rev[tim][i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(tim-1));}inline void ntt(poly&amp;a,int typ) { for(ri i=1;i&lt;lim;++i) if(i&lt;rev[tim][i]) swap(a[i],a[rev[tim][i]]); for(ri i=1,t=0,a0,a1,mt;i&lt;lim;i&lt;&lt;=1,++t) for(ri j=0;j&lt;lim;j+=i&lt;&lt;1) { mt=1; for(ri k=0;k&lt;i;++k,Mul(mt,w[t])) { a0=a[j+k],a1=mul(a[j+k+i],mt); a[j+k]=add(a0,a1),a[j+k+i]=dec(a0,a1); } } if(~typ) return; reverse(++a.begin(),a.end()); for(ri i=0;i&lt;lim;++i) Mul(a[i],invv[tim]);}inline poly operator*(poly a,poly b) { int n=(int)a.size(),m=(int)b.size(),t=n+m-1; if(t&lt;=128) { poly c(t); for(ri i=0;i&lt;n;++i) if(a[i]) for(ri j=0;j&lt;m;++j) Add(c[i+j],mul(a[i],b[j])); return c; } init(t); a.resize(lim),ntt(a,1); b.resize(lim),ntt(b,1); for(ri i=0;i&lt;lim;++i) Mul(a[i],b[i]); return ntt(a,-1),a.resize(t),a;}inline poly operator-(poly a,poly b) { int n=(int)b.size(); if((int)a.size()&lt;n) a.resize(n); for(ri i=0;i&lt;n;++i) Dec(a[i],b[i]); return a;}inline poly poly_inv(poly a,int K) { poly b(1,Inv(a[0])),c; for(ri i=1;i&lt;K;i&lt;&lt;=1) { init(i&lt;&lt;2); b.resize(lim),ntt(b,1); c=a,c.resize(i&lt;&lt;1),c.resize(lim),ntt(c,1); for(ri j=0;j&lt;lim;++j) Mul(b[j],dec(2,mul(b[j],c[j]))); ntt(b,-1),b.resize(i&lt;&lt;1); } return b.resize(K),b;}inline poly poly_deriv(poly a) { for(ri i=1,up=(int)a.size();i&lt;up;++i) a[i-1]=mul(a[i],i); return a.pop_back(),a;}inline poly poly_integ(poly a) { a.pb(0); for(ri i=(int)a.size()-1;i;--i) a[i]=mul(inv[i],a[i-1]); return a[0]=0,a;}inline poly poly_ln(poly a,int K) { return a=poly_integ(poly_deriv(a)*poly_inv(a,K)),a.resize(K),a; }inline poly poly_exp(poly a,int K) { poly b(1,1),c; for(ri i=1;i&lt;K;i&lt;&lt;=1) { c=a,c.resize(i&lt;&lt;1),Add(c[0],1); b=b*(c-poly_ln(b,i&lt;&lt;1)),b.resize(i&lt;&lt;1); } return b.resize(K),b;}const int N=1e5+5,blo=(1&lt;&lt;15)-1;int n,fac[N],ifac[N],pw1[N],pw2[N];inline int getpw(int x) { return mul(pw1[x&amp;blo],pw2[x&gt;&gt;15]); }poly cur1,cur2,F,G;inline void init() { fac[0]=fac[1]=ifac[0]=ifac[1]=1; for(ri i=2;i&lt;=100001;++i) { fac[i]=mul(fac[i-1],i); ifac[i]=mul(ifac[i-1],inv[i]); } pw1[0]=pw2[0]=1; for(ri i=1;i&lt;=blo+1;++i) pw1[i]=add(pw1[i-1],pw1[i-1]); for(ri i=1;i&lt;=blo+1;++i) pw2[i]=mul(pw2[i-1],pw1[blo+1]); F.resize(100002),G.resize(100001); for(ri i=0;i&lt;=100001;++i) F[i]=mul(ifac[i],getpw((ll)i*(i-1)/2%(mod-1))); F=poly_ln(F,100002); for(ri i=0;i&lt;=100001;++i) { Mul(F[i],i); if(i) G[i-1]=F[i]; } G=poly_deriv(F=poly_ln(G,100001));}int main() { #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif init_ntt(); init(); for(ri tt=5;tt;--tt) { cin&gt;&gt;n; if(n==1) { puts(&quot;1&quot;);continue; } cur1=G,cur1.resize(n); cur2=F,cur2.resize(n); for(ri i=0;i&lt;n;++i) Mul(cur2[i],mod-(n-1)); cur1=cur1*poly_exp(cur2,n); cout&lt;&lt;mul(fac[n-1],mul(inv[n-1],cur1[n-2]))&lt;&lt;&apos;\\n&apos;; } return 0;} calc&#x52A0;&#x5F3A;&#x7248; &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x53D1;&#x73B0;&#x7B54;&#x6848;&#x5C31;&#x662F; [xn]&#x220F;i=1A(1+ix)[x^n]\\prod\\limits_{i=1}^A(1+ix)[xn]i=1&#x220F;A&#x200B;(1+ix) &#x53D6;&#x4E2A;&#x5BF9;&#x6570;&#xFF1A; =[xn]e&#x2211;i=1Aln&#x2061;(1+ix)=[xn]e&#x2211;t=1A&#x2211;i&gt;0+&#x221E;(tx)ii(&#x2212;1)i+1=[xn]e&#x2211;i&gt;0+&#x221E;xi(&#x2212;1)i+1&#x2211;t=1Ati=[xn]e&#x2211;i&gt;0nxi(&#x2212;1)i+1&#x2211;t=1Ati\\begin{aligned} =&amp;[x^n]e^{\\sum\\limits_{i=1}^A\\ln(1+ix)}\\\\ =&amp;[x^n]e^{\\sum\\limits_{t=1}^A\\sum\\limits_{i&gt;0}^{+\\infty}\\frac{(tx)^i}{i}(-1)^{i+1}}\\\\ =&amp;[x^n]e^{\\sum\\limits_{i&gt;0}^{+\\infty}x^i(-1)^{i+1}\\sum\\limits_{t=1}^At^i}\\\\ =&amp;[x^n]e^{\\sum\\limits_{i&gt;0}^{n}x^i(-1)^{i+1}\\sum\\limits_{t=1}^At^i}\\\\ \\end{aligned} ====&#x200B;[xn]ei=1&#x2211;A&#x200B;ln(1+ix)[xn]et=1&#x2211;A&#x200B;i&gt;0&#x2211;+&#x221E;&#x200B;i(tx)i&#x200B;(&#x2212;1)i+1[xn]ei&gt;0&#x2211;+&#x221E;&#x200B;xi(&#x2212;1)i+1t=1&#x2211;A&#x200B;ti[xn]ei&gt;0&#x2211;n&#x200B;xi(&#x2212;1)i+1t=1&#x2211;A&#x200B;ti&#x200B; &#x53D1;&#x73B0;&#x540E;&#x9762;&#x4E00;&#x5768;&#x53EF;&#x4EE5;&#x6784;&#x9020; EGF &#x6C42;&#x548C;&#xFF1A; &#x2211;i=1Ait=[xt](&#x2211;i=1A&#x2211;j&gt;0+&#x221E;ijxii!)=[xt](&#x2211;i=1Aeix)=[xt]e(A+1)x&#x2212;1ex&#x2212;1\\begin{aligned} \\sum\\limits_{i=1}^Ai^t=&amp;[x^t](\\sum\\limits_{i=1}^A\\sum\\limits_{j&gt;0}^{+\\infty}\\frac{i^jx^i}{i!})\\\\ =&amp;[x^t](\\sum\\limits_{i=1}^Ae^{ix})\\\\ =&amp;[x^t]\\frac{e^{(A+1)x}-1}{e^x-1} \\end{aligned} i=1&#x2211;A&#x200B;it===&#x200B;[xt](i=1&#x2211;A&#x200B;j&gt;0&#x2211;+&#x221E;&#x200B;i!ijxi&#x200B;)[xt](i=1&#x2211;A&#x200B;eix)[xt]ex&#x2212;1e(A+1)x&#x2212;1&#x200B;&#x200B; &#x591A;&#x9879;&#x5F0F;&#x6C42;&#x9006;+&#x591A;&#x9879;&#x5F0F; exp &#x5373;&#x53EF; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef vector&lt;int&gt; poly;#define pb push_backnamespace modular { const int mod=998244353; inline int add(int a,int b) { return a+b&lt;mod?a+b:a+b-mod; } inline int dec(int a,int b) { return a&lt;b?a-b+mod:a-b; } inline int mul(int a,int b) { return (ll)a*b%mod; } inline void Add(int&amp;a,int b) { a=a+b&lt;mod?a+b:a+b-mod; } inline void Dec(int&amp;a,int b) { a=a&lt;b?a-b+mod:a-b; } inline void Mul(int&amp;a,int b) { a=(ll)a*b%mod; } inline int ksm(int a,int p) { int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; } inline int Inv(int a) { return ksm(a,mod-2); }}using namespace modular;int lim,tim,invv[23],w[23],inv[1&lt;&lt;20];vector&lt;int&gt;rev[23];inline void init_ntt() { w[22]=ksm(3,(mod-1)&gt;&gt;23); for(ri i=21;~i;--i) w[i]=mul(w[i+1],w[i+1]); invv[0]=1; for(ri iv=mod+1&gt;&gt;1,i=1;i&lt;23;++i) invv[i]=mul(invv[i-1],iv); inv[1]=1; for(ri i=2,up=1&lt;&lt;20;i&lt;up;++i) inv[i]=mul(inv[mod-mod/i*i],mod-mod/i);}inline void init(int up) { lim=1,tim=0; while(lim&lt;up) lim&lt;&lt;=1,++tim; if(rev[tim].size()) return; rev[tim].resize(lim); for(ri i=1;i&lt;lim;++i) rev[tim][i]=(rev[tim][i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(tim-1));}inline void ntt(poly&amp;a,int typ) { for(ri i=1;i&lt;lim;++i) if(i&lt;rev[tim][i]) swap(a[i],a[rev[tim][i]]); for(ri i=1,t=0,a0,a1,mt;i&lt;lim;i&lt;&lt;=1,++t) for(ri j=0;j&lt;lim;j+=i&lt;&lt;1) { mt=1; for(ri k=0;k&lt;i;++k,Mul(mt,w[t])) { a0=a[j+k],a1=mul(a[j+k+i],mt); a[j+k]=add(a0,a1),a[j+k+i]=dec(a0,a1); } } if(~typ) return; reverse(++a.begin(),a.end()); for(ri i=0;i&lt;lim;++i) Mul(a[i],invv[tim]);}inline poly operator*(poly a,poly b) { int n=(int)a.size(),m=(int)b.size(),t=n+m-1; if(t&lt;=128) { poly c(t); for(ri i=0;i&lt;n;++i) if(a[i]) for(ri j=0;j&lt;m;++j) Add(c[i+j],mul(a[i],b[j])); return c; } init(t); a.resize(lim),ntt(a,1); b.resize(lim),ntt(b,1); for(ri i=0;i&lt;lim;++i) Mul(a[i],b[i]); return ntt(a,-1),a.resize(t),a;}inline poly operator-(poly a,poly b) { int n=(int)b.size(); if((int)a.size()&lt;n) a.resize(n); for(ri i=0;i&lt;n;++i) Dec(a[i],b[i]); return a;}inline poly poly_inv(poly a,int K) { poly b(1,Inv(a[0])),c; for(ri i=1;i&lt;K;i&lt;&lt;=1) { init(i*3); b.resize(lim),ntt(b,1); c=a,c.resize(i&lt;&lt;1),c.resize(lim),ntt(c,1); for(ri j=0;j&lt;lim;++j) Mul(b[j],dec(2,mul(b[j],c[j]))); ntt(b,-1),b.resize(i&lt;&lt;1); } return b.resize(K),b;}inline poly poly_deriv(poly a) { for(ri i=1,up=(int)a.size();i&lt;up;++i) a[i-1]=mul(a[i],i); return a.pop_back(),a;}inline poly poly_integ(poly a) { a.pb(0); for(ri i=(int)a.size()-1;i;--i) a[i]=mul(inv[i],a[i-1]); return a[0]=0,a;}inline poly poly_ln(poly a,int K) { return a=poly_integ(poly_deriv(a)*poly_inv(a,K)),a.resize(K),a; }inline poly poly_exp(poly a,int K) { poly b(1,1),c; for(ri i=1;i&lt;K;i&lt;&lt;=1) { c=a,c.resize(i&lt;&lt;1),Add(c[0],1); b=b*(c-poly_ln(b,i&lt;&lt;1)),b.resize(i&lt;&lt;1); } return b.resize(K),b;}const int N=5e5+5;int K,n,fac[N],ifac[N];poly F,G;inline void init() { fac[0]=fac[1]=ifac[0]=ifac[1]=1; for(ri i=2;i&lt;=n+1;++i) { fac[i]=mul(fac[i-1],i); ifac[i]=mul(ifac[i-1],inv[i]); }}int main() { #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif init_ntt(); cin&gt;&gt;K&gt;&gt;n; init(); F.resize(n+1),G.resize(n+1); for(ri i=0,rs=K+1,mt=rs;i&lt;=n;++i,Mul(rs,mt)) F[i]=ifac[i+1],G[i]=mul(F[i],rs); G=G*poly_inv(F,n+1); F[0]=0; for(ri t,i=1;i&lt;=n;++i) { t=mul(fac[i-1],G[i]); F[i]=i&amp;1?t:(t?mod-t:0); } F=poly_exp(F,n+1); for(ri i=1;i&lt;=n;++i) cout&lt;&lt;mul(fac[i],F[i])&lt;&lt;&apos;\\n&apos;; return 0;} &#x96C6;&#x5408;&#x5212;&#x5206;&#x8BA1;&#x6570; &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x8003;&#x8651; DP &#x8D1D;&#x5C14;&#x6570;&#xFF1A; fn=&#x2211;i=0n&#x2212;1fi(n&#x2212;1i)&#x4EE4;F&#x4E3A;f&#x7684;&#x751F;&#x6210;&#x51FD;&#x6570;xF&#x2032;=F&#x22C5;(xex)F&#x2032;=FexF=eex+C\\begin{aligned} f_n=&amp;\\sum\\limits_{i=0}^{n-1}f_i\\binom{n-1}{i}\\\\ &#x4EE4; F &#x4E3A;&amp; f &#x7684;&#x751F;&#x6210;&#x51FD;&#x6570;\\\\ xF&apos;=&amp;F\\cdot(xe^x)\\\\ F&apos;=&amp;Fe^x\\\\ F=&amp;e^{e^x+C}\\\\ \\end{aligned} fn&#x200B;=&#x4EE4;F&#x4E3A;xF&#x2032;=F&#x2032;=F=&#x200B;i=0&#x2211;n&#x2212;1&#x200B;fi&#x200B;(in&#x2212;1&#x200B;)f&#x7684;&#x751F;&#x6210;&#x51FD;&#x6570;F&#x22C5;(xex)Fexeex+C&#x200B; &#x5E26;&#x5165; f0f_0f0&#x200B; &#x53EF;&#x77E5; C=&#x2212;1C=-1C=&#x2212;1 &#x591A;&#x9879;&#x5F0F; exp &#x5373;&#x53EF; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef vector&lt;int&gt; poly;#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() { int ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}namespace modular { const int mod=998244353; inline int add(int a,int b) { return a+b&lt;mod?a+b:a+b-mod; } inline int dec(int a,int b) { return a&lt;b?a-b+mod:a-b; } inline int mul(int a,int b) { return (ll)a*b%mod; } inline void Add(int&amp;a,int b) { a=a+b&lt;mod?a+b:a+b-mod; } inline void Dec(int&amp;a,int b) { a=a&lt;b?a-b+mod:a-b; } inline void Mul(int&amp;a,int b) { a=(ll)a*b%mod; } inline int ksm(int a,int p) { int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; } inline int Inv(int a) { return ksm(a,mod-2); }}using namespace modular;int inv[1&lt;&lt;20],lim,tim,invv[21];vector&lt;int&gt;w[21],rev[21];inline void init_ntt() { w[20].resize(1&lt;&lt;20),w[20][0]=1,w[20][1]=ksm(3,(mod-1)&gt;&gt;21); for(ri i=2,up=1&lt;&lt;20;i&lt;up;++i) w[20][i]=mul(w[20][i-1],w[20][1]); for(ri i=19;~i;--i) { w[i].resize(1&lt;&lt;i); for(ri j=0,up=1&lt;&lt;i;j&lt;up;++j) w[i][j]=w[i+1][j&lt;&lt;1]; } invv[0]=1; for(ri i=1,iv=mod+1&gt;&gt;1;i&lt;21;++i) invv[i]=mul(invv[i-1],iv); inv[1]=1; for(ri i=2,up=1&lt;&lt;20;i&lt;up;++i) inv[i]=mul(inv[mod-mod/i*i],mod-mod/i);}inline void init(int up) { lim=1,tim=0; while(lim&lt;up) lim&lt;&lt;=1,++tim; if(rev[tim].size()) return; rev[tim].resize(lim); for(ri i=1;i&lt;lim;++i) rev[tim][i]=(rev[tim][i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(tim-1));}inline void ntt(poly&amp;a,int typ) { for(ri i=1;i&lt;lim;++i) if(i&lt;rev[tim][i]) swap(a[i],a[rev[tim][i]]); for(ri i=1,t=0,a0,a1;i&lt;lim;i&lt;&lt;=1,++t) for(ri j=0;j&lt;lim;j+=i&lt;&lt;1) { for(ri k=0;k&lt;i;++k) { a0=a[j+k],a1=mul(a[j+k+i],w[t][k]); a[j+k]=add(a0,a1),a[j+k+i]=dec(a0,a1); } } if(~typ) return; reverse(++a.begin(),a.end()); for(ri i=0;i&lt;lim;++i) Mul(a[i],invv[tim]);}inline poly operator*(poly a,poly b) { int n=(int)a.size(),m=(int)b.size(),t=n+m-1; if(t&lt;=128) { poly c(t); for(ri i=0;i&lt;n;++i) if(a[i]) for(ri j=0;j&lt;m;++j) Add(c[i+j],mul(a[i],b[j])); return c; } init(t); a.resize(lim),ntt(a,1); b.resize(lim),ntt(b,1); for(ri i=0;i&lt;lim;++i) Mul(a[i],b[i]); return ntt(a,-1),a.resize(t),a;}inline poly operator-(poly a,poly b) { int n=(int)b.size(); if((int)a.size()&lt;n) a.resize(n); for(ri i=0;i&lt;n;++i) Dec(a[i],b[i]); return a;}inline poly poly_inv(poly a,int K) { poly b(1,Inv(a[0])),c; for(ri i=1;i&lt;K;i&lt;&lt;=1) { init(i*3); b.resize(lim),ntt(b,1); c=a,c.resize(i&lt;&lt;1),c.resize(lim),ntt(c,1); for(ri j=0;j&lt;lim;++j) Mul(b[j],dec(2,mul(b[j],c[j]))); ntt(b,-1),b.resize(i&lt;&lt;1); } return b.resize(K),b;}inline poly poly_deriv(poly a) { for(ri i=1,up=(int)a.size();i&lt;up;++i) a[i-1]=mul(a[i],i); return a.pop_back(),a;}inline poly poly_integ(poly a) { a.pb(0); for(ri i=(int)a.size()-1;i;--i) a[i]=mul(inv[i],a[i-1]); return a[0]=0,a;}inline poly poly_ln(poly a,int K) { return a=poly_inv(a,K)*poly_deriv(a),a.resize(K-1),poly_integ(a); }inline poly poly_exp(poly a,int K) { poly b(1,1),c; for(ri i=1;i&lt;K;i&lt;&lt;=1) { c=a,c.resize(i&lt;&lt;1),Add(c[0],1); b=b*(c-poly_ln(b,i&lt;&lt;1)),b.resize(i&lt;&lt;1); } return b.resize(K),b;}const int N=1e5+5;int fac[N],ifac[N],f[N];inline int C(int n,int m) { return n&lt;m||m&lt;0?0:mul(fac[n],mul(ifac[m],ifac[n-m])); }inline void init() { fac[0]=fac[1]=ifac[0]=ifac[1]=1; for(ri i=2;i&lt;=100000;++i) { fac[i]=mul(fac[i-1],i); ifac[i]=mul(ifac[i-1],inv[i]); }}poly F;inline void init_F() { F.resize(100001); for(ri i=1;i&lt;=100000;++i) F[i]=ifac[i]; F=poly_exp(F,100001); for(ri i=0;i&lt;=100000;++i) Mul(F[i],fac[i]);}int main() { #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif init_ntt(); init(); init_F(); for(ri tt=read();tt;--tt) cout&lt;&lt;F[read()]&lt;&lt;&apos;\\n&apos;; return 0;} WD&#x4E0E;&#x79EF;&#x6728; &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x8003;&#x8651;&#x975E;&#x7A7A;&#x96C6;&#x5408;&#x751F;&#x6210;&#x51FD;&#x6570;&#x4E3A; ex&#x2212;1e^x-1ex&#x2212;1 &#xFF0C;&#x8BBE; FFF &#x4E3A;&#x5206;&#x6BCD;&#x751F;&#x6210;&#x51FD;&#x6570;&#xFF0C; GGG &#x4E3A;&#x5206;&#x5B50;&#x751F;&#x6210;&#x51FD;&#x6570; &#x90A3;&#x4E48;&#x663E;&#x7136;&#x6709; F=&#x2211;i=0+&#x221E;(ex&#x2212;1)ii!i!=11&#x2212;(ex&#x2212;1)=12&#x2212;exF=\\sum\\limits_{i=0}^{+\\infty}\\frac{(e^x-1)^i}{i!}i!=\\frac{1}{1-(e^x-1)}=\\frac1{2-e^x}F=i=0&#x2211;+&#x221E;&#x200B;i!(ex&#x2212;1)i&#x200B;i!=1&#x2212;(ex&#x2212;1)1&#x200B;=2&#x2212;ex1&#x200B; &#x540C;&#x7406;&#x80FD;&#x63A8;&#x51FA; G=ex&#x2212;1(2&#x2212;ex)2G=\\frac{e^x-1}{(2-e^x)^2}G=(2&#x2212;ex)2ex&#x2212;1&#x200B; &#x7136;&#x540E;&#x505A;&#x5B8C;&#x4E86; CODE","categories":[{"name":"public","slug":"public","permalink":"http://xdl030112.github.io/categories/public/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://xdl030112.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"杂题乱做 Round12","slug":"sol12","date":"2019-12-26T03:47:36.000Z","updated":"2019-12-28T08:52:53.695Z","comments":true,"path":"sol12/","link":"","permalink":"http://xdl030112.github.io/sol12/","excerpt":"","text":"&#x67D0;&#x4F4D;&#x6B4C;&#x59EC;&#x7684;&#x6545;&#x4E8B; &#x89E3;&#x9898;&#x601D;&#x8DEF;: &#x5C06;&#x5E8F;&#x5217;&#x79BB;&#x6563;&#x5316;&#x540E;&#xFF0C;&#x53EF;&#x4EE5;&#x7ED9;&#x6BCF;&#x4E00;&#x6BB5;&#x533A;&#x95F4;&#x5B9A;&#x4E00;&#x4E2A;&#x6700;&#x5927;&#x503C;&#x7684;&#x6700;&#x5C0F;&#x4E0A;&#x754C;&#xFF0C;&#x90A3;&#x4E48;&#x6BCF;&#x4E00;&#x79CD;&#x4E0A;&#x754C;&#x7684;&#x503C;&#x662F;&#x72EC;&#x7ACB;&#x7684;&#xFF0C;&#x8003;&#x8651;&#x628A;&#x76F8;&#x540C;&#x4E0A;&#x754C;&#x7684;&#x5757;&#x626F;&#x51FA;&#x6765; DP &#x5BF9;&#x4E8E;&#x4E00;&#x79CD;&#x4E0A;&#x754C;&#xFF0C;&#x628A;&#x5BF9;&#x5E94;&#x7684;&#x6BB5;&#x548C;&#x9650;&#x5236;&#x63D0;&#x51FA;&#x6765;&#xFF0C;&#x5BF9;&#x4E8E;&#x6BCF;&#x4E2A;&#x5757;&#x7EF4;&#x62A4;&#x4E00;&#x4E2A; maxlmaxlmaxl &#x8868;&#x793A;&#x5904;&#x7406;&#x5230;&#x533A;&#x95F4; iii &#x65F6;&#xFF0C;&#x6700;&#x540E;&#x586B;&#x5165;&#x7684;&#x4E00;&#x4E2A;&#x7B49;&#x4E8E;&#x4E0A;&#x754C;&#x7684;&#x503C;&#x6240;&#x5728;&#x7684;&#x5757;&#x6807;&#x53F7;&#x5E94;&#x8BE5;&#x4E0D;&#x5C0F;&#x4E8E; maxlmaxlmaxl &#xFF0C;&#x5BF9;&#x4E8E;&#x4E00;&#x4E2A;&#x9650;&#x5236;&#x5BF9;&#x5E94;&#x7684;&#x5757; [l,...,r][l,...,r][l,...,r] &#xFF0C;&#x6211;&#x4EEC;&#x7528; lll &#x66F4;&#x65B0; maxl[r]maxl[r]maxl[r] &#xFF0C;&#x6700;&#x540E;&#x76F4;&#x63A5; DP &#x8BBE; fi,jf_{i,j}fi,j&#x200B; &#x8868;&#x793A;&#x5F53;&#x524D;&#x5728;&#x7B2C; iii &#x5757;&#xFF0C;&#x6700;&#x540E;&#x4E00;&#x4E2A;&#x586B;&#x7684;&#x7B49;&#x4E8E;&#x4E0A;&#x754C;&#x7684;&#x6570;&#x5728;&#x7B2C; jjj &#x5757;&#x7684;&#x65B9;&#x6848;&#x6570; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() { int ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}namespace modular { const int mod=998244353; inline int add(int a,int b) { return a+b&lt;mod?a+b:a+b-mod; } inline int dec(int a,int b) { return a&lt;b?a-b+mod:a-b; } inline int mul(int a,int b) { return (ll)a*b%mod; } inline void Add(int&amp;a,int b) { a=a+b&lt;mod?a+b:a+b-mod; } inline void Dec(int&amp;a,int b) { a=a&lt;b?a-b+mod:a-b; } inline void Mul(int&amp;a,int b) { a=(ll)a*b%mod; } inline int ksm(int a,int p) { int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; } inline int Inv(int a) { return ksm(a,mod-2); } inline int fix(int a) { return (a%mod+mod)%mod; }}using namespace modular;template&lt;typename T&gt; inline void ckmin(T&amp;a,T b) { a&gt;b?a=b:0; }template&lt;typename T&gt; inline void ckmax(T&amp;a,T b) { a&lt;b?a=b:0; }const int N=1005;int n,m,A,seg[N],sz,vl[N],sig,a[N];struct Q { int l,r,v; friend inline bool operator&lt;(Q a,Q b) { return a.v^b.v?a.v&lt;b.v:(a.l^b.l?a.l&lt;b.l:a.r&lt;b.r); }}qry[N];inline int findps(int x) { return lower_bound(seg+1,seg+sig+1,x)-seg; }inline int findvl(int x) { return lower_bound(vl+1,vl+sz+1,x)-vl; }inline int calc(int w) { vector&lt;int&gt;upd,psl,f[2]; int cur=0; upd.pb(0),f[0].pb(0),f[1].pb(0),psl.pb(0); for(ri i=1;i&lt;sig;++i) if(a[i]==w) upd.pb(i),psl.pb(0),f[0].pb(0),f[1].pb(0); for(ri l,r,i=1;i&lt;=m;++i) if(qry[i].v==w) { if(upd.size()==1) return 0; l=lower_bound(upd.begin(),upd.end(),qry[i].l)-upd.begin(); r=lower_bound(upd.begin(),upd.end(),qry[i].r)-upd.begin()-1; ckmax(psl[r],l); } f[cur=0][0]=1; for(ri i=1,s,c1,c2,up=(int)upd.size()-1;i&lt;=up;++i) { cur^=1; for(ri j=0;j&lt;=i;++j) f[cur][j]=0; c1=ksm(vl[w],seg[upd[i]+1]-seg[upd[i]]),c2=ksm(vl[w]-1,seg[upd[i]+1]-seg[upd[i]]); s=0; for(ri j=psl[i];j&lt;i;++j) if(f[cur^1][j]) Add(f[cur][j],mul(f[cur^1][j],c2)); for(ri j=0;j&lt;i;++j) if(f[cur^1][j]) Add(s,f[cur^1][j]); f[cur][i]=mul(dec(c1,c2),s); } int res=0; for(ri i=0,up=(int)upd.size()-1;i&lt;=up;++i) Add(res,f[cur][i]); return res;}int main() { #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif for(ri tt=read();tt;--tt) { n=read(),m=read(),A=read(); sig=sz=0; for(ri i=1;i&lt;=m;++i) { qry[i].l=read(),qry[i].r=read()+1,qry[i].v=read(); seg[++sig]=qry[i].l,seg[++sig]=qry[i].r,vl[++sz]=qry[i].v; } seg[++sig]=1,seg[++sig]=n+1; sort(seg+1,seg+sig+1),sig=unique(seg+1,seg+sig+1)-seg-1; sort(vl+1,vl+sz+1),sz=unique(vl+1,vl+sz+1)-vl-1; for(ri i=1;i&lt;=sig;++i) a[i]=sz+1; sort(qry+1,qry+m+1); for(ri i=1;i&lt;=m;++i) { qry[i].l=findps(qry[i].l); qry[i].r=findps(qry[i].r); qry[i].v=findvl(qry[i].v); for(ri j=qry[i].l;j&lt;qry[i].r;++j) ckmin(a[j],qry[i].v); } int res=1,ss=0; for(ri i=1;i&lt;=sz;++i) { Mul(res,calc(i)); if(!res) break; } if(!res ) { puts(&quot;0&quot;);continue; } for(ri i=1;i&lt;sig;++i) if(a[i]==sz+1) ss+=seg[i+1]-seg[i]; cout&lt;&lt;mul(res,ksm(A,ss))&lt;&lt;&apos;\\n&apos;; } return 0;} &#x4E5D;&#x4E2A;&#x592A;&#x9633; &#x89E3;&#x9898;&#x601D;&#x8DEF;: &#x5355;&#x4F4D;&#x6839;&#x53CD;&#x6F14;&#x88F8;&#x9898;&#xFF0C;&#x4E0D;&#x7528;&#x5199;&#x9898;&#x89E3;&#x4E86; &#x597D;&#x5427;&#x8FD8;&#x662F;&#x6C34;&#x4E00;&#x53D1;&#x9898;&#x89E3;&#x5427;&#x3002; Ans=&#x2211;i=0n(&#x2211;j=0K&#x2212;1&#x3C9;Kij)(ni)=&#x2211;i=0K&#x2212;1&#x2211;j=0n&#x3C9;Kij(nj)=&#x2211;i=0K&#x2212;1(&#x3C9;Ki+1)n\\begin{aligned} Ans=&amp;\\sum\\limits_{i=0}^n(\\sum\\limits_{j=0}^{K-1}\\omega_K^{ij})\\binom ni\\\\ =&amp;\\sum\\limits_{i=0}^{K-1}\\sum\\limits_{j=0}^n\\omega_K^{ij}\\binom nj\\\\ =&amp;\\sum\\limits_{i=0}^{K-1}(\\omega_K^i+1)^n \\end{aligned} Ans===&#x200B;i=0&#x2211;n&#x200B;(j=0&#x2211;K&#x2212;1&#x200B;&#x3C9;Kij&#x200B;)(in&#x200B;)i=0&#x2211;K&#x2212;1&#x200B;j=0&#x2211;n&#x200B;&#x3C9;Kij&#x200B;(jn&#x200B;)i=0&#x2211;K&#x2212;1&#x200B;(&#x3C9;Ki&#x200B;+1)n&#x200B; CODE cpp12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;namespace modular { const int mod=998244353; inline int add(int a,int b) { return a+b&lt;mod?a+b:a+b-mod; } inline int dec(int a,int b) { return a&lt;b?a-b+mod:a-b; } inline int mul(int a,int b) { return (ll)a*b%mod; } inline void Add(int&amp;a,int b) { a=a+b&lt;mod?a+b:a+b-mod; } inline void Dec(int&amp;a,int b) { a=a&lt;b?a-b+mod:a-b; } inline void Mul(int&amp;a,int b) { a=(ll)a*b%mod; } inline int ksm(int a,int p) { int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; } inline int Inv(int a) { return ksm(a,mod-2); } inline int fix(int a) { return (a%mod+mod)%mod; }}using namespace modular;ll n;int K,omega;int main() { #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif cin&gt;&gt;n&gt;&gt;K; n%=mod-1; omega=ksm(3,(mod-1)/K); int res=0; for(ri i=0,mt=1;i&lt;K;++i,Mul(mt,omega)) Add(res,ksm(mt+1,n)); cout&lt;&lt;mul(res,Inv(K)); return 0;} Hard Nim &#x89E3;&#x9898;&#x601D;&#x8DEF;: &#x8003;&#x8651;&#x5230;&#x95EE;&#x9898;&#x8F6C;&#x5316;&#x4E3A;&#x6C42;&#x5F02;&#x6216;&#x503C;&#x4E3A; 000 &#x7684;&#x65B9;&#x6848;&#x6570;&#xFF0C;&#x90A3;&#x4E48;&#x5BF9;&#x4E8E;&#x6BCF;&#x5806;&#x77F3;&#x5B50;&#x53EF;&#x4EE5;&#x9009;&#x53D6;&#x7684;&#x96C6;&#x5408;&#x4E3A;&#x4E0D;&#x8D85;&#x8FC7; mmm &#x7684;&#x7D20;&#x6570;&#x96C6;&#x5408;&#xFF0C;&#x53D1;&#x73B0;&#x5C31;&#x662F;&#x4E2A; fwtfwtfwt &#x5FEB;&#x901F;&#x5E42; CODE cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;namespace modular { const int mod=1e9+7; inline int add(int a,int b) { return a+b&lt;mod?a+b:a+b-mod; } inline int dec(int a,int b) { return a&lt;b?a-b+mod:a-b; } inline int mul(int a,int b) { return (ll)a*b%mod; } inline void Add(int&amp;a,int b) { a=a+b&lt;mod?a+b:a+b-mod; } inline void Dec(int&amp;a,int b) { a=a&lt;b?a-b+mod:a-b; } inline void Mul(int&amp;a,int b) { a=(ll)a*b%mod; } inline int ksm(int a,int p) { int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; } inline int Inv(int a) { return ksm(a,mod-2); } inline int fix(int a) { return (a%mod+mod)%mod; }}using namespace modular;const int N=50005;int n,m,pri[N],tot=0,a[N&lt;&lt;1];bool vs[N];inline void init() { int up=50000; for(ri i=2;i&lt;=up;++i) { if(!vs[i]) pri[++tot]=i; for(ri j=1,lm=up/i;j&lt;=tot&amp;&amp;pri[j]&lt;=lm;++j) { vs[i*pri[j]]=1; if(i==i/pri[j]*pri[j]) break; } }}int lim;inline void fwt(int*a,int typ) { for(ri i=1,a0,a1,iv=mod+1&gt;&gt;1;i&lt;lim;i&lt;&lt;=1) for(ri j=0,len=i&lt;&lt;1;j&lt;lim;j+=len) for(ri k=0;k&lt;i;++k) { a0=a[j+k],a1=a[j+k+i]; a[j+k]=add(a0,a1),a[j+k+i]=dec(a0,a1); if(typ==-1) Mul(a[j+k],iv),Mul(a[j+k+i],iv); }}int main() { #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif init(); while(cin&gt;&gt;n&gt;&gt;m) { lim=1; while(lim&lt;=m) lim&lt;&lt;=1; for(ri i=0;i&lt;lim;++i) a[i]=0; for(ri i=1;i&lt;=tot&amp;&amp;pri[i]&lt;=m;++i) a[pri[i]]=1; fwt(a,1); for(ri i=0;i&lt;lim;++i) a[i]=ksm(a[i],n); fwt(a,-1); cout&lt;&lt;a[0]&lt;&lt;&apos;\\n&apos;; } return 0;} &#x4E8C;&#x5143;&#x8FD0;&#x7B97; &#x89E3;&#x9898;&#x601D;&#x8DEF;: &#x9898;&#x76EE;&#x7ED9;&#x51FA;&#x4E86;&#x4E24;&#x79CD;&#x4E92;&#x8865;&#x7684;&#x57FA;&#x7840;&#x5377;&#x79EF;&#x65B9;&#x5F0F;&#xFF0C;&#x90A3;&#x4E48;&#x8003;&#x8651;&#x5206;&#x6CBB;, &#x53D1;&#x73B0;&#x521A;&#x597D; [l,mid][l,mid][l,mid] &#x4E2D;&#x6240;&#x6709;&#x4E0B;&#x6807;&#x5C0F;&#x4E8E; [mid+1,r][mid+1,r][mid+1,r] &#x6240;&#x6709;&#x4E0B;&#x6807;&#xFF0C;&#x4E8E;&#x662F;&#x5206;&#x6CBB; fft &#x5904;&#x7406;&#x5373;&#x53EF; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() { int ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}struct cp { double a,b; cp(double a=0,double b=0):a(a),b(b) {} friend inline cp operator+(cp a,cp b) { return cp(a.a+b.a,a.b+b.b); } friend inline void operator+=(cp&amp;a,cp b) { a=a+b; } friend inline cp operator-(cp a,cp b) { return cp(a.a-b.a,a.b-b.b); } friend inline void operator-=(cp&amp;a,cp b) { a=a-b; } friend inline cp operator*(cp a,cp b) { return cp(a.a*b.a-a.b*b.b,a.a*b.b+a.b*b.a); } friend inline void operator*=(cp&amp;a,cp b) { a=a*b; } friend inline cp operator/(cp a,double b) { return cp(a.a/b,a.b/b); } friend inline void operator/=(cp&amp;a,double b) { a=a/b; }};typedef vector&lt;cp&gt; poly;const double pi=acos(-1.0);cp w[23];int lim,tim;vector&lt;int&gt;rev[23];inline void init_fft() { for(ri i=0;i&lt;23;++i) w[i]=cp(cos(pi/(1&lt;&lt;i)),sin(pi/(1&lt;&lt;i))); }inline void init(int up) { lim=1,tim=0; while(lim&lt;up) lim&lt;&lt;=1,++tim; if(rev[tim].size()) return; rev[tim].resize(lim); for(ri i=1;i&lt;lim;++i) rev[tim][i]=(rev[tim][i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(tim-1));}inline void fft(poly&amp;a,int typ) { for(ri i=1;i&lt;lim;++i) if(i&lt;rev[tim][i]) swap(a[i],a[rev[tim][i]]); cp a0,a1,mt; for(ri i=1,t=0;i&lt;lim;i&lt;&lt;=1,++t) for(ri j=0,len=i&lt;&lt;1;j&lt;lim;j+=len) { mt=cp(1,0); for(ri k=0;k&lt;i;++k,mt*=w[t]) { a0=a[j+k],a1=a[j+k+i]*mt; a[j+k]=a0+a1,a[j+k+i]=a0-a1; } } if(~typ) return; reverse(++a.begin(),a.end()); for(ri i=0;i&lt;lim;++i) a[i]/=lim;}inline poly operator*(poly a,poly b) { int n=(int)a.size(),m=(int)b.size(),t=n+m-1; if(t&lt;=128) { poly c(t); for(ri i=0;i&lt;n;++i) for(ri j=0;j&lt;m;++j) c[i+j]+=a[i]*b[j]; return c; } init(t); a.resize(lim),fft(a,1); b.resize(lim),fft(b,1); for(ri i=0;i&lt;lim;++i) a[i]*=b[i]; return fft(a,-1),a.resize(t),a;}const int N=50005;int n,m,mx,q,_a[N],_b[N];poly a,b,ta,tb,tc;ll res[N&lt;&lt;2];inline void solve(int l,int r) { if(l==r) { res[0]+=((ll)(a[l].a+0.5))*((ll)(b[l].a+0.5)); return; } int mid=l+r&gt;&gt;1; solve(l,mid),solve(mid+1,r); if(r-l+1&lt;=256) { for(ri i=l;i&lt;=mid;++i) for(ri j=mid+1;j&lt;=r;++j) { res[i+j]+=((ll)(a[i].a+0.5))*((ll)(b[j].a+0.5)); res[j-i]+=((ll)(a[j].a+0.5))*((ll)(b[i].a+0.5)); } } else { ta.resize(mid-l+1),tb.resize(r-mid); for(ri i=l;i&lt;=mid;++i) ta[i-l]=a[i]; for(ri i=mid+1;i&lt;=r;++i) tb[i-mid-1]=b[i]; tc=ta*tb; for(ri i=0;i&lt;(int)tc.size();++i) res[i+mid+1+l]+=(ll)(tc[i].a+0.5); for(ri i=mid+1;i&lt;=r;++i) tb[i-mid-1]=a[i]; for(ri i=l;i&lt;=mid;++i) ta[i-l]=b[i]; reverse(ta.begin(),ta.end()); tc=ta*tb; for(ri i=0;i&lt;(int)tc.size();++i) res[i+1]+=(ll)(tc[i].a+0.5); }}int main() { #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); freopen(&quot;own.out&quot;,&quot;w&quot;,stdout); #endif init_fft(); for(ri tt=read();tt;--tt) { n=read(),m=read(),q=read(),mx=-1; for(ri i=1;i&lt;=n;++i) mx=max(mx,_a[i]=read()); for(ri i=1;i&lt;=m;++i) mx=max(mx,_b[i]=read()); a.clear(),a.resize(mx+1); b.clear(),b.resize(mx+1); for(ri i=0;i&lt;=(mx&lt;&lt;1);++i) res[i]=0; for(ri i=1;i&lt;=n;++i) ++a[_a[i]].a; for(ri i=1;i&lt;=m;++i) ++b[_b[i]].a; solve(0,mx); for(ri x;q;--q) { x=read(); if(x&lt;=(mx&lt;&lt;1)) cout&lt;&lt;res[x]&lt;&lt;&apos;\\n&apos;; else puts(&quot;0&quot;); } } return 0;} Lightsabers (hard) &#x89E3;&#x9898;&#x601D;&#x8DEF;: &#x53EF;&#x4EE5;&#x76F4;&#x63A5;&#x5BF9;&#x6BCF;&#x79CD;&#x989C;&#x8272;&#x6784;&#x9020;&#x5F62;&#x5F0F;&#x5E42;&#x7EA7;&#x6570;&#x7136;&#x540E;&#x505A;&#x53CC;&#x6A21;&#x5206;&#x6CBB; nttnttntt &#x4E0D;&#x8FC7;&#x770B;&#x5230;&#x4E86;&#x4E00;&#x79CD;&#x795E;&#x5947;&#x7684;&#x542F;&#x53D1;&#x5F0F;&#x5408;&#x5E76;&#x7684;&#x505A;&#x6CD5; &#x5927;&#x6982;&#x662F;&#x6BCF;&#x6B21;&#x5408;&#x5E76;&#x4E24;&#x4E2A;&#x5F53;&#x524D;&#x5EA6;&#x6700;&#x5C0F;&#x7684;&#x591A;&#x9879;&#x5F0F;&#xFF0C;&#x590D;&#x6742;&#x5EA6;&#x4ECD;&#x7136;&#x662F; O(nlog&#x2061;n2)O(n\\log n^2)O(nlogn2) &#x672C;&#x6765;&#x542C;&#x8BF4;&#x8981;&#x5FEB;&#x4E00;&#x70B9;&#x4F46;&#x662F;&#x7531;&#x4E8E;&#x6211;&#x5199;&#x7684;&#x53CC;&#x6A21;ntt&#x592A;&#x83DC;&#x4E86;&#x4E8E;&#x662F;&#x88AB;&#x5206;&#x6CBB;ntt&#x540A;&#x7740;&#x6253; CODE1 cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef vector&lt;int&gt; poly;#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() { int ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}const int N=2e5+5;int n,m,K,a[N],vl[N],cnt[N],sig=0;inline int find(int x) { return lower_bound(vl+1,vl+sig+1,x)-vl; }struct Ntt { int mod,g,lim,tim,w[21],invv[21]; inline int add(int a,int b) { return a+b&lt;mod?a+b:a+b-mod; } inline int dec(int a,int b) { return a&lt;b?a-b+mod:a-b; } inline int mul(int a,int b) { return (ll)a*b%mod; } inline void Add(int&amp;a,int b) { a=a+b&lt;mod?a+b:a+b-mod; } inline void Dec(int&amp;a,int b) { a=a&lt;b?a-b+mod:a-b; } inline void Mul(int&amp;a,int b) { a=(ll)a*b%mod; } inline int ksm(int a,int p) { int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; } inline int Inv(int a) { return ksm(a,mod-2); } vector&lt;int&gt;rev[21]; inline void init_ntt() { invv[0]=1; for(ri i=1,iv=mod+1&gt;&gt;1;i&lt;21;++i) invv[i]=mul(invv[i-1],iv); w[20]=ksm(g,(mod-1)&gt;&gt;21); for(ri i=19;~i;--i) w[i]=mul(w[i+1],w[i+1]); } inline void init(int up) { lim=1,tim=0; while(lim&lt;up) lim&lt;&lt;=1,++tim; if(rev[tim].size()) return; rev[tim].resize(lim); for(ri i=1;i&lt;lim;++i) rev[tim][i]=(rev[tim][i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(tim-1)); } inline void ntt(poly&amp;a,int typ) { for(ri i=1;i&lt;lim;++i) if(i&lt;rev[tim][i]) swap(a[i],a[rev[tim][i]]); for(ri i=1,t=0,a0,a1,mt;i&lt;lim;i&lt;&lt;=1,++t) for(ri j=0,len=i&lt;&lt;1;j&lt;lim;j+=len) { mt=1; for(ri k=0;k&lt;i;++k,Mul(mt,w[t])) { a0=a[j+k],a1=mul(a[j+k+i],mt); a[j+k]=add(a0,a1),a[j+k+i]=dec(a0,a1); } } if(~typ) return; reverse(++a.begin(),a.end()); for(ri i=0;i&lt;lim;++i) Mul(a[i],invv[tim]); } inline poly poly_mul(poly a,poly b) { int n=(int)a.size(),m=(int)b.size(),t=n+m-1; init(t); a.resize(lim),ntt(a,1); b.resize(lim),ntt(b,1); for(ri i=0;i&lt;lim;++i) Mul(a[i],b[i]); return ntt(a,-1),a.resize(t),a; }}A,B;const int mod=1009;int iv1,iv2;inline ll mul(ll a,ll b,ll mod) { return a*b-(ll)((long double)a/mod*b+1e-8)*mod; }inline int merge(int x,int y) { ll md=(ll)A.mod*B.mod; return (mul(x,(ll)B.mod*iv1%md,md)+mul(y,(ll)A.mod*iv2%md,md))%md%mod;}inline poly poly_mul(poly a,poly b) { int n=(int)a.size(),m=(int)b.size(),t=n+m-1; if(t&lt;=128) { poly c(t); for(ri i=0;i&lt;n;++i) if(a[i]) for(ri j=0;j&lt;m;++j) { c[i+j]+=a[i]*b[j]; if(c[i+j]&gt;=100000000) c[i+j]%=mod; } for(ri i=0;i&lt;t;++i) c[i]%=mod; return c; } poly _a=A.poly_mul(a,b),_b=B.poly_mul(a,b); a.resize(t); for(ri i=0;i&lt;t;++i) a[i]=merge(_a[i],_b[i]); return a;}inline poly getpoly(int x) { return poly(x+1,1); }inline poly solve(int l,int r) { if(l==r) return getpoly(cnt[l]); int mid=l+r&gt;&gt;1; return poly_mul(solve(l,mid),solve(mid+1,r));}int main() { #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif A.mod=998244353,A.g=3,A.init_ntt(); B.mod=1004535809,B.g=3,B.init_ntt(); iv1=A.Inv(B.mod),iv2=B.Inv(A.mod); n=read(),m=read(),K=read(); for(ri i=1;i&lt;=n;++i) a[i]=vl[++sig]=read(); sort(vl+1,vl+sig+1),sig=unique(vl+1,vl+sig+1)-vl-1; for(ri i=1;i&lt;=n;++i) ++cnt[find(a[i])]; cout&lt;&lt;solve(1,sig)[K]; return 0;} CODE2 cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef vector&lt;int&gt; poly;#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() { int ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}const int N=2e5+5;int n,m,K,a[N],vl[N],cnt[N],sig=0;inline int find(int x) { return lower_bound(vl+1,vl+sig+1,x)-vl; }struct Ntt { int mod,g,lim,tim,w[21],invv[21]; inline int add(int a,int b) { return a+b&lt;mod?a+b:a+b-mod; } inline int dec(int a,int b) { return a&lt;b?a-b+mod:a-b; } inline int mul(int a,int b) { return (ll)a*b%mod; } inline void Add(int&amp;a,int b) { a=a+b&lt;mod?a+b:a+b-mod; } inline void Dec(int&amp;a,int b) { a=a&lt;b?a-b+mod:a-b; } inline void Mul(int&amp;a,int b) { a=(ll)a*b%mod; } inline int ksm(int a,int p) { int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; } inline int Inv(int a) { return ksm(a,mod-2); } vector&lt;int&gt;rev[21]; inline void init_ntt() { invv[0]=1; for(ri i=1,iv=mod+1&gt;&gt;1;i&lt;21;++i) invv[i]=mul(invv[i-1],iv); w[20]=ksm(g,(mod-1)&gt;&gt;21); for(ri i=19;~i;--i) w[i]=mul(w[i+1],w[i+1]); } inline void init(int up) { lim=1,tim=0; while(lim&lt;up) lim&lt;&lt;=1,++tim; if(rev[tim].size()) return; rev[tim].resize(lim); for(ri i=1;i&lt;lim;++i) rev[tim][i]=(rev[tim][i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(tim-1)); } inline void ntt(poly&amp;a,int typ) { for(ri i=1;i&lt;lim;++i) if(i&lt;rev[tim][i]) swap(a[i],a[rev[tim][i]]); for(ri i=1,t=0,a0,a1,mt;i&lt;lim;i&lt;&lt;=1,++t) for(ri j=0,len=i&lt;&lt;1;j&lt;lim;j+=len) { mt=1; for(ri k=0;k&lt;i;++k,Mul(mt,w[t])) { a0=a[j+k],a1=mul(a[j+k+i],mt); a[j+k]=add(a0,a1),a[j+k+i]=dec(a0,a1); } } if(~typ) return; reverse(++a.begin(),a.end()); for(ri i=0;i&lt;lim;++i) Mul(a[i],invv[tim]); } inline poly poly_mul(poly a,poly b) { int n=(int)a.size(),m=(int)b.size(),t=n+m-1; init(t); a.resize(lim),ntt(a,1); b.resize(lim),ntt(b,1); for(ri i=0;i&lt;lim;++i) Mul(a[i],b[i]); return ntt(a,-1),a.resize(t),a; }}A,B;const int mod=1009;int iv1,iv2;inline ll mul(ll a,ll b,ll mod) { return a*b-(ll)((long double)a/mod*b+1e-8)*mod; }inline int merge(int x,int y) { ll md=(ll)A.mod*B.mod; return (mul(x,(ll)B.mod*iv1%md,md)+mul(y,(ll)A.mod*iv2%md,md))%md%mod;}inline poly poly_mul(poly a,poly b) { int n=(int)a.size(),m=(int)b.size(),t=n+m-1; if(t&lt;=128) { poly c(t); for(ri i=0;i&lt;n;++i) if(a[i]) for(ri j=0;j&lt;m;++j) { c[i+j]+=a[i]*b[j]; if(c[i+j]&gt;=100000000) c[i+j]%=mod; } for(ri i=0;i&lt;t;++i) c[i]%=mod; return c; } poly _a=A.poly_mul(a,b),_b=B.poly_mul(a,b); a.resize(t); for(ri i=0;i&lt;t;++i) a[i]=merge(_a[i],_b[i]); return a;}inline poly getpoly(int x) { return poly(x+1,1); }inline poly solve(int l,int r) { if(l==r) return getpoly(cnt[l]); int mid=l+r&gt;&gt;1; return poly_mul(solve(l,mid),solve(mid+1,r));}int main() { #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif A.mod=998244353,A.g=3,A.init_ntt(); B.mod=1004535809,B.g=3,B.init_ntt(); iv1=A.Inv(B.mod),iv2=B.Inv(A.mod); n=read(),m=read(),K=read(); for(ri i=1;i&lt;=n;++i) a[i]=vl[++sig]=read(); sort(vl+1,vl+sig+1),sig=unique(vl+1,vl+sig+1)-vl-1; for(ri i=1;i&lt;=n;++i) ++cnt[find(a[i])]; cout&lt;&lt;solve(1,sig)[K]; return 0;} Kyoya and Train &#x89E3;&#x9898;&#x601D;&#x8DEF;: &#x8003;&#x8651;&#x6734;&#x7D20; dp &#xFF0C;&#x8BBE; fi,Tf_{i,T}fi,T&#x200B; &#x8868;&#x793A;&#x5F53;&#x524D;&#x5728;&#x70B9; iii &#x65F6;&#x523B;&#x4E3A; ttt &#x7684;&#x6700;&#x5C0F;&#x82B1;&#x8D39; &#x90A3;&#x4E48;&#x6709;&#x663E;&#x7136;&#x7684;&#x8F6C;&#x79FB; fu,T=min&#x2061;v{&#x2211;i=1tfv,T+i&#xD7;P(u,v),i}f_{u,T}=\\min\\limits_v\\{\\sum\\limits_{i=1}^tf_{v,T+i}\\times P_{(u,v),i}\\}fu,T&#x200B;=vmin&#x200B;{i=1&#x2211;t&#x200B;fv,T+i&#x200B;&#xD7;P(u,v),i&#x200B;} &#x53D1;&#x73B0;&#x53EF;&#x4EE5;&#x5206;&#x6CBB; fft &#x51FA;&#x8FB9;&#x7684;&#x8D21;&#x732E;&#xFF0C;&#x4E8E;&#x662F; O(mtlog&#x2061;t2)O(mt\\log t^2)O(mtlogt2) &#x8FC7;&#x4E86; &#x6211;&#x628A;&#x5355;&#x5411;&#x8FB9;&#x5EFA;&#x6210;&#x53CC;&#x5411;&#x7684;&#x8C03;&#x4E86;&#x4E00;&#x5E74; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() { int ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}struct cp { double x,y; cp(double x=0,double y=0):x(x),y(y) {} friend inline cp operator+(cp a,cp b) { return cp(a.x+b.x,a.y+b.y); } friend inline void operator+=(cp&amp;a,cp b) { a=a+b; } friend inline cp operator-(cp a,cp b) { return cp(a.x-b.x,a.y-b.y); } friend inline void operator-=(cp&amp;a,cp b) { a=a-b; } friend inline cp operator*(cp a,cp b) { return cp(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x); } friend inline void operator*=(cp&amp;a,cp b) { a=a*b; } friend inline cp operator*(cp a,double b) { return cp(a.x*b,a.y*b); } friend inline void operator*=(cp&amp;a,double b) { a=a*b; } friend inline cp operator/(cp a,double b) { return cp(a.x/b,a.y/b); } friend inline void operator/=(cp&amp;a,double b) { a=a/b; }};typedef vector&lt;cp&gt; poly;const double pi=acos(-1.0);int lim,tim,n,m,t,W;cp w[23];vector&lt;int&gt;rev[23];inline void init_fft() { for(ri i=0;i&lt;23;++i) w[i]=cp(cos(pi/(1&lt;&lt;i)),sin(pi/(1&lt;&lt;i))); }inline void init(int up) { lim=1,tim=0; while(lim&lt;up) lim&lt;&lt;=1,++tim; if(rev[tim].size()) return; rev[tim].resize(lim); for(ri i=1;i&lt;lim;++i) rev[tim][i]=(rev[tim][i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(tim-1));}inline void fft(poly&amp;a,int typ) { for(ri i=1;i&lt;lim;++i) if(i&lt;rev[tim][i]) swap(a[i],a[rev[tim][i]]); cp a0,a1,mt; for(ri i=1,t=0;i&lt;lim;i&lt;&lt;=1,++t) for(ri j=0,len=i&lt;&lt;1;j&lt;lim;j+=len) { mt=cp(1,0); for(ri k=0;k&lt;i;++k,mt*=w[t]) { a0=a[j+k],a1=a[j+k+i]*mt; a[j+k]=a0+a1,a[j+k+i]=a0-a1; } } if(~typ) return; reverse(++a.begin(),a.end()); for(ri i=0;i&lt;lim;++i) a[i]/=lim;}inline poly operator*(poly a,poly b) { int n=(int)a.size(),m=(int)b.size(),t=n+m-1; init(t); a.resize(lim),fft(a,1); b.resize(lim),fft(b,1); for(ri i=0;i&lt;lim;++i) a[i]*=b[i]; return fft(a,-1),a.resize(t),a;}const int N=105,M=205,K=20005;int a[M],b[M],c[M],dis[N][N];double f[N][K],sum[M][K],p[M][K];inline void solve(int l,int r) { if(l==r) { for(ri e=1;e&lt;=m;++e) f[a[e]][l]=min(f[a[e]][l],sum[e][l]+c[e]); return; } int mid=l+r&gt;&gt;1; solve(mid+1,r); poly F(r-mid),G(r-l+1),H; for(ri e=1;e&lt;=m;++e) { for(ri i=mid+1;i&lt;=r;++i) F[i-mid-1]=cp(f[b[e]][i],0); for(ri i=1;i&lt;=r-l;++i) G[r-l-i]=cp(p[e][i],0); H=F*G; for(ri i=l;i&lt;=mid;++i) sum[e][i]+=H[i-mid-1+r-l].x; } solve(l,mid);}int main() { #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif init_fft(); n=read(),m=read(),t=read(),W=read(); for(ri i=1;i&lt;=n;++i) for(ri j=1;j&lt;=n;++j) dis[i][j]=i==j?0:1e9; for(ri i=1;i&lt;=m;++i) { a[i]=read(),b[i]=read(),c[i]=read(); if(c[i]&lt;dis[a[i]][b[i]]) dis[a[i]][b[i]]=c[i]; for(ri j=1;j&lt;=t;++j) p[i][j]=read()/100000.0; } for(ri k=1;k&lt;=n;++k) for(ri i=1;i&lt;=n;++i) for(ri j=1;j&lt;=n;++j) dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]); for(ri i=0;i&lt;N;++i) for(ri j=0;j&lt;K;++j) f[i][j]=1e9; for(ri i=1;i&lt;=n;++i) f[i][t+1]=dis[i][n]+W; for(ri i=0;i&lt;=t;++i) f[n][i]=0; double ss; for(ri e=1;e&lt;=m;++e) { ss=0; for(ri i=1;i&lt;=t;++i) { ss+=p[e][t+1-i]; sum[e][i]=ss*f[b[e]][t+1]; } } solve(0,t); printf(&quot;%.10lf&quot;,f[1][0]); return 0;} Frightful Formula &#x89E3;&#x9898;&#x601D;&#x8DEF;: &#x8003;&#x8651;&#x6BCF;&#x4E2A;&#x683C;&#x5B50;&#x5BF9;&#x7B54;&#x6848;&#x7684;&#x8D21;&#x732E;&#xFF0C;&#x53D1;&#x73B0;&#x683C;&#x5B50; (i&gt;1,j&gt;1)(i&gt;1,j&gt;1)(i&gt;1,j&gt;1) &#x7684;&#x7CFB;&#x6570;&#x662F; (n+n&#x2212;i&#x2212;jn&#x2212;i)an&#x2212;jbn&#x2212;i\\binom{n+n-i-j}{n-i}a^{n-j}b^{n-i}(n&#x2212;in+n&#x2212;i&#x2212;j&#x200B;)an&#x2212;jbn&#x2212;i &#xFF0C;&#x683C;&#x5B50; (1,i&gt;1)(1,i&gt;1)(1,i&gt;1) &#x7684;&#x7CFB;&#x6570;&#x662F; (n+n&#x2212;2&#x2212;in&#x2212;2)an&#x2212;ibn&#x2212;1\\binom{n+n-2-i}{n-2}a^{n-i}b^{n-1}(n&#x2212;2n+n&#x2212;2&#x2212;i&#x200B;)an&#x2212;ibn&#x2212;1 &#xFF0C;&#x683C;&#x5B50; (i&gt;1,1)(i&gt;1,1)(i&gt;1,1) &#x7684;&#x7CFB;&#x6570;&#x662F; (n+n&#x2212;2&#x2212;in&#x2212;2)an&#x2212;1bn&#x2212;i\\binom{n+n-2-i}{n-2}a^{n-1}b^{n-i}(n&#x2212;2n+n&#x2212;2&#x2212;i&#x200B;)an&#x2212;1bn&#x2212;i &#xFF0C;&#x90A3;&#x4E48;&#x663E;&#x7136; Ans=&#x2211;i=2nf1,i(n+n&#x2212;2&#x2212;in&#x2212;2)an&#x2212;ibn&#x2212;1+&#x2211;i=2nfi,1(n+n&#x2212;2&#x2212;in&#x2212;2)an&#x2212;1bn&#x2212;i+&#x2211;i=2n&#x2211;j=2nc(n+n&#x2212;i&#x2212;jn&#x2212;i)an&#x2212;jbn&#x2212;i\\begin{aligned} Ans=&amp;\\sum\\limits_{i=2}^nf_{1,i}\\binom{n+n-2-i}{n-2}a^{n-i}b^{n-1}+\\sum\\limits_{i=2}^nf_{i,1}\\binom{n+n-2-i}{n-2}a^{n-1}b^{n-i}+\\sum\\limits_{i=2}^n\\sum\\limits_{j=2}^nc\\binom{n+n-i-j}{n-i}a^{n-j}b^{n-i} \\end{aligned} Ans=&#x200B;i=2&#x2211;n&#x200B;f1,i&#x200B;(n&#x2212;2n+n&#x2212;2&#x2212;i&#x200B;)an&#x2212;ibn&#x2212;1+i=2&#x2211;n&#x200B;fi,1&#x200B;(n&#x2212;2n+n&#x2212;2&#x2212;i&#x200B;)an&#x2212;1bn&#x2212;i+i=2&#x2211;n&#x200B;j=2&#x2211;n&#x200B;c(n&#x2212;in+n&#x2212;i&#x2212;j&#x200B;)an&#x2212;jbn&#x2212;i&#x200B; &#x53D1;&#x73B0;&#x524D;&#x9762;&#x7684;&#x53EF;&#x4EE5; O(n)O(n)O(n) &#x7B97;&#x540E;&#x9762;&#x7684;&#x53EF;&#x4EE5;&#x5377;&#x79EF;&#x7B97;&#xFF0C;&#x590D;&#x6742;&#x5EA6; O(nlog&#x2061;n)O(n\\log n)O(nlogn) &#x5176;&#x5B9E;&#x540E;&#x9762;&#x7684;&#x5F0F;&#x5B50;&#x53EF;&#x4EE5;&#x7528;&#x7EC4;&#x5408;&#x6570;&#x63A8;&#x51FA;O(n)&#x7684;&#x5F0F;&#x5B50;&#x4F46;&#x7531;&#x4E8E;&#x6211;&#x592A;&#x61D2;&#x4E86;&#x5C31;&#x4E0D;&#x5199;&#x4E86;&#xFF0C;&#x53EF;&#x4EE5;&#x53C2;&#x89C1;&#x5B98;&#x65B9;&#x9898;&#x89E3; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() { int ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}struct cp { double x,y; cp(double x=0,double y=0):x(x),y(y) {} friend inline cp operator+(cp a,cp b) { return cp(a.x+b.x,a.y+b.y); } friend inline void operator+=(cp&amp;a,cp b) { a=a+b; } friend inline cp operator-(cp a,cp b) { return cp(a.x-b.x,a.y-b.y); } friend inline void operator-=(cp&amp;a,cp b) { a=a-b; } friend inline cp operator*(cp a,cp b) { return cp(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x); } friend inline void operator*=(cp&amp;a,cp b) { a=a*b; } friend inline cp operator*(cp a,double b) { return cp(a.x*b,a.y*b); } friend inline void operator*=(cp&amp;a,double b) { a=a*b; } friend inline cp operator/(cp a,double b) { return cp(a.x/b,a.y/b); } friend inline void operator/=(cp&amp;a,double b) { a=a/b; } inline cp operator~() const { return cp(x,-y); }};typedef vector&lt;cp&gt; poly;const double pi=acos(-1.0);int lim,tim;vector&lt;cp&gt; w[20];vector&lt;int&gt;rev[20];inline void init_fft() { w[19].resize(1&lt;&lt;19); for(ri i=0,lm=1&lt;&lt;19;i&lt;lm;++i) w[19][i]=cp(cos(pi/lm*i),sin(pi/lm*i)); for(ri i=18;~i;--i) { w[i].resize(1&lt;&lt;i); for(ri j=0,up=1&lt;&lt;i;j&lt;up;++j) w[i][j]=w[i+1][j&lt;&lt;1]; }}inline void init(int up) { lim=1,tim=0; while(lim&lt;up) lim&lt;&lt;=1,++tim; if(rev[tim].size()) return; rev[tim].resize(lim); for(ri i=1;i&lt;lim;++i) rev[tim][i]=(rev[tim][i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(tim-1));}inline void fft(poly&amp;a,int typ) { for(ri i=1;i&lt;lim;++i) if(i&lt;rev[tim][i]) swap(a[i],a[rev[tim][i]]); cp a0,a1; for(ri i=1,t=0;i&lt;lim;i&lt;&lt;=1,++t) for(ri j=0,len=i&lt;&lt;1;j&lt;lim;j+=len) { for(ri k=0;k&lt;i;++k) { a0=a[j+k],a1=a[j+k+i]*w[t][k]; a[j+k]=a0+a1,a[j+k+i]=a0-a1; } } if(~typ) return; reverse(++a.begin(),a.end()); for(ri i=0;i&lt;lim;++i) a[i]/=lim;}namespace modular { const int mod=1e6+3; inline int add(int a,int b) { return a+b&lt;mod?a+b:a+b-mod; } inline int dec(int a,int b) { return a&lt;b?a-b+mod:a-b; } inline int mul(int a,int b) { return (ll)a*b%mod; } inline void Add(int&amp;a,int b) { a=a+b&lt;mod?a+b:a+b-mod; } inline void Dec(int&amp;a,int b) { a=a&lt;b?a-b+mod:a-b; } inline void Mul(int&amp;a,int b) { a=(ll)a*b%mod; } inline int ksm(int a,int p) { int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; } inline int Inv(int a) { return ksm(a,mod-2); }}using namespace modular;const int N=4e5+5,blo=1023;inline int poly_mul(int*a,int*b,int n,int m,int*c) { int t=n+m-1; init(t); poly A(lim),B(lim),P(lim),Q(lim); for(ri i=0;i&lt;n;++i) A[i]=cp(a[i]&gt;&gt;10,a[i]&amp;blo); for(ri i=0;i&lt;m;++i) B[i]=cp(b[i]&gt;&gt;10,b[i]&amp;blo); fft(A,1),fft(B,1); cp cur[4]; for(ri i=0,j=0;i&lt;lim;++i,j=j?j-1:lim-1) { cur[0]=(A[i]+(~A[j]))*cp(0.5,0); cur[1]=((~A[j])-A[i])*cp(0,0.5); cur[2]=(B[i]+(~B[j]))*cp(0.5,0); cur[3]=((~B[j])-B[i])*cp(0,0.5); P[i]=cur[0]*cur[2]+cp(0,1)*cur[1]*cur[3]; Q[i]=cur[0]*cur[3]+cp(0,1)*cur[1]*cur[2]; } fft(P,-1),fft(Q,-1); ll cr[4]; for(ri i=0;i&lt;t;++i) { cr[0]=(ll)(P[i].x+0.5)%mod; cr[1]=(ll)(P[i].y+0.5)%mod; cr[2]=(ll)(Q[i].x+0.5)%mod; cr[3]=(ll)(Q[i].y+0.5)%mod; c[i]=((cr[0]&lt;&lt;20)+(cr[2]+cr[3]&lt;&lt;10)+cr[1])%mod; } return t;}int n,c,vl1[N&gt;&gt;1],vl2[N&gt;&gt;1],fac[N],ifac[N],pwa[N&gt;&gt;1],pwb[N&gt;&gt;1];inline void init() { int up=n&lt;&lt;1; fac[0]=fac[1]=ifac[0]=ifac[1]=1; for(ri i=2;i&lt;=up;++i) { fac[i]=mul(fac[i-1],i); ifac[i]=mul(ifac[mod-mod/i*i],mod-mod/i); } for(ri i=2;i&lt;=up;++i) Mul(ifac[i],ifac[i-1]);}inline int C(int n,int m) { return n&lt;m||m&lt;0?0:(ll)fac[n]*ifac[m]*ifac[n-m]%mod; }int F[N&gt;&gt;1],G[N&gt;&gt;1],H[N],len;int main() { #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif init_fft(); pwa[0]=pwb[0]=1; n=read(),pwa[1]=read(),pwb[1]=read(),c=read(); init(); for(ri i=2;i&lt;=n;++i) pwa[i]=mul(pwa[i-1],pwa[1]),pwb[i]=mul(pwb[i-1],pwb[1]); for(ri i=1;i&lt;=n;++i) vl1[i]=read(); for(ri i=1;i&lt;=n;++i) vl2[i]=read(); int res=0; for(ri i=2;i&lt;=n;++i) { Add(res,mul(mul(vl1[i],C((n&lt;&lt;1)-2-i,n-2)),mul(pwa[n-1],pwb[n-i]))); Add(res,mul(mul(vl2[i],C((n&lt;&lt;1)-2-i,n-2)),mul(pwb[n-1],pwa[n-i]))); } for(ri i=0;i&lt;n-1;++i) F[i]=mul(ifac[i],pwa[i]),G[i]=mul(ifac[i],pwb[i]); len=poly_mul(F,G,n-1,n-1,H); for(ri i=0;i&lt;len;++i) Add(res,mul(mul(c,fac[i]),H[i])); cout&lt;&lt;res; return 0;}","categories":[{"name":"public","slug":"public","permalink":"http://xdl030112.github.io/categories/public/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://xdl030112.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"杂题乱做 Round11","slug":"sol11","date":"2019-12-24T15:12:07.000Z","updated":"2019-12-25T00:05:39.723Z","comments":true,"path":"sol11/","link":"","permalink":"http://xdl030112.github.io/sol11/","excerpt":"","text":"Triple &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x8FD8;&#x662F;&#x8DDF; &#x9ECE;&#x660E;&#x524D;&#x7684;&#x5DE7;&#x514B;&#x529B; &#x5DEE;&#x4E0D;&#x591A;&#xFF0C;&#x6784;&#x9020;&#x96C6;&#x5408;&#x5E42;&#x7EA7;&#x6570;&#xFF0C;&#x90A3;&#x4E48;&#x7B54;&#x6848;&#x7B49;&#x4E8E; &#x220F;i=1n(axXi+bxYi+cxZi)\\prod\\limits_{i=1}^n(ax^{X_i}+bx^{Y_i}+cx^{Z_i})i=1&#x220F;n&#x200B;(axXi&#x200B;+bxYi&#x200B;+cxZi&#x200B;) &#xFF0C;&#x8FD9;&#x6837;&#x6BCF;&#x4E00;&#x4E2A;&#x5F0F;&#x5B50;&#x5BF9;&#x7B54;&#x6848;&#x7684;&#x8D21;&#x732E;&#x4E00;&#x5B9A;&#x662F; &#xB1;a&#xB1;b&#xB1;c\\pm a\\pm b\\pm c&#xB1;a&#xB1;b&#xB1;c &#xFF0C;&#x4F46;&#x76F4;&#x63A5; fwtfwtfwt &#x4E4B;&#x540E;&#x89E3;&#x65B9;&#x7A0B;&#x5E38;&#x6570;&#x5B9E;&#x5728;&#x592A;&#x5927;&#xFF0C;&#x8003;&#x8651;&#x4F18;&#x5316;&#xFF0C;&#x53D1;&#x73B0;&#x53EF;&#x4EE5;&#x628A;&#x5F0F;&#x5B50;&#x6539;&#x5199;&#x6210; &#x2211;i=1n(a+bYi&#x2295;Xi+cZi&#x2295;Xi)\\sum\\limits_{i=1}^n(a+b^{Y_i\\oplus X_i}+c^{Z_i\\oplus X_i})i=1&#x2211;n&#x200B;(a+bYi&#x200B;&#x2295;Xi&#x200B;+cZi&#x200B;&#x2295;Xi&#x200B;) &#x6700;&#x540E;&#x7ED9;&#x7ED3;&#x679C;&#x5F02;&#x6216;&#x4E0A; &#x2295;i=1nXi\\oplus_{i=1}^nX_i&#x2295;i=1n&#x200B;Xi&#x200B; &#xFF0C;&#x663E;&#x7136;&#x4E0A;&#x8FF0;&#x4E24;&#x79CD;&#x65B9;&#x5F0F;&#x5F97;&#x5230;&#x7684;&#x7ED3;&#x679C;&#x662F;&#x4E00;&#x6837;&#x7684;&#xFF0C;&#x90A3;&#x4E48;&#x8FD9;&#x6B21;&#x6BCF;&#x4E2A;&#x5F0F;&#x5B50;&#x5BF9;&#x7B54;&#x6848;&#x7684;&#x8D21;&#x732E;&#x5C31;&#x662F; a&#xB1;b&#xB1;ca\\pm b\\pm ca&#xB1;b&#xB1;c &#xFF0C;&#x4E8E;&#x662F;&#x5C31;&#x5982;&#x540C;&#x524D;&#x7F6E;&#x9898;&#x76EE;&#x4E00;&#x6837;&#x5206;&#x522B;&#x628A; &#x2211;i=1nxYi&#x2295;Xi,&#x2211;i=1nxZi&#x2295;Xi,&#x2211;i=1nxYi&#x2295;Zi\\sum\\limits_{i=1}^nx^{Y_i\\oplus X_i},\\sum\\limits_{i=1}^nx^{Z_i\\oplus X_i},\\sum\\limits_{i=1}^nx^{Y_i\\oplus Z_i}i=1&#x2211;n&#x200B;xYi&#x200B;&#x2295;Xi&#x200B;,i=1&#x2211;n&#x200B;xZi&#x200B;&#x2295;Xi&#x200B;,i=1&#x2211;n&#x200B;xYi&#x200B;&#x2295;Zi&#x200B; &#x7ED9; dwtdwtdwt &#x6389;&#xFF0C;&#x7B97;&#x6210;&#x6B63;&#x786E;&#x70B9;&#x503C;&#x4E4B;&#x540E;&#x518D; idwtidwtidwt &#x56DE;&#x53BB;&#x5C31;&#x884C;&#x4E86; CODE cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;#define ri register inttypedef long long ll;using namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() { int ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}namespace modular { const int mod=998244353; inline int add(int a,int b) { return a+b&lt;mod?a+b:a+b-mod; } inline int dec(int a,int b) { return a&lt;b?a-b+mod:a-b; } inline int mul(int a,int b) { return (ll)a*b%mod; } inline void Add(int&amp;a,int b) { a=a+b&lt;mod?a+b:a+b-mod; } inline void Dec(int&amp;a,int b) { a=a&lt;b?a-b+mod:a-b; } inline void Mul(int&amp;a,int b) { a=(ll)a*b%mod; } inline int ksm(int a,int p) { int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; } inline int Inv(int a) { return ksm(a,mod-2); }}using namespace modular;const int N=1e6+5;int lim,n,X,Y,Z,vl[4],a[N],b[N],c[N];inline void dwt(int*a,int typ) { for(ri i=1,a0,a1,iv=mod+1&gt;&gt;1;i&lt;lim;i&lt;&lt;=1)for(ri j=0,len=i&lt;&lt;1;j&lt;lim;j+=len) for(ri k=0;k&lt;i;++k) { a0=a[j+k],a1=a[j+k+i]; a[j+k]=add(a0,a1),a[j+k+i]=dec(a0,a1); if(typ==-1) Mul(a[j+k],iv),Mul(a[j+k+i],iv); }}int main() { #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(),lim=1&lt;&lt;read(); X=read(),Y=read(),Z=read(); int ss=0; for(ri i=1,_a,_b,_c;i&lt;=n;++i) { _a=read(),_b=read()^_a,_c=read()^_a; ss^=_a; ++a[_b^_c],++b[_b],++c[_c]; } dwt(a,1),dwt(b,1),dwt(c,1); vl[0]=add(X,add(Y,Z)); vl[1]=add(X,dec(Y,Z)); vl[2]=add(X,dec(Z,Y)); vl[3]=dec(X,add(Y,Z)); for(ri iv=Inv(4),x,y,z,w,i=0;i&lt;lim;++i) { x=mul(iv,add(add(n,a[i]),add(b[i],c[i]))); y=mul(iv,dec(add(n,b[i]),add(c[i],a[i]))); z=mul(iv,dec(add(n,c[i]),add(b[i],a[i]))); w=mul(iv,dec(add(n,a[i]),add(b[i],c[i]))); a[i]=mul(mul(ksm(vl[0],x),ksm(vl[1],y)),mul(ksm(vl[2],z),ksm(vl[3],w))); } dwt(a,-1); for(ri i=0;i&lt;lim;++i) cout&lt;&lt;a[i^ss]&lt;&lt;&apos; &apos;; return 0;} &#x5C0F; Y &#x7684;&#x80CC;&#x5305;&#x8BA1;&#x6570;&#x95EE;&#x9898; &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x5BF9;&#x4E8E;&#x7B2C; iii &#x79CD;&#x7269;&#x54C1;&#xFF0C;&#x5982;&#x679C;&#x6309;&#x7167;&#x6A21; iii &#x7684;&#x4F59;&#x6570;&#x8BB0;&#x5F55;&#x524D;&#x7F00;&#x548C;&#x505A;&#x80CC;&#x5305; DPDPDP &#x7684;&#x8BDD;&#x590D;&#x6742;&#x5EA6;&#x662F; O(ni)O(ni)O(ni) &#x7684;&#xFF0C;&#x90A3;&#x4E48;&#x8003;&#x8651;&#x5BF9;&#x524D; KKK &#x79CD;&#x7269;&#x54C1;&#x6309;&#x7167;&#x4E0A;&#x8FF0;&#x505A;&#x6CD5;&#x8FDB;&#x884C;&#x80CC;&#x5305;&#xFF0C;&#x90A3;&#x4E48;&#x540E;&#x9762;&#x7684;&#x7269;&#x54C1;&#x6700;&#x591A;&#x80FD;&#x9009; nK\\frac nKKn&#x200B; &#x4E2A;&#xFF0C;&#x6240;&#x4EE5;&#x8003;&#x8651;&#x5982;&#x4E0B; DPDPDP &#xFF0C;&#x8BBE;&#x540E;&#x9762;&#x6240;&#x6709;&#x7269;&#x54C1;&#x4E00;&#x5171;&#x9009;&#x4E86; iii &#x4E2A;&#xFF0C;&#x603B;&#x548C;&#x4E3A; jjj &#x7684;&#x65B9;&#x6848;&#x6570;&#xFF0C;&#x5BF9;&#x4E8E;&#x8F6C;&#x79FB;&#x4F5C;&#x5982;&#x4E0B;&#x8003;&#x8651;&#xFF0C;&#x6211;&#x4EEC;&#x60F3;&#x8C61;&#x8FD9; iii &#x4E2A;&#x7269;&#x54C1;&#x6392;&#x597D;&#x5E8F;&#x653E;&#x5728;&#x4E00;&#x4E2A;&#x5E8F;&#x5217;&#x4E0A;&#xFF0C;&#x73B0;&#x5728;&#x6709;&#x4E24;&#x79CD;&#x64CD;&#x4F5C;&#xFF1A; &#x5728;&#x961F;&#x9996;&#x63D2;&#x5165;&#x4E00;&#x4E2A;&#x5927;&#x5C0F;&#x4E3A; K+1K+1K+1 &#x7684;&#x7269;&#x54C1; &#x7ED9;&#x5F53;&#x524D;&#x6240;&#x6709;&#x7269;&#x54C1;&#x6743;&#x503C;+1 &#x8FD9;&#x6837;&#x80FD;&#x505A;&#x5230;&#x4E0D;&#x91CD;&#x4E0D;&#x6F0F;&#xFF0C;&#x590D;&#x6742;&#x5EA6;&#x4E3A; O(n2K)O(\\frac{n^2}K)O(Kn2&#x200B;) &#xFF0C;&#x56E0;&#x6B64; KKK &#x53D6; n\\sqrt nn&#x200B; &#x65F6;&#x6700;&#x4F18; CODE cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() { int ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}namespace modular { const int mod=23333333; inline int add(int a,int b) { return a+b&lt;mod?a+b:a+b-mod; } inline int dec(int a,int b) { return a&lt;b?a-b+mod:a-b; } inline int mul(int a,int b) { return (ll)a*b%mod; } inline void Add(int&amp;a,int b) { a=a+b&lt;mod?a+b:a+b-mod; } inline void Dec(int&amp;a,int b) { a=a&lt;b?a-b+mod:a-b; } inline void Mul(int&amp;a,int b) { a=(ll)a*b%mod; } inline int ksm(int a,int p) { int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; } inline int Inv(int a) { return ksm(a,mod-2); }}using namespace modular;const int N=1e5+5;int f[2][N],cur,g[350][N],n,sum[350],ss[N];int main() { #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(); f[cur=0][0]=1; int res=0,sig=sqrt(n); for(ri x,id=1;id&lt;=sig;++id) { x=id*id; cur^=1; for(ri i=0;i&lt;id;++i) sum[i]=0; for(ri i=0,t=0;i&lt;=n;++i,t=t==id-1?0:t+1) { Add(sum[t],f[cur^1][i]); f[cur][i]=sum[t]; if(i&gt;=x) Dec(sum[t],f[cur^1][i-x]); } } g[0][0]=1; for(ri i=0;i&lt;=sig;++i) for(ri j=0;j&lt;=n;++j) if(g[i][j]) { if(i&amp;&amp;i+j&lt;=n) Add(g[i][j+i],g[i][j]); if(j+sig+1&lt;=n) Add(g[i+1][j+sig+1],g[i][j]); if(j) Add(ss[j],g[i][j]); } ss[0]=1; for(ri i=0;i&lt;=n;++i) Add(res,mul(ss[i],f[cur][n-i])); cout&lt;&lt;res; return 0;} &#x6700;&#x5927;&#x524D;&#x7F00;&#x548C; &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x66B4;&#x529B;&#x679A;&#x4E3E;&#x6BCF;&#x79CD;&#x524D;&#x7F00;&#x7684;&#x96C6;&#x5408;&#x4E3A;&#x6700;&#x5927;&#x524D;&#x7F00;&#x548C;&#x7684;&#x7B54;&#x6848;&#x90A3;&#x4E48;&#x540E;&#x9762;&#x586B;&#x4E0A;&#x7684;&#x6570;&#x7EC4;&#x6210;&#x7684;&#x4EFB;&#x610F;&#x524D;&#x7F00;&#x548C;&#x90FD;&#x5FC5;&#x987B;&#x5C0F;&#x4E8E;0&#xFF0C;&#x628A;&#x8FD9;&#x4E2A;&#x65B9;&#x6848;&#x6570;&#x8BBE;&#x4E3A; ggg &#x7C7B;&#x4F3C;&#x8003;&#x8651;&#x4E00;&#x4E2A;&#x96C6;&#x5408;&#x4F5C;&#x4E3A;&#x6700;&#x5927;&#x524D;&#x7F00;&#x548C;&#xFF0C;&#x628A;&#x8FD9;&#x4E2A;&#x5E8F;&#x5217;&#x53CD;&#x8FC7;&#x6765;&#xFF0C;&#x5219;&#x4E00;&#x5B9A;&#x4E0D;&#x5B58;&#x5728;&#x524D;&#x7F00;&#x548C;&#x5C0F;&#x4E8E;0&#xFF0C;&#x4E8E;&#x662F;&#x540C;&#x7406;&#x5B9A;&#x4E49;&#x4E00;&#x4E2A; fff &#xFF0C;&#x628A;&#x8FD9;&#x4E24;&#x4E2A;&#x72B6;&#x538B; dpdpdp &#x51FA;&#x6765;&#x5373;&#x53EF; CODE cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() { int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch)) f^=ch==&apos;-&apos;,ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;}namespace modular { const int mod=998244353; inline int add(int a,int b) { return a+b&lt;mod?a+b:a+b-mod; } inline int dec(int a,int b) { return a&lt;b?a-b+mod:a-b; } inline int mul(int a,int b) { return (ll)a*b%mod; } inline void Add(int&amp;a,int b) { a=a+b&lt;mod?a+b:a+b-mod; } inline void Dec(int&amp;a,int b) { a=a&lt;b?a-b+mod:a-b; } inline void Mul(int&amp;a,int b) { a=(ll)a*b%mod; } inline int ksm(int a,int p) { int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; } inline int Inv(int a) { return ksm(a,mod-2); } inline int fix(int a) { return (a%mod+mod)%mod; }}using namespace modular;const int N=25;int n,lim;ll s1[1&lt;&lt;20];int s2[1&lt;&lt;20],f[1&lt;&lt;20],g[1&lt;&lt;20];inline void fmt(ll*a1,int*a2) { for(ri i=1;i&lt;lim;i&lt;&lt;=1) for(ri j=0,len=i&lt;&lt;1;j&lt;lim;j+=len) for(ri k=0;k&lt;i;++k) s1[j+k+i]+=s1[j+k],Add(s2[j+k+i],s2[j+k]);}int main() { #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(),lim=1&lt;&lt;n; for(ri i=0;i&lt;n;++i) s1[1&lt;&lt;i]=read(),s2[1&lt;&lt;i]=fix(s1[1&lt;&lt;i]),f[1&lt;&lt;i]=1; fmt(s1,s2); g[0]=1; for(ri i=1;i&lt;lim;++i) { if(s1[i]&gt;=0) { for(ri j=0;j&lt;n;++j) if(!(i&gt;&gt;j&amp;1)) Add(f[i|(1&lt;&lt;j)],f[i]); } else for(ri j=0;j&lt;n;++j) if(i&gt;&gt;j&amp;1) Add(g[i],g[i^(1&lt;&lt;j)]); } int res=0; for(ri i=1;i&lt;lim;++i) Add(res,mul(mul(s2[i],f[i]),g[(lim-1)^i])); cout&lt;&lt;res; return 0;} Chef and Horcrux &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x5148;&#x7B80;&#x5355;&#x6C42;&#x51FA; mexmexmex &#x4E3A; iii &#x7684;&#x5B50;&#x5E8F;&#x5217;&#x4E2A;&#x6570;&#xFF0C;&#x7136;&#x540E;&#x76F4;&#x63A5; KKK &#x8FDB;&#x5236; fwtfwtfwt &#x8F6C;&#x70B9;&#x503C;&#xFF0C;&#x7136;&#x540E;&#x5FEB;&#x901F;&#x5E42;&#x4E00;&#x4E0B;&#x518D;&#x8F6C;&#x56DE;&#x53BB;&#x7EDF;&#x8BA1;&#x7B54;&#x6848;&#x5C31;&#x5B8C;&#x4E86; CODE cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() { int ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline ll readl() { ll ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}namespace modular { const int mod=330301441; inline int add(int a,int b) { return a+b&lt;mod?a+b:a+b-mod; } inline int dec(int a,int b) { return a&lt;b?a-b+mod:a-b; } inline int mul(int a,int b) { return (ll)a*b%mod; } inline void Add(int&amp;a,int b) { a=a+b&lt;mod?a+b:a+b-mod; } inline void Dec(int&amp;a,int b) { a=a&lt;b?a-b+mod:a-b; } inline void Mul(int&amp;a,int b) { a=(ll)a*b%mod; } inline int ksm(int a,int p) { int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; } inline int Inv(int a) { return ksm(a,mod-2); }}using namespace modular;const int N=1e5+5;int n,K,X,pw[N],inv[11],a[N&lt;&lt;4],cnt[N],mx,lim,w[11][11];inline void init() { pw[0]=1; for(ri i=1;i&lt;=100000;++i) pw[i]=add(pw[i-1],pw[i-1]); inv[1]=1; for(ri i=2;i&lt;11;++i) { inv[i]=mul(inv[mod-mod/i*i],mod-mod/i),w[i][0]=1,w[i][1]=ksm(3,(mod-1)/(i&lt;&lt;1)); for(ri j=2;j&lt;i;++j) w[i][j]=mul(w[i][j-1],w[i][1]); }}inline void fft(int*a,int typ) { static int sum[11]; for(ri j=0;j&lt;K;++j) if(a[j]) for(ri i=0,t=0;i&lt;K;++i,t=t+j&lt;K?t+j:t+j-K) Add(sum[i],mul(a[j],w[K][t])); for(ri i=0;i&lt;K;++i) a[i]=sum[i],sum[i]=0; if(~typ) return; for(ri i=1;i+i&lt;K;++i) swap(a[i],a[K-i]); for(ri i=0;i&lt;K;++i) Mul(a[i],inv[K]);}inline void fwt(int*a,int typ) { static int cur[11]; for(ri i=1;i&lt;lim;i*=K) for(ri j=0,len=i*K;j&lt;lim;j+=len) for(ri k=0;k&lt;i;++k) { for(ri o=0;o&lt;K;++o) cur[o]=a[o*i+j+k]; fft(cur,typ); for(ri o=0;o&lt;K;++o) a[o*i+j+k]=cur[o]; }}int main() { #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif init(); for(ri ps,tt=read();tt;--tt) { n=read(),K=read(),X=readl()%(mod-1); mx=0; for(ri i=1,x;i&lt;=n;++i) x=read(),++cnt[x],mx=max(mx,x); ++mx; for(ri i=0,pre=0,premt=1;i&lt;=mx;++i) { pre+=cnt[i]; a[i]=mul(premt,pw[n-pre]); if(!cnt[i]) { ps=i;break; } Mul(premt,dec(pw[cnt[i]],1)); } for(lim=1;lim&lt;=ps;lim*=K); int res=0,ss=ksm(Inv(pw[n]),X); fwt(a,1); for(ri i=0;i&lt;lim;++i) a[i]=ksm(a[i],X); fwt(a,-1); for(ri i=0;i&lt;lim;++i) if(a[i]) Mul(a[i],ss),Add(res,mul(ksm(i,2*i),ksm(a[i],3*i))),a[i]=0; cout&lt;&lt;res&lt;&lt;&apos;\\n&apos;; for(ri i=0;i&lt;=mx;++i) cnt[i]=0; } return 0;} &#x751F;&#x6210;&#x6811;&#x6C42;&#x548C; &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x4E3B;&#x8981;&#x662F;&#x5F97;&#x89C2;&#x5BDF;&#x5230;&#x53EF;&#x4EE5;&#x6309;&#x4F4D;&#x8003;&#x8651;&#xFF0C;&#x90A3;&#x4E48;&#x6BCF;&#x4E00;&#x4F4D;&#x672C;&#x6765;&#x5E94;&#x8BE5;&#x662F;&#x505A;&#x4E0D;&#x8FDB;&#x4F4D;&#x52A0;&#x6CD5;&#x4F46;&#x662F;&#x77E9;&#x9635;&#x6811;&#x53EA;&#x80FD;&#x505A;&#x4E58;&#x6CD5;&#xFF0C;&#x56E0;&#x6B64;&#x6211;&#x4EEC;&#x5C06;&#x5176;&#x8F6C;&#x4E3A;&#x70B9;&#x503C;&#xFF0C;&#x77E9;&#x9635;&#x6811;&#x4E4B;&#x540E;&#x518D;&#x8F6C;&#x56DE;&#x6765;&#x5373;&#x53EF; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() { int ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}namespace modular { const int mod=1e9+7,iv3=(mod+1)/3; inline int add(int a,int b) { return a+b&lt;mod?a+b:a+b-mod; } inline int dec(int a,int b) { return a&lt;b?a-b+mod:a-b; } inline int mul(int a,int b) { return (ll)a*b%mod; } inline void Add(int&amp;a,int b) { a=a+b&lt;mod?a+b:a+b-mod; } inline void Dec(int&amp;a,int b) { a=a&lt;b?a-b+mod:a-b; } inline void Mul(int&amp;a,int b) { a=(ll)a*b%mod; } inline int ksm(int a,int p) { int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; } inline int Inv(int a) { return ksm(a,mod-2); } inline int fix(int a) { return (a%mod+mod)%mod; }}using namespace modular;struct cp { int a,b; cp(int a=0,int b=0):a(a),b(b) {} friend inline cp operator+(cp a, cp b) { return cp(add(a.a,b.a),add(a.b,b.b)); } friend inline void operator+=(cp&amp;a,cp b) { a=a+b; } friend inline cp operator-(cp a,cp b) { return cp(dec(a.a,b.a),dec(a.b,b.b)); } friend inline void operator-=(cp&amp;a,cp b) { a=a-b; } friend inline cp operator*(cp a,cp b) { return cp(dec(mul(a.a,b.a),mul(a.b,b.b)),dec(add(mul(a.a,b.b),mul(a.b,b.a)),mul(a.b,b.b))); } friend inline void operator*=(cp&amp;a,cp b) { a=a*b; } friend inline cp operator*(cp a,int b) { return cp(mul(a.a,b),mul(a.b,b)); } friend inline void operator*=(cp&amp;a,int b) { a=a*b; } inline cp inv() const { return cp(dec(a,b),mod-b)*Inv(dec(add(mul(a,a),mul(b,b)),mul(a,b))); } friend inline cp operator/(cp a,cp b) { return a*(b.inv()); } friend inline void operator/=(cp&amp;a,cp b) { a=a/b; } friend inline bool operator!=(cp a,cp b) { return a.a^b.a||a.b^b.b; }}w[3];const int N=105;int n,m;cp a[N][N];struct edge{ int u,v,w; edge(int u=0,int v=0,int w=0):u(u),v(v),w(w) {}}e[N*N&gt;&gt;1];inline cp Det() { cp res(1,0),iv,t; vector&lt;int&gt;pos; for(ri ps,i=1;i&lt;n;++i) { for(ps=i;ps&lt;n;++ps) if(a[ps][i]!=cp(0,0)) break; if(ps==n) { res=cp(0,0);break; } if(ps&gt;i) { res=cp(mod-res.a,mod-res.b); for(ri j=1;j&lt;n;++j) swap(a[i][j],a[ps][j]); } pos.clear(); for(ri j=i;j&lt;n;++j) if(a[i][j]!=cp(0,0)) pos.pb(j); iv=a[i][i].inv(); for(ri j=i,up=pos.size();j&lt;n;++j) if(a[j][i]!=cp(0,0)&amp;&amp;j!=i) { t=iv*a[j][i]; for(ri k=0;k&lt;up;++k) a[j][pos[k]]-=a[i][pos[k]]*t; } res*=a[i][i]; } for(ri i=1;i&lt;n;++i) for(ri j=1;j&lt;n;++j) a[i][j]=cp(0,0); return res;}cp cur[3];int vl[N*N&gt;&gt;1];inline void idft() { static cp sum[3]; for(ri j=0;j&lt;3;++j) for(ri i=0;i&lt;3;++i) sum[i]+=cur[j]*w[i*j&lt;3?i*j:i*j-3]; for(ri i=0;i&lt;3;++i) cur[i]=sum[i]*iv3,sum[i]=cp(0,0); swap(cur[1],cur[2]);}inline int calc() { return add(cur[1].a,add(cur[2].a,cur[2].a)); }int main() { freopen(&quot;sum.in&quot;,&quot;r&quot;,stdin); freopen(&quot;sum.out&quot;,&quot;w&quot;,stdout); n=read(),m=read(); w[0]=cp(1,0); w[1]=cp(0,1); w[2]=cp(mod-1,mod-1); int mx=0,res=0; for(ri i=1;i&lt;=m;++i) e[i].u=read(),e[i].v=read(),e[i].w=read(),mx=max(mx,e[i].w); cp t; for(ri i=1;i&lt;=mx;i*=3) { for(ri j=1;j&lt;=m;++j) vl[j]=e[j].w/i%3; for(ri o=0;o&lt;3;++o) { for(ri j=1;j&lt;=m;++j) { t=w[vl[j]*o%3]; a[e[j].u][e[j].u]+=t; a[e[j].v][e[j].v]+=t; a[e[j].u][e[j].v]-=t; a[e[j].v][e[j].u]-=t; } cur[o]=Det(); } idft(),Add(res,mul(i,calc())); } cout&lt;&lt;res; return 0;} Petya and Sequence &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x8003;&#x8651;&#x5982;&#x4F55;&#x5224;&#x5B9A;&#xFF0C;&#x53D1;&#x73B0;&#x628A; BBB &#x7ED9; reversereversereverse &#x8FC7;&#x6765;&#x5C31;&#x662F;&#x5728;&#x505A;&#x5FAA;&#x73AF;&#x5377;&#x79EF;&#xFF0C;&#x90A3;&#x4E48;&#x76F8;&#x5F53;&#x4E8E;&#x662F;&#x95EE;&#x5C06; AAA &#x5728;&#x8F6C;&#x70B9;&#x503C;&#x4E4B;&#x540E;&#x6709;&#x6CA1;&#x6709;&#x96F6;&#x9879;&#xFF0C;&#x4E8E;&#x662F;&#x83BD;&#x4E00;&#x4E2A; Bluestein&#x2032;s&#xA0;algorithmBluestein&apos;s\\ algorithmBluestein&#x2032;s&#xA0;algorithm &#x5C31;&#x884C;&#x4E86; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef vector&lt;int&gt; poly;#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() { int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch)) f^=ch==&apos;-&apos;,ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;}namespace modular { int mod; inline int add(int a,int b) { return a+b&lt;mod?a+b:a+b-mod; } inline int dec(int a,int b) { return a&lt;b?a-b+mod:a-b; } inline int mul(int a,int b) { return (ll)a*b%mod; } inline void Add(int&amp;a,int b) { a=a+b&lt;mod?a+b:a+b-mod; } inline void Dec(int&amp;a,int b) { a=a&lt;b?a-b+mod:a-b; } inline void Mul(int&amp;a,int b) { a=(ll)a*b%mod; } inline int ksm(int a,int p) { int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; } inline int Inv(int a) { return ksm(a,mod-2); } inline int fix(int a) { return (a%mod+mod)%mod; }}using namespace modular;const int N=30005;int iv1,iv2;int vl[N],n,G,pri[1000005],tot=0,omega[N&lt;&lt;1];bool vs[10000005];inline int C2(int x) { return (ll)x*(x-1)/2%n; }struct Ntt { int mod,g,lim,tim; inline int add(int a,int b) { return a+b&lt;mod?a+b:a+b-mod; } inline int dec(int a,int b) { return a&lt;b?a-b+mod:a-b; } inline int mul(int a,int b) { return (ll)a*b%mod; } inline void Add(int&amp;a,int b) { a=a+b&lt;mod?a+b:a+b-mod; } inline void Dec(int&amp;a,int b) { a=a&lt;b?a-b+mod:a-b; } inline void Mul(int&amp;a,int b) { a=(ll)a*b%mod; } inline int ksm(int a,int p) { int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; } inline int Inv(int a) { return ksm(a,mod-2); } inline int fix(int a) { return (a%mod+mod)%mod; } int w[19],invv[19]; vector&lt;int&gt;rev[19]; inline void init_ntt() { invv[0]=1; for(ri iv=mod+1&gt;&gt;1,i=1;i&lt;19;++i) invv[i]=mul(invv[i-1],iv); w[18]=ksm(g,(mod-1)&gt;&gt;19); for(ri i=17;~i;--i) w[i]=mul(w[i+1],w[i+1]); } inline void init(int up) { lim=1,tim=0; while(lim&lt;up) lim&lt;&lt;=1,++tim; if(rev[tim].size()) return; rev[tim].resize(lim); for(ri i=1;i&lt;lim;++i) rev[tim][i]=(rev[tim][i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(tim-1)); } inline void ntt(poly&amp;a,int typ) { for(ri i=1;i&lt;lim;++i) if(i&lt;rev[tim][i]) swap(a[i],a[rev[tim][i]]); for(ri i=1,t=0,a0,a1,mt;i&lt;lim;i&lt;&lt;=1,++t) for(ri j=0,len=i&lt;&lt;1;j&lt;lim;j+=len) { mt=1; for(ri k=0;k&lt;i;++k,Mul(mt,w[t])) { a0=a[j+k],a1=mul(mt,a[j+k+i]); a[j+k]=add(a0,a1),a[j+k+i]=dec(a0,a1); } } if(~typ) return; reverse(++a.begin(),a.end()); for(ri i=0;i&lt;lim;++i) Mul(a[i],invv[tim]); } inline poly trans(poly a) { poly b; int t=a.size(); init(t); a.resize(lim),ntt(a,1); b.resize(lim); for(ri i=0;i&lt;n;++i) b[i]=omega[((n&lt;&lt;1)-((ll)i*i%(n&lt;&lt;1)))%(n&lt;&lt;1)],i&amp;&amp;(b[lim-i]=b[i]); ntt(b,1); for(ri i=0;i&lt;lim;++i) Mul(a[i],b[i]); return ntt(a,-1),a.resize(t),a; }}A,B;inline void init_prime() { for(ri i=2;i&lt;=10000000;++i) { if(!vs[i]) pri[++tot]=i; for(ri j=1,up=10000000/i;j&lt;=tot&amp;&amp;pri[j]&lt;=up;++j) { vs[i*pri[j]]=1; if(i==i/pri[j]*pri[j]) break; } }}inline bool check(int x) { for(ri i=1,lm=sqrt(x);i&lt;=tot&amp;&amp;pri[i]&lt;=lm;++i) if(x==x/pri[i]*pri[i]) return 0; return 1;}inline void find_G() { vector&lt;int&gt;divv; int cur=mod-1; for(ri i=2,lm=sqrt(cur);i&lt;=lm;++i) { if(cur!=cur/i*i) continue; divv.pb(i); if(i*i!=cur) divv.pb(cur/i); } for(G=2;;++G) { bool ff=1; for(ri i=(int)divv.size()-1;~i;--i) if(ksm(G,divv[i])==1) { ff=0;break; } if(ff) break; }}inline ll ksc(ll a,ll b,ll mod) { return a*b-(ll)((long double)a/mod*b+1e-8)*mod; }inline void dft() { poly a(n&lt;&lt;1),rsa,rsb; for(ri i=0;i&lt;n;++i) a[i]=mul(fix(vl[i]),omega[(ll)i*i%(n&lt;&lt;1)]); rsa=A.trans(a),rsb=B.trans(a); ll md=(ll)A.mod*B.mod; for(ri i=0;i&lt;n;++i) vl[i]=(ksc((ll)rsa[i]*iv1,B.mod,md)+ksc((ll)rsb[i]*iv2,A.mod,md))%md%mod*omega[C2(i)]%mod;}int main() { #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif A.mod=998244353,A.g=3,A.init_ntt(); B.mod=1005060097,B.g=5,B.init_ntt(); iv1=A.Inv(B.mod),iv2=B.Inv(A.mod); init_prime(); for(ri tt=read();tt;--tt) { n=read(); for(ri i=0;i&lt;n;++i) vl[i]=read(); mod=10000000/(n&lt;&lt;1)*(n&lt;&lt;1)+1; while(!check(mod)) mod+=n&lt;&lt;1; find_G(); omega[0]=1,omega[1]=ksm(G,(mod-1)/(n&lt;&lt;1)); for(ri i=2;i&lt;(n&lt;&lt;1);++i) omega[i]=mul(omega[i-1],omega[1]); dft(); bool ff=0; for(ri i=0;i&lt;n;++i) if(!vl[i]) { ff=1;break; } puts(ff?&quot;YES&quot;:&quot;NO&quot;); } return 0;} Call It What You Want &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x5927;&#x6982;&#x8003;&#x5BDF;&#x4E86;&#x5206;&#x5706;&#x591A;&#x9879;&#x5F0F;&#x548C;&#x83AB;&#x6BD4;&#x4E4C;&#x65AF;&#x51FD;&#x6570;&#x7684;&#x4E00;&#x4E9B;&#x5C0F;&#x6027;&#x8D28; &#x9996;&#x5148;&#x8BBE; fn(x)=xn&#x2212;1f_n(x)=x^n-1fn&#x200B;(x)=xn&#x2212;1 &#xFF0C;&#x90A3;&#x4E48;&#x6709; fn(x)=&#x220F;d&#x2223;n&#x3A6;d(x)f_n(x)=\\prod\\limits_{d|n}\\Phi_d(x)fn&#x200B;(x)=d&#x2223;n&#x220F;&#x200B;&#x3A6;d&#x200B;(x) &#xFF0C;&#x8FDB;&#x884C;&#x591A;&#x9879;&#x5F0F;&#x53D6;&#x5BF9;&#xFF0C; ln&#x2061;(xn&#x2212;1)=&#x2211;d&#x2223;nln&#x2061;(&#x3A6;d(x))\\ln (x^n-1)=\\sum\\limits_{d|n}\\ln(\\Phi_d(x))ln(xn&#x2212;1)=d&#x2223;n&#x2211;&#x200B;ln(&#x3A6;d&#x200B;(x)) &#x7136;&#x540E;&#x83AB;&#x6BD4;&#x4E4C;&#x65AF;&#x53CD;&#x6F14;&#x4E00;&#x4E0B;&#xFF1A; ln&#x2061;(&#x3A6;n(x))=&#x2211;d&#x2223;n&#x3BC;(d)ln&#x2061;(xnd&#x2212;1)\\ln(\\Phi_n(x))=\\sum\\limits_{d|n}\\mu(d)\\ln(x^{\\frac nd}-1)ln(&#x3A6;n&#x200B;(x))=d&#x2223;n&#x2211;&#x200B;&#x3BC;(d)ln(xdn&#x200B;&#x2212;1) &#x7136;&#x540E; expexpexp &#x56DE;&#x53BB;&#xFF1A; &#x3A6;n(x)=&#x220F;d&#x2223;n(xd&#x2212;1)&#x3BC;(nd)\\Phi_n(x)=\\prod\\limits_{d|n}(x^d-1)^{\\mu(\\frac nd)}&#x3A6;n&#x200B;(x)=d&#x2223;n&#x220F;&#x200B;(xd&#x2212;1)&#x3BC;(dn&#x200B;) &#x8003;&#x8651;&#x5230; &#x3BC;(x)\\mu(x)&#x3BC;(x) &#x53EA;&#x5728; xxx &#x6CA1;&#x6709;&#x5E73;&#x65B9;&#x56E0;&#x5B50;&#x7684;&#x65F6;&#x5019;&#x6709;&#x8D21;&#x732E;&#xFF0C;&#x800C; 2&#xD7;3&#xD7;5&#xD7;7&#xD7;11&#xD7;13&#x2264;100000&#x2264;2&#xD7;3&#xD7;5&#xD7;7&#xD7;11&#xD7;13&#xD7;172\\times3\\times5\\times7\\times11\\times13\\le100000\\le2\\times3\\times5\\times7\\times11\\times13\\times172&#xD7;3&#xD7;5&#xD7;7&#xD7;11&#xD7;13&#x2264;100000&#x2264;2&#xD7;3&#xD7;5&#xD7;7&#xD7;11&#xD7;13&#xD7;17 &#xFF0C;&#x56E0;&#x6B64;&#x53EF;&#x4EE5;&#x66B4;&#x529B;&#x72B6;&#x538B;&#x6BCF;&#x4E2A;&#x6570;&#x7684;&#x6709;&#x8D21;&#x732E;&#x7684;&#x7EA6;&#x6570; CODE cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() { int ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}const int N=1e5+5;int phi[N],pri[N&gt;&gt;2],tot=0,n;bool vs[N],vis[N];vector&lt;int&gt;divv[N],Phi[N];inline void init() { phi[1]=1; for(ri i=2;i&lt;=100000;++i) { if(!vs[i]) { pri[++tot]=i,phi[i]=i-1; for(ri j=i;j&lt;=100000;j+=i) divv[j].pb(i); } for(ri j=1,up=100000/i;j&lt;=tot&amp;&amp;pri[j]&lt;=up;++j) { vs[i*pri[j]]=1; if(i==i/pri[j]*pri[j]) { phi[i*pri[j]]=phi[i]*pri[j];break; } phi[i*pri[j]]=phi[i]*(pri[j]-1); } }}inline bool cmp(int a,int b) { if(phi[a]^phi[b]) return phi[a]&lt;phi[b]; for(ri i=phi[a];~i;--i) if(Phi[a][i]^Phi[b][i]) return Phi[a][i]&lt;Phi[b][i]; return 1;}int main() { #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif init(); for(ri tt=read();tt;--tt) { n=read(); vector&lt;int&gt;id; for(ri i=1;i&lt;=n;++i) if(n==n/i*i) { id.pb(i); if(vis[i]) continue; vis[i]=1; Phi[i].resize(phi[i]+1); Phi[i][0]=i&gt;1?1:-1; for(ri ct,x,s=0,lm=(int)divv[i].size();s&lt;(1&lt;&lt;lm);++s) { ct=0,x=i; for(ri j=0;j&lt;lm;++j) if(s&gt;&gt;j&amp;1) ct^=1,x/=divv[i][j]; if(!ct) for(ri j=phi[i];j&gt;=x;--j) Phi[i][j]-=Phi[i][j-x]; else for(ri j=x;j&lt;=phi[i];++j) Phi[i][j]+=Phi[i][j-x]; } } sort(id.begin(),id.end(),cmp); for(ri i=0,x;i&lt;(int)id.size();++i) { putchar(&apos;(&apos;); x=id[i]; for(ri j=phi[x];~j;--j) { if(!Phi[x][j]) continue; if(Phi[x][j]&gt;0&amp;&amp;j!=phi[x]) putchar(&apos;+&apos;); if(j&amp;&amp;Phi[x][j]==-1) putchar(&apos;-&apos;); if(!j||Phi[x][j]&gt;1||Phi[x][j]&lt;-1) cout&lt;&lt;Phi[x][j]; if(j) putchar(&apos;x&apos;); if(j&gt;1) putchar(&apos;^&apos;),cout&lt;&lt;j; } putchar(&apos;)&apos;); } puts(&quot;&quot;); } return 0;}","categories":[{"name":"public","slug":"public","permalink":"http://xdl030112.github.io/categories/public/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://xdl030112.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"杂题乱做 Round10","slug":"sol10","date":"2019-12-19T02:10:32.000Z","updated":"2019-12-26T04:22:28.729Z","comments":true,"path":"sol10/","link":"","permalink":"http://xdl030112.github.io/sol10/","excerpt":"","text":"&#x673A;&#x5668;&#x4EBA;&#x9AD8;&#x5C14;&#x592B;&#x7403;&#x8D5B; &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x9996;&#x5148;&#x66B4;&#x529B; dpdpdp &#x8BBE; fi,jf_{i,j}fi,j&#x200B; &#x8868;&#x793A;&#x5148;&#x624B;&#x5728; (i,j)(i,j)(i,j) &#x5904;&#x51FA;&#x53D1;&#x7684;&#x7ED3;&#x679C;&#x76F4;&#x63A5;&#x8F6C;&#x79FB;&#x3002; &#x7136;&#x540E;&#x8003;&#x8651;&#x4F18;&#x5316;&#x8FD9;&#x4E2A;&#x505A;&#x6CD5;&#x3002;&#x6253;&#x8868;&#x4F1A;&#x53D1;&#x73B0;&#x5BF9;&#x4E8E;&#x5927;&#x90E8;&#x5206;&#x683C;&#x5B50;&#xFF0C;&#x90FD;&#x6709; fi,j=fi+1,j+1f_{i,j}=f_{i+1,j+1}fi,j&#x200B;=fi+1,j+1&#x200B; &#xFF0C;&#x8BA4;&#x771F;&#x601D;&#x8003;&#x540E;&#x4F1A;&#x53D1;&#x73B0;&#x5982;&#x679C;&#x683C;&#x5B50; (i,j)(i,j)(i,j) &#x6EE1;&#x8DB3;&#x8DDF;&#x5B83;&#x66FC;&#x54C8;&#x987F;&#x8DDD;&#x79BB;&#x4E0D;&#x8D85;&#x8FC7; 222 &#x7684;&#x90E8;&#x5206;&#x90FD;&#x6CA1;&#x6709;&#x6807;&#x8BB0;&#x90A3;&#x4E48; fi,j=fi+1,j+1f_{i,j}=f_{i+1,j+1}fi,j&#x200B;=fi+1,j+1&#x200B; &#x90A3;&#x4E48;&#x66B4;&#x529B; dpdpdp &#x9700;&#x8981;&#x7279;&#x6B8A;&#x5904;&#x7406;&#x7684;&#x683C;&#x5B50;&#x7684;&#x503C;&#xFF0C;&#x7528; mapmapmap &#x8BB0;&#x5F55;&#x6BCF;&#x6761;&#x5BF9;&#x89D2;&#x7EBF;&#x7684;&#x7B54;&#x6848;&#x5373;&#x53EF;&#x5FEB;&#x901F;&#x8F6C;&#x79FB; CODE cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;int,pii&gt; ppp;typedef map&lt;int,ppp&gt;::iterator It;#define fi first#define se second#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch==&apos;-&apos;,ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;}namespace modular{ const int mod=998244353; inline int add(int a,int b){return a+b&lt;mod?a+b:a+b-mod;} inline int dec(int a,int b){return a&lt;b?a-b+mod:a-b;} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Add(int&amp;a,int b){a=a+b&lt;mod?a+b:a+b-mod;} inline void Dec(int&amp;a,int b){a=a&lt;b?a-b+mod:a-b;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;} inline int fix(int a){return (a%mod+mod)%mod;}}using namespace modular;const int N=1e5+5;map&lt;pii,bool&gt;vs;map&lt;int,ppp&gt;F;map&lt;pii,pii&gt;mn_mx;vector&lt;pii&gt;ps;int n,m,K,res=0;inline void DP(int x,int y){ if(F.count(x-y))Add(res,mul(dec(F[x-y].fi,x),fix(F[x-y].se.fi))); F[x-y]=ppp(x,mn_mx[pii(x,y)]);}inline pii calc(int x,int y){return F.count(x-y)?F[x-y].se:pii(0,0);}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(),m=read(),K=read(); for(ri x,y,v,i=1;i&lt;=K;++i){ x=read(),y=read(),v=read(); vs[pii(x,y)]=1; mn_mx[pii(x,y)]=pii(v,v); for(ri dx=0;dx&lt;=2&amp;&amp;dx&lt;x;++dx)for(ri dy=0;dy&lt;=2-dx&amp;&amp;dy&lt;y;++dy) ps.pb(pii(x-dx,y-dy)); } sort(ps.begin(),ps.end()); ps.erase(unique(ps.begin(),ps.end()),ps.end()); pii rgt,dwn; for(ri x,y,t=(int)ps.size()-1;~t;--t){ x=ps[t].fi,y=ps[t].se; if(!vs[pii(x,y)]){ rgt=calc(x,y+1); dwn=calc(x+1,y); mn_mx[pii(x,y)]=pii(min(rgt.se,dwn.se),max(rgt.fi,dwn.fi)); } DP(x,y); } ppp cur; for(It it=F.begin();it!=F.end();++it){ cur=it-&gt;se; Add(res,mul(fix(min(cur.fi,cur.fi-it-&gt;fi)),fix(cur.se.fi))); } cout&lt;&lt;res; return 0;} &#x6709;&#x6807;&#x53F7;&#x7684;DAG&#x8BA1;&#x6570; IV &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x53EF;&#x80FD;&#x5F97;&#x5148;&#x4F1A;&#x524D;&#x4E09;&#x9053; DAGDAGDAG &#x8BA1;&#x6570;&#xFF0C;&#x5148;&#x8003;&#x8651;&#x7B80;&#x5355;&#x7684;&#x95EE;&#x9898;&#xFF0C;&#x5982;&#x679C;&#x4E0D;&#x8981;&#x6C42;&#x8FDE;&#x901A;&#x600E;&#x4E48;&#x505A;&#xFF0C;&#x53D1;&#x73B0;&#x662F;&#x4E2A;&#x5E38;&#x89C1;&#x5957;&#x8DEF;&#xFF0C;&#x679A;&#x4E3E;&#x5165;&#x5EA6;&#x4E3A; 000 &#x7684;&#x70B9;&#x7136;&#x540E;&#x5BB9;&#x65A5;&#x5373;&#x53EF;&#xFF1A; fi=&#x2211;j=1ifi&#x2212;j2j(i&#x2212;j)(&#x2212;1)i+1fi=&#x2211;j=0i&#x2212;1fj2i2&#x2212;j2&#x2212;(i&#x2212;j)2(&#x2212;1)i&#x2212;j+1fi2i2=&#x2211;j=0i&#x2212;1fj2j2(&#x2212;1)i&#x2212;j+12(i&#x2212;j)2&#x6784;&#x9020;F(x)=&#x2211;i=0+&#x221E;fi2i2xi,G(x)=&#x2211;i=1+&#x221E;(&#x2212;1)i+12i2F=F&#xD7;G+1F=11&#x2212;G\\begin{aligned} f_i=&amp;\\sum\\limits_{j=1}^if_{i-j}2^{j(i-j)}(-1)^{i+1}\\\\ f_i=&amp;\\sum\\limits_{j=0}^{i-1}f_j\\sqrt2^{i^2-j^2-(i-j)^2}(-1)^{i-j+1}\\\\ \\frac{f_i}{\\sqrt2^{i^2}}=&amp;\\sum\\limits_{j=0}^{i-1}\\frac{f_j}{\\sqrt2^{j^2}}\\frac{(-1)^{i-j+1}}{\\sqrt2^{(i-j)^2}}\\\\ &#x6784;&#x9020;F(x)=&amp;\\sum\\limits_{i=0}^{+\\infty}\\frac{f_i}{\\sqrt2^{i^2}}x^i,G(x)=\\sum\\limits_{i=1}^{+\\infty}\\frac{(-1)^{i+1}}{\\sqrt2^{i^2}}\\\\ F=&amp;F\\times G+1\\\\ F=&amp;\\frac{1}{1-G} \\end{aligned} fi&#x200B;=fi&#x200B;=2&#x200B;i2fi&#x200B;&#x200B;=&#x6784;&#x9020;F(x)=F=F=&#x200B;j=1&#x2211;i&#x200B;fi&#x2212;j&#x200B;2j(i&#x2212;j)(&#x2212;1)i+1j=0&#x2211;i&#x2212;1&#x200B;fj&#x200B;2&#x200B;i2&#x2212;j2&#x2212;(i&#x2212;j)2(&#x2212;1)i&#x2212;j+1j=0&#x2211;i&#x2212;1&#x200B;2&#x200B;j2fj&#x200B;&#x200B;2&#x200B;(i&#x2212;j)2(&#x2212;1)i&#x2212;j+1&#x200B;i=0&#x2211;+&#x221E;&#x200B;2&#x200B;i2fi&#x200B;&#x200B;xi,G(x)=i=1&#x2211;+&#x221E;&#x200B;2&#x200B;i2(&#x2212;1)i+1&#x200B;F&#xD7;G+11&#x2212;G1&#x200B;&#x200B; &#x8FD9;&#x6837;&#x80FD;&#x591F;&#x5728; O(nlog&#x2061;n)O(n\\log n)O(nlogn) &#x7684;&#x65F6;&#x95F4;&#x5185;&#x6C42;&#x51FA; fff &#x63A5;&#x4E0B;&#x6765;&#x5C31;&#x6709;&#x4E24;&#x79CD;&#x601D;&#x8DEF;&#x4E86;&#xFF0C;&#x7B2C;&#x4E00;&#x79CD;&#x662F;&#x5229;&#x7528;&#x8865;&#x96C6;&#x8F6C;&#x5316;&#x7684;&#x601D;&#x60F3;&#xFF0C;&#x8BBE;&#x7B54;&#x6848;&#x7B49;&#x4E8E; gig_igi&#x200B; &#xFF0C;&#x90A3;&#x4E48; gi=fi&#x2212;&#x2211;j=1i&#x2212;1gjfi&#x2212;j(i&#x2212;1j&#x2212;1)g_i=f_i-\\sum\\limits_{j=1}^{i-1}g_jf_{i-j}\\binom{i-1}{j-1}gi&#x200B;=fi&#x200B;&#x2212;j=1&#x2211;i&#x2212;1&#x200B;gj&#x200B;fi&#x2212;j&#x200B;(j&#x2212;1i&#x2212;1&#x200B;) &#x7136;&#x540E;&#x4E00;&#x6CE2;&#x5316;&#x7B80;&#x4E0A;&#x591A;&#x9879;&#x5F0F;&#x6C42;&#x9006; &#x7B2C;&#x4E8C;&#x79CD;&#x4E5F;&#x633A;&#x5BB9;&#x6613;&#x60F3;&#x5230;&#x7684;&#xFF0C;&#x8BBE; GGG &#x4E3A;&#x7B54;&#x6848;&#x7684;&#x751F;&#x6210;&#x51FD;&#x6570;&#xFF0C;&#x663E;&#x7136;&#x6709; eG=Fe^G=FeG=F &#xFF0C;&#x90A3;&#x4E48;&#x5199;&#x4E2A;&#x591A;&#x9879;&#x5F0F;&#x53D6;&#x5BF9;&#x5373;&#x53EF; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef vector&lt;int&gt; poly;#define pb push_backnamespace modular { const int mod=998244353,sqr2=116195171; inline int add(int a,int b) { return a+b&lt;mod?a+b:a+b-mod; } inline int dec(int a,int b) { return a&lt;b?a-b+mod:a-b; } inline int mul(int a,int b) { return (ll)a*b%mod; } inline void Add(int&amp;a,int b) { a=a+b&lt;mod?a+b:a+b-mod; } inline void Dec(int&amp;a,int b) { a=a&lt;b?a-b+mod:a-b; } inline void Mul(int&amp;a,int b) { a=(ll)a*b%mod; } inline int ksm(int a,int p) { int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; } inline int Inv(int a) { return ksm(a,mod-2); }}using namespace modular;const int N=500005;int n,invv[23],w[23],lim,tim,inv[N],fac[N],ifac[N];vector&lt;int&gt;rev[23];inline int C(int n,int m) { return n&lt;m||m&lt;0?0:mul(fac[n],mul(ifac[n-m],ifac[m])); }inline void init() { fac[0]=fac[1]=ifac[0]=ifac[1]=inv[1]=1; for(ri i=2;i&lt;=500000;++i) { fac[i]=mul(fac[i-1],i); inv[i]=mul(inv[mod-mod/i*i],mod-mod/i); ifac[i]=mul(ifac[i-1],inv[i]); }}inline void init_ntt() { invv[0]=1,w[22]=ksm(3,(mod-1)&gt;&gt;23); for(ri i=1,iv=mod+1&gt;&gt;1;i&lt;23;++i) invv[i]=mul(invv[i-1],iv); for(ri i=21;~i;--i) w[i]=mul(w[i+1],w[i+1]);}inline void init(int up) { lim=1,tim=0; while(lim&lt;up) lim&lt;&lt;=1,++tim; if(rev[tim].size()) return; rev[tim].resize(lim); for(ri i=1;i&lt;lim;++i) rev[tim][i]=(rev[tim][i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(tim-1));}inline void ntt(poly&amp;a,int typ) { for(ri i=0;i&lt;lim;++i) if(i&lt;rev[tim][i]) swap(a[i],a[rev[tim][i]]); for(ri i=1,t=0,a0,a1,mt;i&lt;lim;i&lt;&lt;=1,++t) for(ri j=0,len=i&lt;&lt;1;j&lt;lim;j+=len) { mt=1; for(ri k=0;k&lt;i;++k,Mul(mt,w[t])) { a0=a[j+k],a1=mul(mt,a[j+k+i]); a[j+k]=add(a0,a1),a[j+k+i]=dec(a0,a1); } } if(~typ) return; reverse(++a.begin(),a.end()); for(ri i=0;i&lt;lim;++i) Mul(a[i],invv[tim]);}inline poly operator*(poly a,poly b) { int n=a.size(),m=b.size(),t=n+m-1; if(t&lt;=64) { poly c(t); for(ri i=0;i&lt;n;++i) if(a[i]) for(ri j=0;j&lt;m;++j) Add(c[i+j],mul(a[i],b[j])); return c; } init(t); a.resize(lim),ntt(a,1); b.resize(lim),ntt(b,1); for(ri i=0;i&lt;lim;++i) Mul(a[i],b[i]); return ntt(a,-1),a.resize(t),a;}inline poly operator-(poly a,poly b) { if((int)a.size()&lt;(int)b.size()) a.resize((int)b.size()); for(ri i=0,up=(int)b.size();i&lt;up;++i) Dec(a[i],b[i]); return a;}inline poly poly_inv(poly a,int K) { poly b(1,Inv(a[0])),c; for(ri i=1;i&lt;K;i&lt;&lt;=1) { init(i&lt;&lt;2); c=a,c.resize(i&lt;&lt;1),c.resize(lim),ntt(c,1); b.resize(lim),ntt(b,1); for(ri j=0;j&lt;lim;++j) Mul(b[j],dec(2,mul(b[j],c[j]))); ntt(b,-1),b.resize(i&lt;&lt;1); } return b.resize(K),b;}inline poly poly_integ(poly a) { a.pb(0); for(ri i=(int)a.size()-1;i;--i)a[i]=mul(a[i-1],inv[i]); return a[0]=0,a;}inline poly poly_direv(poly a) { for(ri i=1,up=(int)a.size();i&lt;up;++i) a[i-1]=mul(a[i],i); return a.pop_back(),a;}inline poly poly_ln(poly a,int K) { poly res=poly_integ(poly_direv(a)*poly_inv(a,K)); return res.resize(K),res;}int main() { freopen(&quot;dagIV.in&quot;,&quot;r&quot;,stdin); freopen(&quot;dagIV.out&quot;,&quot;w&quot;,stdout); cin&gt;&gt;n; init(); init_ntt(); poly f(n+1); for(ri t,i=0;i&lt;=n;++i) { t=mul(ifac[i],Inv(ksm(sqr2,(ll)i*i%(mod-1)))); f[i]=t?(i&amp;1?mod-t:t):0; } f=poly_inv(f,n+1); for(ri i=0;i&lt;=n;++i) Mul(f[i],ksm(sqr2,(ll)i*i%(mod-1))); f=poly_ln(f,n+1); cout&lt;&lt;mul(f[n],fac[n]); return 0;} arewell &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x5BB9;&#x65A5;&#x7684;&#x601D;&#x60F3;&#x8DDF;&#x4E0A;&#x9762;&#x7684;&#x6C42; fff &#x7684;&#x4E00;&#x6837;&#xFF0C;&#x679A;&#x4E3E;&#x5165;&#x5EA6;&#x4E3A; 000 &#x7684;&#x70B9;&#xFF0C;&#x7136;&#x540E;&#x53D1;&#x73B0;&#x8F6C;&#x79FB;&#x53D8;&#x6210;&#x4E86;&#x679A;&#x4E3E;&#x5B50;&#x96C6;&#xFF0C;&#x76F4;&#x63A5;&#x7528;&#x5B50;&#x96C6;&#x5377;&#x79EF;&#x4F18;&#x5316;&#x5373;&#x53EF; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef vector&lt;int&gt; poly;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() { int ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}namespace modular { const int mod=998244353; inline int add(int a,int b) { return a+b&lt;mod?a+b:a+b-mod; } inline int dec(int a,int b) { return a&lt;b?a-b+mod:a-b; } inline int mul(int a,int b) { return (ll)a*b%mod; } inline void Add(int&amp;a,int b) { a=a+b&lt;mod?a+b:a+b-mod; } inline void Dec(int&amp;a,int b) { a=a&lt;b?a-b+mod:a-b; } inline void Mul(int&amp;a,int b) { a=(ll)a*b%mod; } inline int ksm(int a,int p) { int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; } inline int Inv(int a) { return ksm(a,mod-2); }}using namespace modular;int n,m,lim,coe,all,pw[25],ppw[405];poly cnt,f[25],g[25],bitcnt;inline void fwt(poly&amp;a,int typ) { for(ri a0,a1,iv=mod+1&gt;&gt;1,i=1;i&lt;lim;i&lt;&lt;=1) for(ri j=0,len=i&lt;&lt;1;j&lt;lim;j+=len) for(ri k=0;k&lt;i;++k) { a0=a[j+k],a1=a[j+k+i]; a[j+k]=add(a0,a1),a[j+k+i]=dec(a0,a1); if(typ==-1) Mul(a[j+k],iv),Mul(a[j+k+i],iv); }}int main() { #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(),m=read(); coe=mod+1&gt;&gt;1; pw[0]=1,ppw[0]=1; for(ri i=1;i&lt;=n;++i) pw[i]=pw[i-1]&lt;&lt;1; for(ri i=1;i&lt;=m;++i) ppw[i]=mul(ppw[i-1],coe); lim=pw[n],all=lim-1; cnt.resize(lim),bitcnt.resize(lim); for(ri i=0;i&lt;=n;++i) f[i].resize(lim),g[i].resize(lim); for(ri u,v,i=1;i&lt;=m;++i) { u=read()-1,v=read()-1; for(ri s=all^pw[u]^pw[v],t=s;~t;t=t?(t-1)&amp;s:-1) ++cnt[t^pw[u]^pw[v]]; } for(ri t,s=0;s&lt;lim;++s) { bitcnt[s]=bitcnt[s&gt;&gt;1]+(s&amp;1); g[bitcnt[s]][s]=bitcnt[s]&amp;1?ppw[cnt[s]]:mod-ppw[cnt[s]]; } for(ri i=0;i&lt;=n;++i) fwt(g[i],1); f[0][0]=1; fwt(f[0],1); for(ri i=0;i&lt;n;++i) for(ri s=0;s&lt;lim;++s) if(f[i][s]) for(ri j=1;i+j&lt;=n;++j) Add(f[i+j][s],mul(f[i][s],g[j][s])); fwt(f[n],-1); cout&lt;&lt;mul(f[n][all],Inv(mul(ppw[m],ksm(3,m)))); return 0;} ffort &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x8BBE;&#x603B;&#x4F24;&#x5BB3;&#x4E3A; XXX &#x7684;&#x65B9;&#x6848;&#x6570;&#x4E3A; f(X)f(X)f(X) &#x90A3;&#x4E48;&#x6700;&#x540E;&#x8FD9;&#x4E2A;&#x4F1A;&#x5BF9;&#x7B54;&#x6848;&#x4EA7;&#x751F; (X&#x2212;1n&#x2212;1)\\binom{X-1}{n-1}(n&#x2212;1X&#x2212;1&#x200B;) &#x7684;&#x8D21;&#x732E;&#xFF0C;&#x7531;&#x4E8E; XXX &#x975E;&#x5E38;&#x5927;&#x56E0;&#x6B64;&#x9700;&#x8981;&#x6362;&#x4E00;&#x4E2A;&#x89D2;&#x5EA6;&#x601D;&#x8003;&#xFF0C;&#x89C2;&#x5BDF;&#x4E0A;&#x8FF0;&#x5F0F;&#x5B50;&#x53D1;&#x73B0;&#x662F;&#x8981;&#x63D2;&#x5165; n&#x2212;1n-1n&#x2212;1 &#x4E2A;&#x677F;&#xFF0C;&#x90A3;&#x4E48;&#x6211;&#x4EEC;&#x5BF9; mmm &#x79CD;&#x6570;&#x636E;&#x7ED3;&#x6784;&#x5206;&#x522B;&#x6784;&#x9020;&#x751F;&#x6210;&#x51FD;&#x6570; Fi(x)F_i(x)Fi&#x200B;(x) &#xFF0C;&#x5176;&#x4E2D; Fi(x)[xj]F_i(x)[x^j]Fi&#x200B;(x)[xj] &#x8868;&#x793A;&#x5176;&#x4E2D;&#x653E; jjj &#x4E2A;&#x677F;&#x7684;&#x65B9;&#x6848;&#x6570;&#xFF0C;&#x7136;&#x540E;&#x6211;&#x4EEC;&#x5BF9;&#x6BCF;&#x4E00;&#x79CD;&#x6570;&#x636E;&#x7ED3;&#x6784;&#x505A;&#x4E00;&#x6B21;&#x591A;&#x9879;&#x5F0F;&#x5FEB;&#x901F;&#x5E42;&#x6700;&#x540E;&#x4E58;&#x8D77;&#x6765;&#x5373;&#x53EF;&#xFF0C;&#x6CE8;&#x610F;&#x6700;&#x540E;&#x4E00;&#x4E2A;&#x8981;&#x7279;&#x6B8A;&#x5904;&#x7406; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef vector&lt;int&gt; poly;#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() { int ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}namespace modular { const int mod=998244353; inline int add(int a,int b) { return a+b&lt;mod?a+b:a+b-mod; } inline int dec(int a,int b) { return a&lt;b?a-b+mod:a-b; } inline int mul(int a,int b) { return (ll)a*b%mod; } inline void Add(int&amp;a,int b) { a=a+b&lt;mod?a+b:a+b-mod; } inline void Dec(int&amp;a,int b) { a=a&lt;b?a-b+mod:a-b; } inline void Mul(int&amp;a,int b) { a=(ll)a*b%mod; } inline int ksm(int a,int p) { int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; } inline int Inv(int a) { return ksm(a,mod-2); }}using namespace modular;const int N=500005;int invv[23],w[23],inv[N],lim,tim;vector&lt;int&gt;rev[23];inline void init() { inv[1]=1; for(ri i=2;i&lt;=500000;++i) inv[i]=mul(inv[mod-mod/i*i],mod-mod/i);}inline void init_ntt() { invv[0]=1,w[22]=ksm(3,(mod-1)&gt;&gt;23); for(ri i=1,iv=mod+1&gt;&gt;1;i&lt;23;++i) invv[i]=mul(invv[i-1],iv); for(ri i=21;~i;--i) w[i]=mul(w[i+1],w[i+1]);}inline void init(int up) { lim=1,tim=0; while(lim&lt;up) lim&lt;&lt;=1,++tim; if(rev[tim].size()) return; rev[tim].resize(lim); for(ri i=1;i&lt;lim;++i) rev[tim][i]=(rev[tim][i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(tim-1));}inline void ntt(poly&amp;a,int typ) { for(ri i=0;i&lt;lim;++i) if(i&lt;rev[tim][i]) swap(a[i],a[rev[tim][i]]); for(ri i=1,t=0,a0,a1,mt;i&lt;lim;i&lt;&lt;=1,++t) for(ri j=0,len=i&lt;&lt;1;j&lt;lim;j+=len) { mt=1; for(ri k=0;k&lt;i;++k,Mul(mt,w[t])) { a0=a[j+k],a1=mul(a[j+k+i],mt); a[j+k]=add(a0,a1),a[j+k+i]=dec(a0,a1); } } if(~typ) return; reverse(++a.begin(),a.end()); for(ri i=0;i&lt;lim;++i) Mul(a[i],invv[tim]);}inline poly operator*(poly a,poly b) { int n=a.size(),m=b.size(),t=n+m-1; if(t&lt;=64) { poly c(t); for(ri i=0;i&lt;n;++i) if(a[i]) for(ri j=0;j&lt;m;++j) Add(c[i+j],mul(a[i],b[j])); return c; } init(t); a.resize(lim),ntt(a,1); b.resize(lim),ntt(b,1); for(ri i=0;i&lt;lim;++i) Mul(a[i],b[i]); return ntt(a,-1),a.resize(t),a;}inline poly operator-(poly a,poly b) { if((int)a.size()&lt;(int)b.size()) a.resize((int)b.size()); for(ri i=0,up=(int)b.size();i&lt;up;++i) Dec(a[i],b[i]); return a;}inline poly poly_inv(poly a,int K) { poly b(1,Inv(a[0])),c; for(ri i=1;i&lt;K;i&lt;&lt;=1) { init(i&lt;&lt;2); c=a,c.resize(i&lt;&lt;1),c.resize(lim),ntt(c,1); b.resize(lim),ntt(b,1); for(ri j=0;j&lt;lim;++j) Mul(b[j],dec(2,mul(b[j],c[j]))); ntt(b,-1),b.resize(i&lt;&lt;1); } return b.resize(K),b;}inline poly poly_deriv(poly a) { for(ri i=1,up=(int)a.size();i&lt;up;++i) a[i-1]=mul(a[i],i); return a.pop_back(),a;}inline poly poly_integ(poly a) { a.pb(0); for(ri i=(int)a.size()-1;i;--i) a[i]=mul(inv[i],a[i-1]); return a[0]=0,a;}inline poly poly_ln(poly a,int K) { return a=poly_integ(poly_deriv(a)*poly_inv(a,K)),a.resize(K),a; }inline poly poly_exp(poly a,int K) { poly b(1,1),c; for(ri i=1;i&lt;K;i&lt;&lt;=1) { c=a,c.resize(i&lt;&lt;1); c=c-poly_ln(b,i&lt;&lt;1); Add(c[0],1); b=b*c,b.resize(i&lt;&lt;1); } return b.resize(K),b;}inline poly poly_ksm(poly a,int pw,int K) { int iv=Inv(a[0]),mt=ksm(a[0],pw); a.resize(K); for(ri i=0;i&lt;K;++i) Mul(a[i],iv); a=poly_ln(a,K); for(ri i=0;i&lt;K;++i) Mul(a[i],pw); a=poly_exp(a,K); for(ri i=0;i&lt;K;++i) Mul(a[i],mt); return a;}int n,m,a[N],b[N];int main() { #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(),m=read(); init(),init_ntt(); for(ri i=1;i&lt;=m;++i) a[i]=read(),b[i]=read(); ++m,a[m]=1,b[m]=b[m-1]-1,--a[m-1]; poly res(1,1),f; for(ri t,iv,i=1;i&lt;=m;++i) if(a[i]) { f.resize(n); f[0]=b[i]; for(ri mt=add(b[i],1),j=1;j&lt;n;++j) { Mul(mt,mul(inv[j+1],b[i]+1-j)); f[j]=mt; } if(i==m) Add(f[0],1); f=poly_ksm(f,a[i],n); res=res*f; res.resize(n); } cout&lt;&lt;res[n-1]; return 0;} Temperature Survey &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x8003;&#x8651;&#x628A;&#x95EE;&#x9898;&#x770B;&#x6210;&#x8D70;&#x7F51;&#x683C;&#x7684;&#x65B9;&#x6848;&#x6570;&#xFF0C;&#x90A3;&#x4E48;&#x4E0D;&#x65AD;&#x628A; (mid,amid)(mid,a_{mid})(mid,amid&#x200B;) &#x5F53;&#x6210;&#x77E9;&#x5F62;&#x7684;&#x53F3;&#x4E0A;&#x89D2;&#xFF0C;&#x7136;&#x540E;&#x9012;&#x5F52;&#x5206;&#x6CBB;&#x53EF;&#x4EE5;&#x9012;&#x5F52;&#x5212;&#x5206;&#x51FA; O(n)O(n)O(n) &#x4E2A;&#x77E9;&#x5F62;&#xFF0C;&#x8FD9;&#x4E9B;&#x77E9;&#x5F62;&#x8FB9;&#x957F;&#x548C;&#x662F; O(nlog&#x2061;n)O(n\\log n)O(nlogn) &#x7EA7;&#x522B;&#x7684;&#xFF0C;&#x7136;&#x540E;&#x5BF9;&#x4E8E;&#x6BCF;&#x4E2A;&#x77E9;&#x5F62;&#x7528; nttnttntt &#x8BA1;&#x7B97;&#x5176;&#x4E0A;/&#x5DE6;&#x8FB9;&#x754C;&#x5BF9;&#x5176;&#x4E0B;/&#x53F3;&#x8FB9;&#x754C;&#x7684;&#x8D21;&#x732E;&#x5373;&#x53EF; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include&lt;bits/stdc++.h&gt;#include&lt;tr1/unordered_map&gt;#define ri register intusing namespace std;typedef long long ll;typedef vector&lt;int&gt; poly;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() { int ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}namespace modular { const int mod=998244353; inline int add(int a,int b) { return a+b&lt;mod?a+b:a+b-mod; } inline int dec(int a,int b) { return a&lt;b?a-b+mod:a-b; } inline int mul(int a,int b) { return (ll)a*b%mod; } inline void Add(int&amp;a,int b) { a=a+b&lt;mod?a+b:a+b-mod; } inline void Dec(int&amp;a,int b) { a=a&lt;b?a-b+mod:a-b; } inline void Mul(int&amp;a,int b) { a=(ll)a*b%mod; } inline int ksm(int a,int p) { int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; }}using namespace modular;const int N=5e5+5;int lim,tim,invv[23],w[23],fac[N],ifac[N],a[N],n;vector&lt;int&gt;rev[23];inline void init_ntt() { fac[0]=fac[1]=ifac[0]=ifac[1]=1; for(ri i=2;i&lt;=500000;++i) { fac[i]=mul(fac[i-1],i); ifac[i]=mul(ifac[mod-mod/i*i],mod-mod/i); } for(ri i=2;i&lt;=500000;++i) Mul(ifac[i],ifac[i-1]); w[22]=ksm(3,(mod-1)&gt;&gt;23); invv[0]=1; for(ri i=1,iv=mod+1&gt;&gt;1;i&lt;23;++i) invv[i]=mul(invv[i-1],iv); for(ri i=21;~i;--i) w[i]=mul(w[i+1],w[i+1]);}inline int C(int n,int m) { return n&lt;m||m&lt;0?0:mul(fac[n],mul(ifac[m],ifac[n-m])); }inline void init(int up) { lim=1,tim=0; while(lim&lt;up)lim&lt;&lt;=1,++tim; if(rev[tim].size()) return; rev[tim].resize(lim); for(ri i=1;i&lt;lim;++i) rev[tim][i]=(rev[tim][i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(tim-1));}inline void ntt(poly&amp;a,int typ) { for(ri i=0;i&lt;lim;++i) if(i&lt;rev[tim][i]) swap(a[i],a[rev[tim][i]]); for(ri mt,i=1,t=0,a0,a1;i&lt;lim;i&lt;&lt;=1,++t) for(ri j=0,len=i&lt;&lt;1;j&lt;lim;j+=len) { mt=1; for(ri k=0;k&lt;i;++k,Mul(mt,w[t])) { a0=a[j+k],a1=mul(a[j+k+i],mt); a[j+k]=add(a0,a1),a[j+k+i]=dec(a0,a1); } } if(~typ) return; reverse(++a.begin(),a.end()); for(ri i=0;i&lt;lim;++i) Mul(a[i],invv[tim]);}inline poly operator*(poly a,poly b) { int n=(int)a.size(),m=(int)b.size(),t=n+m-1; if(t&lt;=64) { poly c(t); for(ri i=0;i&lt;n;++i) if(a[i]) for(ri j=0;j&lt;m;++j) Add(c[i+j],mul(a[i],b[j])); return c; } init(t); a.resize(lim),ntt(a,1); b.resize(lim),ntt(b,1); for(ri i=0;i&lt;lim;++i) Mul(a[i],b[i]); return ntt(a,-1),a.resize(t),a;}inline poly calc1(poly a,int len) { int n=(int)a.size(); poly b(n); for(ri i=0;i&lt;n;++i) b[i]=C(i+len,i); a=a*b; return a.resize(n),a;}inline poly calc2(poly a,int len) { int n=(int)a.size(); poly b(len+n); for(ri i=0;i&lt;n;++i) Mul(a[i],ifac[n-i-1]); for(ri i=0;i&lt;len+n;++i) b[i]=fac[i]; b=a*b; a.resize(len+1); for(ri i=0;i&lt;=len;++i) a[i]=mul(ifac[i],b[i+n-1]); return a;}tr1::unordered_map&lt;int,int&gt; f[N];inline void solve(int l,int r,int ql,int qr) { if(l&gt;r||ql&gt;qr) return; int mid=l+r&gt;&gt;1,ps=mid+1; solve(l,mid-1,ql,a[mid-1]); poly F(a[mid]-ql+1),G; for(ri i=ql;i&lt;=a[mid];++i) F[i-ql]=f[mid-1][i]; G=calc1(F,r-mid); for(ri i=ql;i&lt;=a[mid];++i) Add(f[r][i],G[i-ql]); G=calc2(F,r-mid); for(ri i=mid;i&lt;r;++i) Add(f[i][a[mid]],G[i-mid]); F.clear(); F.resize(r-mid+1); for(ri i=mid;i&lt;=r;++i) F[i-mid]=f[i][ql-1]; G=calc1(F,a[mid]-ql); for(ri i=mid;i&lt;=r;++i) Add(f[i][a[mid]],G[i-mid]); G=calc2(F,a[mid]-ql); for(ri i=ql;i&lt;a[mid];++i) Add(f[r][i],G[i-ql]); while(ps&lt;=r&amp;&amp;a[ps]==a[mid]) ++ps; if(ps&lt;=r) solve(ps,r,a[mid]+1,qr);}int main() { #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif init_ntt(); for(ri tt=read();tt;--tt) { n=read(); for(ri i=0;i&lt;=n;++i) f[i].clear(); for(ri i=1;i&lt;=n;++i) a[i]=read(); f[1][0]=1; solve(1,n,1,a[n]); int res=0; for(ri i=1;i&lt;=a[n];++i) Add(res,f[n][i]); cout&lt;&lt;res&lt;&lt;&apos;\\n&apos;; } return 0;} &#x7B97;&#x529B;&#x8BAD;&#x7EC3; &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x76F8;&#x5F53;&#x4E8E;&#x662F;&#x6C42; &#x2295;i=1n(1+xai)\\oplus_{i=1}^n(1+x^{a_i})&#x2295;i=1n&#x200B;(1+xai&#x200B;) &#xFF0C;&#x90A3;&#x4E48;&#x53EF;&#x4EE5;&#x5148;&#x53C2;&#x8003;&#x4E00;&#x4E0B; &#x9ECE;&#x660E;&#x524D;&#x7684;&#x5DE7;&#x514B;&#x529B; &#x662F;&#x600E;&#x4E48;&#x505A;&#x7684;&#xFF0C;&#x8FD9;&#x9898;&#x4E5F;&#x6BD4;&#x8F83;&#x7C7B;&#x4F3C;&#xFF0C;&#x5927;&#x6982;&#x662F;&#x6269;&#x57DF;&#x5C06;&#x6BCF;&#x4E2A;&#x6570;&#x8868;&#x793A;&#x6210; &#x2211;i=0Kai&#x3C9;Ki\\sum\\limits_{i=0}^Ka_i\\omega_K^ii=0&#x2211;K&#x200B;ai&#x200B;&#x3C9;Ki&#x200B; &#x7684;&#x5F62;&#x5F0F;&#xFF0C;&#x7136;&#x540E;&#x5148;&#x628A; &#x2211;i=1n(1+xai)\\sum\\limits_{i=1}^n(1+x^{a_i})i=1&#x2211;n&#x200B;(1+xai&#x200B;) &#x7ED9; fwtfwtfwt &#x4E86;&#xFF0C;&#x63A5;&#x7740;&#x5BF9;&#x4E8E;&#x6BCF;&#x4E00;&#x7EF4;&#x5206;&#x522B;&#x6C42;&#x51FA;&#x5B83;&#x662F;&#x7531; ttt &#x4E2A; &#x3C9;Ki\\omega_K^i&#x3C9;Ki&#x200B; &#x52A0;&#x8D77;&#x6765;&#x7684;&#xFF0C;&#x90A3;&#x4E48;&#x8FD9;&#x4E00;&#x7EF4;&#x7684;&#x5B9E;&#x9645;&#x503C;&#x5E94;&#x8BE5;&#x662F; (1+&#x3C9;Ki)t(1+\\omega_K^i)^t(1+&#x3C9;Ki&#x200B;)t &#x6210;&#x529F;&#x8FD8;&#x539F;&#x70B9;&#x503C;&#x4E4B;&#x540E;&#x518D; ifwtifwtifwt &#x56DE;&#x53BB;&#x5373;&#x53EF; &#x6CE8;&#x610F;&#x5230;&#x8FD9;&#x9898;&#x6709;&#x70B9;&#x5361;&#x5E38;&#xFF0C;&#x56E0;&#x6B64;&#x6C42; (1+&#x3C9;Ki)t(1+\\omega_K^i)^t(1+&#x3C9;Ki&#x200B;)t &#x8981;&#x7528; BSGSBSGSBSGS &#x5361;&#x5E38; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;const int rlen=1&lt;&lt;18|1l;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)int n,K,tim,lim,iv;inline int read(int B) { int ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=ans*B+(ch^48),ch=gc(); return ans;}namespace modular { const int mod=998244353; inline int add(int a,int b) { return a+b&lt;mod?a+b:a+b-mod; } inline int dec(int a,int b) { return a&lt;b?a-b+mod:a-b; } inline int mul(int a,int b) { return (ll)a*b%mod; } inline void Add(int&amp;a,int b) { a=a+b&lt;mod?a+b:a+b-mod; } inline void Dec(int&amp;a,int b) { a=a&lt;b?a-b+mod:a-b; } inline void Mul(int&amp;a,int b) { a=(ll)a*b%mod; } inline int ksm(int a,int p) { int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; } inline int Inv(int a) { return ksm(a,mod-2); }}using namespace modular;const int N=1e6+5;struct cp { int a[6]; cp() { memset(a,0,sizeof(a)); } inline int&amp;operator[](const int&amp;k) { return a[k]; } inline const int&amp;operator[](const int&amp;k) const { return a[k]; } friend inline cp operator+(cp a,cp b) { for(ri i=0;i&lt;K;++i) Add(a[i],b[i]); return a; } friend inline void operator+=(cp&amp;a,cp b) { a=a+b; } friend inline cp operator-(cp a,cp b) { for(ri i=0;i&lt;K;++i) Dec(a[i],b[i]); return a; } friend inline void operator-=(cp&amp;a,cp b) { a=a-b; } friend inline cp operator*(cp a,int b) { for(ri i=0;i&lt;K;++i) Mul(a[i],b); return a; } friend inline void operator*=(cp&amp;a,int b) { a=a*b; } friend inline cp operator*(cp a,cp b) { cp res; for(ri i=0;i&lt;K;++i) if(a[i]) for(ri j=0;j&lt;K;++j) Add(res[i+j&lt;K?i+j:i+j-K],mul(a[i],b[j])); return res; } friend inline void operator*=(cp&amp;a,cp b) { a=a*b; } inline int getval() { return dec(add(a[0],a[1]),add(a[2],a[3])); }}a[N],w[6],cur[6];inline void init() { w[0][0]=w[1][1]=1; for(ri i=2;i&lt;K;++i) w[i]=w[i-1]*w[1]; }inline void dft(cp*a,int typ) { static cp res[6]; for(ri i=0;i&lt;K;++i) { res[i]=cp(); for(ri j=0;j&lt;K;++j) res[i]+=w[i*j%K]*a[j]; } for(ri i=0;i&lt;K;++i) a[i]=res[i]; if(~typ) return; for(ri i=1;i+i&lt;K;++i) swap(a[i],a[K-i]); for(ri i=0;i&lt;K;++i) a[i]*=iv;}inline void dwt(cp*a,int typ) { for(ri i=1;i&lt;lim;i*=K) for(ri j=0,len=i*K;j&lt;lim;j+=len) { for(ri k=0;k&lt;i;++k) { for(ri o=0;o&lt;K;++o) cur[o]=a[j+k+o*i]; dft(cur,typ); for(ri o=0;o&lt;K;++o) a[j+k+o*i]=cur[o]; } }}int sqr;cp tp[N],pws[N],pwb[N];inline cp getpow(int x) { return pws[x%sqr]*pwb[x/sqr]; }inline void trans(cp*a) { for(ri i=0;i&lt;lim;++i) tp[i][0]=1; sqr=sqrt(1.0*n)+10; for(ri t=0;t&lt;K;++t) { cp A; A[0]=pws[0][0]=pwb[0][0]=1,++A[t]; for(ri o=1;o&lt;=sqr;++o) pws[o]=A*pws[o-1]; pwb[1]=pws[sqr]; for(ri o=2;o&lt;=sqr;++o) pwb[o]=pwb[o-1]*pwb[1]; for(ri i=0;i&lt;lim;++i) tp[i]*=getpow(a[i][t]); } for(ri i=0;i&lt;lim;++i) a[i]=tp[i];}int main() { #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(10),K=read(10),tim=read(10),iv=Inv(K); lim=1; for(ri i=1;i&lt;=tim;++i) lim*=K; for(ri i=1;i&lt;=n;++i) ++a[read(K)][0]; init(); dwt(a,1); trans(a); dwt(a,-1); for(ri i=0;i&lt;lim;++i) cout&lt;&lt;a[i].getval()&lt;&lt;&apos;\\n&apos;; return 0;} &#x9B54;&#x529B;&#x73AF; &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x8003;&#x8651; burnsideburnsideburnside &#x5F15;&#x7406;&#xFF0C;&#x53D1;&#x73B0;&#x53EA;&#x7528;&#x679A;&#x4E3E; d&#x2223;gcd&#x2061;(n,m)d|\\gcd(n,m)d&#x2223;gcd(n,m) &#xFF0C;&#x7136;&#x540E;&#x8BA1;&#x7B97; f(d)f(d)f(d) &#x8868;&#x793A; md\\frac mddm&#x200B; &#x4E2A;&#x9ED1;&#x7403;&#xFF0C; n&#x2212;md\\frac {n-m}ddn&#x2212;m&#x200B; &#x4E2A;&#x767D;&#x7403;&#x7684;&#x5E8F;&#x5217;&#xFF0C;&#x5176;&#x4E2D;&#x9ED1;&#x7403;&#xFF08;&#x9996;&#x5C3E;&#x7684;&#x9ED1;&#x7403;&#x8981;&#x52A0;&#x8D77;&#x6765;&#xFF09;&#x4E0D;&#x8FDE;&#x7EED;&#x8D85;&#x8FC7; KKK &#x4E2A;&#x7684;&#x65B9;&#x6848;&#x6570; &#x90A3;&#x4E48;&#x6211;&#x4EEC;&#x5F3A;&#x5236;&#x7ED3;&#x5C3E;&#x6CA1;&#x6709;&#x9ED1;&#x7403;&#xFF0C;&#x679A;&#x4E3E;&#x5F00;&#x5934;&#x9ED1;&#x7403;&#x6709; ttt &#x4E2A;&#xFF0C;&#x65B9;&#x6848;&#x6570;&#x4E58;&#x4E0A; t+1t+1t+1 &#x5373;&#x53EF;&#xFF0C;&#x73B0;&#x5728;&#x95EE;&#x9898;&#x53D8;&#x6210;&#x4E86;&#x5728; n&#x2212;md\\frac{n-m}ddn&#x2212;m&#x200B; &#x4E2A;&#x767D;&#x7403;&#x4E2D;&#x63D2;&#x5165; md&#x2212;t\\frac md-tdm&#x200B;&#x2212;t &#x4E2A;&#x9ED1;&#x7403;&#xFF0C;&#x6BCF;&#x4E2A;&#x7A7A;&#x9699;&#x4E0D;&#x80FD;&#x63D2;&#x5165;&#x8D85;&#x8FC7; KKK &#x4E2A;&#xFF0C;&#x95EE;&#x65B9;&#x6848;&#x6570;&#xFF0C;&#x90A3;&#x4E48;&#x5BB9;&#x65A5;&#x7B97;&#x5373;&#x53EF; CODE cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;namespace modular { const int mod=998244353; inline int add(int a,int b) { return a+b&lt;mod?a+b:a+b-mod; } inline int dec(int a,int b) { return a&lt;b?a-b+mod:a-b; } inline int mul(int a,int b) { return (ll)a*b%mod; } inline void Add(int&amp;a,int b) { a=a+b&lt;mod?a+b:a+b-mod; } inline void Dec(int&amp;a,int b) { a=a&lt;b?a-b+mod:a-b; } inline void Mul(int&amp;a,int b) { a=(ll)a*b%mod; } inline int ksm(int a,int p) { int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; } inline int Inv(int a) { return ksm(a,mod-2); }}using namespace modular;const int N=1e5+5;int n,m,K,fac[N],ifac[N],inv[N],g,tot=0,pri[N],phi[N];bool vs[N];inline int gcd(int a,int b) { int t;while(b) t=a,a=b,b=t-t/a*a;return a; }inline void init() { fac[0]=fac[1]=ifac[0]=ifac[1]=inv[1]=1; for(ri i=2;i&lt;=n;++i) { fac[i]=mul(fac[i-1],i); inv[i]=mul(inv[mod-mod/i*i],mod-mod/i); ifac[i]=mul(ifac[i-1],inv[i]); }}inline int C(int n,int m) { return n&lt;m||m&lt;0?0:mul(fac[n],mul(ifac[m],ifac[n-m])); }inline int F(int a,int b) { int res=0; for(ri i=0,t,up=min(a/(K+1),b-1);i&lt;=up;++i) { t=mul(C(b-1,i),C(a+b-2-i*(K+1),a-i*(K+1))); i&amp;1?Dec(res,t):Add(res,t); } return res;}inline int calc(int a,int b) { if(b==1) return a&lt;=K?a+1:0; int res=0; for(ri i=0;i&lt;=a&amp;&amp;i&lt;=K;++i) Add(res,mul(i+1,F(a-i,b))); return res;}int main() { #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif cin&gt;&gt;n&gt;&gt;m&gt;&gt;K; if(n==m) return cout&lt;&lt;(K&gt;=n),0; init(); g=gcd(n,m); int res=0; for(ri tm=1;tm&lt;=g;++tm) { if(tm==1) phi[tm]=1; else { if(!vs[tm]) phi[tm]=tm-1,pri[++tot]=tm; for(ri i=1,lm=g/tm;i&lt;=tot&amp;&amp;pri[i]&lt;=lm;++i) { vs[tm*pri[i]]=1; if(tm==tm/pri[i]*pri[i]) { phi[tm*pri[i]]=phi[tm]*pri[i];break; } phi[tm*pri[i]]=phi[tm]*(pri[i]-1); } } if(g==g/tm*tm) Add(res,mul(phi[tm],calc(m/tm,(n-m)/tm))); } cout&lt;&lt;mul(res,inv[n]); return 0;} &#x9B54;&#x6CD5;&#x5C0F;&#x7A0B;&#x5E8F; &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x8BFB;&#x5B8C;&#x9898;&#x53D1;&#x73B0;&#x662F;&#x4E2A;&#x4EFB;&#x610F;&#x8FDB;&#x5236;&#x524D;&#x7F00;&#x548C;&#xFF0C;&#x90A3;&#x4E48;&#x6211;&#x4EEC;&#x628A; ccc &#x62FF;&#x6765;&#x505A; ifmtifmtifmt &#x5373;&#x53EF; CODE cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() { int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch)) f^=ch==&apos;-&apos;,ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;}inline ll readl() { ll ans=0; bool f=1; char ch=gc(); while(!isdigit(ch)) f^=ch==&apos;-&apos;,ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;}const int N=1e6+5;int len[N],n,m;ll c[N];int main() { #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif m=read(); cout&lt;&lt;m&lt;&lt;&apos;\\n&apos;; for(ri i=1;i&lt;=m;++i) cout&lt;&lt;(len[i]=read())&lt;&lt;&apos; &apos;; puts(&quot;&quot;); n=read(); len[++m]=n+1; for(ri i=0;i&lt;n;++i) c[i]=readl(); for(ri i=1,id=1;;i*=len[id++]) { if(len[id]&gt;1) for(ri j=n-1;j&gt;=i;--j) if(j/i%len[id]&gt;0) c[j]-=c[j-i]; if(i&gt;n/len[id]) break; } cout&lt;&lt;n&lt;&lt;&apos;\\n&apos;; for(ri i=0;i&lt;n;++i) cout&lt;&lt;c[i]&lt;&lt;&apos; &apos;; puts(&quot;&quot;); return 0;} &#x5982;&#x4F55;&#x4F18;&#x96C5;&#x5730;&#x6C42;&#x548C; &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x8003;&#x8651;&#x6784;&#x9020;&#x7EC4;&#x5408;&#x6570;&#x591A;&#x9879;&#x5F0F;&#xFF1A; fj=&#x2211;i=0m(ji)aiaj=&#x2211;i=0m(ji)(&#x2212;1)j&#x2212;ifiajj!=(&#x2212;1)j&#x2212;i(j&#x2212;i)!fii!ntt&#x6C42;&#x51FA;aires=&#x2211;i=0nfi(ni)xi(1&#x2212;x)n&#x2212;i=&#x2211;i=0n(&#x2211;j=0m(ij)aj)xi(1&#x2212;x)n&#x2212;i(ni)=&#x2211;j=0maj&#x2211;i=0n(ni)xi(1&#x2212;x)n&#x2212;i(ij)=&#x2211;j=0maj(nj)&#x2211;i=0nxi(1&#x2212;x)n&#x2212;i(n&#x2212;ji&#x2212;j)=&#x2211;j=0maj(nj)xj&#x2211;i=0n&#x2212;jxi(1&#x2212;x)n&#x2212;j&#x2212;i(n&#x2212;ji)=&#x2211;j=0maj(nj)xi\\begin{aligned} f_j=&amp;\\sum\\limits_{i=0}^m\\binom jia_i\\\\ a_j=&amp;\\sum\\limits_{i=0}^m\\binom ji(-1)^{j-i}f_i\\\\ \\frac{a_j}{j!}=&amp;\\frac{(-1)^{j-i}}{(j-i)!}\\frac{f_i}{i!}\\\\ ntt&amp;&#x6C42;&#x51FA;a_i\\\\ res=&amp;\\sum\\limits_{i=0}^nf_i\\binom nix^i(1-x)^{n-i}\\\\ =&amp;\\sum\\limits_{i=0}^n(\\sum\\limits_{j=0}^m\\binom ija_j)x^i(1-x)^{n-i}\\binom ni\\\\ =&amp;\\sum\\limits_{j=0}^ma_j\\sum\\limits_{i=0}^n\\binom{n}{i}x^i(1-x)^{n-i}\\binom ij\\\\ =&amp;\\sum\\limits_{j=0}^ma_j\\binom nj\\sum\\limits_{i=0}^nx^i(1-x)^{n-i}\\binom {n-j}{i-j}\\\\ =&amp;\\sum\\limits_{j=0}^ma_j\\binom njx^j\\sum\\limits_{i=0}^{n-j}x^i(1-x)^{n-j-i}\\binom{n-j}i\\\\ =&amp;\\sum\\limits_{j=0}^ma_j\\binom njx^i\\\\ \\end{aligned} fj&#x200B;=aj&#x200B;=j!aj&#x200B;&#x200B;=nttres======&#x200B;i=0&#x2211;m&#x200B;(ij&#x200B;)ai&#x200B;i=0&#x2211;m&#x200B;(ij&#x200B;)(&#x2212;1)j&#x2212;ifi&#x200B;(j&#x2212;i)!(&#x2212;1)j&#x2212;i&#x200B;i!fi&#x200B;&#x200B;&#x6C42;&#x51FA;ai&#x200B;i=0&#x2211;n&#x200B;fi&#x200B;(in&#x200B;)xi(1&#x2212;x)n&#x2212;ii=0&#x2211;n&#x200B;(j=0&#x2211;m&#x200B;(ji&#x200B;)aj&#x200B;)xi(1&#x2212;x)n&#x2212;i(in&#x200B;)j=0&#x2211;m&#x200B;aj&#x200B;i=0&#x2211;n&#x200B;(in&#x200B;)xi(1&#x2212;x)n&#x2212;i(ji&#x200B;)j=0&#x2211;m&#x200B;aj&#x200B;(jn&#x200B;)i=0&#x2211;n&#x200B;xi(1&#x2212;x)n&#x2212;i(i&#x2212;jn&#x2212;j&#x200B;)j=0&#x2211;m&#x200B;aj&#x200B;(jn&#x200B;)xji=0&#x2211;n&#x2212;j&#x200B;xi(1&#x2212;x)n&#x2212;j&#x2212;i(in&#x2212;j&#x200B;)j=0&#x2211;m&#x200B;aj&#x200B;(jn&#x200B;)xi&#x200B; &#x5F53;&#x7136;&#x5229;&#x7528;&#x4E0B;&#x964D;&#x5E42;&#x591A;&#x9879;&#x5F0F;&#x540C;&#x6837;&#x80FD;&#x591F;&#x89E3;&#x51B3;&#x95EE;&#x9898; CODE cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef vector&lt;int&gt; poly;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() { int ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}namespace modular { const int mod=998244353; inline int add(int a,int b) { return a+b&lt;mod?a+b:a+b-mod; } inline int dec(int a,int b) { return a&lt;b?a-b+mod:a-b; } inline int mul(int a,int b) { return (ll)a*b%mod; } inline void Add(int&amp;a,int b) { a=a+b&lt;mod?a+b:a+b-mod; } inline void Dec(int&amp;a,int b) { a=a&lt;b?a-b+mod:a-b; } inline void Mul(int&amp;a,int b) { a=(ll)a*b%mod; } inline int ksm(int a,int p) { int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; }}using namespace modular;const int N=20005;int invv[23],w[23],lim,tim,ifac[N],fac[N],n,m,t;vector&lt;int&gt; rev[23];inline void init_ntt() { invv[0]=1,w[22]=ksm(3,(mod-1)&gt;&gt;23); for(ri i=21;~i;--i) w[i]=mul(w[i+1],w[i+1]); for(ri i=1,iv=mod+1&gt;&gt;1;i&lt;23;++i) invv[i]=mul(invv[i-1],iv);}inline void init(int up) { lim=1,tim=0; while(lim&lt;up) lim&lt;&lt;=1,++tim; if(rev[tim].size()) return; rev[tim].resize(lim); for(ri i=1;i&lt;lim;++i) rev[tim][i]=(rev[tim][i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(tim-1));}inline void ntt(poly&amp;a,int typ) { for(ri i=0;i&lt;lim;++i) if(i&lt;rev[tim][i]) swap(a[i],a[rev[tim][i]]); for(ri i=1,t=0,a0,a1,mt;i&lt;lim;i&lt;&lt;=1,++t) for(ri j=0,len=i&lt;&lt;1;j&lt;lim;j+=len) { mt=1; for(ri k=0;k&lt;i;++k,Mul(mt,w[t])) { a0=a[j+k],a1=mul(a[j+k+i],mt); a[j+k]=add(a0,a1),a[j+k+i]=dec(a0,a1); } } if(~typ) return; reverse(++a.begin(),a.end()); for(ri i=0;i&lt;lim;++i) Mul(a[i],invv[tim]);}inline poly operator*(poly a,poly b) { int n=(int)a.size(),m=(int)b.size(),t=n+m-1; if(t&lt;=128) { poly c(t); for(ri i=0;i&lt;n;++i) if(a[i]) for(ri j=0;j&lt;m;++j) Add(c[i+j],mul(a[i],b[j])); return c; } init(t); a.resize(lim),ntt(a,1); b.resize(lim),ntt(b,1); for(ri i=0;i&lt;lim;++i) Mul(a[i],b[i]); return ntt(a,-1),a.resize(t),a;}inline void init() { fac[0]=fac[1]=ifac[0]=ifac[1]=1; for(ri i=2;i&lt;=m;++i) { fac[i]=mul(fac[i-1],i); ifac[i]=mul(ifac[mod-mod/i*i],mod-mod/i); } for(ri i=2;i&lt;=m;++i) Mul(ifac[i],ifac[i-1]);}int main() { #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(),m=read(),t=read(); init_ntt(); init(); poly f(m+1),g(m+1); for(ri i=0;i&lt;=m;++i) f[i]=mul(ifac[i],read()),g[i]=i&amp;1?mod-ifac[i]:ifac[i]; f=f*g; int res=0; for(ri i=0,mt1=1,mt2=1,tim=n;i&lt;=m;++i,Mul(mt1,t),Mul(mt2,tim),--tim) Add(res,mul(mul(mt1,mt2),f[i])); cout&lt;&lt;res; return 0;}","categories":[{"name":"public","slug":"public","permalink":"http://xdl030112.github.io/categories/public/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://xdl030112.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"杂题乱做 Round9","slug":"sol9","date":"2019-11-27T14:19:34.000Z","updated":"2019-12-26T04:24:00.754Z","comments":true,"path":"sol9/","link":"","permalink":"http://xdl030112.github.io/sol9/","excerpt":"","text":"&#x730E;&#x4EBA;&#x6740; &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x5173;&#x952E;&#x70B9;&#x5728;&#x4E8E;&#x5BF9;&#x4E8E;&#x4E00;&#x4E2A;&#x6B7B;&#x53BB;&#x7684;&#x4EBA;&#x7684;&#x5904;&#x7406;&#xFF0C;&#x6839;&#x636E;&#x9898;&#x89E3;&#x89C2;&#x5BDF;&#x53EF;&#x77E5;&#x8FD9;&#x4E2A;&#x6982;&#x7387;&#x7B49;&#x4E8E;&#x5728;&#x6240;&#x6709;&#x4EBA;&#x4E2D;&#x968F;&#x673A;&#x9009;&#x4EBA;&#x5F00;&#x67AA;&#xFF0C;&#x800C;&#x5728;&#x9009;&#x5230;&#x5DF2;&#x7ECF;&#x6B7B;&#x53BB;&#x7684;&#x4EBA;&#x7684;&#x65F6;&#x5019;&#x91CD;&#x65B0;&#x9009;&#x4EBA;&#xFF0C;&#x8FD9;&#x6837;&#x8DDF;&#x5728;&#x672A;&#x6B7B;&#x53BB;&#x7684;&#x4EBA;&#x4E2D;&#x968F;&#x673A;&#x9009;&#x4EBA;&#x7684;&#x6982;&#x7387;&#x662F;&#x76F8;&#x540C;&#x7684; &#x5728;&#x77E5;&#x9053;&#x8FD9;&#x4E00;&#x70B9;&#x4E4B;&#x540E;&#x5C31;&#x53EF;&#x4EE5;&#x5C1D;&#x8BD5;&#x5BB9;&#x65A5;&#x4E86;&#xFF0C;&#x8003;&#x8651;&#x81F3;&#x5C11; kkk &#x4E2A;&#x4EBA;&#x5728;&#x7B2C;&#x4E00;&#x4E2A;&#x4EBA;&#x4E4B;&#x540E;&#x6B7B;&#x7684;&#x6982;&#x7387;&#x53D1;&#x73B0;&#x8FD9;&#x4E2A;&#x53EF;&#x4EE5;&#x628A;&#x5B83;&#x4EEC;&#x7684;&#x6743;&#x503C;&#x653E;&#x5728;&#x751F;&#x6210;&#x51FD;&#x6570;&#x6307;&#x6570;&#x4E0A;&#x7136;&#x540E;&#x5229;&#x7528;&#x5206;&#x6CBB; nttnttntt &#x5FEB;&#x901F;&#x7EDF;&#x8BA1; CODE cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly;#define fi first#define se second#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}namespace modular{ const int mod=998244353; inline int add(int a,int b){return a+b&lt;mod?a+b:a+b-mod;} inline int dec(int a,int b){return a&lt;b?a-b+mod:a-b;} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Add(int&amp;a,int b){a=a+b&lt;mod?a+b:a+b-mod;} inline void Dec(int&amp;a,int b){a=a&lt;b?a-b+mod:a-b;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;} inline int Inv(int a){return ksm(a,mod-2);} inline int fix(int a){return (a%mod+mod)%mod;}}using namespace modular;int invv[23],w[23],lim,tim;vector&lt;int&gt;rev[23];inline void init_ntt(){ w[22]=ksm(3,(mod-1)&gt;&gt;23); for(ri i=21;~i;--i)w[i]=mul(w[i+1],w[i+1]); invv[0]=1; for(ri i=1,iv=mod+1&gt;&gt;1;i&lt;23;++i)invv[i]=mul(invv[i-1],iv);}inline void init(const int&amp;up){ lim=1,tim=0; while(lim&lt;up)lim&lt;&lt;=1,++tim; if(rev[tim].size())return; rev[tim].resize(lim); for(ri i=1;i&lt;lim;++i)rev[tim][i]=(rev[tim][i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(tim-1));}inline void ntt(poly&amp;a,const int&amp;type){ for(ri i=0;i&lt;lim;++i)if(i&lt;rev[tim][i])swap(a[i],a[rev[tim][i]]); for(ri i=1,a0,a1,t=0;i&lt;lim;i&lt;&lt;=1,++t)for(ri j=0,len=i&lt;&lt;1;j&lt;lim;j+=len) for(ri k=0,mt=1;k&lt;i;++k,Mul(mt,w[t])){ a0=a[j+k],a1=mul(a[j+k+i],mt); a[j+k]=add(a0,a1),a[j+k+i]=dec(a0,a1); } if(~type)return; reverse(++a.begin(),a.end()); for(ri i=0;i&lt;lim;++i)Mul(a[i],invv[tim]);}inline poly operator*(poly a,poly b){ int n=a.size(),m=b.size(),t=n+m-1; if(t&lt;=64){ poly c(t); for(ri i=0;i&lt;n;++i)for(ri j=0;j&lt;m;++j) Add(c[i+j],mul(a[i],b[j])); return c; } init(t); a.resize(lim),ntt(a,1); b.resize(lim),ntt(b,1); for(ri i=0;i&lt;lim;++i)Mul(a[i],b[i]); return ntt(a,-1),a.resize(t),a;}const int N=1e5+5;int n,a[N],m=0,inv[N];inline poly solve(int l,int r){ if(l==r){ poly ret(a[l]+1); ret[0]=1,ret[a[l]]=mod-1; return ret; } int mid=l+r&gt;&gt;1; return solve(l,mid)*solve(mid+1,r);}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif init_ntt(); n=read(); for(ri i=1;i&lt;=n;++i)a[i]=read(),m+=a[i]; inv[1]=1; for(ri i=2;i&lt;=m;++i)inv[i]=mul(inv[mod-mod/i*i],mod-mod/i); poly f=solve(2,n); int res=0; for(ri i=0;i&lt;f.size();++i)Add(res,mul(f[i],mul(a[1],inv[i+a[1]]))); cout&lt;&lt;res; return 0;} &#x6709;&#x610F;&#x4E49;&#x7684;&#x5B57;&#x7B26;&#x4E32; &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x9996;&#x5148;&#x6709;&#x4E2A;&#x5751;&#x70B9;&#x662F;&#x9898;&#x76EE;&#x4E2D;&#x6570;&#x636E;&#x8303;&#x56F4;&#x4E0D;&#x5168;&#xFF0C;&#x6709;&#x4E00;&#x90E8;&#x5206;&#x6D4B;&#x8BD5;&#x6570;&#x636E;&#x6EE1;&#x8DB3; b=1,d=5b=1,d=5b=1,d=5 &#xFF0C;&#x73B0;&#x5728;&#x8003;&#x8651;&#x8FD9;&#x9898;&#x548B;&#x505A; &#x5927;&#x6982;&#x770B;&#x5230;&#x8FD9;&#x4E2A;&#x73A9;&#x610F;&#x513F;&#x4F1A;&#x8054;&#x7CFB;&#x5230;&#x6570;&#x5217;&#x91CC;&#x9762;&#x7528;&#x7279;&#x5F81;&#x6839;&#x65B9;&#x7A0B;&#x6C42;&#x901A;&#x9879;&#x516C;&#x5F0F;&#xFF0C;&#x4E0D;&#x59A8;&#x8BBE; fn=(b+d2)n+(b&#x2212;d2)nf_n=(\\frac{b+\\sqrt d}{2})^n+(\\frac{b-\\sqrt d}{2})^nfn&#x200B;=(2b+d&#x200B;&#x200B;)n+(2b&#x2212;d&#x200B;&#x200B;)n &#xFF0C;&#x7136;&#x540E;&#x53EF;&#x4EE5;&#x5229;&#x7528;&#x8FD9;&#x4E2A;&#x901A;&#x9879;&#x516C;&#x5F0F;&#x53CD;&#x89E3;&#x51FA;&#x6570;&#x5217;&#x9012;&#x63A8;&#x5F0F; fn=bfn&#x2212;1+b2&#x2212;d4fn&#x2212;2f_n=bf_{n-1}+\\frac{b^2-d}4f_{n-2}fn&#x200B;=bfn&#x2212;1&#x200B;+4b2&#x2212;d&#x200B;fn&#x2212;2&#x200B; &#x8FD9;&#x6837;&#x5C31;&#x80FD;&#x641E;&#x51FA;&#x6765; fnf_nfn&#x200B; &#xFF0C;&#x7136;&#x540E;&#x7531;&#x4E8E;&#x9898;&#x76EE;&#x7ED9;&#x51FA;&#x7684;&#x9650;&#x5236;&#x6761;&#x4EF6;&#xFF0C;&#x8FD9;&#x4E2A; b&#x2212;d2&#x2208;(&#x2212;1,0]\\frac{b-\\sqrt d}2\\in(-1,0]2b&#x2212;d&#x200B;&#x200B;&#x2208;(&#x2212;1,0] &#xFF0C;&#x6240;&#x4EE5;&#x8FD9;&#x4E2A; (b&#x2212;d2)n&#x2208;(&#x2212;1,1)(\\frac{b-\\sqrt d}2)^n\\in(-1,1)(2b&#x2212;d&#x200B;&#x200B;)n&#x2208;(&#x2212;1,1) &#xFF0C;&#x4E5F;&#x5C31;&#x662F;&#x8BF4;&#x6700;&#x540E;&#x9700;&#x8981;&#x7279;&#x5224; fnf_nfn&#x200B; &#x662F;&#x5426;&#x8981;&#x51CF;&#x4E00; CODE cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef unsigned long long Ull;#define fi first#define se second#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline Ull readul(){ Ull ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}const Ull mod=7528443412579576937;inline Ull add(Ull a,Ull b){return a+b&lt;mod?a+b:a+b-mod;}inline void Add(Ull&amp;a,Ull b){a=a+b&lt;mod?a+b:a+b-mod;}inline Ull mul(Ull a,Ull b){return (a*b-(Ull)((long double)a/mod*b)*mod+mod)%mod;}Ull d,b,n;struct mat{ Ull a[2][2]; mat(){memset(a,0,sizeof(a));} inline Ull*operator[](const int&amp;k){return a[k];} friend inline mat operator*(mat a,mat b){ mat c; for(ri i=0;i&lt;2;++i)for(ri k=0;k&lt;2;++k)if(a[i][k]) for(ri j=0;j&lt;2;++j)Add(c[i][j],mul(a[i][k],b[k][j])); return c; }}t;int f[105];int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif b=readul(),d=readul(),n=readul(); if(n==0){ cout&lt;&lt;1; return 0; } if(n==1){ cout&lt;&lt;b; return 0; } t[0][0]=b,t[0][1]=1; t[1][0]=(d-b*b)&gt;&gt;2,t[1][1]=0; mat res=t; for(Ull p=n-2;p;t=t*t,p&gt;&gt;=1)if(p&amp;1)res=res*t; Ull ans=add(mul(res[0][0],b),mul(res[1][0],2)); ((n%2==0)&amp;&amp;(b*b!=d))&amp;&amp;(--ans); cout&lt;&lt;ans; return 0;} &#x5206;&#x62C6;&#x6570; &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x8C8C;&#x4F3C;&#x662F;&#x4E2A;&#x751F;&#x6210;&#x51FD;&#x6570;&#x57FA;&#x7840;&#x95EE;&#x9898;&#xFF0C;&#x5927;&#x6982;&#x662F;&#x7528;&#x591A;&#x9879;&#x5F0F; expexpexp &#x548C;&#x8C03;&#x548C;&#x7EA7;&#x6570;&#x7684;&#x6027;&#x8D28;&#x6765;&#x4F18;&#x5316;&#x80CC;&#x5305; &#x5927;&#x6982;&#x5C31;&#x662F;&#x5BF9;&#x4E8E;&#x6BCF;&#x4E2A;&#x6570;&#x6784;&#x9020;&#x51FA;&#x5176;&#x751F;&#x6210;&#x51FD;&#x6570;&#x7136;&#x540E;&#x4E58;&#x8D77;&#x6765;&#x5C31;&#x53EF;&#x4EE5;&#x7B97;&#x51FA;&#x7B54;&#x6848;&#xFF0C;&#x7136;&#x540E;&#x5BF9;&#x591A;&#x9879;&#x5F0F;&#x53D6;&#x5BF9;&#x5C31;&#x53D8;&#x6210;&#x52A0;&#x6CD5;&#xFF0C;&#x518D;&#x7528;&#x4E2A;&#x6C42;&#x5BFC;&#x7684;&#x53D8;&#x5316;&#x5C31;&#x80FD;&#x8F6C;&#x6210; expexpexp &#xFF0C;&#x4E0D;&#x7406;&#x89E3;&#x7684;&#x53EF;&#x4EE5;&#x770B;&#x770B;&#x6211;&#x535A;&#x5BA2;&#x91CC;&#x6709;&#x4E00;&#x7BC7; Generating function &#x7684;&#x80CC;&#x5305;&#x4F18;&#x5316;&#x90E8;&#x5206; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef vector&lt;int&gt; poly;typedef long long ll;typedef pair&lt;int,int&gt; pii;#define fi first#define se second#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}namespace modular{ const int mod=998244353; inline int add(int a,int b){return a+b&lt;mod?a+b:a+b-mod;} inline int dec(int a,int b){return a&lt;b?a-b+mod:a-b;} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Add(int&amp;a,int b){a=a+b&lt;mod?a+b:a+b-mod;} inline void Dec(int&amp;a,int b){a=a&lt;b?a-b+mod:a-b;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;}}using namespace modular;int invv[23],w[23],lim,tim,inv[1&lt;&lt;23];vector&lt;int&gt;rev[23];inline void init_ntt(){ inv[1]=1; for(ri i=2,up=1&lt;&lt;23;i&lt;up;++i)inv[i]=mul(inv[mod-mod/i*i],mod-mod/i); invv[0]=1; for(ri i=1,iv=mod+1&gt;&gt;1;i&lt;23;++i)invv[i]=mul(invv[i-1],iv); w[22]=ksm(3,(mod-1)&gt;&gt;23); for(ri i=21;~i;--i)w[i]=mul(w[i+1],w[i+1]);}inline void init(int up){ lim=1,tim=0; while(lim&lt;up)lim&lt;&lt;=1,++tim; if(rev[tim].size())return; rev[tim].resize(lim); for(ri i=0;i&lt;lim;++i)rev[tim][i]=(rev[tim][i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(tim-1));}inline void ntt(poly&amp;a,int type){ for(ri i=0;i&lt;lim;++i)if(i&lt;rev[tim][i])swap(a[i],a[rev[tim][i]]); for(ri i=1,t=0,a0,a1;i&lt;lim;i&lt;&lt;=1,++t)for(ri j=0,len=i&lt;&lt;1;j&lt;lim;j+=len) for(ri k=0,mt=1;k&lt;i;++k,Mul(mt,w[t])){ a0=a[j+k],a1=mul(a[j+k+i],mt); a[j+k]=add(a0,a1),a[j+k+i]=dec(a0,a1); } if(~type)return; reverse(++a.begin(),a.end()); for(ri i=0;i&lt;lim;++i)Mul(a[i],invv[tim]);}inline poly operator*(poly a,poly b){ int n=a.size(),m=b.size(),t=n+m-1; if(t&lt;=64){ poly c(t); for(ri i=0;i&lt;n;++i)if(a[i])for(ri j=0;j&lt;m;++j)if(b[j]) Add(c[i+j],mul(a[i],b[j])); return c; } init(t); a.resize(lim),ntt(a,1); b.resize(lim),ntt(b,1); for(ri i=0;i&lt;lim;++i)Mul(a[i],b[i]); return ntt(a,-1),a.resize(t),a;}inline poly operator-(poly a,poly b){ a.resize(max(a.size(),b.size())); for(ri i=0;i&lt;b.size();++i)Dec(a[i],b[i]); return a;}inline poly poly_inv(poly a,int k){ poly b(1,ksm(a[0],mod-2)),c; for(ri i=1;i&lt;k;i&lt;&lt;=1){ init(i&lt;&lt;2); c=a,c.resize(i&lt;&lt;1); b.resize(lim),ntt(b,1); c.resize(lim),ntt(c,1); for(ri j=0;j&lt;lim;++j)Mul(b[j],dec(2,mul(b[j],c[j]))); ntt(b,-1),b.resize(i&lt;&lt;1); } return b.resize(k),b;}inline poly poly_deriv(poly a){ for(ri i=0;i&lt;(int)a.size()-1;++i)a[i]=mul(a[i+1],i+1); return a.pop_back(),a;}inline poly poly_integ(poly a){ a.pb(0); for(ri i=a.size()-1;i;--i)a[i]=mul(a[i-1],inv[i]); return a[0]=0,a;}inline poly poly_ln(poly a,int k){ a=poly_integ(poly_deriv(a)*poly_inv(a,k)); return a.resize(k),a;}inline poly poly_exp(poly a,int k){ poly b(1,1),c; a.resize(k&lt;&lt;1); for(ri i=1;i&lt;k;i&lt;&lt;=1){ c=poly_ln(b,i&lt;&lt;1); for(ri j=0;j&lt;c.size();++j)c[j]=dec(a[j],c[j]); Add(c[0],1); b=b*c,b.resize(i&lt;&lt;1); } return b.resize(k),b;}poly f;int n;int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(); init_ntt(); f.resize(n+1); for(ri i=1;i&lt;=n;++i)for(ri j=1;i*j&lt;=n;++j)Add(f[i*j],inv[j]); f=poly_exp(f,n+1); for(ri i=1;i&lt;=n;++i)cout&lt;&lt;f[i]&lt;&lt;&apos;\\n&apos;; return 0;} &#x6574;&#x6570;&#x7684;lqp&#x62C6;&#x5206; &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x53EF;&#x4EE5;&#x76F4;&#x63A5; dpdpdp &#x63A8;&#x5F0F;&#x5B50;&#xFF0C;&#x4E5F;&#x53EF;&#x4EE5;&#x7528;&#x751F;&#x6210;&#x51FD;&#x6570;&#x8C8C;&#x4F3C;&#x90FD;&#x633A;&#x5FEB;&#x7684;&#xFF0C;&#x6700;&#x540E;&#x53CD;&#x6B63;&#x662F;&#x53EF;&#x4EE5;&#x7528;&#x77E9;&#x4E58;&#x4F18;&#x5316;&#x7136;&#x800C;&#x6211;&#x592A;&#x61D2;&#x4E86;&#x5C31;&#x6CA1;&#x5199; CODE cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef unsigned long long Ull;#define fi first#define se second#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}namespace modular{ const int mod=1e9+7; inline int add(int a,int b){return a+b&lt;mod?a+b:a+b-mod;} inline int dec(int a,int b){return a&lt;b?a-b+mod:a-b;} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Add(int&amp;a,int b){a=a+b&lt;mod?a+b:a+b-mod;} inline void Dec(int&amp;a,int b){a=a&lt;b?a-b+mod:a-b;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;}}using namespace modular;int n;int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(); if(n&lt;2){ cout&lt;&lt;n; return 0; } int pre1=0,pre2=1; for(ri tmp,i=2;i&lt;=n;++i){ tmp=pre2; pre2=add(pre1,add(pre2,pre2)); pre1=tmp; } cout&lt;&lt;pre2; return 0;} Perpetual Subtraction &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x8981;&#x7528;&#x4E00;&#x70B9;&#x7EBF;&#x6027;&#x4EE3;&#x6570;&#x4E2D;&#x77E9;&#x9635;&#x5BF9;&#x89D2;&#x5316;&#x7684;&#x77E5;&#x8BC6;&#xFF0C;&#x524D;&#x7F6E;&#x77E5;&#x8BC6;&#x53EF;&#x4EE5;&#x5728; Linear algebra &#x5B66; &#x8FD9;&#x9898;&#x60F3;&#x529E;&#x6CD5;&#x63A8;&#x4E00;&#x63A8;&#x8F6C;&#x79FB;&#x77E9;&#x9635;&#x7684;&#x6865;&#x63A5;&#x77E9;&#x9635; &#x3A6;\\Phi&#x3A6; &#xFF0C;&#x53D1;&#x73B0;&#x8FD8;&#x86EE;&#x6709;&#x89C4;&#x5F8B;&#x7684;&#xFF0C;&#x5927;&#x6982;&#x662F; &#x3A6;i,j=(&#x2212;1)i+jCji\\Phi_{i,j}=(-1)^{i+j}C_j^i&#x3A6;i,j&#x200B;=(&#x2212;1)i+jCji&#x200B; &#xFF0C;&#x7136;&#x540E;&#x53EF;&#x4EE5;&#x6BD4;&#x8F83;&#x7B80;&#x5355;&#x7684;&#x63A8;&#x51FA; &#x3A6;i,j&#x2212;1=Cji\\Phi^{-1}_{i,j}=C_j^i&#x3A6;i,j&#x2212;1&#x200B;=Cji&#x200B; &#xFF0C;&#x7136;&#x540E;&#x5DE6;&#x4E58;&#x77E9;&#x9635;&#x5C31;&#x662F;&#x4E00;&#x4E2A;&#x6C99;&#x96D5;&#x5377;&#x79EF;&#x76F4;&#x63A5;&#x505A;&#x5C31;&#x597D;&#xFF0C;&#x611F;&#x89C9;&#x5565;&#x90FD;&#x6CA1;&#x8BB2;&#x6709;&#x95EE;&#x9898;&#x8BC4;&#x8BBA;&#x533A;&#x95EE;&#x5427; &#x4E0B;&#x9762;&#x4ECB;&#x7ECD;&#x53E6;&#x5916;&#x4E00;&#x4E2A;&#x65B9;&#x6CD5;&#xFF1A; &#x9996;&#x5148;&#x8BBE; f0,if_{0,i}f0,i&#x200B; &#x8868;&#x793A;&#x5F53;&#x524D;&#x8F6E;&#x503C;&#x4E3A; iii &#x7684;&#x6982;&#x7387;&#xFF0C;&#x90A3;&#x4E48;&#x4E0B;&#x4E00;&#x8F6E;&#x503C;&#x4E3A; iii &#x7684;&#x6982;&#x7387; f1,if_{1,i}f1,i&#x200B; &#x53EF;&#x4EE5;&#x7528; f0f_0f0&#x200B; &#x9012;&#x63A8; f1,i=&#x2211;j=inf0,j1j+1&#x5217;&#x51FA;&#x751F;&#x6210;&#x51FD;&#x6570;F0(x),F1(x)F1(x)=&#x2211;i=0nxi&#x2211;j=0nf0,j1j+1=&#x2211;j=0nf0,jj+1&#x2211;i=0jxi=&#x2211;j=0nf0,jxjj+1xj+1&#x2212;1x&#x2212;1=1x&#x2212;1&#x2211;j=0nf0,j&#x222B;1xtjdt=&#x222B;1xF0(t)dtx&#x2212;1&#x4EE4;G1(x)=F1(x+1)=&#x222B;0xF0(t)dtx&#x2212;1&#x90A3;&#x4E48;g1,i=g0,ii&#x2212;1,gm,i=g0,i(i&#x2212;1)m&#x7528;&#x4E8C;&#x9879;&#x5F0F;&#x53CD;&#x6F14;&#x63A8;&#x51FA;f,g&#x6B63;&#x9006;&#x53D8;&#x6362;&#x5373;&#x53EF;\\begin{aligned} f_{1,i}=&amp;\\sum\\limits_{j=i}^nf_{0,j}\\frac1{j+1}\\\\ &#x5217;&#x51FA;&#x751F;&#x6210;&amp;&#x51FD;&#x6570;F_0(x),F_1(x)\\\\ F_1(x)=&amp;\\sum\\limits_{i=0}^nx^i\\sum\\limits_{j=0}^nf_{0,j}\\frac1{j+1}\\\\ =&amp;\\sum\\limits_{j=0}^n\\frac{f_{0,j}}{j+1}\\sum\\limits_{i=0}^jx^i\\\\ =&amp;\\sum\\limits_{j=0}^nf_{0,j}\\frac{x_j}{j+1}\\frac{x^{j+1}-1}{x-1}\\\\ =&amp;\\frac1{x-1}\\sum\\limits_{j=0}^nf_{0,j}\\int_1^xt^j\\text dt\\\\ =&amp;\\frac{\\int_1^xF_0(t)\\text dt}{x-1}\\\\ &#x4EE4;G_1(x)=&amp;F_1(x+1)=\\frac{\\int_0^xF_0(t)\\text dt}{x-1}\\\\ &#x90A3;&#x4E48;g_{1,i}=&amp;\\frac{g_{0,i}}{i-1},g_{m,i}=\\frac{g_{0,i}}{(i-1)^m}\\\\ &#x7528;&#x4E8C;&#x9879;&#x5F0F;&amp;&#x53CD;&#x6F14;&#x63A8;&#x51FA; f,g &#x6B63;&#x9006;&#x53D8;&#x6362;&#x5373;&#x53EF; \\end{aligned} f1,i&#x200B;=&#x5217;&#x51FA;&#x751F;&#x6210;F1&#x200B;(x)=====&#x4EE4;G1&#x200B;(x)=&#x90A3;&#x4E48;g1,i&#x200B;=&#x7528;&#x4E8C;&#x9879;&#x5F0F;&#x200B;j=i&#x2211;n&#x200B;f0,j&#x200B;j+11&#x200B;&#x51FD;&#x6570;F0&#x200B;(x),F1&#x200B;(x)i=0&#x2211;n&#x200B;xij=0&#x2211;n&#x200B;f0,j&#x200B;j+11&#x200B;j=0&#x2211;n&#x200B;j+1f0,j&#x200B;&#x200B;i=0&#x2211;j&#x200B;xij=0&#x2211;n&#x200B;f0,j&#x200B;j+1xj&#x200B;&#x200B;x&#x2212;1xj+1&#x2212;1&#x200B;x&#x2212;11&#x200B;j=0&#x2211;n&#x200B;f0,j&#x200B;&#x222B;1x&#x200B;tjdtx&#x2212;1&#x222B;1x&#x200B;F0&#x200B;(t)dt&#x200B;F1&#x200B;(x+1)=x&#x2212;1&#x222B;0x&#x200B;F0&#x200B;(t)dt&#x200B;i&#x2212;1g0,i&#x200B;&#x200B;,gm,i&#x200B;=(i&#x2212;1)mg0,i&#x200B;&#x200B;&#x53CD;&#x6F14;&#x63A8;&#x51FA;f,g&#x6B63;&#x9006;&#x53D8;&#x6362;&#x5373;&#x53EF;&#x200B; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly; #define fi first#define se second#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline ll readl(){ ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}namespace modular{ const int mod=998244353; inline int add(int a,int b){return a+b&lt;mod?a+b:a+b-mod;} inline int dec(int a,int b){return a&lt;b?a-b+mod:a-b;} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Add(int&amp;a,int b){a=a+b&lt;mod?a+b:a+b-mod;} inline void Dec(int&amp;a,int b){a=a&lt;b?a-b+mod:a-b;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;}}using namespace modular;const int N=1e5+5;int n,invv[23],w[23],lim,tim;vector&lt;int&gt;rev[N];inline void init(const int&amp;up){ lim=1,tim=0; while(lim&lt;up)lim&lt;&lt;=1,++tim; if(rev[tim].size())return; rev[tim].resize(lim); for(ri i=0;i&lt;lim;++i)rev[tim][i]=(rev[tim][i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(tim-1));}ll m;inline void init_ntt(){ w[22]=ksm(3,(mod-1)&gt;&gt;23); for(ri i=21;~i;--i)w[i]=mul(w[i+1],w[i+1]); invv[0]=1; for(ri i=1,iv=mod+1&gt;&gt;1;i&lt;23;++i)invv[i]=mul(invv[i-1],iv);}inline void ntt(poly&amp;a,int type){ for(ri i=0;i&lt;lim;++i)if(i&lt;rev[tim][i])swap(a[i],a[rev[tim][i]]); for(ri i=1,t=0,a0,a1;i&lt;lim;i&lt;&lt;=1,++t)for(ri j=0,len=i&lt;&lt;1;j&lt;lim;j+=len) for(ri k=0,mt=1;k&lt;i;++k,Mul(mt,w[t])){ a0=a[j+k],a1=mul(a[j+k+i],mt); a[j+k]=add(a0,a1),a[j+k+i]=dec(a0,a1); } if(~type)return; reverse(++a.begin(),a.end()); for(ri i=0;i&lt;lim;++i)Mul(a[i],invv[tim]);}inline poly operator*(poly a,poly b){ int n=a.size(),m=b.size(),t=n+m-1; if(t&lt;=64){ poly c(t); for(ri i=0;i&lt;n;++i)for(ri j=0;j&lt;m;++j) Add(c[i+j],mul(a[i],b[j])); return c; } init(t); a.resize(lim),ntt(a,1); b.resize(lim),ntt(b,1); for(ri i=0;i&lt;lim;++i)Mul(a[i],b[i]); return ntt(a,-1),a.resize(t),a;}int fac[N],ifac[N],inv[N];inline void init_fac(){ fac[0]=fac[1]=ifac[0]=ifac[1]=inv[1]=1; for(ri i=2;i&lt;=n+1;++i){ fac[i]=mul(fac[i-1],i); inv[i]=mul(inv[mod-mod/i*i],mod-mod/i); ifac[i]=mul(ifac[i-1],inv[i]); }}poly a,f,g;int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(); m=readl(); a.resize(n+1),f.resize(n+1),g.resize(n+1); for(ri i=0;i&lt;=n;++i)a[i]=read(); init_ntt(),init_fac(); for(ri i=0;i&lt;=n;++i)f[i]=mul(fac[i],a[i]),g[i]=ifac[i]; reverse(f.begin(),f.end()); a=f*g; a.resize(n+1); reverse(a.begin(),a.end()); for(ri i=0;i&lt;=n;++i)Mul(a[i],ifac[i]); for(ri i=0;i&lt;=n;++i)Mul(a[i],ksm(inv[i+1],m%(mod-1))); for(ri i=0;i&lt;=n;++i)f[i]=mul(fac[i],a[i]),g[i]=i&amp;1?mod-ifac[i]:ifac[i]; reverse(f.begin(),f.end()); a=f*g; a.resize(n+1); reverse(a.begin(),a.end()); for(ri i=0;i&lt;=n;++i)Mul(a[i],ifac[i]); for(ri i=0;i&lt;=n;++i)cout&lt;&lt;a[i]&lt;&lt;&apos; &apos;; return 0;} &#x9ECE;&#x660E;&#x524D;&#x7684;&#x5DE7;&#x514B;&#x529B; &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x5BF9;&#x4E8E;&#x6BCF;&#x4E2A;&#x6570;&#x6784;&#x9020;&#x96C6;&#x5408;&#x5E42;&#x7EA7;&#x6570;&#xFF0C;&#x53D1;&#x73B0;&#x662F;&#x8981;&#x6C42; &#x2295;i=1n(1+2xai)[x0]\\oplus_{i=1}^n(1+2x^{a_i})[x^0]&#x2295;i=1n&#x200B;(1+2xai&#x200B;)[x0] &#x7136;&#x540E;&#x89C2;&#x5BDF;&#x5F02;&#x6216;&#x5377;&#x79EF;&#x7684;&#x6027;&#x8D28;&#xFF0C;&#x5047;&#x5982;&#x7B2C; iii &#x4F4D;&#x4E3A; 111 &#xFF0C;&#x90A3;&#x4E48;&#x5B83;&#x4F1A;&#x6839;&#x636E; j&amp;ij\\&amp;ij&amp;i &#x7684;&#x5947;&#x5076;&#x6027;&#x5BF9; jjj &#x4F4D;&#x7F6E;&#x4EA7;&#x751F; &#xB1;1\\pm1&#xB1;1 &#x7684;&#x8D21;&#x732E;&#xFF0C;&#x56E0;&#x6B64;&#x6BCF;&#x4E2A;&#x6570; fwtfwtfwt &#x540E;&#x6BCF;&#x4E00;&#x4F4D;&#x7684;&#x7ED3;&#x679C;&#x4E00;&#x5B9A;&#x4E3A; 111 &#x6216;&#x8005; &#x2212;3-3&#x2212;3 &#xFF0C;&#x8FD9;&#x6837;&#x6211;&#x4EEC;&#x76F4;&#x63A5;&#x628A; &#x2211;i=1n(1+2xai)\\sum_{i=1}^n(1+2x^{a_i})&#x2211;i=1n&#x200B;(1+2xai&#x200B;) &#x62FF;&#x6765; fwtfwtfwt &#xFF0C;&#x7136;&#x540E;&#x89E3;&#x6BCF;&#x4E00;&#x4F4D;&#x6709;&#x591A;&#x5C11;&#x4E2A; &#x2212;1,3-1,3&#x2212;1,3 &#x7136;&#x540E;&#x6C42;&#x51FA;&#x771F;&#x5B9E;&#x7684;&#x70B9;&#x503C;&#x8868;&#x8FBE;&#x5F0F;&#x7684;&#x4E58;&#x79EF;&#x7ED3;&#x679C;&#xFF0C;&#x7136;&#x540E;&#x518D; ifwtifwtifwt &#x56DE;&#x53BB;&#x5373;&#x53EF; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef vector&lt;int&gt; poly;typedef long long ll;typedef pair&lt;int,int&gt; pii;#define fi first#define se second#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}namespace modular{ const int mod=998244353; inline int add(int a,int b){return a+b&lt;mod?a+b:a+b-mod;} inline int dec(int a,int b){return a&lt;b?a-b+mod:a-b;} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Add(int&amp;a,int b){a=a+b&lt;mod?a+b:a+b-mod;} inline void Dec(int&amp;a,int b){a=a&lt;b?a-b+mod:a-b;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;}}using namespace modular;const int N=2e6+5;int n,a[N],mx=0,lim,pw[N];inline void fwt(int*f){ for(ri a0,a1,i=1;i&lt;lim;i&lt;&lt;=1)for(ri j=0,len=i&lt;&lt;1;j&lt;lim;j+=len) for(ri k=0;k&lt;i;++k){ a0=a[j+k],a1=a[j+k+i]; a[j+k]=a0+a1,a[j+k+i]=a0-a1; }}inline void ifwt(int*f){ for(ri iv=mod+1&gt;&gt;1,a0,a1,i=1;i&lt;lim;i&lt;&lt;=1)for(ri j=0,len=i&lt;&lt;1;j&lt;lim;j+=len) for(ri k=0;k&lt;i;++k){ a0=a[j+k],a1=a[j+k+i]; a[j+k]=add(a0,a1),a[j+k+i]=dec(a0,a1); Mul(a[j+k],iv),Mul(a[j+k+i],iv); }}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(); pw[0]=1; for(ri i=1,vl;i&lt;=n;++i){ pw[i]=add(pw[i-1],add(pw[i-1],pw[i-1])); ++a[0]; a[vl=read()]+=2; mx=max(mx,vl); } for(lim=1;lim&lt;=mx;lim&lt;&lt;=1); fwt(a); for(ri x,i=0;i&lt;lim;++i){ x=(a[i]+n)/4; a[i]=(n-x)&amp;1?mod-pw[x]:pw[x]; } ifwt(a); cout&lt;&lt;dec(a[0],1); return 0;} Radix sum &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x4E0D;&#x8003;&#x8651;&#x6A21;&#x6570;&#x7684;&#x8BDD;&#x5C31;&#x662F; 101010 &#x8FDB;&#x5236; fwtfwtfwt &#x88F8;&#x9898;&#xFF0C;&#x73B0;&#x5728;&#x6709;&#x4E86;&#x6A21;&#x6570;&#xFF0C;&#x90A3;&#x4E48;&#x53EF;&#x4EE5;&#x66B4;&#x529B;&#x6269;&#x57DF;&#xFF0C;&#x7528;&#x4E00;&#x4E2A;&#x5411;&#x91CF; (a0,a1,...,a9)T(a_0,a_1,...,a_9)^{\\text T}(a0&#x200B;,a1&#x200B;,...,a9&#x200B;)T &#x6765;&#x8868;&#x793A;&#x4E00;&#x4E2A;&#x6570; &#x2211;i=09ai&#x3C9;10i\\sum\\limits_{i=0}^9a_i\\omega_{10}^ii=0&#x2211;9&#x200B;ai&#x200B;&#x3C9;10i&#x200B;&#xFF0C;&#x8FD9;&#x6837;&#x5C31;&#x80FD;&#x591F;&#x6B63;&#x5E38;&#x7684; dftdftdft &#x4E86;&#xFF0C;&#x7136;&#x540E;&#x518D;&#x8003;&#x8651;&#x600E;&#x4E48;&#x6C42; 101010 &#x7684;&#x9006;&#x5143;&#xFF0C;&#x53D1;&#x73B0; 555 &#x7684;&#x9006;&#x5143;&#x53EF;&#x4EE5;&#x5E7F;&#x4E49;&#x6B27;&#x62C9;&#x5B9A;&#x7406;&#x76F4;&#x63A5;&#x641E;&#xFF0C; 222 &#x53EF;&#x4EE5;&#x76F4;&#x63A5;&#x9664;&#xFF0C;&#x8FD9;&#x6837;&#x5C31;&#x505A;&#x5B8C;&#x4E86;&#xFF0C;&#x4E0D;&#x8FC7;&#x6700;&#x540E;&#x6C42;&#x7B54;&#x6848;&#x7684;&#x65F6;&#x5019;&#x9700;&#x8981;&#x7206;&#x7B97;&#x4E00;&#x6CE2; CODE cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly;typedef unsigned long long ull;const ull inv_5=57646075230342349ull;#define fi first#define se second#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}const int N=1e5+5;int n,a[N],mx=0,lim;ull c[20];struct cp{ ull a[10]; inline void clear(){for(ri i=0;i&lt;10;++i)a[i]=0;} inline ull&amp;operator[](const int&amp;k){return a[k];} inline const ull&amp;operator[](const int&amp;k)const{return a[k];} friend inline cp operator*(cp a,cp b){ for(ri i=0;i&lt;10;++i)for(ri j=0;j&lt;10;++j)c[i+j]+=a[i]*b[j]; for(ri i=0;i&lt;10;++i)a[i]=c[i]+c[i+10],c[i]=c[i+10]=0; return a; } friend inline void operator*=(cp&amp;a,cp b){a=a*b;} friend inline cp operator^(cp a,int p){ cp res; res.clear(),res[0]=1; for(;p;p&gt;&gt;=1,a=a*a)if(p&amp;1)res=res*a; return res; } inline cp fix(){ cp res=*this; for(ri i=0;i&lt;10;++i)res[i]=(res[i]&gt;&gt;1)*inv_5; return res; } inline ull val(){return (a[0]-a[2]+a[7]-a[5])%(1ull&lt;&lt;58);}}f[N&lt;&lt;1];inline void dwt(cp*f){ cp s[10]; for(ri i=1;i&lt;lim;i*=10)for(ri j=0,len=i*10;j&lt;lim;j+=len) for(ri k=0;k&lt;i;++k){ for(ri ps,p=0;p&lt;10;++p){ s[p].clear(); for(ri ps,q=0;q&lt;10;++q){ ps=p*q%10; for(ri o=0;o+ps&lt;10;++o)s[p][o+ps]+=f[j+k+q*i][o]; for(ri o=10-ps;o&lt;10;++o)s[p][o+ps-10]+=f[j+k+q*i][o]; } } for(ri p=0;p&lt;10;++p)f[j+k+p*i]=s[p]; }}inline void idwt(cp*f){ static cp s[10]; for(ri i=1;i&lt;lim;i*=10)for(ri j=0,len=i*10;j&lt;lim;j+=len) for(ri k=0;k&lt;i;++k){ for(ri ps,p=0;p&lt;10;++p){ s[p].clear(); for(ri ps,q=0;q&lt;10;++q){ ps=p*q%10; ps=ps?10-ps:0; for(ri o=0;o+ps&lt;10;++o)s[p][o+ps]+=f[j+k+q*i][o]; for(ri o=10-ps;o&lt;10;++o)s[p][o+ps-10]+=f[j+k+q*i][o]; } } for(ri p=0;p&lt;10;++p)f[j+k+p*i]=s[p].fix(); }}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(); for(ri i=1;i&lt;=n;++i)++f[a[i]=read()][0],mx=max(mx,a[i]); for(lim=10;lim&lt;mx;lim*=10); dwt(f); for(ri i=0;i&lt;lim;++i)f[i]=f[i]^n; idwt(f); for(ri i=0;i&lt;n;++i)cout&lt;&lt;f[i].val()&lt;&lt;&apos;\\n&apos;; return 0;}","categories":[{"name":"public","slug":"public","permalink":"http://xdl030112.github.io/categories/public/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://xdl030112.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"杂题乱做 Round8","slug":"sol8","date":"2019-11-23T03:29:21.000Z","updated":"2019-12-26T04:24:49.106Z","comments":true,"path":"sol8/","link":"","permalink":"http://xdl030112.github.io/sol8/","excerpt":"","text":"&#x9752;&#x6625;&#x732A;&#x5934;&#x5C11;&#x5E74;&#x4E0D;&#x4F1A;&#x68A6;&#x5230;&#x5154;&#x5973;&#x90CE;&#x5B66;&#x59D0; &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x9996;&#x5148;&#x662F;&#x5904;&#x7406;&#x73AF;&#x7684;&#x95EE;&#x9898;&#xFF0C;&#x8FD9;&#x8C8C;&#x4F3C;&#x662F;&#x4E00;&#x4E2A;&#x5E38;&#x89C1;&#x5957;&#x8DEF;&#xFF0C;&#x5373;&#x89C4;&#x5B9A;&#x5F00;&#x5934;&#x4E00;&#x5B9A;&#x662F;&#x7B2C;&#x4E00;&#x79CD;&#x7B97;&#x51FA;&#x65B9;&#x6848;&#x6570;&#x518D;&#x6263;&#x53BB;&#x5F00;&#x5934;&#x7ED3;&#x5C3E;&#x90FD;&#x662F;&#x7B2C;&#x4E00;&#x79CD;&#x7684;&#x65B9;&#x6848;&#x6570;&#xFF0C;&#x6700;&#x540E;&#x4E58;&#x4E0A;&#x6BCF;&#x79CD;&#x65B9;&#x6848;&#x88AB;&#x8BA1;&#x7B97;&#x7684;&#x6B21;&#x6570;&#x5373;&#x53EF; &#x73B0;&#x5728;&#x53EA;&#x9700;&#x8003;&#x8651;&#x5E8F;&#x5217;&#x4E0A;&#x5982;&#x4F55;&#x505A;&#xFF0C;&#x663E;&#x7136;&#x8981;&#x5BF9;&#x6BCF;&#x79CD;&#x989C;&#x8272;&#x5206;&#x5F00;&#x8003;&#x8651;&#xFF0C;&#x76F8;&#x5F53;&#x4E8E;&#x662F;&#x5C06;&#x6BCF;&#x79CD;&#x989C;&#x8272;&#x5206;&#x6210;&#x82E5;&#x5E72;&#x6BB5;&#x7136;&#x540E;&#x5728;&#x5E8F;&#x5217;&#x4E0A;&#x62FC;&#x63A5;&#x4F7F;&#x5F97;&#x76F8;&#x90BB;&#x7684;&#x4E24;&#x6BB5;&#x4E0D;&#x80FD;&#x662F;&#x540C;&#x4E00;&#x79CD;&#x989C;&#x8272;&#xFF0C;&#x8FD9;&#x4E0D;&#x53C8;&#x662F;&#x90A3;&#x9053;[JSOI2019]&#x795E;&#x7ECF;&#x7F51;&#x7EDC;&#x5417;&#xFF0C;&#x663E;&#x7136;&#x7528;&#x5BB9;&#x65A5;+&#x751F;&#x6210;&#x51FD;&#x6570;&#x89E3;&#x51B3;&#xFF0C;&#x90A3;&#x4E48;&#x73B0;&#x5728;&#x53EA;&#x7528;&#x6C42;&#x628A; nnn &#x4E2A;&#x989C;&#x8272;&#x7684;&#x7403;&#x5212;&#x5206;&#x6210; mmm &#x6BB5;&#xFF0C;&#x6240;&#x6709;&#x65B9;&#x6848;&#x7684;&#x6BB5;&#x4E58;&#x79EF;&#x4E4B;&#x548C;&#xFF0C;&#x8FD9;&#x4E2A;&#x4E5F;&#x53EF;&#x4EE5;&#x751F;&#x6210;&#x51FD;&#x6570;&#x63A8;&#x5BFC;&#x4E00;&#x4E0B;&#xFF0C;&#x63A8;&#x5BFC;&#x5982;&#x4E0B;&#xFF1A; Ans=[xn](&#x2211;i=0+&#x221E;ixi)m=[xn]xm(&#x2211;i=0+&#x221E;xi)2m=[xn&#x2212;m](&#x2211;i=0+&#x221E;xi)2m=Cn+m&#x2212;12m&#x2212;1\\begin{aligned} Ans=&amp;[x^n](\\sum\\limits_{i=0}^{+\\infty}ix^i)^m\\\\ =&amp;[x^n]x^m(\\sum\\limits_{i=0}^{+\\infty}x^i)^{2m}\\\\ =&amp;[x^{n-m}](\\sum\\limits_{i=0}^{+\\infty}x^i)^{2m}\\\\ =&amp;C_{n+m-1}^{2m-1} \\end{aligned} Ans====&#x200B;[xn](i=0&#x2211;+&#x221E;&#x200B;ixi)m[xn]xm(i=0&#x2211;+&#x221E;&#x200B;xi)2m[xn&#x2212;m](i=0&#x2211;+&#x221E;&#x200B;xi)2mCn+m&#x2212;12m&#x2212;1&#x200B;&#x200B; &#x8003;&#x8651;&#x679A;&#x4E3E;&#x7B2C; iii &#x79CD;&#x989C;&#x8272;&#x5206;&#x4E3A;&#x4E86; bib_ibi&#x200B; &#x6BB5;&#xFF0C;&#x6700;&#x540E;&#x5728;&#x5E8F;&#x5217;&#x4E0A;&#x5C06;&#x76F8;&#x90BB;&#x7684;&#x6BB5;&#x5408;&#x8D77;&#x6765;&#x540E;&#x81F3;&#x5C11; cic_ici&#x200B; &#x6BB5;&#xFF0C;&#x90A3;&#x4E48;&#x73B0;&#x5728;&#x53EF;&#x4EE5;&#x5217;&#x51FA;&#x5E8F;&#x5217;&#x4E0A;&#x7B54;&#x6848;&#x7684;&#x5F0F;&#x5B50;&#xFF1A; Ans=&#x2211;c&#x2211;b(&#x220F;Cai+bi&#x2212;12bi&#x2212;1Cbi&#x2212;1ci&#x2212;1(&#x2212;1)bi&#x2212;ci)(&#x2211;i=1nci)!&#x220F;i=&#x2212;1nci!\\begin{aligned} Ans=&amp;\\sum\\limits_{c}\\sum\\limits_{b}(\\prod\\limits C_{a_i+b_i-1}^{2b_i-1}C_{b_i-1}^{c_i-1}(-1)^{b_i-c_i})\\frac{(\\sum\\limits_{i=1}^nc_i)!}{\\prod\\limits_{i=-1}^nc_i!} \\end{aligned} Ans=&#x200B;c&#x2211;&#x200B;b&#x2211;&#x200B;(&#x220F;Cai&#x200B;+bi&#x200B;&#x2212;12bi&#x200B;&#x2212;1&#x200B;Cbi&#x200B;&#x2212;1ci&#x200B;&#x2212;1&#x200B;(&#x2212;1)bi&#x200B;&#x2212;ci&#x200B;)i=&#x2212;1&#x220F;n&#x200B;ci&#x200B;!(i=1&#x2211;n&#x200B;ci&#x200B;)!&#x200B;&#x200B; &#x7136;&#x540E;&#x628A;&#x5F0F;&#x5B50;&#x62C6;&#x5F00;&#x5BF9;&#x6BCF;&#x79CD;&#x7403;&#x90FD;&#x6784;&#x9020;&#x751F;&#x6210;&#x51FD;&#x6570;&#x6700;&#x540E;&#x5206;&#x6CBB; nttnttntt &#x5408;&#x5E76;&#x8D77;&#x6765;&#x5373;&#x53EF;&#xFF0C;&#x6CE8;&#x610F;&#x7B2C;&#x4E00;&#x79CD;&#x989C;&#x8272;&#x9700;&#x8981;&#x8FDB;&#x884C;&#x7279;&#x6B8A;&#x5904;&#x7406;&#xFF0C;&#x597D;&#x5427;&#x8FD8;&#x662F;&#x5217;&#x4E00;&#x4E2A;&#x751F;&#x6210;&#x51FD;&#x6570;&#x7684;&#x5F0F;&#x5B50;&#xFF1A; fi(x)=&#x2211;i=0aixii!(&#x2211;b&#x2265;iCai+b&#x2212;12bCb&#x2212;1i&#x2212;1(&#x2212;1)b&#x2212;c)\\begin{aligned} f_i(x)=&amp;\\sum\\limits_{i=0}^{a_i}\\frac{x^i}{i!}(\\sum\\limits_{b\\ge i}C_{a_i+b-1}^{2b}C_{b-1}^{i-1}(-1)^{b-c}) \\end{aligned} fi&#x200B;(x)=&#x200B;i=0&#x2211;ai&#x200B;&#x200B;i!xi&#x200B;(b&#x2265;i&#x2211;&#x200B;Cai&#x200B;+b&#x2212;12b&#x200B;Cb&#x2212;1i&#x2212;1&#x200B;(&#x2212;1)b&#x2212;c)&#x200B; &#x663E;&#x7136;&#x53EF;&#x4EE5;&#x5377;&#x79EF;&#x5904;&#x7406; &#x8FD8;&#x5269;&#x4E00;&#x4E2A;&#x95EE;&#x9898;&#x662F;&#x6BCF;&#x79CD;&#x73AF;&#x88AB;&#x8BA1;&#x7B97;&#x7684;&#x6B21;&#x6570;&#xFF0C;&#x5047;&#x8BBE;&#x5FAA;&#x73AF;&#x8282;&#x7684;&#x957F;&#x5EA6;&#x4E3A; len,m=&#x2211;i=1nailen,m=\\sum\\limits_{i=1}^na_ilen,m=i=1&#x2211;n&#x200B;ai&#x200B; &#xFF0C;&#x7B2C;&#x4E00;&#x79CD;&#x989C;&#x8272;&#x7684;&#x7403;&#x5728;&#x4E00;&#x4E2A;&#x5FAA;&#x73AF;&#x8282;&#x4E2D;&#x88AB;&#x5206;&#x6210;&#x4E86; xxx &#x6BB5;&#xFF0C;&#x90A3;&#x4E48;&#x7528;&#x4E0A;&#x8FF0;&#x505A;&#x6CD5;&#x5B9E;&#x9645;&#x88AB;&#x8BA1;&#x7B97;&#x4E86; xmlen\\frac{x}{\\frac{m}{len}}lenm&#x200B;x&#x200B; &#x6B21;&#xFF0C;&#x4E8C;&#x5341;&#x51E0;&#x6740;&#x662F;&#x54EA;&#x4E2A;&#x5E94;&#x8BE5;&#x8BA1;&#x7B97; lenlenlen &#x6B21;&#xFF0C;&#x56E0;&#x6B64;&#x5BF9;&#x4E8E;&#x7B2C;&#x4E00;&#x79CD;&#x989C;&#x8272;&#x7684;&#x7403;&#x6211;&#x4EEC;&#x5BF9;&#x6BCF;&#x4E00;&#x4F4D;&#x591A;&#x9664;&#x4EE5;&#x4E00;&#x4E2A; xxx &#xFF0C;&#x4E4B;&#x540E;&#x7684;&#x7B54;&#x6848;&#x518D;&#x4E58;&#x4E0A; mmm &#x5373;&#x53EF;&#x5F97;&#x5230;&#x6B63;&#x786E;&#x7B54;&#x6848; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly;#define fi first#define se second#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}namespace modular{ const int mod=998244353; inline int add(int a,int b){return a+b&lt;mod?a+b:a+b-mod;} inline int dec(int a,int b){return a&lt;b?a-b+mod:a-b;} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Add(int&amp;a,int b){a=a+b&lt;mod?a+b:a+b-mod;} inline void Dec(int&amp;a,int b){a=a&lt;b?a-b+mod:a-b;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;}}using namespace modular;int invv[23],w[23],lim,tim;vector&lt;int&gt;rev[23];inline void init_ntt(){ invv[0]=1; for(ri iv=mod+1&gt;&gt;1,i=1;i&lt;23;++i)invv[i]=mul(invv[i-1],iv); w[22]=ksm(3,(mod-1)&gt;&gt;23); for(ri i=21;~i;--i)w[i]=mul(w[i+1],w[i+1]);}inline void init(int up){ lim=1,tim=0; while(lim&lt;up)lim&lt;&lt;=1,++tim; if(rev[tim].size())return; rev[tim].resize(lim); for(ri i=0;i&lt;lim;++i)rev[tim][i]=(rev[tim][i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(tim-1));}inline void ntt(poly&amp;a,int typ){ for(ri i=0;i&lt;lim;++i)if(i&lt;rev[tim][i])swap(a[i],a[rev[tim][i]]); for(ri i=1,a0,a1,t=0;i&lt;lim;i&lt;&lt;=1,++t)for(ri j=0,len=i&lt;&lt;1;j&lt;lim;j+=len) for(ri k=0,mt=1;k&lt;i;++k,Mul(mt,w[t]))a0=a[j+k],a1=mul(a[j+k+i],mt),a[j+k]=add(a0,a1),a[j+k+i]=dec(a0,a1); if(~typ)return; reverse(++a.begin(),a.end()); for(ri i=0;i&lt;lim;++i)Mul(a[i],invv[tim]);}inline poly operator*(poly a,poly b){ int n=a.size(),m=b.size(),t=n+m-1; if(t&lt;=64){ poly c(t); for(ri i=0;i&lt;n;++i)for(ri j=0;j&lt;m;++j)Add(c[i+j],mul(a[i],b[j])); return c; } init(t); a.resize(lim),ntt(a,1); b.resize(lim),ntt(b,1); for(ri i=0;i&lt;lim;++i)Mul(a[i],b[i]); return ntt(a,-1),a.resize(t),a;}inline void revv(poly&amp;a){reverse(a.begin(),a.end());}const int N=2e5+5;int a[N],n,m=0,fac[N&lt;&lt;1],inv[N&lt;&lt;1],ifac[N&lt;&lt;1];poly f[N];inline poly fix(poly a){for(ri i=0;i&lt;a.size();++i)Mul(a[i],ifac[i]);return a;}inline poly solve(int l,int r){ if(l==r)return fix(f[l]); int mid=l+r&gt;&gt;1; return solve(l,mid)*solve(mid+1,r);}inline void init_fac(){ fac[0]=fac[1]=ifac[0]=ifac[1]=inv[1]=1; for(ri i=2;i&lt;=m;++i){ fac[i]=mul(fac[i-1],i); inv[i]=mul(inv[mod-mod/i*i],mod-mod/i); ifac[i]=mul(ifac[i-1],inv[i]); }}inline int C(int n,int m){return n&lt;m||m&lt;0?0:mul(fac[n],mul(ifac[m],ifac[n-m]));}inline void check(){ poly f(8); for(ri i=0;i&lt;8;++i)f[i]=i; init(8); f.resize(lim); ntt(f,1); ntt(f,-1);}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(); for(ri i=1;i&lt;=n;++i)a[i]=read(),m+=a[i]; if(n==1){ cout&lt;&lt;a[1]; return 0; } init_fac(); init_ntt(); check(); for(ri i=1;i&lt;=n;++i){ poly fa(a[i]+1),fb(a[i]+1); for(ri j=1;j&lt;=a[i];++j)fa[j]=mul(C(a[i]+j-1,a[i]-j),fac[j-1]); if(i==1)for(ri j=1;j&lt;=a[i];++j)Mul(fa[j],inv[j]); for(ri j=0;j&lt;=a[i];++j)fb[a[i]-j]=j&amp;1?mod-ifac[j]:ifac[j]; fa=fa*fb; f[i]=poly(a[i]+1); for(ri j=1;j&lt;=a[i];++j)f[i][j]=mul(fa[a[i]+j],ifac[j-1]); } int res=0; poly g=solve(2,n),h(a[1]); for(ri i=0;i&lt;a[1];++i)h[i]=mul(f[1][i+1],ifac[i]); h=g*h; for(ri i=1;i&lt;h.size();++i)Add(res,mul(h[i],fac[i])); if(a[1]&gt;1){ h=poly(a[1]-1); for(ri i=0;i&lt;a[1]-1;++i)h[i]=mul(f[1][i+2],ifac[i]); h=g*h; for(ri i=1;i&lt;h.size();++i)Dec(res,mul(h[i],fac[i])); } cout&lt;&lt;mul(res,m); return 0;} Endless Spin &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x53C8;&#x4E00;&#x9053;&#x5957;&#x8DEF;&#x9898;&#xFF0C;&#x8003;&#x8651;&#x7528; min&#x2212;maxmin-maxmin&#x2212;max &#x5BB9;&#x65A5;&#x8F6C;&#x5316;&#x95EE;&#x9898;&#xFF0C;&#x53D8;&#x4E3A;&#x6C42;&#x4E00;&#x4E2A;&#x96C6;&#x5408;&#x6240;&#x6709;&#x5143;&#x7D20;&#x7B2C;&#x4E00;&#x6B21;&#x88AB;&#x8986;&#x76D6;&#x65F6;&#x95F4;&#x7684;&#x6700;&#x5C0F;&#x503C;&#xFF0C;&#x8FD9;&#x4E2A;&#x53EF;&#x4EE5;&#x7528;&#x6982;&#x7387;&#x8F6C;&#x5316;+&#x4E00;&#x4E2A;&#x7B80;&#x5355; dpdpdp &#x6765;&#x6C42;&#xFF0C;&#x9996;&#x5148;&#x8BBE;&#x8FD9;&#x4E2A;&#x96C6;&#x5408;&#x67D0;&#x4E2A;&#x5143;&#x7D20;&#x88AB;&#x8986;&#x76D6;&#x7684;&#x6982;&#x7387;&#x4E3A; PPP &#xFF0C;&#x90A3;&#x4E48;&#x8FD9;&#x4E2A;&#x96C6;&#x5408;&#x67D0;&#x4E2A;&#x5143;&#x7D20;&#x88AB;&#x8986;&#x76D6;&#x7684;&#x671F;&#x671B;&#x6B21;&#x6570;&#x4E3A; &#x2211;i=0+&#x221E;(1&#x2212;P1)i=1P\\sum\\limits_{i=0}^{+\\infty}(\\frac{1-P}{1})^i=\\frac1Pi=0&#x2211;+&#x221E;&#x200B;(11&#x2212;P&#x200B;)i=P1&#x200B; &#xFF0C;&#x8BBE; fi,j,0/1f_{i,j,0/1}fi,j,0/1&#x200B; &#x8868;&#x793A;&#x5904;&#x7406;&#x5230;&#x7B2C; iii &#x4E2A;&#x4F4D;&#x7F6E;&#xFF0C;&#x6709; jjj &#x4E2A;&#x533A;&#x95F4;&#x8DDF;&#x5F53;&#x524D;&#x96C6;&#x5408;&#x4E0D;&#x76F8;&#x4EA4;&#xFF0C;&#x5F53;&#x524D;&#x96C6;&#x5408;&#x4E2D;&#x5143;&#x7D20;&#x7684;&#x5947;&#x5076;&#x6027;&#x4E3A; 0/10/10/1 &#x7684;&#x65B9;&#x6848;&#x6570;&#xFF0C;&#x7136;&#x540E;&#x8BE5;&#x600E;&#x4E48;&#x8F6C;&#x79FB;&#x600E;&#x4E48;&#x8F6C;&#x79FB;&#xFF0C;&#x6CE8;&#x610F;&#x6700;&#x540E;&#x7B54;&#x6848;&#x8981;&#x7EF4;&#x62A4;&#x4E00;&#x4E2A;&#x5C0F;&#x6570;&#x7C7B; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly;#define fi first#define se second#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}const int N=55;int n;struct Db{ ll a[31]; inline ll&amp;operator[](const int&amp;k){return a[k];} inline const ll&amp;operator[](const int&amp;k)const{return a[k];} inline void trans(ll _a,ll _b){ a[0]=_a/_b; _a%=_b; for(ri i=1;i&lt;=30;++i)_a*=10,a[i]=_a/_b,_a%=_b; } friend inline Db operator+(Db a,Db b){ Db c; ll dt=0; for(ri i=30;~i;--i){ c[i]=a[i]+b[i]+dt; if(i)dt=c[i]/10,c[i]%=10; } return c; } friend inline Db operator-(Db a,Db b){ for(ri i=30;i;--i){ if(a[i]&lt;b[i])--a[i-1],a[i]+=10; a[i]-=b[i]; } return a[0]-=b[0],a; } friend inline Db operator*(Db a,ll b){ ll dt=0; for(ri i=30;~i;--i){ a[i]*=b; a[i]+=dt; if(i)dt=a[i]/10,a[i]%=10; } return a; }}res[N],tmp1,tmp2,tmp;inline void print(Db a){ if(a[16]&gt;4)++a[15]; for(ri i=15;i;--i){ if(a[i]==10)++a[i-1],a[i]=0; else break; } cout&lt;&lt;a[0]&lt;&lt;&apos;.&apos;; for(ri i=1;i&lt;=15;++i)cout&lt;&lt;a[i]; puts(&quot;&quot;);}inline int calc(int x){return x*(x+1)&gt;&gt;1;}ll f[N][N*N][2];//double res[N];inline void init(){ for(ri all,n=1;n&lt;=50;++n){ memset(f,0,sizeof(f)); f[0][0][0]=1; for(ri i=1;i&lt;=n;++i)for(ri j=0;j&lt;i;++j) for(ri num=calc(i-j-1),up=calc(i);num&lt;=up;++num) for(ri op=0;op&lt;2;++op)f[i][num][op]+=f[j][num-calc(i-j-1)][!op]; all=calc(n); tmp1.trans(0,1); tmp2.trans(0,1); for(ri i=1;i&lt;=n;++i)for(ri num=0,up=calc(i);num&lt;=up;++num)if(f[i][num][1]!=f[i][num][0]){ tmp.trans(f[i][num][1],all-num-calc(n-i)); tmp1=tmp1+tmp*all; tmp.trans(f[i][num][0],all-num-calc(n-i)); tmp2=tmp2+tmp*all; } res[n]=tmp1-tmp2; }}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif init(); for(ri tt=read();tt;--tt)print(res[read()]); return 0;} &#x6590;&#x6CE2;&#x90A3;&#x5951;&#x7684;&#x6700;&#x5C0F;&#x516C;&#x500D;&#x6570; &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x9996;&#x5148;&#x6709;&#x4E00;&#x4E2A;&#x7ED3;&#x8BBA; gcd&#x2061;(fiba,fibb)=fibgcd&#x2061;(a,b)\\gcd(fib_a,fib_b)=fib_{\\gcd(a,b)}gcd(fiba&#x200B;,fibb&#x200B;)=fibgcd(a,b)&#x200B; &#xFF0C;&#x4E0B;&#x9762;&#x7ED9;&#x51FA;&#x8BC1;&#x660E;&#xFF1A; &#x9996;&#x5148;&#x6709;&#x4E24;&#x4E2A;&#x5F15;&#x7406; gcd&#x2061;(fibi,fibi&#x2212;1)=gcd&#x2061;(fibi&#x2212;1,fibi&#x2212;2)=&#x22EF;=1\\gcd(fib_i,fib_{i-1})=\\gcd(fib_{i-1},fib_{i-2})=\\cdots=1gcd(fibi&#x200B;,fibi&#x2212;1&#x200B;)=gcd(fibi&#x2212;1&#x200B;,fibi&#x2212;2&#x200B;)=&#x22EF;=1 fibn+m=fibn&#x2212;1&#xD7;fibm+fibn&#xD7;fibm+1fib_{n+m}=fib_{n-1}\\times fib_{m}+fib_{n}\\times fib_{m+1}fibn+m&#x200B;=fibn&#x2212;1&#x200B;&#xD7;fibm&#x200B;+fibn&#x200B;&#xD7;fibm+1&#x200B; &#xFF0C;&#x8FD9;&#x4E2A;&#x8003;&#x8651;&#x5229;&#x7528;&#x6570;&#x5B66;&#x5F52;&#x7EB3;&#x6CD5;&#xFF0C; m=1m=1m=1 &#x65F6;&#x663E;&#x7136;&#x6210;&#x7ACB;&#xFF0C;&#x90A3;&#x4E48; fibn+m=fibn+m&#x2212;1+fibn+m&#x2212;2=fibn&#x2212;1fibm&#x2212;1+fibnfibm+fibn&#x2212;2fibm&#x2212;1+fibn&#x2212;1fibm=fibnfibm&#x2212;1+fibnfibm+fibn&#x2212;1fibm=fibn&#x2212;1fibm+fibnfibm+1&#x21D2;gcd&#x2061;(fibn+m,fibn)=gcd&#x2061;(fibn&#x2212;1fibm+fibnfibm+1,fibn)=gcd&#x2061;(fibn&#x2212;1fibm,fibn)=gcd&#x2061;(fibn,fibm)\\begin{aligned} fib_{n+m}=&amp;fib_{n+m-1}+fib_{n+m-2}\\\\ =&amp;fib_{n-1}fib_{m-1}+fib_{n}fib_{m}+fib_{n-2}fib_{m-1}+fib_{n-1}fib_{m}\\\\ =&amp;fib_{n}fib_{m-1}+fib_{n}fib_{m}+fib_{n-1}fib_{m}\\\\ =&amp;fib_{n-1}fib_{m}+fib_{n}fib_{m+1}\\\\ \\Rightarrow \\gcd(fib_{n+m},fib_n)=&amp;\\gcd(fib_{n-1}fib_{m}+fib_{n}fib_{m+1},fib_n)\\\\ =&amp;\\gcd(fib_{n-1}fib_{m},fib_n)\\\\ =&amp;\\gcd(fib_n,fib_m) \\end{aligned} fibn+m&#x200B;====&#x21D2;gcd(fibn+m&#x200B;,fibn&#x200B;)===&#x200B;fibn+m&#x2212;1&#x200B;+fibn+m&#x2212;2&#x200B;fibn&#x2212;1&#x200B;fibm&#x2212;1&#x200B;+fibn&#x200B;fibm&#x200B;+fibn&#x2212;2&#x200B;fibm&#x2212;1&#x200B;+fibn&#x2212;1&#x200B;fibm&#x200B;fibn&#x200B;fibm&#x2212;1&#x200B;+fibn&#x200B;fibm&#x200B;+fibn&#x2212;1&#x200B;fibm&#x200B;fibn&#x2212;1&#x200B;fibm&#x200B;+fibn&#x200B;fibm+1&#x200B;gcd(fibn&#x2212;1&#x200B;fibm&#x200B;+fibn&#x200B;fibm+1&#x200B;,fibn&#x200B;)gcd(fibn&#x2212;1&#x200B;fibm&#x200B;,fibn&#x200B;)gcd(fibn&#x200B;,fibm&#x200B;)&#x200B; &#x53D1;&#x73B0;&#x5C31;&#x662F;&#x8F97;&#x8F6C;&#x76F8;&#x9664;&#x7684;&#x5F62;&#x5F0F;&#xFF0C;&#x56E0;&#x6B64;&#x539F;&#x547D;&#x9898;&#x5F97;&#x8BC1; &#x73B0;&#x5728;&#x8003;&#x8651;&#x5230;&#x6700;&#x540E;&#x7B54;&#x6848;&#x76F8;&#x5F53;&#x4E8E;&#x662F;&#x8D28;&#x56E0;&#x6570;&#x7684;&#x6307;&#x6570;&#x53D6; max&#x2061;\\maxmax &#xFF0C;&#x56E0;&#x6B64;&#x6211;&#x4EEC;&#x5BF9;&#x6307;&#x6570;&#x7ED9; min&#x2212;maxmin-maxmin&#x2212;max &#x5BB9;&#x65A5;&#x4E00;&#x6CE2;&#x53D8;&#x6210;&#x53D6; min&#x2061;\\minmin lcm(f{S})=&#x220F;T&#x2286;S,T=&#x338;&#x2205;fgcd&#x2061;{T}(&#x2212;1)&#x2223;T&#x2223;+1\\begin{aligned} lcm(f_{\\{S\\}})=\\prod\\limits_{T\\subseteq S,T\\not=\\emptyset}f_{\\gcd\\{T\\}}^{(-1)^{|T|+1}} \\end{aligned} lcm(f{S}&#x200B;)=T&#x2286;S,T&#xE020;&#x200B;=&#x2205;&#x220F;&#x200B;fgcd{T}(&#x2212;1)&#x2223;T&#x2223;+1&#x200B;&#x200B; &#x90A3;&#x4E48;&#x95EE;&#x9898;&#x53EF;&#x4EE5;&#x8F6C;&#x5316;&#x4E3A;&#x6C42; gcd&#x2061;=d\\gcd=dgcd=d &#x4E14;&#x96C6;&#x5408;&#x5927;&#x5C0F;&#x4E3A;&#x5947;&#x6570;/&#x5076;&#x6570;&#x7684;&#x96C6;&#x5408;&#x6709;&#x591A;&#x5C11;&#x4E2A;&#xFF0C;&#x663E;&#x7136;&#x53EF;&#x4EE5;&#x7528; MobiusMobiusMobius &#x53CD;&#x6F14;&#x641E;&#xFF0C;&#x590D;&#x6742;&#x5EA6; O(nln&#x2061;n)O(n\\ln n)O(nlnn) CODE cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly;#define fi first#define se second#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}namespace modular{ const int mod=1e9+7; inline int add(int a,int b){return a+b&lt;mod?a+b:a+b-mod;} inline int dec(int a,int b){return a&lt;b?a-b+mod:a-b;} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Add(int&amp;a,int b){a=a+b&lt;mod?a+b:a+b-mod;} inline void Dec(int&amp;a,int b){a=a&lt;b?a-b+mod:a-b;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p,int md){int ret=1;for(;p;p&gt;&gt;=1,a=(ll)a*a%md)(p&amp;1)&amp;&amp;(ret=(ll)ret*a%md);return ret;}}using namespace modular;const int N=50005,M=1e6+5;int fib[M],pw[M],cnt[M],a[N],mu[M],pri[M],tot=0,mx=0,n,ct[M];bool vs[M];inline void init(){ fib[1]=fib[2]=1; for(ri i=3;i&lt;=mx;++i)fib[i]=add(fib[i-1],fib[i-2]); for(ri i=1;i&lt;=mx;++i)for(ri j=i;j&lt;=mx;j+=i)cnt[i]+=ct[j]; mu[1]=1; for(ri i=2;i&lt;=mx;++i){ if(!vs[i])pri[++tot]=i,mu[i]=mod-2; for(ri j=1,up=mx/i;j&lt;=tot&amp;&amp;pri[j]&lt;=up;++j){ vs[i*pri[j]]=1; if(i==i/pri[j]*pri[j]){ mu[i*pri[j]]=0; break; } mu[i*pri[j]]=mod-1-mu[i]; } }}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(); for(ri i=1;i&lt;=n;++i)a[i]=read(),mx=max(mx,a[i]); sort(a+1,a+n+1),n=unique(a+1,a+n+1)-a-1; for(ri i=1;i&lt;=n;++i)++ct[a[i]]; init(); for(ri i=1;i&lt;=mx;++i)cnt[i]&amp;&amp;(cnt[i]=ksm(2,cnt[i]-1,mod-1)); for(ri i=1;i&lt;=mx;++i)for(ri j=i;j&lt;=mx;j+=i) pw[i]=(pw[i]+(ll)mu[j/i]*cnt[j]%(mod-1))%(mod-1); for(ri i=1;i&lt;=mx;++i)cnt[i]&amp;&amp;(--cnt[i]); for(ri i=1;i&lt;=mx;++i)for(ri j=i;j&lt;=mx;j+=i) pw[i]=(pw[i]-(ll)mu[j/i]*cnt[j]%(mod-1)+(mod-1))%(mod-1); int res=1; for(ri i=1;i&lt;=mx;++i)Mul(res,ksm(fib[i],pw[i],mod)); cout&lt;&lt;res; return 0;} &#x6700;&#x5C0F;&#x516C;&#x500D;&#x4F69;&#x5C14;&#x6570; &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x9996;&#x5148;&#x53EF;&#x4EE5;&#x89E3;&#x51FA;&#x9012;&#x63A8;&#x5F0F; fi=2fi&#x2212;1+fi&#x2212;2f_i=2f_{i-1}+f_{i-2}fi&#x200B;=2fi&#x2212;1&#x200B;+fi&#x2212;2&#x200B; &#xFF0C;&#x8DDF;&#x4E0A;&#x4E00;&#x9053;&#x9898;&#x4E00;&#x6837;&#x53EF;&#x4EE5;&#x63A8;&#x51FA; gcd&#x2061;(fi,fj)=fgcd&#x2061;(i,j)\\gcd(f_i,f_j)=f_{\\gcd(i,j)}gcd(fi&#x200B;,fj&#x200B;)=fgcd(i,j)&#x200B; &#xFF0C;&#x4F46;&#x53D1;&#x73B0;&#x8FD9;&#x9898;&#x6BCF;&#x7EC4;&#x6570;&#x636E;&#x8981;&#x6C42;&#x591A;&#x4E2A;&#x7B54;&#x6848;&#xFF0C;&#x56E0;&#x6B64;&#x4E0A;&#x9053;&#x9898;&#x7684;&#x65B9;&#x6CD5;&#x8C8C;&#x4F3C;&#x5DF2;&#x7ECF;&#x4E0D;&#x9002;&#x7528;&#x4E86;&#xFF0C;&#x6211;&#x4EEC;&#x8003;&#x8651;&#x4E00;&#x79CD;&#x65B0;&#x7684;&#x8F6C;&#x5316;&#xFF1A; lcm(f{S})=&#x220F;T&#x2286;S,T=&#x338;&#x2205;fgcd&#x2061;{T}(&#x2212;1)&#x2223;T&#x2223;+1\\begin{aligned} lcm(f_{\\{S\\}})=\\prod\\limits_{T\\subseteq S,T\\not=\\emptyset}f_{\\gcd\\{T\\}}^{(-1)^{|T|+1}} \\end{aligned} lcm(f{S}&#x200B;)=T&#x2286;S,T&#xE020;&#x200B;=&#x2205;&#x220F;&#x200B;fgcd{T}(&#x2212;1)&#x2223;T&#x2223;+1&#x200B;&#x200B; &#x8003;&#x8651;&#x6784;&#x9020;&#x51FD;&#x6570; g(x)g(x)g(x) &#x6EE1;&#x8DB3; &#x220F;d&#x2223;xg(d)=f(x)\\prod\\limits_{d|x}g(d)=f(x)d&#x2223;x&#x220F;&#x200B;g(d)=f(x) &#xFF0C;&#x53D1;&#x73B0;&#x8FD9;&#x4E2A; g(x)g(x)g(x) &#x5C45;&#x7136;&#x4E5F;&#x80FD; O(nln&#x2061;n)O(n\\ln n)O(nlnn) &#x7684;&#x65F6;&#x95F4;&#x9884;&#x5904;&#x7406;&#x51FA;&#x6765;&#xFF0C;&#x4E14; lcm(f{S})=&#x220F;T&#x2286;S,T=&#x338;&#x2205;(&#x220F;d&#x2223;gcd&#x2061;{T}g(d))(&#x2212;1)&#x2223;T&#x2223;+1=&#x220F;dgd&#x2211;T&#x2286;S,T=&#x338;&#x2205;,d&#x2223;gcd&#x2061;{T}(&#x2212;1)T=&#x220F;dgd\\begin{aligned} lcm(f_{\\{S\\}})=&amp;\\prod\\limits_{T\\subseteq S,T\\not=\\emptyset}(\\prod\\limits_{d|\\gcd{\\{T\\}}}g(d))^{(-1)^{|T|+1}}\\\\ =&amp;\\prod\\limits_{d}g_d^{\\sum\\limits_{T\\subseteq S,T\\not=\\emptyset,d|\\gcd{\\{T\\}}}(-1)^T}\\\\ =&amp;\\prod\\limits_{d}g_d \\end{aligned} lcm(f{S}&#x200B;)===&#x200B;T&#x2286;S,T&#xE020;&#x200B;=&#x2205;&#x220F;&#x200B;(d&#x2223;gcd{T}&#x220F;&#x200B;g(d))(&#x2212;1)&#x2223;T&#x2223;+1d&#x220F;&#x200B;gdT&#x2286;S,T&#xE020;&#x200B;=&#x2205;,d&#x2223;gcd{T}&#x2211;&#x200B;(&#x2212;1)T&#x200B;d&#x220F;&#x200B;gd&#x200B;&#x200B; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly;#define fi first#define se second#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}namespace modular{ int mod; inline int add(int a,int b){return a+b&lt;mod?a+b:a+b-mod;} inline int dec(int a,int b){return a&lt;b?a-b+mod:a-b;} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Add(int&amp;a,int b){a=a+b&lt;mod?a+b:a+b-mod;} inline void Dec(int&amp;a,int b){a=a&lt;b?a-b+mod:a-b;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;} inline int Inv(int a){return ksm(a,mod-2);}}using namespace modular;const int N=1e6+5;int f[N],g[N],n;int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif for(ri tt=read();tt;--tt){ n=read(),mod=read(); f[1]=g[1]=1; for(ri i=2;i&lt;=n;++i)f[i]=g[i]=add(add(f[i-1],f[i-1]),f[i-2]); for(ri t,i=2;i&lt;=n;++i){ t=Inv(g[i]); for(ri j=i+i;j&lt;=n;j+=i)Mul(g[j],t); } int res=0,pre=1; for(ri i=1;i&lt;=n;++i)Mul(pre,g[i]),Add(res,mul(pre,i)); cout&lt;&lt;res&lt;&lt;&apos;\\n&apos;; } return 0;} &#x751F;&#x6210;&#x6811;&#x8BA1;&#x6570; &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x8003;&#x8651; kkk &#x6B21;&#x5E42;&#x7684;&#x7EC4;&#x5408;&#x610F;&#x4E49;&#x53EF;&#x4EE5;&#x7528;&#x751F;&#x6210;&#x51FD;&#x6570;&#x8868;&#x793A;&#xFF0C;&#x90A3;&#x4E48;&#x5BF9;&#x4E8E;&#x6BCF;&#x4E00;&#x6761;&#x8FB9;&#x6784;&#x9020;&#x751F;&#x6210;&#x51FD;&#x6570; ft(x)=&#x2211;i=0+&#x221E;(wtx)ii!f_t(x)=\\sum\\limits_{i=0}^{+\\infty}\\frac{(w_tx)^i}{i!}ft&#x200B;(x)=i=0&#x2211;+&#x221E;&#x200B;i!(wt&#x200B;x)i&#x200B; &#xFF0C;&#x7136;&#x540E;&#x628A;&#x8FD9;&#x4E2A;&#x5F53;&#x6210;&#x5143;&#x7D20;&#x6C42;&#x884C;&#x5217;&#x5F0F;&#x503C;&#x6700;&#x540E;&#x53D6;&#x591A;&#x9879;&#x5F0F;&#x7684;&#x7B2C; KKK &#x9879;&#x7CFB;&#x6570;&#x5373;&#x53EF;&#xFF0C;&#x7136;&#x800C;&#x76F4;&#x63A5;&#x7528;&#x591A;&#x9879;&#x5F0F;&#x6C42;&#x503C;&#x4E0D;&#x662F;&#x5F88;&#x597D;&#x505A;&#xFF0C;&#x56E0;&#x6B64;&#x6211;&#x4EEC;&#x5E26;&#x5165;&#x70B9;&#x503C;&#x8FDB;&#x53BB;&#x7B97;&#x6700;&#x540E;&#x7528;&#x725B;&#x987F;&#x63D2;&#x503C;/&#x62C9;&#x683C;&#x6717;&#x65E5;&#x63D2;&#x503C;&#x628A;&#x7CFB;&#x6570;&#x641E;&#x51FA;&#x6765;&#x5C31;&#x884C;&#x4E86; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_backusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}namespace modular{ const int mod=1e9+7; inline int add(int a,int b){return a+b&lt;mod?a+b:a+b-mod;} inline int dec(int a,int b){return a&lt;b?a-b+mod:a-b;} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Add(int&amp;a,int b){a=a+b&lt;mod?a+b:a+b-mod;} inline void Dec(int&amp;a,int b){a=a&lt;b?a-b+mod:a-b;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;} inline int Inv(int x){return ksm(x,mod-2);} inline int fix(int x){return (x%mod+mod)%mod;}}using namespace modular;const int N=55,M=10005;int n,K,m,w[N][N],a[N][N],f[N],fac[M],ifac[M],inv[M];inline void init(){ fac[0]=ifac[0]=fac[1]=ifac[1]=inv[1]=1; for(ri i=2;i&lt;=10000;++i){ fac[i]=mul(fac[i-1],i); inv[i]=mul(inv[mod-mod/i*i],mod-mod/i); ifac[i]=mul(ifac[i-1],inv[i]); }}inline int calc(){ int res=1; for(ri ps,i=1;i&lt;n;++i){ for(ps=i;ps&lt;=n;++ps)if(a[ps][i]){ ps=i; break; } if(ps==n+1)return 0; if(ps^i){ for(ri j=1;j&lt;=n;++j)swap(a[ps][j],a[i][j]); res=res?mod-res:0; } for(ri j=1,t,iv=Inv(a[i][i]);j&lt;=n;++j)if(j!=i&amp;&amp;a[j][i]){ t=mul(a[j][i],iv); for(ri k=i;k&lt;=n;++k)Dec(a[j][k],mul(t,a[i][k])); } Mul(res,a[i][i]); } return res;}struct Newton_Inter{ int up,px[M],py[M],cur,dt[2][M],f[M],ff[M]; Newton_Inter(){up=cur=0;} inline int&amp;operator[](const int&amp;k){return f[k];} inline const int&amp;operator[](const int&amp;k)const{return f[k];} inline void insert(int x,int y){ px[++up]=x,py[up]=y; if(up==1)dt[cur][0]=f[0]=y,ff[0]=1; else{ cur^=1,dt[cur][0]=y; for(ri i=1;i&lt;up;++i)dt[cur][i]=mul(dec(dt[cur][i-1],dt[!cur][i-1]),inv[px[up]-px[up-i]]); for(ri i=up-1;~i;--i)ff[i]=add(i?ff[i-1]:0,mul(mod-px[up-1],ff[i])); for(ri i=0;i&lt;up;++i)Add(f[i],mul(ff[i],dt[cur][up-1])); } }}F;int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(),K=read(); init(); for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=n;++j)w[i][j]=read(); m=n*K; for(ri t=0;t&lt;=m;++t){ for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=n;++j)a[i][j]=0; for(ri res,i=1;i&lt;=n;++i)for(ri j=1;j&lt;i;++j){ res=0; for(ri mt=1,_t=mul(t,w[i][j]),_pw=0;_pw&lt;=K;++_pw){ Add(res,mul(mt,ifac[_pw])); Mul(mt,_t); } Add(a[i][i],res); Add(a[j][j],res); Dec(a[i][j],res); Dec(a[j][i],res); } F.insert(t,calc()); } cout&lt;&lt;mul(F[K],fac[K]); return 0;} Mike and Fish &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x8003;&#x8651;&#x5C06;&#x884C;&#x5217;&#x626F;&#x51FA;&#x6765;&#x5EFA;&#x4E8C;&#x5206;&#x56FE;&#xFF0C;&#x7136;&#x540E;&#x5C06;&#x9650;&#x5236;&#x6539;&#x4E3A; black=whiteblack=whiteblack=white &#x4E14;&#x4FDD;&#x8BC1;&#x5408;&#x6CD5;&#x600E;&#x4E48;&#x505A;&#xFF0C;&#x53D1;&#x73B0;&#x53EA;&#x7528;&#x5728;&#x4E8C;&#x5206;&#x56FE;&#x4E0A;&#x8DD1;&#x6B27;&#x62C9;&#x56DE;&#x8DEF;&#x5373;&#x53EF;&#xFF0C;&#x90A3;&#x4E48;&#x73B0;&#x5728;&#x53EF;&#x80FD;&#x6709;&#x5EA6;&#x6570;&#x4E3A;&#x5947;&#x6570;&#x7684;&#x70B9;&#xFF0C;&#x6211;&#x4EEC;&#x5728;&#x4E24;&#x8FB9;&#x5404;&#x5EFA;&#x4E00;&#x4E2A;&#x865A;&#x70B9;&#x5904;&#x7406;&#x5373;&#x53EF; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_backusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}const int N=4e5+5;int n,idx=0;bool col[N],vs[N];pii a[N];vector&lt;pii&gt;e[N];void dfs(int p){ pii tmp; while((int)e[p].size()){ tmp=e[p].back(); e[p].pop_back(); if(vs[tmp.se])continue; vs[tmp.se]=1; col[tmp.se]=p&lt;tmp.fi; dfs(tmp.fi); }}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(); for(ri i=1;i&lt;=n;++i){ a[i].fi=read(); a[i].se=read()+200000; ++idx; e[a[i].fi].pb(pii(a[i].se,idx)); e[a[i].se].pb(pii(a[i].fi,idx)); } for(ri i=1;i&lt;=400000;++i){ if(((int)e[i].size())&amp;1){ ++idx; e[i].pb(pii(400001,idx)); e[400001].pb(pii(i,idx)); } } for(ri i=1;i&lt;=400001;++i)dfs(i); for(ri i=1;i&lt;=n;++i)cout&lt;&lt;(col[i]?&apos;r&apos;:&apos;b&apos;); return 0;} XOR Replace &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x8BBE; an+1=&#x2295;i=1naia_{n+1}=\\oplus_{i=1}^na_ian+1&#x200B;=&#x2295;i=1n&#x200B;ai&#x200B; &#xFF0C;&#x4ED4;&#x7EC6;&#x89C2;&#x5BDF;&#x53D1;&#x73B0;&#x6BCF;&#x6B21;&#x64CD;&#x4F5C;&#x76F8;&#x5F53;&#x4E8E; swap(ai,an+1)swap(a_i,a_{n+1})swap(ai&#x200B;,an+1&#x200B;) &#xFF0C;&#x90A3;&#x4E48;&#x6211;&#x4EEC;&#x5C06;&#x4E0D;&#x540C;&#x7684; (ai,bi)(a_i,b_i)(ai&#x200B;,bi&#x200B;) &#x8FDE;&#x8FB9;&#xFF0C;&#x6700;&#x540E;&#x6309;&#x7167;&#x8FDE;&#x901A;&#x5757;&#x6570;&#x8BA8;&#x8BBA;&#x5373;&#x53EF;&#x5F97;&#x5230;&#x7B54;&#x6848;&#xFF0C;&#x5927;&#x6982;&#x5C31;&#x662F;&#x8054;&#x901A;&#x5757;&#x5185;&#x6309;&#x7167;&#x7F6E;&#x6362;&#x7684;&#x65B9;&#x5F0F;&#x4E00;&#x5B9A;&#x53EF;&#x4EE5;&#x7528;&#x8FDE;&#x901A;&#x5757;&#x5927;&#x5C0F;&#x6570;&#x6B21;&#x6362;&#x5B8C;&#xFF0C;&#x4E24;&#x4E2A;&#x8FDE;&#x901A;&#x5757;&#x4E4B;&#x95F4;&#x9700;&#x8981;&#x7528;&#x4E00;&#x6B21;&#x6765;&#x8FDB;&#x884C;&#x8F6C;&#x6362; CODE cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_backusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}const int N=4e5+5;int n,a[N],b[N],_a[N],_b[N];inline bool check(){ for(ri i=1;i&lt;=n+1;++i)_a[i]=a[i],_b[i]=b[i]; sort(_a+1,_a+n+2); sort(_b+1,_b+n+2); for(ri i=1;i&lt;=n+1;++i)if(_a[i]^_b[i])return 0; return 1;}int vl[N&lt;&lt;1],sig=0;inline int Find(int x){return lower_bound(vl+1,vl+sig+1,x)-vl;}int ft[N&lt;&lt;1];inline int find(int x){return x^ft[x]?ft[x]=find(ft[x]):x;}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(); for(ri i=1;i&lt;=n;++i)a[n+1]^=(a[i]=read()); for(ri i=1;i&lt;=n;++i)b[n+1]^=(b[i]=read()); if(!check()){ cout&lt;&lt;-1; return 0; } int res=0; vl[++sig]=a[n+1]; vl[++sig]=b[n+1]; for(ri i=1;i&lt;=n;++i){ if(a[i]==b[i])continue; vl[++sig]=a[i]; vl[++sig]=b[i]; ++res; } if(!res){ cout&lt;&lt;0; return 0; } sort(vl+1,vl+sig+1),sig=unique(vl+1,vl+sig+1)-vl-1; for(ri i=1;i&lt;=sig;++i)ft[i]=i; for(ri i=1;i&lt;=n+1;++i){ if(a[i]==b[i])continue; a[i]=find(Find(a[i])); b[i]=find(Find(b[i])); if(a[i]^b[i])ft[b[i]]=a[i]; } for(ri i=1;i&lt;=sig;++i)if(ft[i]==i)++res; cout&lt;&lt;res-1; return 0;} Two Trees &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x80FD;&#x5426;&#x6784;&#x9020;&#x53EA;&#x9700;&#x8003;&#x8651;&#x540C;&#x4E00;&#x4E2A;&#x70B9;&#x5728;&#x4E24;&#x68F5;&#x6811;&#x4E2D;&#x513F;&#x5B50;&#x6570;&#x7684;&#x5947;&#x5076;&#x6027;&#x662F;&#x5426;&#x76F8;&#x540C;&#xFF0C;&#x4E0B;&#x9762;&#x7ED9;&#x51FA;&#x76F8;&#x540C;&#x65F6;&#x7684;&#x6784;&#x9020;&#x65B9;&#x6848; &#x9996;&#x5148;&#x4E00;&#x68F5;&#x6811;&#x4E2D;&#x4E00;&#x5B9A;&#x6709;&#x5947;&#x6570;&#x4E2A;&#x503C;&#x4E3A;&#x5947;&#x6570;&#x7684;&#x70B9;&#xFF0C;&#x4E0D;&#x59A8;&#x8BBE;&#x4E3A; 2k+12k+12k+1 &#x4E2A;&#xFF0C;&#x8003;&#x8651;&#x8BA9;&#x5176;&#x4E2D; 2k2k2k &#x4E2A;&#x4E24;&#x4E24;&#x914D;&#x5BF9;&#x4E00;&#x4E2A; 111 &#x4E00;&#x4E2A; &#x2212;1-1&#x2212;1 &#xFF0C;&#x5269;&#x4E0B;&#x4E00;&#x4E2A;&#x968F;&#x610F; 111 &#x6216;&#x8005; &#x2212;1-1&#x2212;1 &#x5C31;&#x80FD;&#x4FDD;&#x8BC1;&#x8FD9;&#x4E2A;&#x5B50;&#x6811;&#x7684;&#x6743;&#x503C;&#x548C;&#x7EDD;&#x5BF9;&#x503C;&#x4E3A; 111 &#xFF0C;&#x90A3;&#x4E48;&#x8003;&#x8651;&#x600E;&#x4E48;&#x9650;&#x5236; 111 &#x548C; &#x2212;1-1&#x2212;1 &#x5339;&#x914D;&#x7684;&#x5173;&#x7CFB;&#xFF1A;&#x53EF;&#x4EE5;&#x5C06;&#x5F53;&#x524D;&#x672A;&#x5339;&#x914D;&#x4E14;&#x513F;&#x5B50;&#x6570;&#x4E3A;&#x5076;&#x6570;&#x7684;&#x70B9;&#x653E;&#x5230;&#x4E00;&#x4E2A;&#x5E8F;&#x5217;&#x4E2D;&#x7136;&#x540E;&#x6BCF;&#x4E24;&#x4E2A;&#x8FDE;&#x4E00;&#x6761;&#x8FB9;&#xFF0C;&#x8FD9;&#x6837;&#x4E24;&#x68F5;&#x6811;&#x90FD;&#x8FDE;&#x597D;&#x540E;&#x4E00;&#x5B9A;&#x641E;&#x51FA;&#x6765;&#x4E00;&#x4E2A;&#x4E8C;&#x5206;&#x56FE;&#xFF0C;&#x4E8C;&#x5206;&#x56FE;&#x67D3;&#x8272;&#x5373;&#x53EF; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_backusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch==&apos;-&apos;,ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;}const int N=1e5+5;int n,ans[N];vector&lt;int&gt;e[N];struct Tree{ vector&lt;int&gt;g[N]; int rt,stk[N],top; void dfs(int p){ for(ri i=0,v;i&lt;g[p].size();++i)dfs(v=g[p][i]); if(!(((int)g[p].size())&amp;1))stk[++top]=p; while(top&gt;1){ e[stk[top]].pb(stk[top-1]); e[stk[top-1]].pb(stk[top]); top-=2; } } inline void init(){ for(ri ft,i=1;i&lt;=n;++i){ ft=read(); if(ft==-1)rt=i; else g[ft].pb(i); } } inline void solve(){ top=0; dfs(rt); }}t[2];bool vs[N],col[N];void dfs(int p,int cl){ if(vs[p])return; vs[p]=1; col[p]=cl; for(ri i=0;i&lt;e[p].size();++i)dfs(e[p][i],cl^1);}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(); for(ri i=0;i&lt;2;++i)t[i].init(); for(ri i=1;i&lt;=n;++i)if(((int)t[0].g[i].size()+(int)t[1].g[i].size())&amp;1){ puts(&quot;IMPOSSIBLE&quot;); return 0; } puts(&quot;POSSIBLE&quot;); for(ri i=0;i&lt;2;++i)t[i].solve(); for(ri i=1;i&lt;=n;++i)dfs(i,0); for(ri i=1;i&lt;=n;++i)cout&lt;&lt;((((int)t[0].g[i].size())&amp;1)?0:(col[i]?1:-1))&lt;&lt;&apos; &apos;; return 0;}","categories":[{"name":"public","slug":"public","permalink":"http://xdl030112.github.io/categories/public/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://xdl030112.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"杂题乱做 Round7","slug":"sol7","date":"2019-11-18T03:35:12.000Z","updated":"2019-12-26T04:26:08.642Z","comments":true,"path":"sol7/","link":"","permalink":"http://xdl030112.github.io/sol7/","excerpt":"","text":"Sockpuppets &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x8003;&#x8651;&#x5230;&#x9898;&#x76EE;&#x7684;&#x5339;&#x914D;&#x6761;&#x4EF6;&#x663E;&#x7136;&#x9700;&#x8981;&#x5EFA;&#x4E00;&#x68F5; trietrietrie &#x6811;&#x51FA;&#x6765;&#xFF0C;&#x6CE8;&#x610F;&#x5230;&#x8FD9;&#x68F5;&#x6811;&#x6DF1;&#x5EA6;&#x4E0D;&#x8D85;&#x8FC7; 101010 &#xFF0C;&#x8003;&#x8651;&#x8BBE; fi,j,kf_{i,j,k}fi,j,k&#x200B; &#x8868;&#x793A;&#x5F53;&#x524D;&#x5904;&#x7406;&#x5230;&#x5B50;&#x6811; iii &#xFF0C;&#x5B50;&#x6811;&#x4E2D;&#x6709; jjj &#x4E2A;&#x70B9;&#x9700;&#x8981;&#x8FDB;&#x884C;&#x5339;&#x914D;&#xFF0C;&#x81EA;&#x5DF1;&#x7684;&#x7956;&#x5148;&#x5DF2;&#x7ECF;&#x6709; kkk &#x4E2A;&#x88AB;&#x63D0;&#x524D;&#x9009;&#x7528;&#x5339;&#x914D;&#x7684;&#x65B9;&#x6848;&#x6570;&#xFF0C;&#x7136;&#x540E;&#x6309;&#x7167;&#x5F53;&#x524D;&#x70B9;&#x7684;&#x7C7B;&#x578B;&#x5206;&#x5F00;&#x8F6C;&#x79FB;&#x5373;&#x53EF; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;typedef double db;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;typedef pair&lt;ll,ll&gt; pll;typedef unsigned long long Ull;typedef unsigned int uii;typedef double db;typedef long double ld;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch==&apos;-&apos;,ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;}inline ll readl(){ ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s){ int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;}namespace modular{ const int mod=1e9+7; inline int add(int a,int b){return a+b&lt;mod?a+b:a+b-mod;} inline int dec(int a,int b){return a&lt;b?a-b+mod:a-b;} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Add(int&amp;a,int b){a=a+b&lt;mod?a+b:a+b-mod;} inline void Dec(int&amp;a,int b){a=a&lt;b?a-b+mod:a-b;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;} inline int Inv(int a){return ksm(a,mod-2);} inline void fix(int&amp;a){a=(a%mod+mod)%mod;}}using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b){a&gt;b?a=b:0;}template&lt;typename T&gt;inline void ckmax(T&amp;a,T b){a&lt;b?a=b:0;}const int N=20005;int f[N][15][25],tmp[15][25],n,m;inline int calc1(int x){return x&lt;2?1:mod+1&gt;&gt;1;}inline int calc2(int x,int y){ if(!x)return 1; if(x==1)return y; return (ll)y*(y-1)/2%mod;}namespace trie{ int tot,son[N][26],cnt1[N],cnt2[N]; inline int newnode(){ ++tot; memset(son[tot],0,sizeof(son[tot])); cnt1[tot]=cnt2[tot]=0; return tot; } inline void insert(char*s,int len,int c1,int c2){ int p=0; for(ri x,i=1;i&lt;=len;++i){ x=s[i]-&apos;a&apos;; if(!son[p][x])son[p][x]=newnode(); p=son[p][x]; } cnt1[p]+=c1,cnt2[p]+=c2; } void dfs(int p){ for(ri i=0;i&lt;=10;++i)for(ri j=0;j&lt;=20;++j)f[p][i][j]=0; f[p][0][0]=1; for(ri v,s=0;s&lt;26;++s)if(son[p][s]){ dfs(v=son[p][s]); for(ri i=0;i&lt;=10;++i)for(ri j=0;j&lt;=20;++j)if(f[p][i][j]) for(ri k=0;k+i&lt;=10;++k)for(ri l=0;j+l&lt;=20;++l)if(f[v][k][l]) Add(tmp[i+k][j+l],mul(f[p][i][j],f[v][k][l])); for(ri i=0;i&lt;=10;++i)for(ri j=0;j&lt;=20;++j){ f[p][i][j]=tmp[i][j]; tmp[i][j]=0; } } if(!cnt1[p]&amp;&amp;!cnt2[p])return; for(ri i=0;i&lt;=10;++i)for(ri j=0;j&lt;=20;++j)if(f[p][i][j]){ if(cnt1[p]){ for(ri k=0;k&lt;=2;++k)for(ri l=0;l&lt;=2;++l) if(k+l&gt;0&amp;&amp;k+l&lt;3&amp;&amp;i+k&lt;=10&amp;&amp;j&gt;=l)Add(tmp[i+k][j-l],mul(f[p][i][j],mul(calc1(k),calc2(l,j)))); } else{ if(i)Add(tmp[i-1][j],mul(i,f[p][i][j])); if(j&lt;20)Add(tmp[i][j+1],f[p][i][j]); } } for(ri i=0;i&lt;=10;++i)for(ri j=0;j&lt;=20;++j){ Add(f[p][i][j],tmp[i][j]); tmp[i][j]=0; } }}char s[15];int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif for(ri tt=read(),cas=1;cas&lt;=tt;++cas){ printf(&quot;Case #%d: &quot;,cas); n=read(),m=read(); trie::tot=0; memset(trie::son[0],0,sizeof(trie::son[0])); for(ri i=1,len;i&lt;=n;++i){ len=Read(s); trie::insert(s,len,1,0); } for(ri i=1,len;i&lt;=m;++i){ len=Read(s); trie::insert(s,len,0,1); } trie::dfs(0); cout&lt;&lt;f[0][0][0]&lt;&lt;&apos;\\n&apos;; } return 0;} Drazil and Morning Exercise &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x6211;&#x5199;&#x7684;&#x662F;&#x81EA;&#x5DF1;&#x60F3;&#x7684;&#x4E00;&#x4E2A;&#x5783;&#x573E; O(Tnlog&#x2061;n)O(Tn\\log n)O(Tnlogn) &#x770B;&#x4E86;&#x4E00;&#x4E0B; mayaohuamayaohuamayaohua &#x795E;&#x4ED9;&#x7684; blogblogblog &#x8C8C;&#x4F3C;&#x80FD;&#x7528;&#x5E76;&#x67E5;&#x96C6;&#x4F18;&#x5316;&#x5230; O(Tn&#x3B1;(n))O(Tn\\alpha(n))O(Tn&#x3B1;(n)) &#xFF0C;&#x9996;&#x5148;&#x9884;&#x5904;&#x7406;&#x51FA;&#x6BCF;&#x4E2A;&#x70B9;&#x5230;&#x5176;&#x6700;&#x8FDC;&#x70B9;&#x7684;&#x8DDD;&#x79BB;&#xFF0C;&#x7136;&#x540E;&#x53D1;&#x73B0;&#x82E5;&#x5BF9;&#x4E8E;&#x4E24;&#x4E2A;&#x70B9; (u,v)(u,v)(u,v) &#x6309;&#x7167;&#x5176;&#x8DDD;&#x79BB;&#x4ECE;&#x5927;&#x7684;&#x5F80;&#x5C0F;&#x7684;&#x8FDE;&#x8FB9;&#x4F1A;&#x8FDE;&#x51FA;&#x6765;&#x4E00;&#x68F5;&#x5185;&#x5411;&#x6811;&#xFF0C;&#x4E14;&#x5BF9;&#x4E8E;&#x8FD9;&#x68F5;&#x6811;&#x6BCF;&#x4E2A;&#x70B9;&#x7684;&#x5408;&#x6CD5;&#x8303;&#x56F4;&#x4E00;&#x5B9A;&#x662F;&#x4E00;&#x4E2A;&#x4EE5;&#x5176;&#x4E3A;&#x6839;&#x7684;&#x8FDE;&#x901A;&#x5757;&#xFF0C;&#x90A3;&#x4E48;&#x7528;&#x4E2A;&#x79BB;&#x6563;&#x5316;+ dfsdfsdfs &#x5E8F;+&#x4E3B;&#x5E2D;&#x6811;&#x5C31;&#x53EF;&#x4EE5;&#x6C42;&#x5B50;&#x6811;&#x5185;&#x6BD4;&#x67D0;&#x4E2A;&#x6570;&#x5C0F;&#x7684;&#x70B9;&#x6570; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;typedef double db;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;typedef pair&lt;ll,ll&gt; pll;typedef unsigned long long Ull;typedef unsigned int uii;typedef double db;typedef long double ld;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch==&apos;-&apos;,ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;}inline ll readl(){ ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s){ int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;}namespace modular{ const int mod=1e9+7; inline int add(int a,int b){return a+b&lt;mod?a+b:a+b-mod;} inline int dec(int a,int b){return a&lt;b?a-b+mod:a-b;} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Add(int&amp;a,int b){a=a+b&lt;mod?a+b:a+b-mod;} inline void Dec(int&amp;a,int b){a=a&lt;b?a-b+mod:a-b;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;} inline int Inv(int a){return ksm(a,mod-2);} inline void fix(int&amp;a){a=(a%mod+mod)%mod;}}using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b){a&gt;b?a=b:0;}template&lt;typename T&gt;inline void ckmax(T&amp;a,T b){a&lt;b?a=b:0;}char xxx;const int N=1e5+5;vector&lt;pii&gt;e[N];int n,sig=0,rt[N];ll f[N],_f[N],g[N],vl[N],a[N];inline int find(ll x){return lower_bound(vl+1,vl+sig+1,x)-vl;}void dfs1(int p,int ft){ for(ri i=0,v;i&lt;e[p].size();++i){ if((v=e[p][i].fi)==ft)continue; dfs1(v,p); if(f[v]+e[p][i].se&gt;=f[p]){ _f[p]=f[p]; f[p]=f[v]+e[p][i].se; } else ckmax(_f[p],f[v]+e[p][i].se); }}void dfs2(int p,int ft){ for(ri i=0,v;i&lt;e[p].size();++i){ if((v=e[p][i].fi)==ft)continue; g[v]=max(g[p],f[v]+e[p][i].se==f[p]?_f[p]:f[p])+e[p][i].se; dfs2(v,p); }}int in[N],out[N],pred[N],tot=0,ps[N];void dfs(int p,int ft){ pred[in[p]=++tot]=p; for(ri i=0,v;i&lt;e[p].size();++i){ if((v=e[p][i].fi)==ft)continue; dfs(v,p); } out[p]=tot;}namespace sgt{ #define lc (son[p][0]) #define rc (son[p][1]) #define mid (l+r&gt;&gt;1) int siz[N*100],son[N*100][2],cnt=0; inline void update(int&amp;p,int o,int l,int r,int k){ p=++cnt; siz[p]=siz[o]+1,lc=son[o][0],rc=son[o][1]; if(l==r)return; k&lt;=mid?update(lc,lc,l,mid,k):update(rc,rc,mid+1,r,k); } inline int query(int a,int b,int l,int r,int ql,int qr){ if(siz[a]==siz[b])return 0; if(ql&lt;=l&amp;&amp;r&lt;=qr)return siz[b]-siz[a]; if(qr&lt;=mid)return query(son[a][0],son[b][0],l,mid,ql,qr); if(ql&gt;mid)return query(son[a][1],son[b][1],mid+1,r,ql,qr); return query(son[a][0],son[b][0],l,mid,ql,qr)+query(son[a][1],son[b][1],mid+1,r,ql,qr); } #undef lc #undef rc #undef mid}char yyy;int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); cerr&lt;&lt;(&amp;yyy-&amp;xxx)/1024/1024&lt;&lt;&quot;ldxcaicai\\n&quot;; #endif n=read(); for(ri i=1,u,v,w;i&lt;n;++i){ u=read(),v=read(),w=read(); e[u].pb(pii(v,w)); e[v].pb(pii(u,w)); } dfs1(1,0); dfs2(1,0); for(ri i=1;i&lt;=n;++i)vl[i]=a[i]=max(f[i],g[i]); sort(vl+1,vl+n+1),sig=unique(vl+1,vl+n+1)-vl-1; for(ri i=1;i&lt;=n;++i)a[i]=find(a[i]); int _rt=1; for(ri i=2;i&lt;=n;++i)if(a[i]&lt;a[_rt])_rt=i; dfs(_rt,0); for(ri i=1;i&lt;=n;++i)sgt::update(rt[i],rt[i-1],1,sig,a[pred[i]]); for(ri tt=read();tt;--tt){ ll x=readl(); for(ri l=1,r=0;l&lt;=sig;++l){ while(r&lt;sig&amp;&amp;vl[r+1]-vl[l]&lt;=x)++r; ps[l]=r; } int res=0; for(ri L,R,i=1;i&lt;=n;++i){ ckmax(res,sgt::query(rt[in[i]-1],rt[out[i]],1,sig,a[i],ps[a[i]])); } cout&lt;&lt;res&lt;&lt;&apos;\\n&apos;; } return 0;} Numbers on the blackboard &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x8FD9;&#x9898;&#x6BD4;&#x8F83;&#x6709;&#x610F;&#x601D;&#xFF0C;&#x8003;&#x8651;&#x79BB;&#x7EBF;&#x4E0B;&#x6240;&#x6709;&#x8BE2;&#x95EE;&#x5C06;&#x5176;&#x653E;&#x5728;&#x5176;&#x53F3;&#x7AEF;&#x70B9;&#x5904;&#xFF0C;&#x540C;&#x65F6;&#x7528;&#x589E;&#x91CF;&#x6CD5;&#x6784;&#x9020;&#x4E00;&#x4E9B;&#x7EC4;&#xFF0C;&#x6700;&#x540E;&#x4ECE;&#x5DE6;&#x5411;&#x53F3;&#x5408;&#x5E76;&#x6BCF;&#x4E2A;&#x7EC4;&#xFF0C;&#x800C;&#x7EC4;&#x5185;&#x5219;&#x4ECE;&#x53F3;&#x5411;&#x5DE6;&#x5408;&#x5E76;&#x3002; &#x8003;&#x8651;&#x5982;&#x4F55;&#x5206;&#x7EC4;&#x6700;&#x4F18;&#xFF0C;&#x5982;&#x679C;&#x4E00;&#x4E2A;&#x7EC4;&#x7684;&#x6240;&#x6709;&#x6570;&#x4ECE;&#x53F3;&#x5411;&#x5DE6;&#x7684;&#x7D2F;&#x52A0;&#x548C;&#x5927;&#x4E8E; 000 &#x5C31;&#x8DDF;&#x524D;&#x4E00;&#x4E2A;&#x7EC4;&#x8FDB;&#x884C;&#x5408;&#x5E76;&#xFF0C;&#x5426;&#x5219;&#x5C31;&#x4E0D;&#x5408;&#x5E76;&#xFF0C;&#x8FD9;&#x4E2A;&#x53EF;&#x4EE5;&#x7528;&#x5E76;&#x67E5;&#x96C6;&#x968F;&#x4FBF;&#x7EF4;&#x62A4;&#x4E00;&#x4E0B;&#x7136;&#x540E;&#x5C31;&#x505A;&#x5B8C;&#x4E86; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std; //MoBannamespace MoBan{//Typetypedef long long ll;typedef double db;typedef long double ld;typedef unsigned long long Ull;typedef unsigned int uii;typedef const int csi; // Pairtypedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,ll&gt; pll;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;#define fi first#define se second //Vectortypedef vector&lt;int&gt; vi;typedef vector&lt;pii&gt; vii;typedef vector&lt;pll&gt; vll;typedef vector&lt;pli&gt; vli;typedef vector&lt;pil&gt; vil;#define pb push_back //Maptypedef map&lt;int,int&gt; mii;typedef map&lt;ll,int&gt; mli;typedef map&lt;int,bool&gt; mbi; //Settypedef set&lt;int&gt; si;typedef set&lt;pii&gt; sii;typedef set&lt;pli&gt; sli;typedef set&lt;pil&gt; sil;typedef set&lt;pll&gt; sll;#define ins insert#define del erase const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++) //Inputinline int read(){ bool f=1; int ans=0; char ch=gc(); while(!isdigit(ch))f^=ch==&apos;-&apos;,ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;}inline ll readl(){ ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s){ int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;} //Fileinline void file(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); freopen(&quot;lx.out&quot;,&quot;w&quot;,stdout); #endif} //Functionstemplate&lt;typename T&gt;inline void ckmax(T&amp;a,T b){a&lt;b?a=b:0;}template&lt;typename T&gt;inline void ckmin(T&amp;a,T b){a&gt;b?a=b:0;}}using namespace MoBan; //Modularnamespace modular{ const int mod=1e9+7; inline int add(int a,int b){return a+b&lt;mod?a+b:a+b-mod;} inline int dec(int a,int b){return a&lt;b?a-b+mod:a-b;} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Add(int&amp;a,int b){a=a+b&lt;mod?a+b:a+b-mod;} inline void Dec(int&amp;a,int b){a=a&lt;b?a-b+mod:a-b;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;} inline int Inv(csi&amp;a){return ksm(a,mod-2);} inline int fix(csi&amp;a){return (a%mod+mod)%mod;}}using namespace modular; //My solconst int N=5e5+5,inf=1e9+7;int n,a[N],ft[N],m,ans[N],sum[N],idx[N],vl[N],pre[N],top=0,pw[N],ipw[N],ss[N];pii stk[N];vector&lt;pii&gt;qry[N];inline int find(int x){return ft[x]^x?ft[x]=find(ft[x]):x;}inline int calc(int l,int r){return mul(ipw[l],dec(ss[r],ss[l-1]));} //Mainsigned main(){ file(); n=read(),m=read(); pw[0]=ipw[0]=1; for(ri i=1;i&lt;=n;++i){ a[i]=read(),ft[i]=i; pw[i]=add(pw[i-1],pw[i-1]); ipw[i]=mul(ipw[i-1],mod+1&gt;&gt;1); } for(ri i=1,l,r;i&lt;=m;++i){ l=read(),r=read(); qry[r].pb(pii(l,i)); } for(ri i=1;i&lt;=n;++i){ ss[i]=add(ss[i-1],mul(pw[i],fix(a[i]))); idx[i]=++top; stk[top]=pii(i,i); sum[top]=a[i]; vl[top]=fix(a[i]); while(top&gt;1&amp;&amp;sum[top]&gt;0){ int fx=find(stk[top].fi),fy=find(stk[top-1].fi); ft[fx]=fy; if(stk[top-1].se-stk[top-1].fi+1&gt;=30||sum[top]==inf||sum[top-1]==inf)sum[top-1]=inf; else sum[top-1]=min((ll)inf,(((ll)sum[top])&lt;&lt;(stk[top-1].se-stk[top-1].fi+1))+sum[top-1]); vl[top-1]=add(mul(pw[stk[top-1].se-stk[top-1].fi+1],vl[top]),vl[top-1]); stk[top-1].se=stk[top].se; --top; } pre[top]=add(pre[top-1],vl[top]); for(ri res=0,j=0,l,r,L,R,id;j&lt;qry[i].size();++j){ l=qry[i][j].fi,r=i,id=qry[i][j].se; L=idx[find(l)],R=idx[find(r)]; ans[id]=add(calc(l,stk[L].se),mul(2,dec(pre[R],pre[L]))); } } for(ri i=1;i&lt;=m;++i)cout&lt;&lt;ans[i]&lt;&lt;&apos;\\n&apos;; return 0;} &#x4E3B;&#x65CB;&#x5F8B; &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x6BD4;&#x8F83;&#x5957;&#x8DEF;&#x7684;&#x4E00;&#x9053;&#x9898;&#xFF0C;&#x8003;&#x8651;&#x8FD9;&#x79CD; DAGDAGDAG &#x8BA1;&#x6570;&#x90FD;&#x662F;&#x5220;&#x53BB;&#x5165;&#x5EA6;&#x6216;&#x8005;&#x51FA;&#x5EA6;&#x4E3A; 000 &#x7684;&#x70B9;&#xFF0C;&#x7136;&#x540E;&#x679A;&#x4E3E;&#x5B50;&#x96C6;&#x8865;&#x96C6;&#x8F6C;&#x5316;&#x8F6C;&#x79FB;&#x5373;&#x53EF;&#xFF0C;&#x5173;&#x4E8E;&#x8FD9;&#x9053;&#x9898;&#xFF0C;&#x5B9A;&#x4E49; fsf_sfs&#x200B; &#x8868;&#x793A;&#x96C6;&#x5408; sss &#x5408;&#x6CD5;&#x65B9;&#x6848;&#x6570;&#xFF0C; gsg_sgs&#x200B; &#x8868;&#x793A;&#x96C6;&#x5408; sss &#x7531;&#x82E5;&#x5E72;&#x5F3A;&#x8FDE;&#x901A;&#x5206;&#x91CF;&#x62FC;&#x63A5;&#x800C;&#x6210;&#x7684;&#x65B9;&#x6848;&#x6570;&#xFF0C; sumssum_ssums&#x200B; &#x8868;&#x793A;&#x96C6;&#x5408; sss &#x4E2D;&#x7684;&#x8FB9;&#x6570;&#xFF0C; coes,tcoe_{s,t}coes,t&#x200B; &#x8868;&#x793A;&#x96C6;&#x5408; sss &#x4E2D;&#x5B50;&#x96C6; ttt &#x7684;&#x51FA;&#x5EA6;&#x4E3A; 000 &#x7684;&#x65B9;&#x6848;&#x6570;&#xFF0C;&#x5BF9;&#x4E8E; gsg_sgs&#x200B; &#xFF0C;&#x6211;&#x4EEC;&#x5148;&#x4E0D;&#x628A; fsf_sfs&#x200B; &#x7B97;&#x5165;&#x5176;&#x4E2D;&#xFF0C;&#x8FD9;&#x6837;&#x5C31;&#x6709; fs=2sums&#x2212;&#x2211;T&#x2282;SgTcoeS,Tf_s=2^{sum_s}-\\sum\\limits_{T\\subset S}g_Tcoe_{S,T}fs&#x200B;=2sums&#x200B;&#x2212;T&#x2282;S&#x2211;&#x200B;gT&#x200B;coeS,T&#x200B; &#xFF0C;&#x663E;&#x7136; coecoecoe &#x662F;&#x5F88;&#x597D;&#x5904;&#x7406;&#x7684;&#xFF0C;&#x95EE;&#x9898;&#x8F6C;&#x5316;&#x4E3A;&#x6C42; ggg &#xFF0C;&#x5BF9;&#x4E8E; ggg &#x6211;&#x4EEC;&#x679A;&#x4E3E;&#x5176;&#x6700;&#x5C0F;&#x6807;&#x53F7;&#x6240;&#x5728;&#x7684;&#x8FDE;&#x901A;&#x5757;&#x7136;&#x540E;&#x5C31;&#x53EF;&#x4EE5;&#x8F6C;&#x79FB;&#x4E86; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;//MoBannamespace MoBan{//Typetypedef long long ll;typedef double db;typedef long double ld;typedef unsigned long long Ull;typedef unsigned int uii;typedef const int csi;// Pairtypedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,ll&gt; pll;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;#define fi first#define se second//Vectortypedef vector&lt;int&gt; vi;typedef vector&lt;pii&gt; vii;typedef vector&lt;pll&gt; vll;typedef vector&lt;pli&gt; vli;typedef vector&lt;pil&gt; vil;#define pb push_back//Maptypedef map&lt;int,int&gt; mii;typedef map&lt;ll,int&gt; mli;typedef map&lt;int,bool&gt; mbi;//Settypedef set&lt;int&gt; si;typedef set&lt;pii&gt; sii;typedef set&lt;pli&gt; sli;typedef set&lt;pil&gt; sil;typedef set&lt;pll&gt; sll;#define ins insert#define del eraseconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)//Inputinline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline ll readl(){ ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s){ int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;}//Fileinline void file(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #else #ifndef ONLINE_JUDGE freopen(&quot;a.in&quot;,&quot;r&quot;,stdin); freopen(&quot;a.out&quot;,&quot;w&quot;,stdout); #endif #endif}//Functionstemplate&lt;typename T&gt;inline void ckmax(T&amp;a,T b){a&lt;b?a=b:0;}template&lt;typename T&gt;inline void ckmin(T&amp;a,T b){a&gt;b?a=b:0;}}using namespace MoBan;//Modularnamespace modular{ const int mod=1e9+7; inline int add(csi&amp;a,csi&amp;b){return a+b&lt;mod?a+b:a+b-mod;} inline int dec(csi&amp;a,csi&amp;b){return a&lt;b?a-b+mod:a-b;} inline int mul(csi&amp;a,csi&amp;b){return (ll)a*b%mod;} inline void Add(int&amp;a,csi&amp;b){a=a+b&lt;mod?a+b:a+b-mod;} inline void Dec(int&amp;a,csi&amp;b){a=a&lt;b?a-b+mod:a-b;} inline void Mul(int&amp;a,csi&amp;b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,1),1);return ret;} inline int Inv(csi&amp;a){return ksm(a,mod-2);} inline void fix(int&amp;a){a=(a%mod+mod)%mod;}}using namespace modular;//My solconst int N=16;int n,m,in[1&lt;&lt;15],out[1&lt;&lt;15],pw[N*N],all,cnt[1&lt;&lt;15],f[1&lt;&lt;15],g[1&lt;&lt;15],sum[1&lt;&lt;15],coe[1&lt;&lt;15];inline void dfs(int S,int cur){ if(!cur)return; dfs(S,(cur-1)&amp;S); int t=cur&amp;-cur; coe[cur]=add(dec(coe[cur^t],cnt[out[t]&amp;cur]),cnt[in[t]&amp;(S^cur)]);}//Mainint main(){ file(); n=read(),m=read(); pw[0]=1; for(ri i=1;i&lt;=m;++i)pw[i]=add(pw[i-1],pw[i-1]); for(ri i=1,u,v;i&lt;=m;++i){ u=read()-1,v=read()-1; out[pw[u]]|=pw[v]; in[pw[v]]|=pw[u]; } all=pw[n]; for(ri s=1,t;s&lt;all;++s){ t=s&amp;-s; cnt[s]=cnt[s^t]+1; sum[s]=sum[s^t]+cnt[in[t]&amp;s]+cnt[out[t]&amp;s]; dfs(s,s); for(ri ns=t^s,nt=ns;nt;nt=(nt-1)&amp;ns)Dec(g[s],mul(g[nt],f[s^nt])); f[s]=pw[sum[s]]; for(ri nt=s;nt;nt=(nt-1)&amp;s)Dec(f[s],mul(g[nt],pw[sum[s^nt]+coe[nt]])); Add(g[s],f[s]); } cout&lt;&lt;f[all-1]; return 0;} Biconnected &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x8DDF;&#x4E0A;&#x4E00;&#x9898;&#x601D;&#x8DEF;&#x7C7B;&#x4F3C;&#xFF0C;&#x8FD9;&#x4E0D;&#x8FC7;&#x8FD9;&#x9898;&#x7F29;&#x5B8C;&#x70B9;&#x4E4B;&#x540E;&#x53D8;&#x6210;&#x4E86;&#x4E00;&#x68F5;&#x6811;&#xFF0C;&#x56E0;&#x6B64;&#x8981;&#x9884;&#x5904;&#x7406;&#x4E00;&#x4E2A; fsf_sfs&#x200B; &#x8868;&#x793A;&#x70B9;&#x96C6; sss &#x8FDE;&#x901A;&#x7684;&#x65B9;&#x6848;&#x6570;&#xFF0C;&#x5269;&#x4E0B;&#x7684;&#x8DDF;&#x4E0A;&#x9898;&#x57FA;&#x672C;&#x4E00;&#x6837;&#xFF0C;&#x8FD9;&#x91CC;&#x4E0D;&#x4E00;&#x4E00;&#x8D58;&#x8FF0; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;//MoBannamespace MoBan{//Typetypedef long long ll;typedef double db;typedef long double ld;typedef unsigned long long Ull;typedef unsigned int uii;typedef const int csi;// Pairtypedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,ll&gt; pll;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;#define fi first#define se second//Vectortypedef vector&lt;int&gt; vi;typedef vector&lt;pii&gt; vii;typedef vector&lt;pll&gt; vll;typedef vector&lt;pli&gt; vli;typedef vector&lt;pil&gt; vil;#define pb push_back//Maptypedef map&lt;int,int&gt; mii;typedef map&lt;ll,int&gt; mli;typedef map&lt;int,bool&gt; mbi;//Settypedef set&lt;int&gt; si;typedef set&lt;pii&gt; sii;typedef set&lt;pli&gt; sli;typedef set&lt;pil&gt; sil;typedef set&lt;pll&gt; sll;#define ins insert#define del eraseconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)//Inputinline int read(){ bool f=1; int ans=0; char ch=gc(); while(!isdigit(ch))f^=ch==&apos;-&apos;,ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;}inline ll readl(){ ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s){ int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;}//Fileinline void file(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif}//Functionstemplate&lt;typename T&gt;inline void ckmax(T&amp;a,T b){a&lt;b?a=b:0;}template&lt;typename T&gt;inline void ckmin(T&amp;a,T b){a&gt;b?a=b:0;}}using namespace MoBan;//Modularnamespace modular{ const int mod=1e9+7; inline int add(int a,int b){return a+b&lt;mod?a+b:a+b-mod;} inline int dec(int a,int b){return a&lt;b?a-b+mod:a-b;} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Add(int&amp;a,int b){a=a+b&lt;mod?a+b:a+b-mod;} inline void Dec(int&amp;a,int b){a=a&lt;b?a-b+mod:a-b;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;} inline int Inv(csi&amp;a){return ksm(a,mod-2);} inline int fix(csi&amp;a){return (a%mod+mod)%mod;}}using namespace modular;//My solconst int N=15;int n,m,f[1&lt;&lt;11],g[1&lt;&lt;11],cnt[1&lt;&lt;11],tot[1&lt;&lt;11],pw[15*15],res[1&lt;&lt;11],h[1&lt;&lt;11][1&lt;&lt;11];inline void init(){ pw[0]=1; for(ri i=1;i&lt;144;++i)pw[i]=add(pw[i-1],pw[i-1]); for(ri s=1;s&lt;pw[11];++s)cnt[s]=cnt[s&gt;&gt;1]+(s&amp;1);}inline int lowbit(int x){return x&amp;-x;}inline void init_f(){ f[0]=1; for(ri s=1;s&lt;pw[n];++s){ g[s]=0; for(ri ns=s^lowbit(s),nt=ns;nt;nt=(nt-1)&amp;ns)Add(g[s],mul(f[s^nt],pw[tot[nt]])); f[s]=dec(pw[tot[s]],g[s]); }}inline int Connect(int s,int t){return dec(tot[s|t],add(tot[s],tot[t]));}inline void init_h(){ for(ri s=0;s&lt;pw[n];++s)h[0][s]=1; for(ri s=1;s&lt;pw[n];++s)for(ri t=(pw[n]-1)^s,S=t;t;t=(t-1)&amp;S){ h[s][t]=0; for(ri ns=s^lowbit(s),nt=ns;;nt=(nt-1)&amp;ns){ Add(h[s][t],mul(mul(h[nt][t],f[s^nt]),Connect(s^nt,t))); if(!nt)break; } }}//Mainint main(){ file(); init(); for(ri tt=read();tt;--tt){ n=read(),m=read(); for(ri i=1;i&lt;pw[n];++i)tot[i]=cnt[i]*(cnt[i]-1)/2; for(ri i=1,u,v;i&lt;=m;++i){ u=read()-1,v=read()-1; for(ri s=(pw[n]-1)^pw[u]^pw[v],t=s;;t=(t-1)&amp;s){ --tot[t^pw[u]^pw[v]]; if(!t)break; } } init_f(); init_h(); for(ri s=0;s&lt;pw[n];++s){ res[s]=f[s]; for(ri ns=s^lowbit(s),nt=ns;nt;nt=(nt-1)&amp;ns) Dec(res[s],mul(h[nt][s^nt],res[s^nt])); } cout&lt;&lt;res[pw[n]-1]&lt;&lt;&apos;\\n&apos;; } return 0;} &#x96C6;&#x5408;&#x9009;&#x6570; &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x628A;&#x9898;&#x76EE;&#x4E0A;&#x7684;&#x9650;&#x5236;&#x62CE;&#x51FA;&#x6765;&#x5EFA;&#x4E00;&#x4E2A;&#x56FE;&#x53D1;&#x73B0;&#x662F;&#x7531;&#x82E5;&#x5E72;&#x7F51;&#x683C;&#x56FE;&#x62FC;&#x63A5;&#x8D77;&#x6765;&#x7684;&#xFF0C;&#x4E14;&#x5BF9;&#x4E8E;&#x6BCF;&#x4E2A;&#x4E0D;&#x88AB; 2,32,32,3 &#x6574;&#x9664;&#x7684;&#x6570;&#x4E00;&#x5B9A;&#x4F5C;&#x4E3A;&#x4E00;&#x4E2A;&#x7F51;&#x683C;&#x56FE;&#x7684;&#x5DE6;&#x4E0A;&#x89D2;&#xFF0C;&#x6BCF;&#x4E2A;&#x77E9;&#x9635;&#x884C;&#x6570;&#x7EA6;&#x4E3A; log&#x2061;2n\\log_2 nlog2&#x200B;n &#xFF0C;&#x5217;&#x6570;&#x7EA6;&#x4E3A; log&#x2061;3n\\log_3 nlog3&#x200B;n &#xFF0C;&#x8FD9;&#x6837;&#x628A;&#x5217;&#x72B6;&#x538B;&#x8D77;&#x6765;&#x8F6C;&#x79FB;&#x5373;&#x53EF; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std; //MoBannamespace MoBan{//Typetypedef long long ll;typedef double db;typedef long double ld;typedef unsigned long long Ull;typedef unsigned int uii;typedef const int csi; // Pairtypedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,ll&gt; pll;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;#define fi first#define se second //Vectortypedef vector&lt;int&gt; vi;typedef vector&lt;pii&gt; vii;typedef vector&lt;pll&gt; vll;typedef vector&lt;pli&gt; vli;typedef vector&lt;pil&gt; vil;#define pb push_back //Maptypedef map&lt;int,int&gt; mii;typedef map&lt;ll,int&gt; mli;typedef map&lt;int,bool&gt; mbi; //Settypedef set&lt;int&gt; si;typedef set&lt;pii&gt; sii;typedef set&lt;pli&gt; sli;typedef set&lt;pil&gt; sil;typedef set&lt;pll&gt; sll;#define ins insert#define del erase const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++) //Inputinline int read(){ bool f=1; int ans=0; char ch=gc(); while(!isdigit(ch))f^=ch==&apos;-&apos;,ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;}inline ll readl(){ ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s){ int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;} //Fileinline void file(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif} //Functionstemplate&lt;typename T&gt;inline void ckmax(T&amp;a,T b){a&lt;b?a=b:0;}template&lt;typename T&gt;inline void ckmin(T&amp;a,T b){a&gt;b?a=b:0;}}using namespace MoBan; //Modularnamespace modular{ const int mod=1e9+1; inline int add(int a,int b){return a+b&lt;mod?a+b:a+b-mod;} inline int dec(int a,int b){return a&lt;b?a-b+mod:a-b;} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Add(int&amp;a,int b){a=a+b&lt;mod?a+b:a+b-mod;} inline void Dec(int&amp;a,int b){a=a&lt;b?a-b+mod:a-b;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;} inline int Inv(csi&amp;a){return ksm(a,mod-2);} inline int fix(csi&amp;a){return (a%mod+mod)%mod;}}using namespace modular; //My solconst int N=1&lt;&lt;12;int f[2][N],n,cur;bool trans[N];inline int calc(int x){ memset(f,0,sizeof(f)); vector&lt;int&gt;cnt; for(ri i=x,_cnt;i&lt;=n;i&lt;&lt;=1){ _cnt=0; for(ri j=i;j&lt;=n;j*=3)++_cnt; cnt.pb(_cnt); } cur=0; for(ri i=0,up=1&lt;&lt;cnt[0];i&lt;up;++i)f[cur][i]=trans[i]; for(ri i=1;i&lt;cnt.size();++i){ cur^=1; for(ri t=0,_up=1&lt;&lt;cnt[i];t&lt;_up;++t)f[cur][t]=0; for(ri s=0,up=1&lt;&lt;cnt[i-1];s&lt;up;++s)if(f[cur^1][s]) for(ri t=0,_up=1&lt;&lt;cnt[i];t&lt;_up;++t)if(trans[t]&amp;&amp;(!(s&amp;t))) Add(f[cur][t],f[cur^1][s]); } int res=0; for(ri i=0,up=1&lt;&lt;(cnt.back());i&lt;up;++i)Add(res,f[cur][i]); return res;} //Mainint main(){ file(); n=read(); for(ri i=0;i&lt;(1&lt;&lt;12);++i)trans[i]=(i&lt;&lt;1)&amp;i?0:1; int res=1; for(ri i=1;i&lt;=n;++i){ if(i==i/2*2||i==i/3*3)continue; Mul(res,calc(i)); } cout&lt;&lt;res; return 0;} &#x8FDB;&#x653B;&#xFF01; &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x8003;&#x8651;&#x4E00;&#x4E2A;&#x77E9;&#x5F62;&#x88AB;&#x8BA1;&#x7B97;&#x7684;&#x6B21;&#x6570;&#x7B49;&#x4E8E;&#x5176; 2&#xD7;22\\times 22&#xD7;2 &#x7684;&#x5B50;&#x77E9;&#x5F62;&#x6570;+ 1&#xD7;11\\times 11&#xD7;1 &#x7684;&#x5B50;&#x77E9;&#x5F62;&#x6570;- 1&#xD7;21\\times 21&#xD7;2 &#x7684;&#x5B50;&#x77E9;&#x5F62;&#x6570;- 2&#xD7;12\\times 12&#xD7;1 &#x7684;&#x5B50;&#x77E9;&#x5F62;&#x6570;&#xFF0C;&#x90A3;&#x4E48;&#x5206;&#x522B;&#x7EDF;&#x8BA1;&#x6BCF;&#x4E2A;&#x5C0F;&#x77E9;&#x5F62;&#x88AB;&#x8BA1;&#x7B97;&#x7684;&#x6B21;&#x6570;&#x3002; &#x6709;&#x4E00;&#x4E2A;&#x6BD4;&#x8F83;&#x663E;&#x7136;&#x7684;&#x65B9;&#x6CD5;&#x662F;&#x679A;&#x4E3E;&#x6BCF;&#x4E2A;&#x7A7A;&#x767D;&#x77E9;&#x5F62;&#x7136;&#x540E;&#x5DEE;&#x5206;&#xFF0C;&#x7136;&#x800C;&#x4E5F;&#x53EF;&#x4EE5;&#x76F4;&#x63A5;&#x5BF9;&#x4E8E;&#x6BCF;&#x4E2A;&#x70B9;&#x5904;&#x7406;&#x51FA;&#x5176;&#x5728;&#x5DEE;&#x5206;&#x6570;&#x7EC4;&#x4E2D;&#x7684;&#x503C;&#x7136;&#x540E;&#x76F4;&#x63A5;&#x524D;&#x7F00;&#x548C;&#xFF0C;&#x8FD9;&#x4E2A;&#x7528;&#x5355;&#x8C03;&#x6808;&#x5373;&#x53EF;&#x641E;&#x5B9A;&#xFF0C;&#x4E0D;&#x4F1A;&#x7684;&#x53EF;&#x4EE5;&#x770B;&#x770B;&#x8FD9;&#x9053;&#x9898; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;#define fi first#define se second#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(bool*s){ int top=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))s[++top]=ch^48,ch=gc(); return top;}namespace modular{ const int mod=998244353; inline int add(int a,int b){return a+b&lt;mod?a+b:a+b-mod;} inline int dec(int a,int b){return a&lt;b?a-b+mod:a-b;} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Add(int&amp;a,int b){a=a+b&lt;mod?a+b:a+b-mod;} inline void Dec(int&amp;a,int b){a=a&lt;b?a-b+mod:a-b;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;} inline int Inv(int a){return ksm(a,mod-2);} inline void fix(int&amp;x){x=(x%mod+mod)%mod;}}using namespace modular;const int N=2005;bool s[N][N];int n,m,K,stk[N],top=0,ht[N][N],a[N][N];int cnt1[N][N],cnt2[N][N],cnt3[N][N],cnt4[N][N],ss[N][N];//cnt3:&#xD7;&#xF3;&#xC9;&#xCF;&#xBD;&#xC7;//cnt4:&#xD7;&#xF3;&#xCF;&#xC2;&#xBD;&#xC7;//cnt1:&#xD3;&#xD2;&#xCF;&#xC2;&#xBD;&#xC7;//cnt2:&#xD3;&#xD2;&#xC9;&#xCF;&#xBD;&#xC7; void init(int cnt[][N],bool f1,bool f2){ for(ri i=1;i&lt;=n;++i){ top=0; for(ri j=1;j&lt;=m;++j){ ht[i][j]=s[i][j]?ht[i-1][j]+1:0; while(top&amp;&amp;ht[i][stk[top]]&gt;ht[i][j])--top; cnt[i][j]=cnt[i][stk[top]]+ht[i][j]*(j-stk[top]); stk[++top]=j; } } if(f1)for(ri i=1;i+i&lt;=n;++i)for(ri j=1;j&lt;=m;++j)swap(cnt[i][j],cnt[n-i+1][j]); if(f2)for(ri i=1;i&lt;=n;++i)for(ri j=1;j+j&lt;=m;++j)swap(cnt[i][j],cnt[i][m-j+1]);}inline int solve(){ int res=0; for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=m;++j){ a[i][j]=add(dec(a[i][j],a[i-1][j-1]),add(a[i-1][j],a[i][j-1])); Add(res,ksm(a[i][j],K)); } return res;}inline void clear(){for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=m;++j)a[i][j]=0;}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(),m=read(),K=read(); for(ri i=1;i&lt;=n;++i)Read(s[i]); init(cnt1,0,0); for(ri i=1;i+i&lt;=n;++i)for(ri j=1;j&lt;=m;++j)swap(s[i][j],s[n-i+1][j]); init(cnt2,1,0); for(ri i=1;i&lt;=n;++i)for(ri j=1;j+j&lt;=m;++j)swap(s[i][j],s[i][m-j+1]); init(cnt3,1,1); for(ri i=1;i+i&lt;=n;++i)for(ri j=1;j&lt;=m;++j)swap(s[i][j],s[n-i+1][j]); init(cnt4,0,1); int res=0; clear(); for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=m;++j){ Add(a[i][j],cnt3[i][j]); Dec(a[i+1][j],cnt4[i][j]); Add(a[i+1][j+1],cnt1[i][j]); Dec(a[i][j+1],cnt2[i][j]); } Add(res,solve()); clear(); for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=m;++j){ Add(a[i][j],cnt3[i][j]); Dec(a[i+1][j],cnt4[i][j]); Add(a[i+1][j],cnt1[i][j]); Dec(a[i][j],cnt2[i][j]); } Dec(res,solve()); clear(); for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=m;++j){ Add(a[i][j],cnt3[i][j]); Dec(a[i][j],cnt4[i][j]); Add(a[i][j+1],cnt1[i][j]); Dec(a[i][j+1],cnt2[i][j]); } Dec(res,solve()); clear(); for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=m;++j){ Add(a[i][j],cnt3[i][j]); Dec(a[i][j],cnt4[i][j]); Add(a[i][j],cnt1[i][j]); Dec(a[i][j],cnt2[i][j]); } Add(res,solve()); cout&lt;&lt;res; return 0;} Permuted Matrices &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x8003;&#x8651;&#x53EA;&#x6709;&#x4E00;&#x884C;&#x7684;&#x65F6;&#x5019;&#x548B;&#x505A;&#xFF0C;&#x8003;&#x8651;&#x628A;&#x6574;&#x4E2A;&#x5E8F;&#x5217;&#x5206;&#x6210; &#x230A;nk&#x230B;\\lfloor\\frac{n}{k}\\rfloor&#x230A;kn&#x200B;&#x230B; &#x6BB5;&#xFF0C;&#x8BBE; fif_ifi&#x200B; &#x8868;&#x793A;&#x524D; iii &#x6BB5;&#x5E26;&#x5BB9;&#x65A5;&#x7CFB;&#x6570;&#x7684;&#x7B54;&#x6848;&#xFF0C;&#x7136;&#x540E;&#x679A;&#x4E3E;&#x6700;&#x540E; jjj &#x6BB5;&#x53EF;&#x4EE5;&#x5F3A;&#x5236;&#x5408;&#x5E76;&#x6210;&#x4E00;&#x6BB5;&#x8F6C;&#x79FB;&#x5373;&#x53EF;&#xFF0C;&#x5373; fi=&#x2211;j=1ifi&#x2212;jCikjkf_{i}=\\sum\\limits_{j=1}^if_{i-j}C_{ik}^{jk}fi&#x200B;=j=1&#x2211;i&#x200B;fi&#x2212;j&#x200B;Cikjk&#x200B; &#xFF0C;&#x52A0;&#x4E0A;&#x884C;&#x7684;&#x9650;&#x5236;&#x5C31;&#x662F;&#x628A;&#x540E;&#x9762;&#x7684;&#x7EC4;&#x5408;&#x6570;&#x7ED9;&#x884C;&#x6570;&#x6B21;&#x65B9;&#xFF0C;&#x7136;&#x540E;&#x53D8;&#x4E2A;&#x5F62;&#x5C31;&#x80FD;&#x4E0A;&#x591A;&#x9879;&#x5F0F;&#x641E; CODE cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;#define fi first#define se second#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)namespace modular{ const int mod=1000000123; inline int add(int a,int b){return a+b&lt;mod?a+b:a+b-mod;} inline int dec(int a,int b){return a&lt;b?a-b+mod:a-b;} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Add(int&amp;a,int b){a=a+b&lt;mod?a+b:a+b-mod;} inline void Dec(int&amp;a,int b){a=a&lt;b?a-b+mod:a-b;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;}}using namespace modular;const int N=50005;int fac[N],ifac[N],f[N],n,pre[N];inline void init(){ fac[0]=fac[1]=ifac[0]=ifac[1]=1; for(ri i=2;i&lt;=n;++i){ fac[i]=mul(fac[i-1],i); ifac[i]=mul(ifac[mod-mod/i*i],mod-mod/i); } for(ri i=2;i&lt;=n;++i)Mul(ifac[i],ifac[i-1]); for(ri i=1;i&lt;=n;++i){ fac[i]=ksm(fac[i],n); ifac[i]=ksm(ifac[i],n); }}inline int C(int n,int m){return n&lt;m||m&lt;0?0:mul(fac[n],mul(ifac[m],ifac[n-m]));}vector&lt;int&gt;a;inline int solve(){ f[0]=1; for(ri ss,pre=0,i=1;i&lt;a.size();++i){ pre+=a[i]; f[i]=0; ss=0; for(ri j=i-1;~j;--j){ ss+=a[j+1]; if((i-j)&amp;1)Add(f[i],mul(f[j],C(pre,ss))); else Dec(f[i],mul(f[j],C(pre,ss))); } } return f[a.size()-1];}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=50000; init(); int res=0; for(ri i=1;i&lt;=n;++i){ a.resize(1); for(ri j=n;j;j-=a.back())a.pb(min(i,j)); Add(res,solve()); } cout&lt;&lt;res; return 0;}","categories":[{"name":"public","slug":"public","permalink":"http://xdl030112.github.io/categories/public/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://xdl030112.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"杂题乱做 Round6","slug":"sol6","date":"2019-11-07T08:41:52.000Z","updated":"2019-12-26T04:26:31.458Z","comments":true,"path":"sol6/","link":"","permalink":"http://xdl030112.github.io/sol6/","excerpt":"","text":"&#x968F;&#x673A;&#x6570;&#x751F;&#x6210;&#x5668; &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x770B;&#x4E86;&#x4E00;&#x4E0B;&#x7F51;&#x4E0A;&#x7684;&#x89E3;&#x6CD5;&#x5927;&#x6982;&#x662F; O(nX)O(nX)O(nX) &#x7684;&#xFF1F;&#x5176;&#x5B9E;&#x6709;&#x4E2A; O(n2)O(n^2)O(n2) &#x7684;&#x5728;&#x8FD9;&#x91CC;&#x8BB2;&#x4E00;&#x4E0B;&#x5427; &#x8003;&#x8651;&#x7528; min&#x2212;maxmin-maxmin&#x2212;max &#x5BB9;&#x65A5;&#x8F6C;&#x5316;&#x4E3A;&#x6C42;&#x6240;&#x6709;&#x5B50;&#x96C6;&#x8BE2;&#x95EE;&#x5230;&#x7684;&#x4F4D;&#x7F6E;&#x7684;&#x6700;&#x5C0F;&#x503C;&#x7684;&#x671F;&#x671B;&#xFF0C;&#x8FD9;&#x6837;&#x7B54;&#x6848;&#x53EA;&#x8DDF;&#x6240;&#x6709;&#x8BE2;&#x95EE;&#x8986;&#x76D6;&#x7684;&#x957F;&#x5EA6;&#x6709;&#x5173;&#xFF0C;&#x9996;&#x5148;&#x8003;&#x8651; nnn &#x4E2A; [1,x][1,x][1,x] &#x95F4;&#x968F;&#x673A;&#x6574;&#x6570;&#x7684;&#x671F;&#x671B;&#x6700;&#x5C0F;&#x503C;&#x600E;&#x4E48;&#x6C42;&#xFF0C;&#x8003;&#x8651;&#x679A;&#x4E3E;&#x6700;&#x5C0F;&#x503C;&#x662F;&#x591A;&#x5C11;&#x4EE5;&#x53CA;&#x6709;&#x54EA;&#x4E9B;&#x4F4D;&#x7F6E;&#x662F;&#x6700;&#x5C0F;&#x503C;&#x7136;&#x540E;&#x8FDB;&#x884C;&#x53D8;&#x5F62;&#x5373;&#x53EF;&#xFF0C;&#x4E0B;&#x9762;&#x63A8;&#x4E00;&#x6CE2;&#x5F0F;&#x5B50;&#xFF1A; Emin=&#x2211;i=1xi&#x2211;j=1nCnj(x&#x2212;i)n&#x2212;jxn=&#x2211;i=1xi((x&#x2212;i+1)n&#x2212;(x&#x2212;i)n)xn=&#x2211;i=1xinxn\\begin{aligned} E_{min}=&amp;\\frac{\\sum\\limits_{i=1}^xi\\sum\\limits_{j=1}^nC_n^j(x-i)^{n-j}}{x^n}\\\\ =&amp;\\frac{\\sum\\limits_{i=1}^xi((x-i+1)^n-(x-i)^n)}{x^n}\\\\ =&amp;\\frac{\\sum\\limits_{i=1}^xi^n}{x^n} \\end{aligned} Emin&#x200B;===&#x200B;xni=1&#x2211;x&#x200B;ij=1&#x2211;n&#x200B;Cnj&#x200B;(x&#x2212;i)n&#x2212;j&#x200B;xni=1&#x2211;x&#x200B;i((x&#x2212;i+1)n&#x2212;(x&#x2212;i)n)&#x200B;xni=1&#x2211;x&#x200B;in&#x200B;&#x200B; &#x4E0A;&#x5F0F;&#x5229;&#x7528;&#x62C9;&#x683C;&#x6717;&#x65E5;&#x63D2;&#x503C;&#x53EF;&#x4EE5; O(n2)O(n^2)O(n2) &#x9884;&#x5904;&#x7406;&#xFF0C;&#x4F46;&#x7531;&#x4E8E;&#x8BE5;&#x9898;&#x7684; xxx &#x8303;&#x56F4;&#x8DDF; nnn &#x540C;&#x9636;&#x56E0;&#x6B64;&#x4EE3;&#x7801;&#x91CC;&#x76F4;&#x63A5;&#x7B97;&#x7684; &#x90A3;&#x4E48;&#x73B0;&#x5728;&#x53EA;&#x7528;&#x8003;&#x8651;&#x6240;&#x6709;&#x8BE2;&#x95EE;&#x7684;&#x5B50;&#x96C6;&#x5BF9;&#x957F;&#x5EA6;&#x4E2A;&#x6570;&#x7684;&#x8D21;&#x732E;&#xFF0C;&#x56E0;&#x6B64;&#x8003;&#x8651;&#x5982;&#x4E0B; dpdpdp &#xFF1A; &#x5C06;&#x6240;&#x6709;&#x7684;&#x8BE2;&#x95EE;&#x6309;&#x5DE6;&#x7AEF;&#x70B9;&#x5355;&#x589E;&#x6392;&#x5E8F;&#xFF0C;&#x8BBE; fi,jf_{i,j}fi,j&#x200B; &#x8868;&#x793A;&#x5F53;&#x524D;&#x8986;&#x76D6;&#x957F;&#x5EA6;&#x4E3A; iii &#xFF0C;&#x4E4B;&#x524D;&#x88AB;&#x9009;&#x4E2D;&#x7684;&#x8BE2;&#x95EE;&#x8986;&#x76D6;&#x5230;&#x7684;&#x6700;&#x8FDC;&#x70B9;&#x4E3A; jjj &#x7684;&#x5E26;&#x5BB9;&#x65A5;&#x7CFB;&#x6570;&#x65B9;&#x6848;&#x6570; &#x5047;&#x8BBE;&#x5F53;&#x524D;&#x8BE2;&#x95EE;&#x533A;&#x95F4;&#x4E3A; [l,r][l,r][l,r] &#xFF0C;&#x957F;&#x5EA6;&#x4E3A; lenlenlen &#xFF0C;&#x8FD9;&#x6837;&#x5BF9;&#x4E8E;&#x6240;&#x6709;&#x72B6;&#x6001;&#x6709;&#x5982;&#x4E0B;&#x4E09;&#x79CD;&#x8F6C;&#x79FB;&#xFF1A; fi+len,r&#x2190;(&#x2212;1)fi,j&lt;lf_{i+len,r}\\leftarrow(-1)f_{i,j&lt;l}fi+len,r&#x200B;&#x2190;(&#x2212;1)fi,j&lt;l&#x200B; &#xFF0C;&#x7EF4;&#x62A4;&#x4E00;&#x4E2A;&#x884C;&#x524D;&#x7F00;&#x548C;&#x53EF;&#x4EE5;&#x5F88;&#x5FEB;&#x6C42; fi+r&#x2212;j,r&#x2190;(&#x2212;1)fi,l&#x2264;j&lt;rf_{i+r-j,r}\\leftarrow(-1)f_{i,l\\le j&lt;r}fi+r&#x2212;j,r&#x200B;&#x2190;(&#x2212;1)fi,l&#x2264;j&lt;r&#x200B; ,&#x7EF4;&#x62A4;&#x4E00;&#x4E2A;&#x5BF9;&#x89D2;&#x7EBF;&#x524D;&#x7F00;&#x548C;&#x53EF;&#x4EE5;&#x5F88;&#x5FEB;&#x6C42; fi,j&#x2190;(&#x2212;1)fi,jf_{i,j}\\leftarrow(-1)f_{i,j}fi,j&#x200B;&#x2190;(&#x2212;1)fi,j&#x200B; &#xFF0C;&#x8981;&#x6C42;&#x652F;&#x6301;&#x4E00;&#x4E2A;&#x533A;&#x95F4;&#x6E05;&#x96F6;&#xFF1F;&#xFF1F;&#xFF1F; &#x7ECF;&#x8FC7;&#x8BA8;&#x8BBA;&#x53D1;&#x73B0;&#x53EF;&#x4EE5;&#x7528;&#x7EBF;&#x6BB5;&#x6811;&#x4F18;&#x5316; dpdpdp &#xFF0C;&#x590D;&#x6742;&#x5EA6;&#x4E3A; O(n2log&#x2061;n)O(n^2\\log n)O(n2logn) &#xFF0C;&#x80FD;&#x8FC7;&#x4F46;&#x590D;&#x6742;&#x5EA6;&#x8C8C;&#x4F3C;&#x4E0D;&#x592A;&#x4F18;&#x79C0; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174#include&lt;bits/stdc++.h&gt;#include&lt;tr1/unordered_map&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;typedef unsigned long long Ull;typedef unsigned int uii;typedef tr1::unordered_map&lt;ll,int&gt;::iterator It;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch==&apos;-&apos;,ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;}inline ll readl(){ ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s){ int top=0; char ch=gc(); while(!isdigit(ch)&amp;&amp;ch!=&apos;?&apos;)ch=gc(); while(isdigit(ch)||ch==&apos;?&apos;)s[++top]=ch,ch=gc(); return top;}namespace modular{ const int mod=666623333; inline int add(int a,int b){return a+b&lt;mod?a+b:a+b-mod;} inline int dec(int a,int b){return a&lt;b?a-b+mod:a-b;} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Add(int&amp;a,int b){a=a+b&lt;mod?a+b:a+b-mod;} inline void Dec(int&amp;a,int b){a=a&lt;b?a-b+mod:a-b;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;} inline int Inv(int a){return ksm(a,mod-2);} inline void fix(int&amp;a){a=(a%mod+mod)%mod;}}using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b){a&gt;b?a=b:0;}template&lt;typename T&gt;inline void ckmax(T&amp;a,T b){a&lt;b?a=b:0;}const int N=2005;int cnt=0,f[N][N],g[N],n,q,x;inline void init(){ static int pw[N]; for(ri i=1;i&lt;=x;++i)pw[i]=1; for(ri i=0,res,iv=Inv(x),mt=1;i&lt;=n;++i,Mul(mt,iv)){ res=0; for(ri j=1;j&lt;=x;++j){ Add(res,pw[j]); Mul(pw[j],j); } g[i]=mul(res,mt); }}pii a[N];inline void check(){ static bool vs[N]; static int ans[N]; for(ri s=0,up=1&lt;&lt;q;s&lt;up;++s){ int ct1=0,ct2=0; for(ri i=1;i&lt;=q;++i){ if(s&gt;&gt;(i-1)&amp;1){ ++ct1; for(ri j=a[i].fi;j&lt;=a[i].se;++j)vs[j]=1; } } for(ri i=1;i&lt;=n;++i){ if(vs[i])++ct2; vs[i]=0; } ct1&amp;1?Dec(ans[ct2],1):Add(ans[ct2],1); } int res=0; for(ri i=1;i&lt;=n;++i)cerr&lt;&lt;ans[i]&lt;&lt;&apos; &apos;; for(ri i=1;i&lt;=n;++i)Add(res,mul(ans[i],g[i])); q&amp;1?res=dec(0,res):0; puts(&quot;&quot;); cerr&lt;&lt;res&lt;&lt;&apos;\\n&apos;;}struct sgt{ #define lc (p&lt;&lt;1) #define rc (p&lt;&lt;1|1) #define mid (l+r&gt;&gt;1) int ss[N&lt;&lt;2]; bool cle[N&lt;&lt;2]; inline void pushnow(int p){ ss[p]=0; cle[p]=1; } inline void pushdown(int p){ if(cle[p]){ pushnow(lc); pushnow(rc); cle[p]=0; } } inline void pushup(int p){ss[p]=add(ss[lc],ss[rc]);} inline void update(int p,int l,int r,int k,int v){ if(l==r){ Add(ss[p],v); return; } pushdown(p); k&lt;=mid?update(lc,l,mid,k,v):update(rc,mid+1,r,k,v); pushup(p); } inline void modify(int p,int l,int r,int ql,int qr){ if(ql&lt;=l&amp;&amp;r&lt;=qr)return pushnow(p); pushdown(p); if(qr&lt;=mid)modify(lc,l,mid,ql,qr); else if(ql&gt;mid)modify(rc,mid+1,r,ql,qr); else modify(lc,l,mid,ql,qr),modify(rc,mid+1,r,ql,qr); pushup(p); } inline int query(int p,int l,int r,int ql,int qr){ if(ql&lt;=l&amp;&amp;r&lt;=qr)return ss[p]; pushdown(p); if(qr&lt;=mid)return query(lc,l,mid,ql,qr); if(ql&gt;mid)return query(rc,mid+1,r,ql,qr); return add(query(lc,l,mid,ql,qr),query(rc,mid+1,r,ql,qr)); } #undef lc #undef rc #undef mid}s1[N],s2[N];inline void update(int a,int b,int vl){ if(!vl)return; s1[a].update(1,0,n,b,vl); s2[b-a].update(1,0,n,a,vl);}int sig=0;inline bool cmp(pii a,pii b){return a.fi^b.fi?a.fi&gt;b.fi:a.se&lt;b.se;}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(),x=read(),q=read(); init(); for(ri i=1;i&lt;=q;++i)a[i].fi=read(),a[i].se=read(); sort(a+1,a+q+1,cmp); int mnr=0x3f3f3f3f; for(ri i=1;i&lt;=q;++i){ if(mnr&gt;a[i].se){ mnr=a[i].se; a[++sig]=a[i]; } } q=sig; sort(a+1,a+q+1); update(0,0,mod-1); for(ri i=1,l,r,len;i&lt;=q;++i){ l=a[i].fi,r=a[i].se,len=r-l+1; for(ri j=0;j+len&lt;=n&amp;&amp;j&lt;l;++j)update(j+len,r,dec(0,s1[j].query(1,0,n,0,l-1))); if(l&lt;r)for(ri j=1;j&lt;r;++j)update(j+1,r,dec(0,s2[r-j-1].query(1,0,n,max(j+l-r+1,1),j))); } int res=0; for(ri i=1;i&lt;=n;++i)Add(res,mul(g[i],s1[i].query(1,0,n,0,n))); cout&lt;&lt;res; return 0;} &#x8003;&#x8651;&#x7EE7;&#x7EED;&#x4F18;&#x5316; &#x7ECF;&#x8FC7;&#x89C2;&#x5BDF;&#x53D1;&#x73B0;&#x5982;&#x679C;&#x4E00;&#x4E2A;&#x5927;&#x533A;&#x95F4;&#x5305;&#x542B;&#x4E86;&#x4E00;&#x4E2A;&#x5C0F;&#x533A;&#x95F4;&#xFF0C;&#x90A3;&#x4E48;&#x5927;&#x533A;&#x95F4;&#x53EF;&#x4EE5;&#x820D;&#x6389;&#xFF0C;&#x56E0;&#x4E3A;&#x6700;&#x7EC8;&#x7B54;&#x6848;&#x4E00;&#x5B9A;&#x5728;&#x5C0F;&#x533A;&#x95F4;&#x4E2D;&#xFF0C;&#x4E8E;&#x662F;&#x5728;&#x8FDB;&#x884C;&#x6389;&#x8FD9;&#x4E00;&#x6B65;&#x5904;&#x7406;&#x4E4B;&#x540E;&#x6240;&#x6709;&#x8BE2;&#x95EE;&#x533A;&#x95F4;&#x7684;&#x5DE6;&#x53F3;&#x7AEF;&#x70B9;&#x90FD;&#x662F;&#x5355;&#x589E;&#x7684;&#xFF0C;&#x4E5F;&#x5C31;&#x662F;&#x8BF4;&#x5BF9;&#x4E8E;&#x7B2C;&#x4E09;&#x79CD;&#x8F6C;&#x79FB;&#x540E;&#x9762;&#x7684; fi,jf_{i,j}fi,j&#x200B; &#x672C;&#x6765;&#x5C31;&#x662F; 000 &#xFF0C;&#x90A3;&#x4E48;&#x53EA;&#x7528;&#x7EF4;&#x62A4;&#x884C;&#x524D;&#x7F00;&#x548C;&#x548C;&#x5BF9;&#x89D2;&#x7EBF;&#x524D;&#x7F00;&#x548C;&#x5373;&#x53EF;&#xFF0C;&#x590D;&#x6742;&#x5EA6;&#x4E3A; O(qlog&#x2061;q+n2)O(q\\log q+n^2)O(qlogq+n2) &#xFF0C;&#x53EF;&#x4EE5;&#x52A0;&#x5F3A;&#x5230; n&#x2264;5000,x&#x2264;1e9,q&#x2264;1e6n\\le5000,x\\le 1e9,q\\le1e6n&#x2264;5000,x&#x2264;1e9,q&#x2264;1e6 &#x4E86; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include&lt;bits/stdc++.h&gt;#include&lt;tr1/unordered_map&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;typedef unsigned long long Ull;typedef unsigned int uii;typedef tr1::unordered_map&lt;ll,int&gt;::iterator It;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch==&apos;-&apos;,ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;}inline ll readl(){ ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s){ int top=0; char ch=gc(); while(!isdigit(ch)&amp;&amp;ch!=&apos;?&apos;)ch=gc(); while(isdigit(ch)||ch==&apos;?&apos;)s[++top]=ch,ch=gc(); return top;}namespace modular{ const int mod=666623333; inline int add(int a,int b){return a+b&lt;mod?a+b:a+b-mod;} inline int dec(int a,int b){return a&lt;b?a-b+mod:a-b;} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Add(int&amp;a,int b){a=a+b&lt;mod?a+b:a+b-mod;} inline void Dec(int&amp;a,int b){a=a&lt;b?a-b+mod:a-b;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;} inline int Inv(int a){return ksm(a,mod-2);} inline void fix(int&amp;a){a=(a%mod+mod)%mod;}}using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b){a&gt;b?a=b:0;}template&lt;typename T&gt;inline void ckmax(T&amp;a,T b){a&lt;b?a=b:0;}const int N=2005;int cnt=0,f[N][N],g[N],n,q,x;inline void init(){ static int pw[N]; for(ri i=1;i&lt;=x;++i)pw[i]=1; for(ri i=0,res,iv=Inv(x),mt=1;i&lt;=n;++i,Mul(mt,iv)){ res=0; for(ri j=1;j&lt;=x;++j){ Add(res,pw[j]); Mul(pw[j],j); } g[i]=mul(res,mt); }}pii a[N];int s1[N][N],s2[N][N];int sig=0;inline bool cmp(pii a,pii b){return a.fi^b.fi?a.fi&gt;b.fi:a.se&lt;b.se;}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(),x=read(),q=read(); init(); for(ri i=1;i&lt;=q;++i)a[i].fi=read(),a[i].se=read(); sort(a+1,a+q+1,cmp); int mnr=0x3f3f3f3f; for(ri i=1;i&lt;=q;++i){ if(mnr&gt;a[i].se){ mnr=a[i].se; a[++sig]=a[i]; } } q=sig; sort(a+1,a+q+1); s1[0][0]=s2[0][0]=f[0][0]=mod-1; int prer=0; for(ri i=1,prer=0,l,r,len;i&lt;=q;++i){ l=a[i].fi,r=a[i].se,len=r-l+1; while(prer&lt;r-1){ ++prer; for(ri j=0;j&lt;=prer;++j){ s1[j][prer]=add(s1[j][prer-1],f[j][prer]); s2[prer-j][j]=add(j?s2[prer-j][j-1]:0,f[j][prer]); } } for(ri t,j=0;j+len&lt;=n&amp;&amp;j&lt;l;++j){ t=s1[j][l-1]; if(t)Add(f[j+len][r],mod-t); } if(l&lt;r)for(ri t,j=1;j&lt;r;++j){ t=dec(s2[r-j-1][j],s2[r-j-1][max(j+l-r,0)]); if(t)Add(f[j+1][r],mod-t); } } while(prer&lt;n){ ++prer; for(ri i=0;i&lt;=prer;++i){ s1[i][prer]=add(s1[i][prer-1],f[i][prer]); s2[prer-i][i]=add(i?s2[prer-i][i-1]:0,f[i][prer]); } } int res=0; for(ri i=1;i&lt;=n;++i)Add(res,mul(g[i],s1[i][n])); cout&lt;&lt;res; return 0;} &#x5730;&#x9707;&#x540E;&#x7684;&#x5E7B;&#x60F3;&#x4E61; &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x770B;&#x5230;&#x5168;&#x6392;&#x5217;&#x5C31;&#x60F3;&#x5230;&#x72B6;&#x538B;&#x8FDE;&#x901A;&#x5757;&#x5B50;&#x96C6; dpdpdp &#xFF0C;&#x8BBE; fs,if_{s,i}fs,i&#x200B; &#x8868;&#x793A;&#x5F53;&#x524D;&#x8FDE;&#x901A;&#x5757;&#x4E3A; sss &#xFF0C;&#x7528;&#x4E86; iii &#x6761;&#x8FB9;&#x4F7F;&#x5F97;&#x5176;&#x8FDE;&#x901A;&#x7684;&#x65B9;&#x6848;&#x6570;&#xFF0C; gs,ig_{s,i}gs,i&#x200B; &#x8868;&#x793A;&#x5176;&#x4E0D;&#x8FDE;&#x901A;&#x7684;&#x65B9;&#x6848;&#x6570;&#xFF0C;&#x8865;&#x96C6;&#x8F6C;&#x5316;&#x8F6C;&#x79FB;&#x6700;&#x540E;&#x7EDF;&#x8BA1;&#x7B54;&#x6848;&#x5373;&#x53EF; CODE cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;typedef double db;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;typedef unsigned long long Ull;typedef unsigned int uii;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch==&apos;-&apos;,ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;}inline ll readl(){ ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s){ int top=0; char ch=gc(); while(!isdigit(ch)&amp;&amp;ch!=&apos;?&apos;)ch=gc(); while(isdigit(ch)||ch==&apos;?&apos;)s[++top]=ch,ch=gc(); return top;}namespace modular{ const int mod=666623333; inline int add(int a,int b){return a+b&lt;mod?a+b:a+b-mod;} inline int dec(int a,int b){return a&lt;b?a-b+mod:a-b;} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Add(int&amp;a,int b){a=a+b&lt;mod?a+b:a+b-mod;} inline void Dec(int&amp;a,int b){a=a&lt;b?a-b+mod:a-b;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;} inline int Inv(int a){return ksm(a,mod-2);} inline void fix(int&amp;a){a=(a%mod+mod)%mod;}}using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b){a&gt;b?a=b:0;}template&lt;typename T&gt;inline void ckmax(T&amp;a,T b){a&lt;b?a=b:0;}db f[1&lt;&lt;10][46],g[1&lt;&lt;10][46],C[46][46];int n,m,all,cnt[1&lt;&lt;10],pw[11];inline void init(){ pw[0]=1; for(ri i=1;i&lt;=n;++i)pw[i]=pw[i-1]+pw[i-1]; for(ri i=0;i&lt;=m;++i){ C[i][0]=1; for(ri j=1;j&lt;=i;++j)C[i][j]=C[i-1][j-1]+C[i-1][j]; }}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(),m=read(); init(); all=pw[n]-1; for(ri i=1,a,b;i&lt;=m;++i){ a=read()-1,b=read()-1; for(ri s=all^pw[a]^pw[b],t=s;;t=(t-1)&amp;s){ ++cnt[t^pw[a]^pw[b]]; if(!t)break; } } for(ri s=0;s&lt;=all;++s){ for(ri i=0;i&lt;=cnt[s];++i){ for(ri ts=s^(s&amp;-s),t=ts;t;t=(t-1)&amp;ts){ for(ri j=0,up=min(cnt[t],i);j&lt;=up;++j) g[s][i]+=C[cnt[t]][j]*f[s^t][i-j]; } f[s][i]=C[cnt[s]][i]-g[s][i]; } } db res=0; for(ri i=0;i&lt;=m;++i)res+=g[all][i]/C[m][i]; res/=m+1; printf(&quot;%.6lf&quot;,res); return 0;} Hero meet devil &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; [TJOI2018][TJOI2018][TJOI2018] &#x67D0;&#x9898;&#x7684;&#x539F;&#x578B;&#x5427;&#xFF0C;&#x8BBE; fi,jf_{i,j}fi,j&#x200B; &#x8868;&#x793A;&#x5F53;&#x524D;&#x679A;&#x4E3E;&#x5230;&#x6784;&#x9020;&#x4E32;&#x7684;&#x7B2C; iii &#x4F4D;&#xFF0C;&#x5BF9;&#x4E8E;&#x6A21;&#x677F;&#x4E32;&#x7684; LCSLCSLCS &#x72B6;&#x6001;&#x4E3A; jjj &#x7684;&#x65B9;&#x6848;&#x6570;&#xFF0C;&#x7136;&#x540E;&#x76F4;&#x63A5;&#x8F6C;&#x79FB;&#x5C31;&#x884C;&#x4E86; CODE cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;typedef double db;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;typedef unsigned long long Ull;typedef unsigned int uii;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch==&apos;-&apos;,ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;}inline ll readl(){ ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s){ int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;}namespace modular{ const int mod=1e9+7; inline int add(int a,int b){return a+b&lt;mod?a+b:a+b-mod;} inline int dec(int a,int b){return a&lt;b?a-b+mod:a-b;} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Add(int&amp;a,int b){a=a+b&lt;mod?a+b:a+b-mod;} inline void Dec(int&amp;a,int b){a=a&lt;b?a-b+mod:a-b;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;} inline int Inv(int a){return ksm(a,mod-2);} inline void fix(int&amp;a){a=(a%mod+mod)%mod;}}using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b){a&gt;b?a=b:0;}template&lt;typename T&gt;inline void ckmax(T&amp;a,T b){a&lt;b?a=b:0;}char str[20];int n,f[2][1&lt;&lt;15|5],cur,all,pw[16],cnt[1&lt;&lt;15|5],ans[20],m,a[20],b[20],trans[1&lt;&lt;15|5][4];inline void init(){ pw[0]=1; for(ri i=1;i&lt;=15;++i)pw[i]=pw[i-1]+pw[i-1]; for(ri i=1;i&lt;pw[15];++i)cnt[i]=cnt[i&gt;&gt;1]+(i&amp;1);}char cmp[4]={&apos;A&apos;,&apos;T&apos;,&apos;C&apos;,&apos;G&apos;};inline void Init(){ for(ri s=0;s&lt;=all;++s){ for(ri ns,op=0;op&lt;4;++op){ for(ri j=1;j&lt;=m;++j){ a[j]=(s&gt;&gt;(j-1)&amp;1)+a[j-1]; b[j]=max(max(a[j],b[j-1]),a[j-1]+(str[j]==cmp[op])); } ns=0; for(ri j=1;j&lt;=m;++j)ns|=(b[j]-b[j-1])&lt;&lt;(j-1); trans[s][op]=ns; } }}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif init(); for(ri tt=read();tt;--tt){ m=Read(str); for(ri i=1;i&lt;=m;++i)ans[i]=0; n=read(),all=pw[m]-1; f[cur=0][0]=1; Init(); for(ri i=1;i&lt;=all;++i)f[cur][i]=0; for(ri i=1;i&lt;=n;++i){ cur^=1; for(ri s=0;s&lt;=all;++s)f[cur][s]=0; for(ri s=0;s&lt;=all;++s)if(f[cur^1][s])for(ri op=0;op&lt;4;++op) Add(f[cur][trans[s][op]],f[cur^1][s]); } for(ri i=0;i&lt;=all;++i)Add(ans[cnt[i]],f[cur][i]); for(ri i=0;i&lt;=m;++i)cout&lt;&lt;ans[i]&lt;&lt;&apos;\\n&apos;; } return 0;} &#x8D2D;&#x7968; &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x6709;&#x4E00;&#x773C;&#x7684;&#x72B6;&#x6001;&#x8F6C;&#x79FB;&#x5F0F;&#x548C;&#x9650;&#x5236;&#x6761;&#x4EF6;&#xFF0C;&#x653E;&#x5728;&#x5E8F;&#x5217;&#x4E0A;&#x9762;&#x7684;&#x8BDD;&#x76F4;&#x63A5;&#x659C;&#x7387;&#x4F18;&#x5316;&#x5373;&#x53EF;&#xFF0C;&#x73B0;&#x5728;&#x653E;&#x5728;&#x6811;&#x4E0A;&#x5C31;&#x9700;&#x8981;&#x7528; cdqcdqcdq &#x5206;&#x6CBB;&#x7684;&#x601D;&#x60F3;&#x5148;&#x66F4;&#x65B0;&#x7956;&#x5148;&#xFF0C;&#x90A3;&#x4E48;&#x6BCF;&#x6B21;&#x9009;&#x5F53;&#x524D;&#x6811;&#x7684;&#x91CD;&#x5FC3;&#x7136;&#x540E;&#x5C06;&#x5176;&#x513F;&#x5B50;&#x62A0;&#x6389;&#x9012;&#x5F52;&#x5904;&#x7406;&#x5269;&#x4F59;&#x90E8;&#x5206;&#xFF0C;&#x7136;&#x540E;&#x7528;&#x5269;&#x4F59;&#x90E8;&#x5206;&#x66F4;&#x65B0;&#x62A0;&#x6389;&#x7684;&#x90E8;&#x5206;&#xFF0C;&#x7136;&#x540E;&#x9012;&#x5F52;&#x62A0;&#x6389;&#x7684;&#x90E8;&#x5206;&#x5373;&#x53EF; &#x53E3;&#x80E1;&#xFF1A;&#x8C8C;&#x4F3C;&#x4E5F;&#x53EF;&#x4EE5;&#x5229;&#x7528; dfsdfsdfs &#x5E8F;&#x641E;&#x56DB;&#x7EF4;&#x504F;&#x5E8F;&#xFF0C;&#x4F46;&#x6CA1;&#x5B9E;&#x73B0;&#x4E0D;&#x77E5;&#x9053;&#x6B63;&#x786E;&#x6027; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;typedef double db;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;typedef pair&lt;ll,ll&gt; pll;typedef unsigned long long Ull;typedef unsigned int uii;typedef double db;typedef long double ld;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch==&apos;-&apos;,ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;}inline ll readl(){ ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s){ int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;}namespace modular{ const int mod=1e9+7; inline int add(int a,int b){return a+b&lt;mod?a+b:a+b-mod;} inline int dec(int a,int b){return a&lt;b?a-b+mod:a-b;} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Add(int&amp;a,int b){a=a+b&lt;mod?a+b:a+b-mod;} inline void Dec(int&amp;a,int b){a=a&lt;b?a-b+mod:a-b;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;} inline int Inv(int a){return ksm(a,mod-2);} inline void fix(int&amp;a){a=(a%mod+mod)%mod;}}using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b){a&gt;b?a=b:0;}template&lt;typename T&gt;inline void ckmax(T&amp;a,T b){a&lt;b?a=b:0;}const int N=2e5+5;int n,typ,siz[N],fa[N],all,msz,rt;bool vs[N];vector&lt;int&gt;e[N];ll dis[N],p[N],q[N],lm[N],f[N];void getroot(int p){ siz[p]=1; int ms=0; for(ri i=0,v;i&lt;e[p].size();++i){ if(vs[v=e[p][i]])continue; getroot(v); siz[p]+=siz[v]; ckmax(ms,siz[v]); } ckmax(ms,all-siz[p]); if(msz&gt;ms&amp;&amp;siz[p]!=1)msz=ms,rt=p;}pll a1[N],a2[N];int top1,top2;void get(int p){ a2[++top2]=pll(dis[p]-lm[p],p); for(ri i=0,v;i&lt;e[p].size();++i)if(!vs[v=e[p][i]])get(v);}inline ll calc(int x,pll y){return y.se+q[x]+(dis[x]-y.fi)*p[x];}const ld inf=1e499;const ll inff=1e18;inline ld slope(pll a,pll b){return a.fi==b.fi?inf:(ld)(a.se-b.se)/(ld)(a.fi-b.fi);}void dfs(int p,int sz){ if(sz==1)return; all=msz=sz,rt=p; getroot(p); int cur=rt,x; for(ri i=0;i&lt;e[cur].size();++i)vs[e[cur][i]]=1; dfs(p,sz-siz[cur]+1); top2=0; for(ri i=0;i&lt;e[cur].size();++i)get(e[cur][i]); sort(a2+1,a2+top2+1); x=cur; a1[top1=0]=pll(0ll,inff); pll tmp; for(ri i=top2;i;--i){ while(x!=fa[p]&amp;&amp;dis[x]&gt;=a2[i].fi){ tmp=pll(dis[x],f[x]); while(top1&gt;1&amp;&amp;slope(tmp,a1[top1-1])&gt;=slope(a1[top1],a1[top1-1]))--top1; a1[++top1]=tmp; x=fa[x]; } if(top1){ int l=1,r=top1,res=1; while(l&lt;=r){ int mid=l+r&gt;&gt;1; if(calc(a2[i].se,a1[mid])&lt;=calc(a2[i].se,a1[mid-1]))res=mid,l=mid+1; else r=mid-1; } ckmin(f[a2[i].se],calc(a2[i].se,a1[res])); } } for(ri i=0,v;i&lt;e[cur].size();++i)dfs(e[cur][i],siz[e[cur][i]]);}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); freopen(&quot;lx.out&quot;,&quot;w&quot;,stdout); #endif n=read(),typ=read(); for(ri i=2;i&lt;=n;++i){ fa[i]=read(); dis[i]=dis[fa[i]]+readl(); e[fa[i]].pb(i); p[i]=readl(); q[i]=readl(); lm[i]=readl(); } for(ri i=2;i&lt;=n;++i)f[i]=inff; dfs(1,n); for(ri i=2;i&lt;=n;++i)cout&lt;&lt;f[i]&lt;&lt;&apos;\\n&apos;; return 0;} &#x968F;&#x673A;&#x6E38;&#x8D70; &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x8003;&#x8651;&#x8BBE; fs,if_{s,i}fs,i&#x200B; &#x8868;&#x793A;&#x4ECE; iii &#x51FA;&#x53D1;&#x8D70;&#x5B8C;&#x96C6;&#x5408; sss &#x7684;&#x671F;&#x671B;&#x6B65;&#x6570;&#xFF0C;&#x53D1;&#x73B0;&#x5BF9;&#x4E8E; i&#x2208;si\\in si&#x2208;s &#xFF0C;&#x53EF;&#x4EE5;&#x4ECE; sss &#x7684;&#x5B50;&#x96C6;&#x8F6C;&#x79FB;&#xFF0C;&#x5426;&#x5219;&#x5C31;&#x4E0E;&#x513F;&#x5B50;&#x548C;&#x7236;&#x4EB2;&#x6709;&#x4E00;&#x4E2A;&#x5E26;&#x73AF;&#x7684;&#x8F6C;&#x79FB;&#xFF0C;&#x8FD9;&#x6837;&#x4ECE;&#x5C0F;&#x5230;&#x5927;&#x679A;&#x4E3E; sss &#x518D;&#x5229;&#x7528;&#x6811;&#x4E0A;&#x6D88;&#x5143;&#x7684;&#x601D;&#x60F3;&#x5C31;&#x80FD;&#x7528; O(2nnlog&#x2061;)O(2^nn\\log)O(2nnlog) &#x9884;&#x5904;&#x7406;&#x51FA;&#x7B54;&#x6848;&#xFF08; log&#x2061;\\loglog &#x662F;&#x5FEB;&#x901F;&#x5E42;&#x6C42;&#x9006;&#x5143;&#xFF09; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;typedef double db;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;typedef unsigned long long Ull;typedef unsigned int uii;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch==&apos;-&apos;,ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;}inline ll readl(){ ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s){ int top=0; char ch=gc(); while(!isdigit(ch)&amp;&amp;ch!=&apos;?&apos;)ch=gc(); while(isdigit(ch)||ch==&apos;?&apos;)s[++top]=ch,ch=gc(); return top;}namespace modular{ const int mod=998244353; inline int add(int a,int b){return a+b&lt;mod?a+b:a+b-mod;} inline int dec(int a,int b){return a&lt;b?a-b+mod:a-b;} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Add(int&amp;a,int b){a=a+b&lt;mod?a+b:a+b-mod;} inline void Dec(int&amp;a,int b){a=a&lt;b?a-b+mod:a-b;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;} inline int Inv(int a){return ksm(a,mod-2);} inline void fix(int&amp;a){a=(a%mod+mod)%mod;}}using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b){a&gt;b?a=b:0;}template&lt;typename T&gt;inline void ckmax(T&amp;a,T b){a&lt;b?a=b:0;}const int N=19;int n,q,x,f[1&lt;&lt;18][19],pw[19],all,inv[19];vector&lt;int&gt;e[N];int que[N],hd,tl,fa[N];struct coef{ int a,b; coef(int a=0,int b=0):a(a),b(b){}}g[19];inline void init(){ pw[0]=1; for(ri i=1;i&lt;=n;++i)pw[i]=pw[i-1]+pw[i-1]; all=pw[n]-1; inv[1]=1; for(ri i=2;i&lt;=n;++i)inv[i]=mul(inv[mod-mod/i*i],mod-mod/i);}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(),q=read(),x=read(); init(); for(ri u,v,i=1;i&lt;n;++i){ u=read(),v=read(); e[u].pb(v); e[v].pb(u); } que[hd=tl=1]=1; while(hd&lt;=tl){ int x=que[hd++]; for(ri i=0,v;i&lt;e[x].size();++i){ if((v=e[x][i])==fa[x])continue; fa[v]=x,que[++tl]=v; } } for(ri s=0;s&lt;=all;++s){ for(ri p,t,i=n;i;--i){ p=que[i]; if(s==pw[p-1])g[p]=coef(0,0); else if(s&amp;pw[p-1]){ g[p]=coef(0,0); for(ri j=0;j&lt;e[p].size();++j)Add(g[p].b,f[s^pw[p-1]][e[p][j]]+1); Mul(g[p].b,inv[e[p].size()]); } else{ g[p].a=inv[e[p].size()]; g[p].b=0; t=0; for(ri j=0,v;j&lt;e[p].size();++j)if((v=e[p][j])!=fa[p]){ Add(g[p].b,g[v].b); Add(t,g[v].a); } Mul(g[p].b,inv[e[p].size()]); Mul(t,inv[e[p].size()]); Add(g[p].b,1); t=dec(1,t); Mul(g[p].a,Inv(t)); Mul(g[p].b,Inv(t)); } } for(ri p,i=1;i&lt;=n;++i){ p=que[i]; f[s][p]=add(mul(g[p].a,f[s][fa[p]]),g[p].b); } } while(q--){ int k=read(),s=0; while(k--)s^=pw[read()-1]; cout&lt;&lt;f[s][x]&lt;&lt;&apos;\\n&apos;; } return 0;} &#x968F;&#x673A;&#x7B97;&#x6CD5; &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x8C8C;&#x4F3C;&#x6211;&#x5199;&#x7684; O(n2n)O(n2^n)O(n2n) &#x88AB; cyktxdycyktxdycyktxdy &#x7684; O(n22n)O(n^22^n)O(n22n) &#x540A;&#x7740;&#x6253;&#xFF0C;&#x88AB;&#x55B7;&#x60E8;&#x4E86;=_= &#x8BBE; fsf_{s}fs&#x200B; &#x8868;&#x793A;&#x96C6;&#x5408; sss &#x7684;&#x7B54;&#x6848;&#xFF0C; gsg_sgs&#x200B; &#x8868;&#x793A;&#x96C6;&#x5408; sss &#x7684;&#x6700;&#x5927;&#x72EC;&#x7ACB;&#x96C6;&#x5927;&#x5C0F;&#xFF0C;&#x90A3;&#x4E48;&#x6211;&#x4EEC;&#x89C2;&#x5BDF; sss &#x4E2D;&#x54EA;&#x4E9B;&#x70B9;&#x5728;&#x6700;&#x5927;&#x72EC;&#x7ACB;&#x96C6;&#x4E2D;&#xFF0C;&#x628A;&#x5B83;&#x4EEC;&#x548C;&#x5B83;&#x4EEC;&#x76F8;&#x90BB;&#x7684;&#x70B9;&#x5220;&#x70B9;&#x4ECE;&#x5B50;&#x96C6;&#x8F6C;&#x79FB;&#x8FC7;&#x6765;&#x5373;&#x53EF; CODE cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;typedef double db;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;typedef unsigned long long Ull;typedef unsigned int uii;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch==&apos;-&apos;,ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;}inline ll readl(){ ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s){ int top=0; char ch=gc(); while(!isdigit(ch)&amp;&amp;ch!=&apos;?&apos;)ch=gc(); while(isdigit(ch)||ch==&apos;?&apos;)s[++top]=ch,ch=gc(); return top;}namespace modular{ const int mod=998244353; inline int add(int a,int b){return a+b&lt;mod?a+b:a+b-mod;} inline int dec(int a,int b){return a&lt;b?a-b+mod:a-b;} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Add(int&amp;a,int b){a=a+b&lt;mod?a+b:a+b-mod;} inline void Dec(int&amp;a,int b){a=a&lt;b?a-b+mod:a-b;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;} inline int Inv(int a){return ksm(a,mod-2);} inline void fix(int&amp;a){a=(a%mod+mod)%mod;}}using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b){a&gt;b?a=b:0;}template&lt;typename T&gt;inline void ckmax(T&amp;a,T b){a&lt;b?a=b:0;}int m,trans[21],f[1&lt;&lt;20],n,pw[21],all,g[1&lt;&lt;20],inv[21];inline void init(){ pw[0]=1; for(ri i=1;i&lt;=n;++i)pw[i]=pw[i-1]+pw[i-1]; all=pw[n]-1; inv[1]=1; for(ri i=2;i&lt;=n;++i)inv[i]=mul(inv[mod-mod/i*i],mod-mod/i);}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(),m=read(); init(); for(ri i=1,u,v;i&lt;=m;++i){ u=read()-1,v=read()-1; trans[u]|=pw[v]; trans[v]|=pw[u]; } for(ri s=f[0]=1,ct;s&lt;=all;++s){ ct=0; for(ri t,i=0;i&lt;n;++i)if(s&amp;pw[i]){ t=(s&amp;(~trans[i]))^pw[i]; ++ct; if(g[t]+1==g[s])Add(f[s],f[t]); else if(g[t]+1&gt;g[s])g[s]=g[t]+1,f[s]=f[t]; } Mul(f[s],inv[ct]); } cout&lt;&lt;f[all]; return 0;} Slay the Spire &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x6613;&#x5F97;&#x4E00;&#x4E2A;&#x6027;&#x8D28;&#xFF1A;&#x6700;&#x591A;&#x9009;&#x4E00;&#x5F20;&#x653B;&#x51FB;&#x724C; &#x5728;&#x77E5;&#x9053;&#x8FD9;&#x4E2A;&#x6027;&#x8D28;&#x4E4B;&#x540E;&#x76F4;&#x63A5;&#x679A;&#x4E3E;&#x9009;&#x51FA;&#x6765;&#x653B;&#x51FB;&#x724C;&#x7684;&#x6570;&#x91CF;&#x7136;&#x540E;&#x5DE6;&#x53F3;&#x7684;&#x8D21;&#x732E;&#x53EF;&#x4EE5; dpdpdp &#x9884;&#x5904;&#x7406;&#x51FA;&#x6765;&#xFF0C;&#x7EC4;&#x5408;&#x6570;&#x5B66;&#x7B97;&#x5C31;&#x5B8C;&#x4E86; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;typedef double db;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;typedef unsigned long long Ull;typedef unsigned int uii;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch==&apos;-&apos;,ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;}inline ll readl(){ ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s){ int top=0; char ch=gc(); while(!isdigit(ch)&amp;&amp;ch!=&apos;?&apos;)ch=gc(); while(isdigit(ch)||ch==&apos;?&apos;)s[++top]=ch,ch=gc(); return top;}namespace modular{ const int mod=998244353; inline int add(int a,int b){return a+b&lt;mod?a+b:a+b-mod;} inline int dec(int a,int b){return a&lt;b?a-b+mod:a-b;} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Add(int&amp;a,int b){a=a+b&lt;mod?a+b:a+b-mod;} inline void Dec(int&amp;a,int b){a=a&lt;b?a-b+mod:a-b;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;} inline int Inv(int a){return ksm(a,mod-2);} inline void fix(int&amp;a){a=(a%mod+mod)%mod;}}using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b){a&gt;b?a=b:0;}template&lt;typename T&gt;inline void ckmax(T&amp;a,T b){a&lt;b?a=b:0;}const int N=3005;int n,m,K,fac[N],ifac[N],a1[N],a2[N],f1[N][N],f2[N][N];inline void init(){ fac[0]=fac[1]=ifac[0]=ifac[1]=1; for(ri i=2;i&lt;=3000;++i){ fac[i]=mul(fac[i-1],i); ifac[i]=mul(ifac[mod-mod/i*i],mod-mod/i); } for(ri i=2;i&lt;=3000;++i)Mul(ifac[i],ifac[i-1]);}inline int C(int n,int m){return n&lt;m||m&lt;0?0:mul(fac[n],mul(ifac[m],ifac[n-m]));}inline int calc1(int x,int ps){ if(x&gt;n)return 0; int res=0; for(ri i=x-ps+1;i&lt;=n;++i)Add(res,mul(C(i-1,x-ps),dec(f1[i][ps],f1[i+1][ps]))); return res;}inline int calc2(int x,int ps){ if(!ps)return C(n,x); if(x&gt;n)return 0; int res=0; for(ri i=x-ps+1;i&lt;=n;++i)Add(res,mul(C(i-1,x-ps),dec(f2[i][ps],f2[i+1][ps]))); return res;}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif init(); for(ri tt=read();tt;--tt){ n=read(),m=read(),K=read(); for(ri i=1;i&lt;=n;++i)a2[i]=read(); for(ri i=1;i&lt;=n;++i)a1[i]=read(); sort(a1+1,a1+n+1); sort(a2+1,a2+n+1); for(ri i=1;i&lt;=n+1;++i)for(ri j=0;j&lt;=n+1;++j)f1[i][j]=f2[i][j]=0; for(ri i=n;i;--i)for(ri j=1;j&lt;=n-i+1;++j) f1[i][j]=add(add(f1[i+1][j],f1[i+1][j-1]),mul(C(n-i,j-1),a1[i])); f2[n+1][0]=1; for(ri i=n;i;--i)for(ri j=0;j&lt;=n-i+1;++j) f2[i][j]=add(f2[i+1][j],mul(a2[i],j?f2[i+1][j-1]:0)); int res=0; for(ri L,R,i=1,up=min(m,n);i&lt;=m;++i){ if(m-i&gt;n)continue; R=min(K-1,m-i); L=K-R; Add(res,mul(calc1(i,L),calc2(m-i,R))); } cout&lt;&lt;res&lt;&lt;&apos;\\n&apos;; } return 0;} &#x73CD;&#x73E0; &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x8003;&#x8651;&#x5230;&#x6BCF;&#x79CD;&#x6570;&#x4F1A;&#x51FA;&#x73B0;&#x5947;&#x6570;&#x6B21;&#x6216;&#x8005;&#x5076;&#x6570;&#x6B21;&#xFF0C;&#x5176;&#x4E2D;&#x5947;&#x6570;&#x6B21;&#x7684;&#x6700;&#x591A;&#x6709; n&#x2212;2mn-2mn&#x2212;2m &#x79CD;&#xFF0C;&#x90A3;&#x4E48;&#x663E;&#x7136;&#x53EF;&#x4EE5;&#x5217;&#x51FA;&#x5982;&#x4E0B;&#x5F0F;&#x5B50;&#xFF1A; Ans=&#xA0;n!&#x2211;i=0n&#x2212;2mCDi(ex&#x2212;e&#x2212;x2)i(ex+e&#x2212;x2)D&#x2212;i[xn]\\begin{aligned} Ans=&amp;\\ n!\\sum\\limits_{i=0}^{n-2m}C_D^i(\\frac{e^x-e^{-x}}2)^i(\\frac{e^x+e^{-x}}2)^{D-i}[x^n] \\end{aligned} Ans=&#x200B;&#xA0;n!i=0&#x2211;n&#x2212;2m&#x200B;CDi&#x200B;(2ex&#x2212;e&#x2212;x&#x200B;)i(2ex+e&#x2212;x&#x200B;)D&#x2212;i[xn]&#x200B; &#x4F46;&#x8FD9;&#x6837;&#x53D8;&#x5F62;&#x540E;&#x5E76;&#x4E0D;&#x597D;&#x8BA1;&#x7B97;&#xFF0C;&#x4E8E;&#x662F;&#x8003;&#x8651;&#x52A0;&#x4E00;&#x4E2A;&#x51FD;&#x6570;&#x5BF9;&#x51FA;&#x73B0;&#x5947;&#x6570;&#x6B21;&#x7684;&#x751F;&#x6210;&#x51FD;&#x6570;&#x8FDB;&#x884C;&#x9650;&#x5236;&#xFF1A; Ans=&#xA0;n!&#x2211;i=0n&#x2212;2m(ex+e&#x2212;x2+yex&#x2212;e&#x2212;x2)D[xn][yi]=n!2D&#x2211;i=0n&#x2212;2m((1+y)ex+(1&#x2212;y)e&#x2212;x)D[xn][yi]=n!2D&#x2211;i=0n&#x2212;2m&#x2211;j=0DCDj(1+y)j(1&#x2212;j)D&#x2212;je(2i&#x2212;D)x[xn][yi]=n!2D&#x2211;i=0DCDi(2i&#x2212;D)nn!&#x2211;j=0n&#x2212;2m(1+y)i(1&#x2212;y)D&#x2212;i[yj]&#x89C2;&#x5BDF;&#x5230;(1+y)+(1&#x2212;y)=2=12D&#x2211;i=0DCDi(2i&#x2212;D)n&#x2211;j=0n&#x2212;2m(2&#x2212;(1&#x2212;y))i(1&#x2212;y)D&#x2212;i[yj]=12D&#x2211;i=0DCDi(2i&#x2212;D)n&#x2211;j=0n&#x2212;2m&#x2211;k=0iCik2k(&#x2212;1)i&#x2212;k(1&#x2212;y)D&#x2212;k[yj]=12D&#x2211;i=0DCDi(2i&#x2212;D)n&#x2211;j=0iCij2j(&#x2212;1)i&#x2212;j&#x2211;k=0n&#x2212;2mCD&#x2212;jk(&#x2212;1)k\\begin{aligned} Ans=&amp;\\ n!\\sum\\limits_{i=0}^{n-2m}(\\frac{e^x+e^{-x}}2+y\\frac{e^x-e^{-x}}2)^D[x^n][y^i]\\\\ =&amp;\\frac{n!}{2^D}\\sum\\limits_{i=0}^{n-2m}((1+y)e^x+(1-y)e^{-x})^D[x^n][y^i]\\\\ =&amp;\\frac{n!}{2^D}\\sum\\limits_{i=0}^{n-2m}\\sum\\limits_{j=0}^DC_{D}^{j}(1+y)^j(1-j)^{D-j}e^{(2i-D)x}[x^n][y^i]\\\\ =&amp;\\frac{n!}{2^D}\\sum\\limits_{i=0}^DC_{D}^{i}\\frac{(2i-D)^n}{n!}\\sum\\limits_{j=0}^{n-2m}(1+y)^i(1-y)^{D-i}[y^j]\\\\ &amp;&#x89C2;&#x5BDF;&#x5230;(1+y)+(1-y)=2\\\\ =&amp;\\frac1{2^D}\\sum\\limits_{i=0}^DC_{D}^{i}(2i-D)^n\\sum\\limits_{j=0}^{n-2m}(2-(1-y))^i(1-y)^{D-i}[y^j]\\\\ =&amp;\\frac1{2^D}\\sum\\limits_{i=0}^DC_{D}^{i}(2i-D)^n\\sum\\limits_{j=0}^{n-2m}\\sum\\limits_{k=0}^iC_{i}^{k}2^k(-1)^{i-k}(1-y)^{D-k}[y^j]\\\\ =&amp;\\frac1{2^D}\\sum\\limits_{i=0}^DC_{D}^{i}(2i-D)^n\\sum\\limits_{j=0}^iC_{i}^{j}2^j(-1)^{i-j}\\sum\\limits_{k=0}^{n-2m}C_{D-j}^{k}(-1)^k\\\\ \\end{aligned} Ans=======&#x200B;&#xA0;n!i=0&#x2211;n&#x2212;2m&#x200B;(2ex+e&#x2212;x&#x200B;+y2ex&#x2212;e&#x2212;x&#x200B;)D[xn][yi]2Dn!&#x200B;i=0&#x2211;n&#x2212;2m&#x200B;((1+y)ex+(1&#x2212;y)e&#x2212;x)D[xn][yi]2Dn!&#x200B;i=0&#x2211;n&#x2212;2m&#x200B;j=0&#x2211;D&#x200B;CDj&#x200B;(1+y)j(1&#x2212;j)D&#x2212;je(2i&#x2212;D)x[xn][yi]2Dn!&#x200B;i=0&#x2211;D&#x200B;CDi&#x200B;n!(2i&#x2212;D)n&#x200B;j=0&#x2211;n&#x2212;2m&#x200B;(1+y)i(1&#x2212;y)D&#x2212;i[yj]&#x89C2;&#x5BDF;&#x5230;(1+y)+(1&#x2212;y)=22D1&#x200B;i=0&#x2211;D&#x200B;CDi&#x200B;(2i&#x2212;D)nj=0&#x2211;n&#x2212;2m&#x200B;(2&#x2212;(1&#x2212;y))i(1&#x2212;y)D&#x2212;i[yj]2D1&#x200B;i=0&#x2211;D&#x200B;CDi&#x200B;(2i&#x2212;D)nj=0&#x2211;n&#x2212;2m&#x200B;k=0&#x2211;i&#x200B;Cik&#x200B;2k(&#x2212;1)i&#x2212;k(1&#x2212;y)D&#x2212;k[yj]2D1&#x200B;i=0&#x2211;D&#x200B;CDi&#x200B;(2i&#x2212;D)nj=0&#x2211;i&#x200B;Cij&#x200B;2j(&#x2212;1)i&#x2212;jk=0&#x2211;n&#x2212;2m&#x200B;CD&#x2212;jk&#x200B;(&#x2212;1)k&#x200B; &#x63A8;&#x5BFC;&#x5230;&#x8FD9;&#x91CC;&#x5DF2;&#x7ECF;&#x6709; 60pts60pts60pts &#x4E86; CODE cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}namespace modular{ const int mod=998244353; inline int add(int a,int b){return (a+=b)&lt;mod?a:a-mod;} inline void Add(int&amp;a,int b){a=add(a,b);} inline int dec(int a,int b){return (a-=b)&lt;0?a+mod:a;} inline void Dec(int&amp;a,int b){a=dec(a,b);} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;}}using namespace modular;const int N=4005;int n,m,D,C[N][N],pw[N],_s[N][N];inline void init(){ pw[0]=1; for(ri i=1;i&lt;=D;++i)pw[i]=add(pw[i-1],pw[i-1]); for(ri i=0;i&lt;=D;++i){ C[i][0]=1; for(ri j=1;j&lt;=i;++j) C[i][j]=add(C[i-1][j-1],C[i-1][j]); } for(ri i=0;i&lt;=D;++i){ _s[i][0]=C[i][0]; for(ri j=1;j&lt;=i;++j) _s[i][j]=add(_s[i][j-1],j&amp;1?mod-C[i][j]:C[i][j]); }}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif D=read(),n=read(),m=read(); if(n&lt;2*m)return puts(&quot;0&quot;),0; init(); int res=0; for(ri c1,c2,i=0;i&lt;=D;++i){ c1=mul(C[D][i],ksm(dec(2*i,D),n)); for(ri j=0;j&lt;=i;++j){ c2=mul(pw[j],C[i][j]); if((i-j)&amp;1)c2=mod-c2; Add(res,mul(c1,mul(c2,_s[D-j][min(D-j,n-2*m)]))); } } cout&lt;&lt;mul(res,ksm(pw[D],mod-2)); return 0;} &#x7EE7;&#x7EED;&#x63A8;&#x5BFC; &#x7136;&#x540E;&#x7ECF;&#x8FC7;&#x7B80;&#x5355;&#x63A8;&#x5BFC;&#x5BB9;&#x6613;&#x53D1;&#x73B0;&#xFF0C;s(n,m)=&#x2211;i=0mCni(&#x2212;1)i=(&#x2212;1)mCi&#x2212;1m&#xA0;(m=&#x338;0)s(n,m)=\\sum\\limits_{i=0}^mC_{n}^{i}(-1)^i=(-1)^mC_{i-1}^{m}\\ (m\\not=0)s(n,m)=i=0&#x2211;m&#x200B;Cni&#x200B;(&#x2212;1)i=(&#x2212;1)mCi&#x2212;1m&#x200B;&#xA0;(m&#xE020;&#x200B;=0) &#x4EE4; fi=s(D&#x2212;i,n&#x2212;m&#x2217;2)f_i=s(D-i,n-m*2)fi&#x200B;=s(D&#x2212;i,n&#x2212;m&#x2217;2) &#x539F;&#x5F0F;&#x53D8;&#x4E3A;&#xFF1A; 12D&#x2211;i=0DCDi(2i&#x2212;D)n&#x2211;j=0iCijfj2j(&#x2212;1)i&#x2212;j=12D&#x2211;i=0DCDi(2i&#x2212;D)ni!&#x2211;j=0ifj2jj!(&#x2212;1)i&#x2212;j(i&#x2212;j)!\\begin{aligned} &amp;\\frac1{2^D}\\sum\\limits_{i=0}^DC_{D}^{i}(2i-D)^n\\sum\\limits_{j=0}^iC_{i}^{j}f_j2^j(-1)^{i-j}\\\\ =&amp;\\frac1{2^D}\\sum\\limits_{i=0}^DC_{D}^{i}(2i-D)^ni!\\sum\\limits_{j=0}^i\\frac{f_j2^j}{j!}\\frac{(-1)^{i-j}}{(i-j)!}\\\\ \\end{aligned} =&#x200B;2D1&#x200B;i=0&#x2211;D&#x200B;CDi&#x200B;(2i&#x2212;D)nj=0&#x2211;i&#x200B;Cij&#x200B;fj&#x200B;2j(&#x2212;1)i&#x2212;j2D1&#x200B;i=0&#x2211;D&#x200B;CDi&#x200B;(2i&#x2212;D)ni!j=0&#x2211;i&#x200B;j!fj&#x200B;2j&#x200B;(i&#x2212;j)!(&#x2212;1)i&#x2212;j&#x200B;&#x200B; &#x7136;&#x540E;&#x5377;&#x79EF;&#x5904;&#x7406;&#x51FA; gi=&#x2211;j=0ifj2jj!(&#x2212;1)i&#x2212;j(i&#x2212;j)!g_i=\\sum\\limits_{j=0}^i\\frac{f_j2^j}{j!}\\frac{(-1)^{i-j}}{(i-j)!}gi&#x200B;=j=0&#x2211;i&#x200B;j!fj&#x200B;2j&#x200B;(i&#x2212;j)!(&#x2212;1)i&#x2212;j&#x200B; &#x5373;&#x53EF; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef vector&lt;int&gt; poly;typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}namespace modular{ const int mod=998244353; inline int add(int a,int b){return (a+=b)&lt;mod?a:a-mod;} inline void Add(int&amp;a,int b){a=add(a,b);} inline int dec(int a,int b){return (a-=b)&lt;0?a+mod:a;} inline void Dec(int&amp;a,int b){a=dec(a,b);} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;} inline int Inv(int x){return ksm(x,mod-2);}}using namespace modular;const int N=1e5+5;int n,m,D,fac[N],ifac[N],pw[N];inline void init(){ fac[0]=fac[1]=ifac[0]=ifac[1]=1,pw[0]=1,pw[1]=2; for(ri i=2;i&lt;=D;++i){ pw[i]=add(pw[i-1],pw[i-1]); fac[i]=mul(fac[i-1],i); ifac[i]=mul(ifac[mod-mod/i*i],mod-mod/i); } for(ri i=2;i&lt;=D;++i)Mul(ifac[i],ifac[i-1]);}vector&lt;int&gt;rev[23];int invv[23],w[23];inline void init_ntt(){ invv[0]=1; for(ri iv=mod+1&gt;&gt;1,i=1;i&lt;23;++i) invv[i]=mul(invv[i-1],iv); w[22]=ksm(3,(mod-1)&gt;&gt;23); for(ri i=21;~i;--i)w[i]=mul(w[i+1],w[i+1]);}int lim,tim;inline void init(int up){ lim=1,tim=0; while(lim&lt;up)lim&lt;&lt;=1,++tim; if(rev[tim].size())return; rev[tim].resize(lim); for(ri i=1;i&lt;lim;++i)rev[tim][i]=(rev[tim][i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(tim-1));}inline void ntt(poly&amp;a,int type){ for(ri i=0;i&lt;lim;++i)if(i&lt;rev[tim][i])swap(a[i],a[rev[tim][i]]); for(ri i=1,t=0,a0,a1;i&lt;lim;i&lt;&lt;=1,++t)for(ri j=0,len=i&lt;&lt;1;j&lt;lim;j+=len) for(ri k=0,mt=1;k&lt;i;++k,Mul(mt,w[t])) a0=a[j+k],a1=mul(a[j+k+i],mt),a[j+k]=add(a0,a1),a[j+k+i]=dec(a0,a1); if(~type)return; reverse(++a.begin(),a.end()); for(ri i=0;i&lt;lim;++i)Mul(a[i],invv[tim]);}inline poly operator*(poly a,poly b){ int n=a.size(),m=b.size(),t=n+m-1; if(t&lt;=64){ poly c(t); for(ri i=0;i&lt;n;++i)for(ri j=0;j&lt;m;++j) Add(c[i+j],mul(a[i],b[j])); return c; } init(t); a.resize(lim),ntt(a,1); b.resize(lim),ntt(b,1); for(ri i=0;i&lt;lim;++i)Mul(a[i],b[i]); return ntt(a,-1),a.resize(t),a;}int f[N],g[N];inline int C(int n,int m){return n&lt;m||m&lt;0?0:mul(fac[n],mul(ifac[m],ifac[n-m]));}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif D=read(),n=read(),m=read(); if(n&lt;2*m)return puts(&quot;0&quot;),0; init(); init_ntt(); if(n==2*m)for(ri i=0;i&lt;=D;++i)f[i]=1; else{ if(n&amp;1)for(ri i=0;i&lt;=D;++i)f[i]=n-m*2&gt;=i?!i:add(dec(0,C(i-1,n-m*2)),i==1); else for(ri i=0;i&lt;=D;++i)f[i]=n-m*2&gt;=i?!i:add(C(i-1,n-m*2),i==1); } poly a(D+1),b(D+1); for(ri i=0;i&lt;=D;++i)a[i]=mul(f[D-i],mul(pw[i],ifac[i])),b[i]=i&amp;1?dec(0,ifac[i]):ifac[i]; a=a*b; int res=0; for(ri i=0;i&lt;=D;++i)Add(res,mul(mul(C(D,i),ksm(dec(2*i,D),n)),mul(a[i],fac[i]))); cout&lt;&lt;mul(res,Inv(pw[D])); return 0;}","categories":[{"name":"public","slug":"public","permalink":"http://xdl030112.github.io/categories/public/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://xdl030112.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"杂题乱做 Round5","slug":"sol5","date":"2019-11-05T14:40:45.000Z","updated":"2019-12-26T04:28:08.918Z","comments":true,"path":"sol5/","link":"","permalink":"http://xdl030112.github.io/sol5/","excerpt":"","text":"&#x67D3;&#x8272; &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x5BF9;&#x4E8E; k=2k=2k=2 &#x7684;&#x60C5;&#x51B5;&#x7279;&#x5224;&#x4E00;&#x4E0B;&#xFF0C;&#x7136;&#x540E;&#x5269;&#x4E0B;&#x7684;&#x70B9;&#x53D1;&#x73B0;&#x7528;&#x72B6;&#x538B; dpdpdp &#x4F1A; TLETLETLE &#xFF0C;&#x4E8E;&#x662F;&#x6309;&#x683C;&#x5B50;&#x8F6C;&#x79FB;&#xFF0C;&#x5199;&#x4E2A; kkk &#x8FDB;&#x5236;&#x8F6E;&#x5ED3;&#x7EBF;&#x5373;&#x53EF; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include&lt;bits/stdc++.h&gt;#include&lt;tr1/unordered_map&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;typedef unsigned long long Ull;typedef unsigned int uii;typedef tr1::unordered_map&lt;int,int&gt;::iterator It;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline ll readl(){ ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s){ int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;}namespace modular{ const int mod=376544743; inline int add(int a,int b){return a+b&lt;mod?a+b:a+b-mod;} inline int dec(int a,int b){return a&lt;b?a-b+mod:a-b;} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Add(int&amp;a,int b){a=a+b&lt;mod?a+b:a+b-mod;} inline void Dec(int&amp;a,int b){a=a&lt;b?a-b+mod:a-b;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;} inline int Inv(int a){return ksm(a,mod-2);} inline void fix(int&amp;a){a=(a%mod+mod)%mod;}}using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b){a&gt;b?a=b:0;}template&lt;typename T&gt;inline void ckmax(T&amp;a,T b){a&lt;b?a=b:0;}const int N=1e5+5;int n,m,K,a1[N],a2[N],cur=0,pw[15],sta=0;tr1::unordered_map&lt;int,int&gt;f[2],tmp;int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(),m=read(),K=read(); for(ri i=1;i&lt;=m;++i)a1[i]=read(); for(ri i=1;i&lt;=m;++i)a2[i]=read(); if(K==2){ for(ri i=1;i&lt;=m;++i){ if(i&gt;1&amp;&amp;(a1[i]==a1[i-1]||a2[i]==a2[i-1])){ puts(&quot;0&quot;); return 0; } if(!(a1[i]^a2[i]^(n&amp;1))){ puts(&quot;0&quot;); return 0; } } puts(&quot;1&quot;); return 0; } pw[0]=1; int ss=0; for(ri i=1;i&lt;=m;++i)pw[i]=pw[i-1]*K,ss+=pw[i]*a1[i]; f[cur=0][ss]=1; for(ri ns,sta,trans,i=2;i&lt;n;++i){ for(ri j=1;j&lt;=m;++j){ cur^=1; f[cur].clear(); for(It it=f[cur^1].begin();it!=f[cur^1].end();++it){ sta=it-&gt;fi,trans=it-&gt;se; for(ri k=0;k&lt;K;++k){ if((j!=1&amp;&amp;(k==sta/pw[j-1]%K))||k==sta/pw[j]%K)continue; ns=sta-(sta/pw[j]%K)*pw[j]-(sta/pw[j-1]%K)*pw[j-1]; ns+=k*pw[j]+k*pw[j-1]; Add(f[cur][ns],trans); } } } tmp.clear(); for(It it=f[cur].begin();it!=f[cur].end();++it)tmp[it-&gt;fi%pw[m]*K]=it-&gt;se; f[cur]=tmp; } int res=0,sta,trans; for(It it=f[cur].begin();it!=f[cur].end();++it){ bool ff=1; sta=it-&gt;fi,trans=it-&gt;se; for(ri i=1;i&lt;=m;++i)if(sta/pw[i]%K==a2[i]){ ff=0; break; } if(ff)Add(res,trans); } cout&lt;&lt;res; return 0;} &#x5916;&#x661F;&#x4EBA; &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x8003;&#x8651;&#x628A;&#x6240;&#x6709;&#x4EBA;&#x4ECE;&#x5C0F;&#x5230;&#x5927;&#x6392;&#x5E8F;&#xFF0C;&#x7136;&#x540E;&#x4E00;&#x4E2A;&#x4E00;&#x4E2A;&#x63D2;&#x5165;&#x73B0;&#x5728;&#x7684;&#x5E8F;&#x5217;&#xFF0C;&#x8FD9;&#x6837;&#x4E00;&#x4E2A;&#x4EBA;&#x6709;&#x8D21;&#x732E;&#x5F53;&#x4E14;&#x4EC5;&#x5F53;&#x5176;&#x5728;&#x961F;&#x9996;&#xFF0C;&#x7136;&#x540E;&#x8F6C;&#x79FB;&#x5373;&#x53EF; CODE cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;#include&lt;tr1/unordered_map&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;typedef unsigned long long Ull;typedef unsigned int uii;typedef tr1::unordered_map&lt;int,int&gt;::iterator It;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline ll readl(){ ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s){ int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;}namespace modular{ const int mod=998244353; inline int add(int a,int b){return a+b&lt;mod?a+b:a+b-mod;} inline int dec(int a,int b){return a&lt;b?a-b+mod:a-b;} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Add(int&amp;a,int b){a=a+b&lt;mod?a+b:a+b-mod;} inline void Dec(int&amp;a,int b){a=a&lt;b?a-b+mod:a-b;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;} inline int Inv(int a){return ksm(a,mod-2);} inline void fix(int&amp;a){a=(a%mod+mod)%mod;}}using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b){a&gt;b?a=b:0;}template&lt;typename T&gt;inline void ckmax(T&amp;a,T b){a&lt;b?a=b:0;}const int N=5005;int n,x,a[N],cur;struct F{ int x,y; F(int x=0,int y=0):x(x*(y!=0)),y(y){} friend inline F operator+(F a,F b){return a.x^b.x?(a.x&gt;b.x?a:b):F(a.x,add(a.y,b.y));} friend inline void operator+=(F&amp;a,F b){a=a+b;} friend inline F operator*(F a,int b){return F(a.x,mul(a.y,b));}}f[2][N];int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(),x=read(); for(ri i=1;i&lt;=n;++i)a[i]=read(); sort(a+1,a+n+1); cur=0; for(ri i=0;i&lt;=x;++i)f[cur][i]=F(i,1); for(ri i=1;i&lt;=n;++i){ cur^=1; for(ri j=0;j&lt;=x;++j)f[cur][j]=f[cur^1][j]*(i-1); for(ri j=0;j&lt;=x;++j)f[cur][j]+=f[cur^1][j%a[i]]; } cout&lt;&lt;f[cur][x].x&lt;&lt;&apos;\\n&apos;&lt;&lt;f[cur][x].y; return 0;} Lesson Timetable &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x6BD4;&#x8F83;&#x7B80;&#x5355;&#x7684;&#x7EC4;&#x5408;&#x8BA1;&#x6570; &#x5148;&#x4E0D;&#x8003;&#x8651;&#x6807;&#x53F7;&#xFF0C;&#x8BBE; fi,jf_{i,j}fi,j&#x200B; &#x8868;&#x793A;&#x524D; iii &#x4E2A;&#x4F4D;&#x7F6E;&#x653E;&#x4E86; jjj &#x4E2A;&#x4EBA;&#x7684;&#x65B9;&#x6848;&#x6570;&#xFF0C;&#x53EF;&#x4EE5;&#x8F7B;&#x677E;&#x8F6C;&#x79FB;&#xFF0C;&#x6700;&#x540E;&#x518D;&#x8BA1;&#x7B97;&#x6807;&#x53F7;&#x7684;&#x8D21;&#x732E;&#x5373;&#x53EF; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;typedef unsigned long long Ull;typedef unsigned int uii;typedef map&lt;int,int&gt;::iterator It;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline ll readl(){ ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s){ int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;}namespace modular{ const int mod=1e9+7; inline int add(int a,int b){return a+b&lt;mod?a+b:a+b-mod;} inline int dec(int a,int b){return a&lt;b?a-b+mod:a-b;} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Add(int&amp;a,int b){a=a+b&lt;mod?a+b:a+b-mod;} inline void Dec(int&amp;a,int b){a=a&lt;b?a-b+mod:a-b;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;} inline int Inv(int a){return ksm(a,mod-2);} inline void fix(int&amp;a){a=(a%mod+mod)%mod;}}using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b){a&gt;b?a=b:0;}template&lt;typename T&gt;inline void ckmax(T&amp;a,T b){a&lt;b?a=b:0;}const int N=1005;int f[2][N],n,m,cur=0,fac[N],ifac[N],sum[N];inline void init(){ fac[0]=fac[1]=ifac[0]=ifac[1]=1; for(ri i=2;i&lt;=m;++i){ fac[i]=mul(fac[i-1],i); ifac[i]=mul(ifac[mod-mod/i*i],mod-mod/i); } for(ri i=2;i&lt;=m;++i)Mul(ifac[i],ifac[i-1]);}inline int C(int n,int m){return n&lt;m||m&lt;0?0:mul(fac[n],mul(ifac[m],ifac[n-m]));}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(); for(ri i=1;i&lt;=n;++i)sum[i]=sum[i-1]+read(); m=sum[n]; init(); f[cur=0][0]=1; for(ri i=1,x;i&lt;=n;++i){ x=read(); cur^=1; for(ri j=0;j&lt;=sum[i];++j)f[cur][j]=0; for(ri j=0;j&lt;=sum[i-1];++j)if(f[cur^1][j])for(ri k=0,up=min(sum[i]-j,x);k&lt;=up;++k) Add(f[cur][j+k],mul(f[cur^1][j],C(sum[i]-j,k))); } int res=f[cur][m]; for(ri i=1;i&lt;=n;++i)Mul(res,C(sum[n]-sum[i-1],sum[i]-sum[i-1])); cout&lt;&lt;res; return 0;} On the Bench &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x8003;&#x8651;&#x5230;&#x82E5;&#x6709; a&#xD7;b,a&#xD7;ca\\times b,a\\times ca&#xD7;b,a&#xD7;c &#x5747;&#x4E3A;&#x5B8C;&#x5168;&#x5E73;&#x65B9;&#x6570;&#x7684;&#x8BDD;&#xFF0C;&#x90A3;&#x4E48; b&#xD7;cb\\times cb&#xD7;c &#x4E5F;&#x4E3A;&#x5B8C;&#x5168;&#x5E73;&#x65B9;&#x6570;&#xFF0C;&#x4E8E;&#x662F;&#x53EF;&#x4EE5;&#x628A;&#x6574;&#x4E2A;&#x6570;&#x5217;&#x5206;&#x6210;&#x82E5;&#x5E72;&#x4E0D;&#x76F8;&#x4EA4;&#x7EC4;&#xFF0C;&#x7EC4;&#x5185;&#x5143;&#x7D20;&#x76F8;&#x4E58;&#x5FC5;&#x5B9A;&#x4E3A;&#x5B8C;&#x5168;&#x5E73;&#x65B9;&#x6570;&#xFF0C;&#x4E0D;&#x540C;&#x7EC4;&#x4E24;&#x4E2A;&#x6570;&#x76F8;&#x4E58;&#x5FC5;&#x5B9A;&#x4E0D;&#x4E3A;&#x5B8C;&#x5168;&#x5E73;&#x65B9;&#x6570; &#x90A3;&#x4E48;&#x73B0;&#x5728;&#x95EE;&#x9898;&#x8F6C;&#x5316;&#x6210;&#x4E86;&#x7ED9;&#x4F60; mmm &#x4E2A;&#x7EC4;&#xFF0C;&#x8FD9; mmm &#x4E2A;&#x7EC4;&#x4E00;&#x5171;&#x6709; nnn &#x4E2A;&#x6570;&#xFF0C;&#x8BA9;&#x4F60;&#x5C06;&#x8FD9; nnn &#x4E2A;&#x6570;&#x8FDB;&#x884C;&#x6392;&#x5217;&#xFF0C;&#x4F7F;&#x5F97;&#x76F8;&#x90BB;&#x4E24;&#x4E2A;&#x6570;&#x4E0D;&#x5C5E;&#x4E8E;&#x540C;&#x4E00;&#x4E2A;&#x7EC4;&#xFF0C;&#x95EE;&#x65B9;&#x6848;&#x6570; &#x968F;&#x4FBF;&#x6784;&#x9020;&#x4E2A;&#x5E26;&#x5BB9;&#x65A5;&#x7CFB;&#x6570;&#x7684;&#x989D;&#x751F;&#x6210;&#x51FD;&#x6570;&#x4E58;&#x8D77;&#x6765;&#x5373;&#x53EF;&#xFF0C;&#x8DDF; [JSOI2019]&#x795E;&#x7ECF;&#x7F51;&#x7EDC; &#x7C7B;&#x4F3C; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;typedef unsigned long long Ull;typedef unsigned int uii;typedef map&lt;int,int&gt;::iterator It;typedef vector&lt;int&gt; poly;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline ll readl(){ ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s){ int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;}namespace modular{ const int mod=1e9+7; inline int add(int a,int b){return a+b&lt;mod?a+b:a+b-mod;} inline int dec(int a,int b){return a&lt;b?a-b+mod:a-b;} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Add(int&amp;a,int b){a=a+b&lt;mod?a+b:a+b-mod;} inline void Dec(int&amp;a,int b){a=a&lt;b?a-b+mod:a-b;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;} inline int Inv(int a){return ksm(a,mod-2);} inline void fix(int&amp;a){a=(a%mod+mod)%mod;}}using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b){a&gt;b?a=b:0;}template&lt;typename T&gt;inline void ckmax(T&amp;a,T b){a&lt;b?a=b:0;}const int N=305;int n,all=0,fac[N],ifac[N];vector&lt;int&gt;vl[N];poly f,g;inline void init(){ fac[0]=fac[1]=ifac[0]=ifac[1]=1; for(ri i=2;i&lt;=n;++i){ fac[i]=mul(fac[i-1],i); ifac[i]=mul(ifac[mod-mod/i*i],mod-mod/i); } for(ri i=2;i&lt;=n;++i)Mul(ifac[i],ifac[i-1]);}inline int C(int n,int m){return n&lt;m||m&lt;0?0:mul(fac[n],mul(ifac[m],ifac[n-m]));}inline bool check(int a,int b){ int c=sqrt((ll)a*b); return (ll)c*c==(ll)a*b;}inline poly operator*(poly a,poly b){ int n=a.size(),m=b.size(),t=n+m-1; poly c(t); for(ri i=0;i&lt;n;++i)for(ri j=0;j&lt;m;++j) Add(c[i+j],mul(a[i],b[j])); return c;}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(); init(); for(ri x,i=1;i&lt;=n;++i){ x=read(); bool ff=1; for(ri j=1;j&lt;=all;++j)if(check(vl[j].back(),x)){ ff=0; vl[j].pb(x); break; } if(ff)vl[++all].pb(x); } f=poly(1,1); int mt=1,res=0; for(ri pre=0,i=1;i&lt;=all;++i){ g.resize(vl[i].size()+1); g[0]=0; for(ri j=1,up=vl[i].size();j&lt;=up;++j)g[j]=(up-j)&amp;1?mod-C(up-1,j-1):C(up-1,j-1); for(ri j=0;j&lt;=vl[i].size();++j)Mul(g[j],ifac[j]); f=f*g; pre+=vl[i].size(); Mul(mt,fac[vl[i].size()]); } for(ri i=0;i&lt;f.size();++i)Add(res,mul(f[i],fac[i])); cout&lt;&lt;mul(mt,res); return 0;} &#x6458;&#x82F9;&#x679C; &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x9996;&#x5148;&#x8003;&#x8651;&#x4E00;&#x4E2A;&#x4F4D;&#x7F6E; vvv &#x5728;&#x7B2C;&#x4E00;&#x8F6E;&#x88AB;&#x8D70;&#x5230;&#x7684;&#x6982;&#x7387;&#xFF0C;&#x53D1;&#x73B0;&#x662F; &#x2211;u,[(u,v)&#x2282;e]duu2m&#xD7;duu=&#x2211;duv12m=duv2m\\sum\\limits_{u,[(u,v)\\subset e]}\\frac{du_u}{2m}\\times du_u=\\sum\\limits_{du_v}\\frac1{2m}=\\frac{du_v}{2m}u,[(u,v)&#x2282;e]&#x2211;&#x200B;2mduu&#x200B;&#x200B;&#xD7;duu&#x200B;=duv&#x200B;&#x2211;&#x200B;2m1&#x200B;=2mduv&#x200B;&#x200B; &#x8FD9;&#x6837;&#x63A8;&#x4E0B;&#x53BB;&#x90A3;&#x4E48;&#x6BCF;&#x4E00;&#x8F6E;&#x8D70;&#x5230;&#x70B9; iii &#x7684;&#x6982;&#x7387;&#x90FD;&#x662F; dui2m\\frac{du_i}{2m}2mdui&#x200B;&#x200B; &#xFF0C;&#x6210; sbsbsb &#x9898;&#x4E86; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;typedef unsigned long long Ull;typedef unsigned int uii;typedef map&lt;int,int&gt;::iterator It;typedef vector&lt;int&gt; poly;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline ll readl(){ ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s){ int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;}namespace modular{ const int mod=1e9+7; inline int add(int a,int b){return a+b&lt;mod?a+b:a+b-mod;} inline int dec(int a,int b){return a&lt;b?a-b+mod:a-b;} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Add(int&amp;a,int b){a=a+b&lt;mod?a+b:a+b-mod;} inline void Dec(int&amp;a,int b){a=a&lt;b?a-b+mod:a-b;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;} inline int Inv(int a){return ksm(a,mod-2);} inline void fix(int&amp;a){a=(a%mod+mod)%mod;}}using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b){a&gt;b?a=b:0;}template&lt;typename T&gt;inline void ckmax(T&amp;a,T b){a&lt;b?a=b:0;}const int N=1e5+5;vector&lt;int&gt;e[N];int n,K,m,a[N];int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(),m=read(),K=read(); for(ri i=1;i&lt;=n;++i)a[i]=read(); for(ri i=1,u,v;i&lt;=m;++i){ u=read(),v=read(); e[u].pb(v); e[v].pb(u); } int res=0; for(ri i=1,iv=Inv(2*m);i&lt;=n;++i)Add(res,mul(mul(e[i].size(),iv),a[i])); cout&lt;&lt;mul(res,K); return 0;} &#x5047;&#x9762; &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x8003;&#x8651;&#x8BBE; fi,jf_{i,j}fi,j&#x200B; &#x8868;&#x793A;&#x7B2C; iii &#x4E2A;&#x4EBA;&#x8FD8;&#x5269; jjj &#x70B9;&#x8840;&#x7684;&#x6982;&#x7387;&#xFF0C;&#x7136;&#x540E;&#x5BF9;&#x4E00;&#x4E2A;&#x4EBA; 111 &#x64CD;&#x4F5C;&#x76F4;&#x63A5; O(ai)O(a_i)O(ai&#x200B;) &#x8F6C;&#x79FB; fif_ifi&#x200B; &#xFF0C; 222 &#x64CD;&#x4F5C;&#x628A;&#x9700;&#x8981;&#x7684;&#x70B9;&#x63D0;&#x51FA;&#x6765;&#x8865;&#x96C6;&#x8F6C;&#x5316;&#x5373;&#x53EF; &#x5F53;&#x7136;&#x5982;&#x679C;&#x4F60;&#x50CF;&#x6211;&#x4E00;&#x6837;&#x61D2;&#x7684;&#x8BDD;&#x4E5F;&#x53EF;&#x4EE5;&#x5199;&#x4E00;&#x4E2A;&#x66B4;&#x529B;&#x524D;&#x540E;&#x7F00;&#x4F18;&#x5316;&#x8279;&#x8FC7;&#x53BB;&#xFF0C;&#x4E0D;&#x8FC7;&#x590D;&#x6742;&#x5EA6;&#x662F;&#x9519;&#x7684;&#xFF0C;&#x5F53;&#x7136;&#x6211;&#x5C1D;&#x8BD5;&#x52A0;&#x4E0A;&#x4E86;ntt&#x4F18;&#x5316;&#x7ED3;&#x679C;&#x672C;&#x6765;&#x80FD;&#x5361;&#x8FC7;&#x53BB;&#x7684;TLE&#x4E86;&#x3002; CODE(&#x66B4;&#x529B;&#x975E;&#x6B63;&#x89E3;&#x4F18;&#x5316;) cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;typedef unsigned long long Ull;typedef unsigned int uii;typedef map&lt;int,int&gt;::iterator It;typedef vector&lt;int&gt; poly;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline ll readl(){ ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s){ int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;}namespace modular{ const int mod=998244353; inline int add(int a,int b){return a+b&lt;mod?a+b:a+b-mod;} inline int dec(int a,int b){return a&lt;b?a-b+mod:a-b;} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Add(int&amp;a,int b){a=a+b&lt;mod?a+b:a+b-mod;} inline void Dec(int&amp;a,int b){a=a&lt;b?a-b+mod:a-b;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;} inline int Inv(int a){return ksm(a,mod-2);} inline void fix(int&amp;a){a=(a%mod+mod)%mod;}}using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b){a&gt;b?a=b:0;}template&lt;typename T&gt;inline void ckmax(T&amp;a,T b){a&lt;b?a=b:0;}const int N=205;int n,q,c,a[N],f[N][N],m,g[N],ps[N],inv[N];inline void init(){ inv[1]=1; for(ri i=2;i&lt;=n;++i)inv[i]=mul(inv[mod-mod/i*i],mod-mod/i);}inline int query(int id){ int res=0,ad=0; for(ri i=0;i&lt;=a[id];++i)Add(ad,f[id][i]); assert(ad==1); for(ri i=1;i&lt;=a[id];++i)Add(res,mul(i,f[id][i])); return res;}inline void DP(){ static int pre[N][N],suf[N][N],ss[N]; m=read(); for(ri i=1;i&lt;=m;++i)ps[i]=read(); for(ri i=1;i&lt;=m;++i)pre[0][i]=suf[m+1][i]=0; pre[0][0]=suf[m+1][0]=1; for(ri i=1,P1,P2;i&lt;=m;++i){ P1=dec(1,f[ps[i]][0]),P2=f[ps[i]][0]; for(ri j=1;j&lt;=m;++j)pre[i][j]=add(mul(pre[i-1][j-1],P1),mul(pre[i-1][j],P2)); pre[i][0]=mul(pre[i-1][0],P2); } for(ri i=m,P1,P2;i;--i){ P1=dec(1,f[ps[i]][0]),P2=f[ps[i]][0]; for(ri j=1;j&lt;=m;++j)suf[i][j]=add(mul(suf[i+1][j-1],P1),mul(suf[i+1][j],P2)); suf[i][0]=mul(suf[i+1][0],P2); } for(ri res=0,i=1,P;i&lt;=m;++i,res=0){ P=dec(1,f[ps[i]][0]); for(ri j=0;j&lt;m;++j)if(pre[i-1][j])for(ri k=0;j+k&lt;m;++k)if(suf[i+1][k]) Add(ss[j+k],mul(pre[i-1][j],suf[i+1][k])); for(ri j=0;j&lt;m;++j){ Add(res,mul(ss[j],inv[j+1])); ss[j]=0; } cout&lt;&lt;mul(res,P)&lt;&lt;&apos; &apos;; } puts(&quot;&quot;);}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(); for(ri i=1;i&lt;=n;++i){ a[i]=read(); f[i][a[i]]=1; } init(); for(ri op,p,vl,tt=read();tt;--tt){ op=read(); if(!op){ p=read(),vl=read(); Mul(vl,Inv(read())); for(ri i=0;i&lt;=a[p];++i)f[p][i]=add(mul(f[p][i],i?dec(1,vl):1),mul(f[p][i+1],vl)); } else DP(); } for(ri i=1;i&lt;=n;++i)cout&lt;&lt;query(i)&lt;&lt;&apos; &apos;; return 0;} &#x8BB0;&#x5FC6;&#x7684;&#x8F6E;&#x5ED3; &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x6C34;&#x9898;&#xFF0C;&#x8003;&#x8651;&#x9884;&#x5904;&#x7406;&#x4E00;&#x4E0B; wi,jw_{i,j}wi,j&#x200B; &#x8868;&#x793A;&#x5F53;&#x524D; i,ji,ji,j &#x4E3A;&#x7279;&#x6B8A;&#x70B9;&#xFF0C; i+1&#x22EF;j&#x2212;1i+1\\cdots j-1i+1&#x22EF;j&#x2212;1 &#x5747;&#x4E0D;&#x4E3A;&#x7279;&#x6B8A;&#x70B9;&#x65F6;&#x4ECE; iii &#x5230; jjj &#x7684;&#x671F;&#x671B;&#x6B65;&#x6570;&#xFF0C;&#x7136;&#x540E;&#x663E;&#x7136; wi,jw_{i,j}wi,j&#x200B; &#x6EE1;&#x8DB3;&#x56DB;&#x8FB9;&#x5F62;&#x4E0D;&#x7B49;&#x5F0F;&#xFF0C;&#x4E8E;&#x662F;&#x968F;&#x4FBF;&#x4E0A;&#x4E00;&#x4E2A;&#x51B3;&#x7B56;&#x5355;&#x8C03;&#x6027;&#x4F18;&#x5316;&#x5373;&#x53EF;&#xFF0C;&#x4E0D;&#x8FC7;&#x8BE5;&#x9898;&#x7528; O(n2)O(n^2)O(n2) &#x7684;&#x5199;&#x6CD5;&#x7684;&#x8BDD;&#x6700;&#x597D; infinfinf &#x8BBE;&#x5230; 1e3001e3001e300 &#x5DE6;&#x53F3;&#xFF0C;&#x53E6;&#x5916;&#x4E24;&#x79CD;&#x53EF;&#x4EE5;&#x4E0D;&#x7528; infinfinf &#x56E0;&#x6B64;&#x5C31;&#x4E0D;&#x5B58;&#x5728;&#x4EC0;&#x4E48;&#x95EE;&#x9898; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_backusing namespace std;typedef pair&lt;int,int&gt; pii;typedef long long ll;typedef unsigned long long Ull;typedef unsigned int Uint;typedef double db;typedef long double ld;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;typedef pair&lt;ll,ll&gt; pll;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch==&apos;-&apos;,ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;}inline ll readl(){ ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s){ int top=0; char ch=gc(); while(!isdigit(ch)&amp;&amp;ch!=&apos;?&apos;)ch=gc(); while(isdigit(ch)||ch==&apos;?&apos;)s[++top]=ch,ch=gc(); return top;}namespace modular{ const int mod=1e9+7; inline int add(int a,int b){return a+b&lt;mod?a+b:a+b-mod;} inline int dec(int a,int b){return a&lt;b?a-b+mod:a-b;} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Add(int&amp;a,int b){a=a+b&lt;mod?a+b-mod:a+b;} inline void Dec(int&amp;a,int b){a=a&lt;b?a-b+mod:a-b;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;} inline int Inv(int a){return ksm(a,mod-2);} inline void fix(int&amp;a){a=(a%mod+mod)%mod;}}using namespace modular;template&lt;typename T&gt;inline void ckmax(T&amp;a,T&amp;b){a&lt;b?a=b:0;}template&lt;typename T&gt;inline void ckmin(T&amp;a,T&amp;b){a&gt;b?a=b:0;}const int N=1505,M=705;int n,m,K,cur=0;ld dis[M],f[2][M],w[M][M];vector&lt;int&gt;e[N];void dfs(int p,int dep,int ori,ld coe){ if(!e[p].size()){ dis[ori]+=coe*dep; return; } int du=e[p].size()+(ori==p); for(ri i=0;i&lt;e[p].size();++i) dfs(e[p][i],dep+1,ori,coe/(ld)du);}inline ld calc(int x,int p){return f[cur^1][x]+w[x][p];}inline void solve(int l,int r,int L,int R){ if(L==R){ for(ri i=l;i&lt;=r;++i)f[cur][i]=calc(L,i); return; } int mid=l+r&gt;&gt;1,ps=L; ld tmp=calc(ps,mid),t; for(ri i=ps+1;i&lt;=R&amp;&amp;i&lt;mid;++i)if((t=calc(i,mid))&lt;tmp){ tmp=t; ps=i; } f[cur][mid]=tmp; if(l&lt;mid)solve(l,mid-1,L,ps); if(mid&lt;r)solve(mid+1,r,ps,R);}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif for(ri tt=read();tt;--tt){ n=read(),m=read(),K=read(); for(ri i=1;i&lt;=m;++i)e[i].clear(); for(ri i=1;i&lt;=n;++i)dis[i]=0; for(ri i=1,u,v;i&lt;=m-n;++i){ u=read(),v=read(); e[u].pb(v); } for(ri i=1;i&lt;=n;++i)if(e[i].size())dfs(i,1,i,1); ld coe,sum=0; for(ri len,i=1;i&lt;=n;++i){ w[i][i]=0; coe=1.0/((ld)e[i].size()+1); len=1,sum=dis[i]; for(ri j=i+1;j&lt;=n;++j){ w[i][j]=len+sum/coe; sum+=coe*dis[j]; sum+=coe*(1.0-1.0/((ld)e[j].size()+1))*len; ++len; coe*=1.0/((ld)e[j].size()+1); } } cur=0; for(ri i=2;i&lt;=n;++i)f[cur][i]=w[1][i]; for(ri i=3;i&lt;=K;++i)cur^=1,solve(i,n,i-1,n); printf(&quot;%.4Lf\\n&quot;,f[cur][n]); } return 0;}","categories":[{"name":"public","slug":"public","permalink":"http://xdl030112.github.io/categories/public/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://xdl030112.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"杂题乱做 Round4","slug":"sol4","date":"2019-11-03T14:46:34.000Z","updated":"2019-12-26T04:28:23.115Z","comments":true,"path":"sol4/","link":"","permalink":"http://xdl030112.github.io/sol4/","excerpt":"","text":"&#x4EA4;&#x4E0E;&#x5E76; &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x5BB9;&#x6613;&#x63A2;&#x7A76;&#x51FA;&#x5982;&#x4E0B;&#x6027;&#x8D28;&#xFF1A; &#x6240;&#x6709;&#x5408;&#x6CD5;&#x96C6;&#x5408;&#x53EF;&#x4EE5;&#x7531;&#x96C6;&#x5408;&#x4E2D;&#x7684;&#x4E24;&#x4E2A;&#x533A;&#x95F4;&#x4EE3;&#x66FF; &#x90A3;&#x4E48;&#x5BF9;&#x4E8E;&#x6BCF;&#x4E2A;&#x533A;&#x95F4;&#x627E;&#x4E00;&#x4E2A;&#x8DDF;&#x5B83;&#x4EA4;&#x5E76;&#x957F;&#x5EA6;&#x4E58;&#x79EF;&#x6700;&#x5927;&#x7684;&#x533A;&#x95F4;&#x5373;&#x53EF; &#x53D1;&#x73B0;&#x6709;&#x4E24;&#x79CD;&#x76F8;&#x4EA4;&#x548C;&#x5305;&#x542B;&#xFF0C;&#x90A3;&#x4E48;&#x5148;&#x8003;&#x8651;&#x5982;&#x4F55;&#x5904;&#x7406;&#x5305;&#x542B;&#x7684;&#x60C5;&#x51B5; &#x8003;&#x8651;&#x5148;&#x5DE6;&#x7AEF;&#x70B9;&#x9012;&#x589E;&#x540E;&#x53F3;&#x7AEF;&#x70B9;&#x9012;&#x51CF;&#x7684;&#x987A;&#x5E8F;&#x8FDB;&#x884C;&#x6392;&#x5E8F;&#xFF0C;&#x7EF4;&#x62A4;&#x5F53;&#x524D;&#x6700;&#x53F3;&#x7AEF;&#x70B9;&#x6765;&#x5224;&#x65AD;&#x662F;&#x5426;&#x5305;&#x542B;&#xFF0C;&#x5E76;&#x8DDF;&#x5F53;&#x524D;&#x6700;&#x53F3;&#x7AEF;&#x70B9;&#x5BF9;&#x5E94;&#x533A;&#x95F4;&#x6C42;&#x8D21;&#x732E;&#xFF0C;&#x4F46;&#x8FD9;&#x6837;&#x4E0D;&#x4E00;&#x5B9A;&#x80FD;&#x6C42;&#x51FA;&#x6240;&#x6709;&#x5305;&#x542B;&#x5F53;&#x524D;&#x533A;&#x95F4;&#x4E2D;&#x6700;&#x957F;&#x7684;&#x90A3;&#x4E2A;&#xFF0C;&#x8FD9;&#x4E2A;&#x65F6;&#x5019;&#x8003;&#x8651;&#x5982;&#x4E0B;&#x4E00;&#x70B9;&#x6027;&#x8D28;&#xFF1A; &#x5047;&#x8BBE;&#x5B58;&#x5728; A&#x2282;B,A&#x2282;CA\\subset B,A\\subset CA&#x2282;B,A&#x2282;C &#xFF0C;&#x90A3;&#x4E48; B,CB,CB,C &#x4EA7;&#x751F;&#x7684;&#x8D21;&#x732E;&#x4F18;&#x4E8E; A,BA,BA,B &#x548C; A,CA,CA,C &#x4EA7;&#x751F;&#x7684;&#x8D21;&#x732E; &#x8FD9;&#x6837;&#x5C31;&#x53EF;&#x4EE5;&#x653E;&#x5FC3;&#x641E;&#x6389;&#x6240;&#x6709;&#x88AB;&#x5305;&#x542B;&#x7684;&#x533A;&#x95F4;&#x4E86;&#xFF0C;&#x5269;&#x4E0B;&#x7684;&#x533A;&#x95F4;&#x4E24;&#x4E24;&#x4E0D;&#x5305;&#x542B;&#x4E14;&#x5DE6;&#x53F3;&#x7AEF;&#x70B9;&#x5747;&#x9012;&#x589E;&#xFF0C;&#x4E8E;&#x662F;&#x533A;&#x95F4; i,ji,ji,j &#x7684;&#x8D21;&#x732E;&#x4E3A; (ri&#x2212;lj+1)&#xD7;(rj&#x2212;li+1)(r_i-l_j+1)\\times(r_j-l_i+1)(ri&#x200B;&#x2212;lj&#x200B;+1)&#xD7;(rj&#x200B;&#x2212;li&#x200B;+1) &#x62C6;&#x5F00;&#x770B;&#x53D1;&#x73B0;&#x6709;&#x51B3;&#x7B56;&#x5355;&#x8C03;&#x6027;&#xFF0C;&#x76F4;&#x63A5;&#x5206;&#x6CBB;&#x641E;&#x641E;&#x5373;&#x53EF; CODE cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;typedef unsigned long long Ull;typedef unsigned int uii;typedef set&lt;int&gt;::iterator It;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline ll readl(){ ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s){ int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;}namespace modular{ const int mod=1e9+7; inline int add(int a,int b){return a+b&lt;mod?a+b:a+b-mod;} inline int dec(int a,int b){return a&lt;b?a-b+mod:a-b;} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Add(int&amp;a,int b){a=a+b&lt;mod?a+b:a+b-mod;} inline void Dec(int&amp;a,int b){a=a&lt;b?a-b+mod:a-b;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;} inline int Inv(int a){return ksm(a,mod-2);} inline void fix(int&amp;a){a=(a%mod+mod)%mod;}}using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b){a&gt;b?a=b:0;}template&lt;typename T&gt;inline void ckmax(T&amp;a,T b){a&lt;b?a=b:0;}inline bool cmp(pii a,pii b){return a.fi^b.fi?a.fi&lt;b.fi:a.se&gt;b.se;}const int N=1e6+5;pii a[N];int n,sig=0;ll ans=0;inline ll calc(int x,int p){return (ll)(a[p].se-a[x].fi)*(a[x].se-a[p].fi);}inline void solve(int l,int r,int L,int R){ if(l&gt;r)return; if(L==R){ for(ri i=l;i&lt;=r;++i)if(i&gt;L)ckmax(ans,calc(L,i)); return; } int mid=l+r&gt;&gt;1,ps=L; ll tmp=calc(ps,mid),t; for(ri i=ps+1;i&lt;=R&amp;&amp;i&lt;mid;++i)if((t=calc(i,mid))&gt;tmp){ tmp=t; ps=i; } if(ps&lt;mid)ckmax(ans,tmp); solve(l,mid-1,L,ps); solve(mid+1,r,ps,R); }int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(); for(ri i=1;i&lt;=n;++i)a[i].fi=read(),a[i].se=read(); sort(a+1,a+n+1,cmp); sig=1; for(ri ps=1,mx=a[1].se,i=2;i&lt;=n;++i){ if(a[i].se&gt;mx){ mx=a[i].se; ps=i; a[++sig]=a[i]; } else ckmax(ans,(ll)(a[i].se-a[i].fi)*(a[ps].se-a[ps].fi)); } solve(1,sig,1,sig); cout&lt;&lt;ans; return 0;} &#x5730;&#x56FE; &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x9996;&#x5148;&#x8003;&#x8651;&#x4E00;&#x4E2A;&#x8D2A;&#x5FC3;&#xFF0C;&#x5C06;&#x6240;&#x6709;&#x6570;&#x8FDB;&#x884C;&#x6392;&#x5E8F;&#x7136;&#x540E;&#x5206;&#x6210;&#x4E0D;&#x8D85;&#x8FC7; mmm &#x5757;&#x4E00;&#x5B9A;&#x662F;&#x6700;&#x4F18;&#x7684;&#xFF0C;&#x8BC1;&#x660E;&#x663E;&#x7136; &#x7136;&#x540E;&#x5C31;&#x53EF;&#x4EE5; fi,jf_{i,j}fi,j&#x200B; &#x8868;&#x793A;&#x524D; iii &#x4E2A;&#x6570;&#x5206;&#x4E3A; jjj &#x5757;&#x7684;&#x6700;&#x4F18;&#x8D21;&#x732E;&#xFF0C;&#x9884;&#x5904;&#x7406;&#x6240;&#x6709;&#x533A;&#x95F4;&#x7684;&#x8D21;&#x732E;&#x5373;&#x53EF;&#xFF0C;&#x590D;&#x6742;&#x5EA6; O(n2m)O(n^2m)O(n2m) CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;typedef unsigned long long Ull;typedef unsigned int uii;typedef set&lt;int&gt;::iterator It;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline ll readl(){ ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s){ int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;}namespace modular{ const int mod=1e9+7; inline int add(int a,int b){return a+b&lt;mod?a+b:a+b-mod;} inline int dec(int a,int b){return a&lt;b?a-b+mod:a-b;} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Add(int&amp;a,int b){a=a+b&lt;mod?a+b:a+b-mod;} inline void Dec(int&amp;a,int b){a=a&lt;b?a-b+mod:a-b;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;} inline int Inv(int a){return ksm(a,mod-2);} inline void fix(int&amp;a){a=(a%mod+mod)%mod;}}using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b){a&gt;b?a=b:0;}template&lt;typename T&gt;inline void ckmax(T&amp;a,T b){a&lt;b?a=b:0;}const int N=3005,M=22;const ll inf=1e18;ll f[N][M],w[N][N],s[N];int n,m,a[N];int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(),m=read(); for(ri i=1;i&lt;=n;++i)a[i]=read(); sort(a+1,a+n+1); for(ri i=1;i&lt;=n;++i)s[i]=a[i]+s[i-1]; for(ri mid,len=2;len&lt;=n;++len)for(ri l=1,r=len;r&lt;=n;++l,++r){ mid=l+r&gt;&gt;1; w[l][r]=(ll)a[mid]*(mid-l)-(s[mid-1]-s[l-1])+(s[r]-s[mid])-(ll)a[mid]*(r-mid); } for(ri i=0;i&lt;=n;++i)for(ri j=0;j&lt;=m;++j)f[i][j]=inf; f[0][0]=0; for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=min(m,i);++j)for(ri k=1;k&lt;=i;++k) if(f[k-1][j-1]!=inf)ckmin(f[i][j],f[k-1][j-1]+w[k][i]); cout&lt;&lt;f[n][m]; return 0;} &#x9B54;&#x517D;&#x5730;&#x56FE;DotR &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x8BBE; fi,j,kf_{i,j,k}fi,j,k&#x200B; &#x8868;&#x793A; iii &#x4E3A;&#x6839;&#x7684;&#x5B50;&#x6811;&#x82B1;&#x8D39;&#x81F3;&#x591A; jjj &#x5143;&#xFF0C;&#x6700;&#x540E;&#x62FC;&#x51FA;&#x6765;&#x4E86; kkk &#x4E2A; iii &#x7684;&#x6700;&#x5927;&#x8D21;&#x732E;&#xFF0C;&#x7136;&#x540E;&#x7531;&#x4E8E;&#x662F;&#x68EE;&#x6797;&#x56E0;&#x6B64;&#x8981;&#x5206;&#x7EC4;&#x8F6C;&#x79FB;&#xFF0C;&#x8F6C;&#x79FB;&#x7684;&#x65F6;&#x5019;&#x5229;&#x7528;&#x63D0;&#x524D;&#x8BA1;&#x7B97;&#x8D21;&#x732E;&#x7684;&#x601D;&#x60F3;&#x52A0;&#x4E0A;&#x540E;&#x7F00;&#x548C;&#x4F18;&#x5316;&#x5C31;&#x597D; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;typedef unsigned long long Ull;typedef unsigned int uii;typedef set&lt;int&gt;::iterator It;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline ll readl(){ ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s){ int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;}namespace modular{ const int mod=1e9+7; inline int add(int a,int b){return a+b&lt;mod?a+b:a+b-mod;} inline int dec(int a,int b){return a&lt;b?a-b+mod:a-b;} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Add(int&amp;a,int b){a=a+b&lt;mod?a+b:a+b-mod;} inline void Dec(int&amp;a,int b){a=a&lt;b?a-b+mod:a-b;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;} inline int Inv(int a){return ksm(a,mod-2);} inline void fix(int&amp;a){a=(a%mod+mod)%mod;}}using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b){a&gt;b?a=b:0;}template&lt;typename T&gt;inline void ckmax(T&amp;a,T b){a&lt;b?a=b:0;}const int inf=1e9;int g[2005],f[55][2005][105],suf[55][2005][105],cur=0,du[55],a[55],b[55],vl[55],n,m;vector&lt;pii&gt;e[55];void dfs(int p){ if(!e[p].size()){ ckmin(b[p],m/a[p]); for(ri i=b[p];~i;--i){ f[p][a[p]*i][i]=vl[p]*i; for(ri j=1;j&lt;=m;++j){ ckmax(f[p][j][i],f[p][j-1][i]); suf[p][j][i]=max(f[p][j][i],suf[p][j][i+1]); } } return; } b[p]=inf,a[p]=0; for(ri v,w,i=0;i&lt;e[p].size();++i){ v=e[p][i].fi,w=e[p][i].se; dfs(v); a[p]+=a[v]*w; ckmin(b[p],b[v]/w); } ckmin(b[p],m/a[p]); for(ri i=b[p];~i;--i){ f[p][i*a[p]][i]=i*vl[p]; for(ri j=0,v,w,sw,svl;j&lt;e[p].size();++j){ v=e[p][j].fi,w=e[p][j].se,sw=w*i*a[v],svl=w*i*vl[v]; for(ri k=m;k&gt;=i*a[p];--k)for(ri l=0,up=m-max(k,sw);l&lt;=up;++l) ckmax(f[p][k+l][i],f[p][k][i]+suf[v][sw+l][w*i]-svl); } for(ri j=1;j&lt;=m;++j){ ckmax(f[p][j][i],f[p][j-1][i]); suf[p][j][i]=max(f[p][j][i],suf[p][j][i+1]); } }}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(),m=read(); char ch; for(ri i=1;i&lt;=n;++i){ vl[i]=read(); ch=gc(); while(!isalpha(ch))ch=gc(); if(ch==&apos;B&apos;)a[i]=read(),b[i]=read(); else{ for(ri tt=read(),v,w;tt;--tt){ v=read(),w=read(); e[i].pb(pii(v,w)); ++du[v]; } } } memset(f,-0x3f,sizeof(f)); memset(suf,-0x3f,sizeof(suf)); for(ri i=1;i&lt;=n;++i){ if(du[i])continue; dfs(i); for(ri j=m;j;--j)for(ri k=0;k&lt;=j;++k)ckmax(g[j],g[j-k]+suf[i][k][0]); } cout&lt;&lt;g[m]; return 0;} &#x5C0F; Y &#x548C;&#x4E8C;&#x53C9;&#x6811; &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x663E;&#x7136;&#x8981;&#x9009;&#x4E00;&#x4E2A; du&#x2264;2du\\le2du&#x2264;2 &#x7684;&#x6700;&#x5C0F;&#x7F16;&#x53F7;&#x4F5C;&#x4E3A;&#x6839;&#xFF0C;&#x5269;&#x4E0B;&#x7684;&#x7528; dfsdfsdfs &#x5904;&#x7406;&#x51FA;&#x5B50;&#x6811;&#x4E2D; du&#x2264;2du\\le2du&#x2264;2 &#x7684;&#x6700;&#x5C0F;&#x7F16;&#x53F7;&#x6765;&#x8D2A;&#x5FC3;&#x6784;&#x9020;&#x5373;&#x53EF; &#x5B9E;&#x9645;&#x4E0A;&#x5C31;&#x662F;&#x5206;&#x7C7B;&#x8BA8;&#x8BBA;&#x4E00;&#x6CE2; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;typedef unsigned long long Ull;typedef unsigned int uii;typedef set&lt;int&gt;::iterator It;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline ll readl(){ ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s){ int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;}namespace modular{ const int mod=1e9+7; inline int add(int a,int b){return a+b&lt;mod?a+b:a+b-mod;} inline int dec(int a,int b){return a&lt;b?a-b+mod:a-b;} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Add(int&amp;a,int b){a=a+b&lt;mod?a+b:a+b-mod;} inline void Dec(int&amp;a,int b){a=a&lt;b?a-b+mod:a-b;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;} inline int Inv(int a){return ksm(a,mod-2);} inline void fix(int&amp;a){a=(a%mod+mod)%mod;}}using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b){a&gt;b?a=b:0;}template&lt;typename T&gt;inline void ckmax(T&amp;a,T b){a&lt;b?a=b:0;}const int N=1e6+5,inf=0x3f3f3f3f;vector&lt;int&gt;e[N];int n,du[N],rt,mn[N];void dfs(int p,int ft){ if(du[p]&lt;=2)mn[p]=p; else mn[p]=inf; for(ri i=0,v;i&lt;e[p].size();++i){ if((v=e[p][i])==ft)continue; dfs(v,p),ckmin(mn[p],mn[v]); }}inline int get1(int x,int ft){ int res=0x3f3f3f3f; for(ri i=0,v;i&lt;e[x].size();++i){ if((v=e[x][i])==ft)continue; ckmin(res,mn[e[x][i]]); } return res;}inline int get2(int x,int ft){ int res=0x3f3f3f3f,siz=du[x]-(ft!=0); if(!siz)return x; if(siz==1)return min(x,get1(x,ft)); return get1(x,ft);}void print(int p,int ft,bool f){ vector&lt;int&gt;tmp; for(ri i=0,v;i&lt;e[p].size();++i){ if((v=e[p][i])==ft)continue; tmp.pb(v); } if(!tmp.size())cout&lt;&lt;p&lt;&lt;&apos; &apos;; else if(tmp.size()==1){ if(f){ cout&lt;&lt;p&lt;&lt;&apos; &apos;; if(get1(tmp[0],p)&lt;tmp[0])print(tmp[0],p,0); else print(tmp[0],p,1); } else{ if(p&lt;mn[tmp[0]]){ cout&lt;&lt;p&lt;&lt;&apos; &apos;; print(tmp[0],p,0); } else{ print(tmp[0],p,0); cout&lt;&lt;p&lt;&lt;&apos; &apos;; } } } else{ if(f){ if(get2(tmp[0],p)&gt;get2(tmp[1],p))swap(tmp[0],tmp[1]); cout&lt;&lt;p&lt;&lt;&apos; &apos;; print(tmp[0],p,0); print(tmp[1],p,1); } else{ if(mn[tmp[0]]&gt;mn[tmp[1]])swap(tmp[0],tmp[1]); print(tmp[0],p,0); cout&lt;&lt;p&lt;&lt;&apos; &apos;; print(tmp[1],p,0); } }}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(); for(ri i=1;i&lt;=n;++i){ du[i]=read(); for(ri j=1;j&lt;=du[i];++j)e[i].pb(read()); } rt=n+1; for(ri i=1;i&lt;=n;++i)if(du[i]&lt;3)ckmin(rt,i); dfs(rt,0); print(rt,0,1); return 0;} Anthem of Berland &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x6709;&#x4E00;&#x4E2A;&#x5F88;&#x663E;&#x7136;&#x7684;&#x66B4;&#x529B;&#x601D;&#x8DEF; fi,jf_{i,j}fi,j&#x200B; &#x8868;&#x793A;&#x8D70;&#x5230; sss &#x524D; iii &#x4E3A;&#x5339;&#x914D;&#x5230; ttt &#x7684;&#x7B2C; jjj &#x4F4D;&#x7684;&#x6700;&#x4F18;&#x503C;&#xFF0C;&#x7136;&#x540E;&#x66B4;&#x529B;&#x8F6C;&#x79FB;&#xFF08;&#x8C8C;&#x4F3C;&#x8FD8;&#x80FD;&#x8FC7;&#xFF09; &#x73B0;&#x5728;&#x8003;&#x8651;&#x4E00;&#x4E2A;&#x4E0D;&#x90A3;&#x4E48;&#x66B4;&#x529B;&#x7684;&#x601D;&#x8DEF;&#xFF0C;&#x8BBE; fif_ifi&#x200B; &#x8868;&#x793A;&#x524D; iii &#x4F4D;&#x7684;&#x6700;&#x4F18;&#x503C;&#xFF0C;&#x9996;&#x5148;&#x8003;&#x8651; s[i&#x2212;m+1&#x22EF;i]s[i-m+1\\cdots i]s[i&#x2212;m+1&#x22EF;i] &#x662F;&#x5426;&#x80FD;&#x4E0E; ttt &#x5339;&#x914D;&#xFF0C;&#x5982;&#x679C;&#x53EF;&#x4EE5;&#x5C31;&#x80FD;&#x4ECE;&#x5176; borderborderborder &#xFF0C; borderborderborder &#x7684; borderborderborder &#x7B49;&#x4F4D;&#x7F6E;&#x8F6C;&#x79FB;&#x8FC7;&#x6765;&#xFF0C;&#x56E0;&#x6B64;&#x6211;&#x4EEC;&#x518D;&#x8BB0;&#x5F55;&#x4E00;&#x4E2A; gig_igi&#x200B; &#x8868;&#x793A;&#x4EE5; iii &#x7ED3;&#x5C3E;&#x7684;&#x4F4D;&#x7F6E;&#x8DDF; ttt &#x5339;&#x914D;&#x4E0A;&#x7684;&#x6700;&#x4F18;&#x503C;&#xFF0C;&#x7136;&#x540E;&#x5C31;&#x80FD;&#x8F6C;&#x79FB;&#x5566; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;typedef unsigned long long Ull;typedef unsigned int uii;typedef set&lt;int&gt;::iterator It;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline ll readl(){ ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s){ int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;}namespace modular{ const int mod=1e9+7; inline int add(int a,int b){return a+b&lt;mod?a+b:a+b-mod;} inline int dec(int a,int b){return a&lt;b?a-b+mod:a-b;} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Add(int&amp;a,int b){a=a+b&lt;mod?a+b:a+b-mod;} inline void Dec(int&amp;a,int b){a=a&lt;b?a-b+mod:a-b;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;} inline int Inv(int a){return ksm(a,mod-2);} inline void fix(int&amp;a){a=(a%mod+mod)%mod;}}using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b){a&gt;b?a=b:0;}template&lt;typename T&gt;inline void ckmax(T&amp;a,T b){a&lt;b?a=b:0;}const int N=1e5+5;char s[N],t[N];int n,m,f[N],g[N],nxt[N];int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif scanf(&quot;%s%s&quot;,s+1,t+1); n=strlen(s+1),m=strlen(t+1); for(ri i=1,j=0;i&lt;m;++i){ while(j&amp;&amp;t[i+1]!=t[j+1])j=nxt[j]; nxt[i+1]=t[i+1]==t[j+1]?++j:0; } for(ri p,i=m;i&lt;=n;++i){ bool ff=1; for(ri j=i-m+1,k=1;j&lt;=i;++j,++k)if(s[j]!=&apos;?&apos;&amp;&amp;s[j]!=t[k]){ ff=0; break; } if(ff){ ckmax(g[i],f[i-m]+1); p=nxt[m]; while(p){ ckmax(g[i],g[i-m+p]+1); p=nxt[p]; } } f[i]=max(f[i-1],g[i]); } cout&lt;&lt;f[n]; return 0;} &#x706B;&#x9F20;&#x7684;&#x76AE;&#x8863; -&#x4E0D;&#x7126;&#x8E81;&#x7684;&#x5185;&#x5FC3;- &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x63A8;&#x5F0F;&#x5B50;&#x9898;&#xFF1A; =&#x2211;i=0&#x230A;n2&#x230B;(a)2ibn&#x2212;2iCn2i=&#x2211;i=0n(a)ibn&#x2212;iCni[2&#x2223;i]\\begin{aligned} =&amp;\\sum\\limits_{i=0}^{\\lfloor\\frac{n}2\\rfloor}(\\sqrt a)^{2i}b^{n-2i}C_{n}^{2i}\\\\ =&amp;\\sum\\limits_{i=0}^n(\\sqrt a)^ib^{n-i}C_{n}^i[2|i] \\end{aligned} ==&#x200B;i=0&#x2211;&#x230A;2n&#x200B;&#x230B;&#x200B;(a&#x200B;)2ibn&#x2212;2iCn2i&#x200B;i=0&#x2211;n&#x200B;(a&#x200B;)ibn&#x2212;iCni&#x200B;[2&#x2223;i]&#x200B; &#x5355;&#x4F4D;&#x6839;&#x53CD;&#x6F14;&#x4E00;&#x4E0B;&#x6210; sbsbsb &#x9898;&#x4E86; CODE cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;#define int long long#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() getchar()typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline ll readl(){ ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}namespace modular{ int mod; inline int add(int a,int b){return (a+=b)&lt;mod?a:a-mod;} inline void Add(int&amp;a,int b){a=add(a,b);} inline int dec(int a,int b){return (a-=b)&lt;0?a+mod:a;} inline void Dec(int&amp;a,int b){a=dec(a,b);} inline int mul(int a,int b){return (a*b-(ll)((long double)a/mod*b)*mod+mod)%mod;}}using namespace modular;ll n,A,B;struct F{ ll x,y; F(ll x=0,ll y=0):x(x),y(y){} friend inline F operator*(F &amp;a,F &amp;b){return F(add(mul(a.x,b.y),mul(a.y,b.x)),add(mul(a.y,b.y),mul(mul(a.x,b.x),A)));} friend inline F operator+(F &amp;a,F &amp;b){return F(add(a.x,b.x),add(a.y,b.y));}};inline F ksm(F x,ll b){ F res=F(0,1); for(;b;b&gt;&gt;=1,x=x*x)if(b&amp;1){ res=res*x; } return res;}signed main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif for(ri tt=read();tt;--tt){ n=readl(),A=readl(),B=readl(),mod=readl(); F a=F(1,B%mod); a=ksm(a,n); cout&lt;&lt;a.y&lt;&lt;&apos;\\n&apos;; } return 0;} Ternary String Counting &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x8BBE; fi,j,kf_{i,j,k}fi,j,k&#x200B; &#x8868;&#x793A;&#x586B;&#x4E86;&#x524D; iii &#x4F4D;&#xFF0C;&#x6700;&#x8FD1;&#x4E0D;&#x540C;&#x989C;&#x8272;&#x51FA;&#x73B0;&#x4F4D;&#x7F6E;&#x4E3A; j,kj,kj,k &#x7684;&#x65B9;&#x6848;&#x6570; (i&gt;j&gt;k)(i&gt;j&gt;k)(i&gt;j&gt;k) &#xFF0C;&#x7136;&#x540E;&#x80FD;&#x5F97;&#x5230;&#x5982;&#x4E0B;&#x8F6C;&#x79FB;&#xFF1A; fi,j,k&#x2192;fi+1,i,kf_{i,j,k}\\rightarrow f_{i+1,i,k}fi,j,k&#x200B;&#x2192;fi+1,i,k&#x200B; fi,j,k&#x2192;fi+1,j,kf_{i,j,k}\\rightarrow f_{i+1,j,k}fi,j,k&#x200B;&#x2192;fi+1,j,k&#x200B; fi,j,k&#x2192;fi+1,i,jf_{i,j,k}\\rightarrow f_{i+1,i,j}fi,j,k&#x200B;&#x2192;fi+1,i,j&#x200B; &#x7136;&#x540E;&#x628A;&#x6BCF;&#x4E2A; iii &#x5BF9;&#x5E94;&#x7684; fff &#x77E9;&#x9635;&#x62CE;&#x51FA;&#x6765;&#x770B;&#x53D1;&#x73B0;&#x7B49;&#x4EF7;&#x4E8E;&#x662F;&#x6BCF;&#x6B21;&#x7ED9;&#x4F60;&#x753B;&#x4E00;&#x4E2A;&#x77E9;&#x5F62;&#xFF0C;&#x628A;&#x5916;&#x9762;&#x7684;&#x503C;&#x53D8;&#x4E3A; 000 &#xFF0C;&#x7136;&#x540E;&#x5C06;&#x4E00;&#x5217;/&#x4E00;&#x884C;&#x7684;&#x548C;&#x52A0;&#x7ED9;&#x4E00;&#x4E2A;&#x683C;&#x5B50;&#xFF0C;&#x5E76;&#x4E14;&#x4E00;&#x4E2A;&#x4F4D;&#x7F6E;&#x88AB;&#x6E05;&#x96F6;&#x540E;&#x4E4B;&#x540E;&#x90A3;&#x4E2A;&#x5730;&#x65B9;&#x4E0D;&#x4F1A;&#x518D;&#x88AB;&#x4FEE;&#x6539;&#xFF0C;&#x4E14;&#x5BF9;&#x4E8E;&#x6BCF;&#x4E00;&#x884C;&#x6765;&#x8BF4;&#x6709;&#x503C;&#x7684;&#x662F;&#x8FDE;&#x7EED;&#x533A;&#x95F4;&#xFF0C;&#x4E8E;&#x662F;&#x5BF9;&#x6BCF;&#x4E00;&#x884C;&#x7EF4;&#x62A4;&#x6709;&#x503C;&#x7684;&#x5DE6;&#x53F3;&#x7AEF;&#x70B9;&#xFF0C;&#x884C;&#x548C;&#xFF0C;&#x5217;&#x548C;&#x5373;&#x53EF; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef vector&lt;int&gt; poly;inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline ll readl(){ ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s){ int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;}namespace modular{ const int mod=1e9+7; inline int add(int a,int b){return (a+=b)&lt;mod?a:a-mod;} inline void Add(int&amp;a,int b){a=add(a,b);} inline int dec(int a,int b){return (a-=b)&lt;0?a+mod:a;} inline void Dec(int&amp;a,int b){a=dec(a,b);} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;}}using namespace modular;template&lt;class T&gt;inline void ckmax(T&amp;a,T b){a&lt;b?a=b:0;}template&lt;class T&gt;inline void ckmin(T&amp;a,T b){a&gt;b?a=b:0;}const int N=5005;int n,m;signed main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif for(ri tt=read();tt;--tt){ n=read(),m=read(); vector&lt;int&gt;mn1(n+2),mx1(n+2),mn2(n+2),mx2(n+2),row(n+2),col(n+2),lp(n+2),rp(n+2); vector&lt;vector&lt;int&gt; &gt;f(n+2); for(ri i=0;i&lt;=n+1;++i){ mx1[i]=mx2[i]=i-1; f[i].resize(n+2); } for(ri l,r,v,i=1;i&lt;=m;++i){ l=read(),r=read(),v=read(); if(v==1){ ckmin(mx1[r],l-1); ckmin(mx2[r],l-1); } else if(v==2){ ckmax(mn1[r],l); ckmin(mx2[r],l-1); } else{ ckmax(mn1[r],l); ckmax(mn2[r],l); } } bool ff=1; for(ri i=1;i&lt;=n;++i)if(mn1[i]&gt;mx1[i]||mn2[i]&gt;mx2[i]){ ff=0; break; } if(!ff){ puts(&quot;0&quot;); continue; } row[0]=col[0]=f[0][0]=3,lp[0]=rp[0]=0; for(ri cur=2;cur&lt;=n;++cur){ if(mx1[cur]+1==cur){ for(ri i=mn2[cur];i&lt;=mx2[cur];++i) Add(f[cur-1][i],add(row[i],col[i])); for(ri i=mn2[cur];i&lt;=mx2[cur];++i) Add(col[i],f[cur-1][i]),Add(row[cur-1],f[cur-1][i]); lp[cur-1]=mn2[cur],rp[cur-1]=mx2[cur]; } else lp[cur-1]=1,rp[cur-1]=0; for(ri i=0;i&lt;mn1[cur];++i){ if(lp[i]&gt;rp[i])continue; for(ri j=lp[i];j&lt;=rp[i];++j)Dec(col[j],f[i][j]); row[i]=0; lp[i]=1,rp[i]=0; } for(ri i=mn1[cur];i&lt;=mx1[cur];++i){ if(lp[i]&lt;=rp[i]){ if(lp[i]&gt;mx2[cur]||rp[i]&lt;mn2[cur]){ for(ri j=lp[i];j&lt;=rp[i];++j)Dec(col[j],f[i][j]); row[i]=0; lp[i]=1,rp[i]=0; } else{ for(ri j=lp[i];j&lt;mn2[cur];++j) Dec(col[j],f[i][j]),Dec(row[i],f[i][j]); ckmax(lp[i],mn2[cur]); for(ri j=rp[i];j&gt;mx2[cur];--j) Dec(col[j],f[i][j]),Dec(row[i],f[i][j]); ckmin(rp[i],mx2[cur]); } } } for(ri i=mx1[cur]+1;i&lt;cur-1;++i){ if(lp[i]&gt;rp[i])continue; for(ri j=lp[i];j&lt;=rp[i];++j)Dec(col[j],f[i][j]); row[i]=0; lp[i]=1,rp[i]=0; } } int res=0; for(ri i=0;i&lt;n;++i)Add(res,row[i]); cout&lt;&lt;res&lt;&lt;&apos;\\n&apos;; } return 0;}","categories":[{"name":"public","slug":"public","permalink":"http://xdl030112.github.io/categories/public/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://xdl030112.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"杂题乱做 Round3","slug":"sol3","date":"2019-11-01T14:39:01.000Z","updated":"2019-12-26T04:29:22.187Z","comments":true,"path":"sol3/","link":"","permalink":"http://xdl030112.github.io/sol3/","excerpt":"","text":"&#x5EFA;&#x8BBE;&#x6E38;&#x4E50;&#x573A; &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x5728; mmm &#x5F88;&#x5C0F;&#x7684;&#x65F6;&#x5019;&#x53EF;&#x4EE5;&#x8003;&#x8651;&#x7528;&#x8F6E;&#x5ED3;&#x7EBF;&#x505A;&#xFF0C;&#x4F46;&#x73B0;&#x5728; mmm &#x8F83;&#x5927;&#xFF0C;&#x56E0;&#x6B64;&#x8981;&#x5BF9;&#x8BE5;&#x9898;&#x7684;&#x7279;&#x6B8A;&#x6761;&#x4EF6;&#x8FDB;&#x884C;&#x5206;&#x6790;&#xFF1A; &#x8003;&#x8651;&#x5230;&#x6700;&#x540E;&#x4F1A;&#x5F62;&#x6210;&#x82E5;&#x5E72;&#x56DE;&#x8DEF;&#xFF0C;&#x56E0;&#x6B64;&#x82E5;&#x5C06;&#x6574;&#x5F20;&#x56FE;&#x8FDB;&#x884C;&#x9ED1;&#x767D;&#x67D3;&#x8272;&#xFF0C;&#x90A3;&#x4E48;&#x4E00;&#x4E2A;&#x767D;&#x683C;&#x4E00;&#x5B9A;&#x8FDE;&#x63A5;&#x4E24;&#x4E2A;&#x9ED1;&#x683C;&#xFF0C;&#x7531;&#x4E8E;&#x5F2F;&#x9053;&#x7684;&#x6743;&#x503C;&#x4E3A; vli,jvl_{i,j}vli,j&#x200B; &#xFF0C;&#x76F4;&#x9053;&#x7684;&#x6743;&#x503C;&#x4E3A; 000 &#xFF0C;&#x56E0;&#x6B64;&#x53EF;&#x4EE5;&#x5C06;&#x6BCF;&#x4E2A;&#x683C;&#x5B50;&#x6309;&#x7167;&#x6A2A;&#x7EB5;&#x65B9;&#x5411;&#x5EFA;&#x4E24;&#x4E2A;&#x70B9;&#x5E76;&#x8FDB;&#x884C;&#x5982;&#x4E0B;&#x8FDE;&#x8FB9;&#xFF1A; &#x6E90;&#x70B9;&#x5411;&#x6BCF;&#x4E2A;&#x767D;&#x683C;&#x5BF9;&#x5E94;&#x70B9;&#x8FDE;&#x8FB9;&#xFF0C;&#x8D39;&#x7528; 000 &#xFF0C;&#x6D41;&#x91CF; 222 &#x6BCF;&#x4E2A;&#x9ED1;&#x683C;&#x5BF9;&#x5E94;&#x70B9;&#x5411;&#x6C47;&#x70B9;&#x8FDE;&#x8FB9;&#xFF0C;&#x8D39;&#x7528; 000 &#xFF0C;&#x6D41;&#x91CF; 222 &#x6BCF;&#x4E2A;&#x683C;&#x5B50;&#x7684;&#x6A2A;/&#x7EB5;&#x5411;&#x5BF9;&#x5E94;&#x70B9;&#x5411;&#x683C;&#x5B50;&#x5BF9;&#x5E94;&#x70B9;&#x8FDE;&#x4E24;&#x6761;&#x8FB9;&#xFF0C;&#x4E00;&#x6761;&#x8D39;&#x7528; 000 &#xFF0C;&#x6D41;&#x91CF; 111 &#xFF0C;&#x4E00;&#x6761;&#x8D39;&#x7528; vli,jvl_{i,j}vli,j&#x200B; &#xFF0C;&#x6D41;&#x91CF; 111 &#x76F8;&#x90BB;&#x7684;&#x5408;&#x6CD5;&#x683C;&#x5B50;&#x5728;&#x5BF9;&#x5E94;&#x65B9;&#x5411;&#x8FDE;&#x8FB9; &#x7136;&#x540E;&#x8DD1;&#x6700;&#x5927;&#x8D39;&#x7528;&#x6D41;&#x5373;&#x53EF;&#xFF0C;&#x82E5;&#x662F;&#x5F2F;&#x9053;&#x4F1A;&#x88AB;&#x8BA1;&#x7B97; 2vli,j2vl_{i,j}2vli,j&#x200B; &#x7684;&#x8D39;&#x7528;&#xFF0C;&#x76F4;&#x9053;&#x4F1A;&#x88AB;&#x8BA1;&#x7B97; vli,jvl_{i,j}vli,j&#x200B; &#x7684;&#x8D39;&#x7528;&#xFF0C;&#x56E0;&#x6B64;&#x6700;&#x540E;&#x51CF;&#x53BB;&#x6240;&#x6709;&#x5408;&#x6CD5;&#x683C;&#x5B50;&#x7684;&#x6743;&#x503C;&#x5373;&#x53EF; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;typedef unsigned long long Ull;typedef unsigned int uii;typedef set&lt;int&gt;::iterator It;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline ll readl(){ ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s){ int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;}namespace modular{ const int mod=998244353; inline int add(int a,int b){return a+b&lt;mod?a+b:a+b-mod;} inline int dec(int a,int b){return a&lt;b?a-b+mod:a-b;} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Add(int&amp;a,int b){a=a+b&lt;mod?a+b:a+b-mod;} inline void Dec(int&amp;a,int b){a=a&lt;b?a-b+mod:a-b;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;} inline int Inv(int a){return ksm(a,mod-2);} inline void fix(int&amp;a){a=(a%mod+mod)%mod;}}using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b){a&gt;b?a=b:0;}template&lt;typename T&gt;inline void ckmax(T&amp;a,T b){a&lt;b?a=b:0;}const int inf=0x3f3f3f3f,N=155,M=35,L=N*M*3;int n,m,vl[N][M],ct=0;struct edge{int v,next,c,w;};namespace mcmf{ int d[L],cnt,first[L],s,t,id[L],res,fl; bool in[L]; edge e[L&lt;&lt;4]; inline void init(){ s=0; t=n*m*3+1; cnt=-1; for(ri i=s;i&lt;=t;++i)first[i]=-1; res=0; fl=0; } inline void addedge(int u,int v,int c,int w){ e[++cnt]=(edge){v,first[u],c,w}; first[u]=cnt; } inline void add_(int u,int v,int c,int w){ addedge(u,v,c,w); addedge(v,u,0,-w); } inline bool spfa(){ static int que[L&lt;&lt;4],hd,tl; for(ri i=s;i&lt;=t;++i)d[i]=-inf; que[hd=tl=1]=s; d[s]=0; while(hd&lt;=tl){ int x=que[hd++]; in[x]=0; for(ri i=first[x],v;~i;i=e[i].next){ v=e[i].v; if(e[i].c&gt;0&amp;&amp;d[v]&lt;d[x]+e[i].w){ d[v]=d[x]+e[i].w; id[v]=i; if(!in[v]){ in[v]=1; que[++tl]=v; } } } } if(d[t]==-inf)return 0; res+=d[t]; ++fl; int p=t; while(p!=s)--e[id[p]].c,++e[id[p]^1].c,p=e[id[p]^1].v; return 1; } inline int solve(){ while(spfa()); if(fl!=ct)puts(&quot;-1&quot;),exit(0); return res; }}bool s[N][M];inline int idx(int a,int b,int c){return c*n*m+(a-1)*m+b;}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(),m=read(); for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=m;++j)s[i][j]=read(); int res=0; mcmf::init(); for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=m;++j){ vl[i][j]=read(); if(!s[i][j])res-=vl[i][j],++ct; } for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=m;++j){ if(s[i][j])continue; if((i+j)&amp;1){ mcmf::add_(mcmf::s,idx(i,j,2),2,0); mcmf::add_(idx(i,j,2),idx(i,j,0),1,0); mcmf::add_(idx(i,j,2),idx(i,j,0),1,vl[i][j]); mcmf::add_(idx(i,j,2),idx(i,j,1),1,0); mcmf::add_(idx(i,j,2),idx(i,j,1),1,vl[i][j]); if(i!=1&amp;&amp;!s[i-1][j])mcmf::add_(idx(i,j,0),idx(i-1,j,0),1,0); if(i!=n&amp;&amp;!s[i+1][j])mcmf::add_(idx(i,j,0),idx(i+1,j,0),1,0); if(j!=1&amp;&amp;!s[i][j-1])mcmf::add_(idx(i,j,1),idx(i,j-1,1),1,0); if(j!=m&amp;&amp;!s[i][j+1])mcmf::add_(idx(i,j,1),idx(i,j+1,1),1,0); } else{ mcmf::add_(idx(i,j,2),mcmf::t,2,0); mcmf::add_(idx(i,j,0),idx(i,j,2),1,0); mcmf::add_(idx(i,j,0),idx(i,j,2),1,vl[i][j]); mcmf::add_(idx(i,j,1),idx(i,j,2),1,0); mcmf::add_(idx(i,j,1),idx(i,j,2),1,vl[i][j]); } } res+=mcmf::solve(); cout&lt;&lt;res; return 0;} Druzyny &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x8003;&#x8651;&#x8BBE; fi=(a,b)f_{i}=(a,b)fi&#x200B;=(a,b) &#x8868;&#x793A;&#x5F53;&#x524D;&#x5E8F;&#x5217;&#x6BB5;&#x5F00;&#x5934;&#x4E3A; iii &#xFF0C;&#x4E4B;&#x524D;&#x6700;&#x591A;&#x6709; aaa &#x6BB5;&#x5E8F;&#x5217;&#xFF0C;&#x65B9;&#x6848;&#x6570;&#x4E3A; bbb &#x5F88;&#x660E;&#x663E;&#x53EF;&#x4EE5;&#x8003;&#x8651;&#x679A;&#x4E3E;&#x8BE5;&#x6BB5;&#x7684;&#x7ED3;&#x5C3E;&#x4F4D;&#x7F6E;&#x7136;&#x540E;&#x8FDB;&#x884C;&#x8F6C;&#x79FB;&#xFF0C;&#x590D;&#x6742;&#x5EA6;&#x4E3A; O(n2)O(n^2)O(n2) &#x8F6C;&#x79FB;&#x5F0F;&#x6761;&#x4EF6;&#x5982;&#x4E0B;&#xFF1A; &#x82E5;i&#x80FD;&#x5411;j&#x8F6C;&#x79FB;&#xFF0C;&#x5219;max&#x2061;{ci&#x22EF;j}&#x2264;j&#x2212;i+1&#x2264;min&#x2061;{di&#x22EF;j}&#x82E5;i&#x80FD;&#x5411;j&#x8F6C;&#x79FB;&#xFF0C;&#x5219;\\max\\{c_{i\\cdots j}\\}\\le j-i+1\\le\\min\\{d_{i\\cdots j}\\}&#x82E5;i&#x80FD;&#x5411;j&#x8F6C;&#x79FB;&#xFF0C;&#x5219;max{ci&#x22EF;j&#x200B;}&#x2264;j&#x2212;i+1&#x2264;min{di&#x22EF;j&#x200B;} &#x89C2;&#x5BDF;&#x8F6C;&#x79FB;&#x6761;&#x4EF6;&#x5BB9;&#x6613;&#x53D1;&#x73B0;&#x5408;&#x6CD5;&#x7684;&#x8F6C;&#x79FB;&#x533A;&#x95F4;&#x88AB;&#x5206;&#x6210;&#x4E86;&#x82E5;&#x5E72;&#x8FDE;&#x7EED;&#x6BB5;&#xFF0C;&#x800C;&#x5982;&#x679C;&#x53EA;&#x6709;&#x4E00;&#x4E2A;&#x9650;&#x5236;&#x6761;&#x4EF6;&#x6211;&#x4EEC;&#x53EF;&#x4EE5;&#x901A;&#x8FC7;&#x9884;&#x5904;&#x7406;&#x6BCF;&#x4E2A;&#x6570;&#x5EF6;&#x4F38;&#x7684;&#x6700;&#x8FDC;&#x4F4D;&#x7F6E;&#x6765;&#x8FDB;&#x884C; dpdpdp &#x4F18;&#x5316;&#xFF0C;&#x56E0;&#x6B64;&#x73B0;&#x5728;&#x95EE;&#x9898;&#x53D8;&#x4E3A;&#x7528;&#x5DE7;&#x5999;&#x7684;&#x65B9;&#x6CD5;&#x53BB;&#x6389;&#x5176;&#x4E2D;&#x4E00;&#x4E2A;&#x9650;&#x5236;&#x6761;&#x4EF6; &#x90A3;&#x4E48;&#x5229;&#x7528;&#x6700;&#x503C;&#x5206;&#x6CBB;&#x7684;&#x601D;&#x60F3;&#x5373;&#x53EF;&#xFF0C;&#x6BCF;&#x4E00;&#x5C42;&#x5206;&#x522B;&#x5148;&#x66F4;&#x65B0;&#x51FA;&#x6700;&#x503C;&#x5DE6;&#x8FB9;&#x7684;&#x7B54;&#x6848;&#xFF0C;&#x7136;&#x540E;&#x7528;&#x5176;&#x66F4;&#x65B0;&#x53F3;&#x4FA7;&#x7B54;&#x6848;&#xFF0C;&#x7136;&#x540E;&#x9012;&#x5F52;&#x5206;&#x6CBB;&#x53F3;&#x8FB9;&#x5373;&#x53EF; &#x5728;&#x66F4;&#x65B0;&#x7684;&#x65F6;&#x5019;&#x901A;&#x8FC7;&#x624B;&#x753B;&#x53EF;&#x4EE5;&#x53D1;&#x73B0;&#x8981;&#x4E48;&#x662F;&#x533A;&#x95F4;&#x4E2D;&#x95F4;&#x7684;&#x4E00;&#x6BB5;&#xFF0C;&#x8981;&#x4E48;&#x662F;&#x533A;&#x95F4;&#x7684;&#x4E00;&#x4E2A;&#x524D;&#x7F00;&#xFF0C;&#x5BF9;&#x4E8E;&#x540E;&#x8005;&#x76F4;&#x63A5;&#x8BB0;&#x5F55;&#x524D;&#x7F00;&#x548C;&#x8F6C;&#x79FB;&#x5373;&#x53EF;&#xFF0C;&#x6BCF;&#x5C42;&#x590D;&#x6742;&#x5EA6; O(1)O(1)O(1) &#xFF0C;&#x603B;&#x590D;&#x6742;&#x5EA6;&#x4E3A; O(nlog&#x2061;n)O(n\\log n)O(nlogn) &#xFF0C;&#x800C;&#x5BF9;&#x4E8E;&#x524D;&#x8005;&#x5728;&#x6240;&#x6709;&#x5C42;&#x4E2D;&#x53EA;&#x4F1A;&#x51FA;&#x73B0; O(n)O(n)O(n) &#x6B21;&#xFF0C;&#x6BCF;&#x6B21;&#x7528;&#x7EBF;&#x6BB5;&#x6811;&#x67E5;&#x8BE2;&#x533A;&#x95F4;&#x548C;&#xFF0C;&#x590D;&#x6742;&#x5EA6; O(nlog&#x2061;n)O(n\\log n)O(nlogn) &#x4F46;&#x7531;&#x4E8E;&#x7B14;&#x8005;&#x7684;&#x5B9E;&#x73B0;&#x4E0D;&#x591F;&#x597D;&#x6210;&#x529F;&#x88AB;&#x5361;&#x4E86;&#x7A7A;&#x95F4;&#xFF0C;&#x4E8E;&#x662F;&#x7EBF;&#x6BB5;&#x6811;&#x53D8;&#x6210;&#x4E86; N&#xD7;3N\\times 3N&#xD7;3 &#x7684;&#x4E0A;&#x9650; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171#include&lt;bits/stdc++.h&gt;#define ri int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() getchar()typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}namespace modular{ const int mod=1e9+7; inline int add(int a,int b){return a+b&lt;mod?a+b:a+b-mod;} inline int dec(int a,int b){return a&lt;b?a-b+mod:a-b;} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Add(int&amp;a,int b){a=a+b&lt;mod?a+b:a+b-mod;} inline void Dec(int&amp;a,int b){a=a&lt;b?a-b+mod:a-b;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;} inline int Inv(int a){return ksm(a,mod-2);} inline void fix(int&amp;a){a=(a%mod+mod)%mod;}}using namespace modular;const int N=1e6+5;struct F{ int a,b; F(int a=-1000000,int b=0):a(a),b(b){} friend inline F operator+(F a,F b){return a.a^b.a?(a.a&gt;b.a?a:b):F(a.a,add(a.b,b.b));} friend inline void operator+=(F&amp;a,F b){a=a+b;}}f[N];namespace sgt{ #define lc (p&lt;&lt;1) #define rc (p&lt;&lt;1|1) #define mid (l+r&gt;&gt;1) F vl[N*3],tg[N*3]; void pushnow(int p,F v){ vl[p]+=v; tg[p]+=v; } void pushdown(int p){ if(tg[p].a||tg[p].b){ pushnow(lc,tg[p]); pushnow(rc,tg[p]); tg[p]=F(0,0); } } void pushup(int p){vl[p]=vl[lc]+vl[rc];} void update(int p,int l,int r,int ql,int qr,F v){ if(ql&lt;=l&amp;&amp;r&lt;=qr)return pushnow(p,v); pushdown(p); if(qr&lt;=mid)update(lc,l,mid,ql,qr,v); else if(ql&gt;mid)update(rc,mid+1,r,ql,qr,v); else update(lc,l,mid,ql,qr,v),update(rc,mid+1,r,ql,qr,v); pushup(p); } F query(int p,int l,int r,int ql,int qr){ if(ql&lt;=l&amp;&amp;r&lt;=qr)return vl[p]; pushdown(p); if(qr&lt;=mid)return query(lc,l,mid,ql,qr); if(ql&gt;mid)return query(rc,mid+1,r,ql,qr); return query(lc,l,mid,ql,qr)+query(rc,mid+1,r,ql,qr); }}int n,mn[N],mx[N],ps[N];namespace sgtt{ int vl[N*3]; void pushup(int p){vl[p]=mn[vl[lc]]&gt;mn[vl[rc]]?vl[lc]:vl[rc];} void build(int p,int l,int r){ if(l==r){ vl[p]=l; return; } build(lc,l,mid),build(rc,mid+1,r); pushup(p); } int query(int p,int l,int r,int ql,int qr){ if(ql&lt;=l&amp;&amp;r&lt;=qr)return vl[p]; if(qr&lt;=mid)return query(lc,l,mid,ql,qr); if(ql&gt;mid)return query(rc,mid+1,r,ql,qr); int res1=query(lc,l,mid,ql,qr),res2=query(rc,mid+1,r,ql,qr); return mn[res1]&gt;mn[res2]?res1:res2; } int query(int l,int r){return query(1,1,n,l,r);} #undef lc #undef rc #undef mid}F pre,upd;void solve(int l,int r){ if(l&gt;r)return; if(l==r){ sgt::update(1,1,n,l,l,f[l]); f[l]=sgt::query(1,1,n,l,l); return; } int mid=sgtt::query(l,r-1); solve(l,mid); int pos=max(mid,l+mn[mid]-1); if(pos-mn[mid]+1&gt;l){ upd=sgt::query(1,1,n,l,pos-mn[mid]); pre=F(upd.a+1,upd.b); } else pre=F(); for(ri L,R,res,ql=l,qr=pos-mn[mid]+1,i=pos;i&lt;r;++i,++qr){ if(ps[i]&gt;mid)break; if(qr&gt;=l){ pre+=F(f[qr].a+1,f[qr].b); if(qr==mid){ L=i,R=r-1,res=i-1; while(L&lt;=R){ int md=L+R&gt;&gt;1; if(ps[md]&lt;=l)L=md+1,res=md; else R=md-1; } if(i&lt;=res)sgt::update(1,1,n,i+1,res+1,pre); for(i=res+1;i&lt;r;++i){ if(ps[i]&gt;mid)break; upd=sgt::query(1,1,n,ps[i],qr); f[i+1]+=F(upd.a+1,upd.b); } break; } if(ps[i]&gt;l){ if(ps[i]&lt;=qr){ upd=sgt::query(1,1,n,ps[i],qr); f[i+1]+=F(upd.a+1,upd.b); } continue; } f[i+1]+=pre; } } solve(mid+1,r);}struct Que{ priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;a,b; inline void ins(int x){a.push(x);} inline void del(int x){b.push(x);} inline int top(){while(b.size()&amp;&amp;a.top()==b.top())a.pop(),b.pop();return a.top();}}vl;signed main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(); for(ri i=1;i&lt;=n;++i)mn[i]=read(),mx[i]=read(); ++n; mn[n]=mx[n]=1; f[1]=F(0,1); sgtt::build(1,1,n); for(ri l=1,r=1;r&lt;=n;++r){ vl.ins(mx[r]); while(vl.top()&lt;r-l+1)vl.del(mx[l++]); ps[r]=l; } while(vl.a.size())vl.a.pop(); while(vl.b.size())vl.b.pop(); solve(1,n); F res=f[n]; if(!res.b)puts(&quot;NIE&quot;); else cout&lt;&lt;res.a&lt;&lt;&apos; &apos;&lt;&lt;res.b; return 0;} MachineWorks &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x8003;&#x8651;&#x628A;&#x6240;&#x6709;&#x673A;&#x5668;&#x6309;&#x7167; did_idi&#x200B; &#x6392;&#x5E8F;&#xFF0C;&#x7136;&#x540E;&#x8BBE; fif_ifi&#x200B; &#x8868;&#x793A;&#x5230;&#x7B2C; iii &#x4E2A;&#x7269;&#x54C1;&#x624B;&#x4E2D;&#x80FD;&#x6709;&#x7684;&#x6700;&#x591A;&#x7684;&#x94B1; &#x90A3;&#x4E48;&#x8F6C;&#x79FB;&#x5F0F;&#x4E3A; fi=max&#x2061;{fj+(di&#x2212;dj&#x2212;1)&#xD7;gj+rj}f_i=\\max\\{f_j+(d_i-d_j-1)\\times g_j+r_j\\}fi&#x200B;=max{fj&#x200B;+(di&#x200B;&#x2212;dj&#x200B;&#x2212;1)&#xD7;gj&#x200B;+rj&#x200B;} &#x8C8C;&#x4F3C;&#x53EF;&#x4EE5;&#x659C;&#x7387;&#x4F18;&#x5316;&#xFF0C;&#x7136;&#x540E;&#x53D1;&#x73B0; gjg_jgj&#x200B; &#x4E0D;&#x662F;&#x5355;&#x589E;&#x7684;&#xFF0C;&#x4E8E;&#x662F;&#x5229;&#x7528; cdqcdqcdq &#x5206;&#x6CBB;&#x6765;&#x7EF4;&#x62A4;&#x8FD9;&#x4E2A;&#x504F;&#x5E8F;&#x5373;&#x53EF; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;typedef unsigned long long Ull;typedef unsigned int uii;typedef set&lt;int&gt;::iterator It;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline ll readl(){ ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s){ int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;}namespace modular{ const int mod=998244353; inline int add(int a,int b){return a+b&lt;mod?a+b:a+b-mod;} inline int dec(int a,int b){return a&lt;b?a-b+mod:a-b;} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Add(int&amp;a,int b){a=a+b&lt;mod?a+b:a+b-mod;} inline void Dec(int&amp;a,int b){a=a&lt;b?a-b+mod:a-b;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;} inline int Inv(int a){return ksm(a,mod-2);} inline void fix(int&amp;a){a=(a%mod+mod)%mod;}}using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b){a&gt;b?a=b:0;}template&lt;typename T&gt;inline void ckmax(T&amp;a,T b){a&lt;b?a=b:0;}const int N=1e5+5;int n,C,D,cas=0;const ll inf=1e13;struct F{ int d,p,r,g; friend inline bool operator&lt;(F a,F b){return a.d&lt;b.d;}}a[N];pil b[N],c[N];ll f[N];int q[N],hd,tl,t1,t2;inline double slope(pil a,pil b){return a.fi==b.fi?inf:(double)(a.se-b.se)/(double)(a.fi-b.fi);}inline void solve(int l,int r){ if(l==r){ f[l]-=a[l].p; if(f[l]&lt;0)f[l]=-inf; return; } int mid=l+r&gt;&gt;1; solve(l,mid); t1=0,t2=0; for(ri i=l;i&lt;=mid;++i)if(f[i]!=-inf)b[++t1]=pil(a[i].g,f[i]+a[i].r-(ll)(a[i].d+1)*a[i].g); for(ri i=mid+1;i&lt;=r;++i)c[++t2]=pil(a[i].d,i); sort(b+1,b+t1+1); sort(c+1,c+t2+1); hd=1,tl=0; for(ri i=1;i&lt;=t1;++i){ while(tl-hd&gt;=1&amp;&amp;slope(b[i],b[q[tl]])&gt;slope(b[q[tl]],b[q[tl-1]]))--tl; q[++tl]=i; } if(hd&lt;=tl)for(ri i=1;i&lt;=t2;++i){ while(tl-hd&gt;=1&amp;&amp;slope(b[q[hd]],b[q[hd+1]])&gt;-c[i].fi)++hd; ckmax(f[c[i].se],b[q[hd]].se+(ll)b[q[hd]].fi*c[i].fi); } solve(mid+1,r);}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif while(1){ n=read(),C=read(),D=read(); if(!(n+C+D))break; ++cas; cout&lt;&lt;&quot;Case &quot;&lt;&lt;cas&lt;&lt;&quot;: &quot;; for(ri i=1;i&lt;=n;++i){ a[i].d=read(),a[i].p=read(),a[i].r=read(),a[i].g=read(); f[i+1]=-inf; } a[++n]=(F){0,0,0,0}; a[++n]=(F){D+1,0,0,0}; sort(a+1,a+n+1); f[1]=C; f[n]=-inf; solve(1,n); cout&lt;&lt;f[n]&lt;&lt;&apos;\\n&apos;; } return 0;} &#x73E0;&#x5B9D; &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x9996;&#x5148;&#x8003;&#x8651;&#x6309;&#x7167;&#x4EE3;&#x4EF7;&#x8FDB;&#x884C;&#x5206;&#x7EC4;&#xFF0C;&#x7136;&#x540E;&#x8BBE; fi,jf_{i,j}fi,j&#x200B; &#x8868;&#x793A;&#x524D; iii &#x4E2A;&#x7EC4;&#x4EE3;&#x4EF7;&#x4E3A; jjj &#x7684;&#x6700;&#x4F18;&#x7F8E;&#x89C2;&#x5EA6; &#x8FD9;&#x6837;&#x5C31;&#x6709;&#x4E86; O(300K2)O(300K^2)O(300K2) &#x7684;&#x66B4;&#x529B;&#x641E;&#x6CD5;&#xFF08;&#x4E0D;&#x5982; O(nK)O(nK)O(nK) &#x66B4;&#x529B;&#x5206;&#x591A; &#x7136;&#x540E;&#x6BCF;&#x4E2A;&#x7EC4;&#x6EE1;&#x8DB3;&#x51B3;&#x7B56;&#x5355;&#x8C03;&#x6027;&#xFF08;&#x8FD9;&#x4E2A;&#x975E;&#x5E38;&#x6613;&#x8BC1;&#xFF09;&#xFF0C;&#x4E8E;&#x662F;&#x53EF;&#x4EE5;&#x5BF9;&#x6BCF;&#x4E2A;&#x7EC4;&#x6309;&#x7167;&#x6A21;&#x6570;&#x5206;&#x7C7B;&#x7136;&#x540E;&#x51B3;&#x7B56;&#x5355;&#x8C03;&#x6027;&#x4F18;&#x5316;&#x8F6C;&#x79FB; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;typedef unsigned long long Ull;typedef unsigned int uii;typedef set&lt;int&gt;::iterator It;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline ll readl(){ ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s){ int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;}namespace modular{ const int mod=1e9+7; inline int add(int a,int b){return a+b&lt;mod?a+b:a+b-mod;} inline int dec(int a,int b){return a&lt;b?a-b+mod:a-b;} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Add(int&amp;a,int b){a=a+b&lt;mod?a+b:a+b-mod;} inline void Dec(int&amp;a,int b){a=a&lt;b?a-b+mod:a-b;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;} inline int Inv(int a){return ksm(a,mod-2);} inline void fix(int&amp;a){a=(a%mod+mod)%mod;}}using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b){a&gt;b?a=b:0;}template&lt;typename T&gt;inline void ckmax(T&amp;a,T b){a&lt;b?a=b:0;}const int M=50005,K=305;int n,m,cur,blo;ll f[2][M];vector&lt;ll&gt;vl[K];vector&lt;int&gt;ps;inline ll calc(int x,int p){return f[cur^1][ps[x]]+(x==p?0:vl[blo][p-x-1]);}inline void solve(int l,int r,int L,int R){ if(l&gt;r)return; if(L==R){ for(ri i=l;i&lt;=r;++i)f[cur][ps[i]]=calc(L,i); return; } int mid=l+r&gt;&gt;1,x=max(L,mid-(int)vl[blo].size()); ll tmp=calc(x,mid),t; for(ri i=x+1;i&lt;=R&amp;&amp;i&lt;=mid;++i)if((t=calc(i,mid))&gt;tmp){ x=i; tmp=t; } f[cur][ps[mid]]=tmp; solve(l,mid-1,L,x); solve(mid+1,r,x,R);}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(),m=read(); for(ri a,b,i=1;i&lt;=n;++i){ a=read(),b=read(); vl[a].pb(b); } cur=0; for(ri i=1;i&lt;=300;++i){ if(!vl[i].size())continue; blo=i; sort(vl[i].begin(),vl[i].end()); reverse(vl[i].begin(),vl[i].end()); for(ri j=1;j&lt;vl[i].size();++j)vl[i][j]+=vl[i][j-1]; cur^=1; for(ri j=0;j&lt;i;++j){ ps.clear(); for(ri k=j;k&lt;=m;k+=i)ps.pb(k); if(ps.size())solve(0,ps.size()-1,0,ps.size()-1); } } for(ri i=1;i&lt;=m;++i)cout&lt;&lt;f[cur][i]&lt;&lt;&apos; &apos;; return 0;} Ember and Storm&#x2019;s Tree Game &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x8003;&#x8651;&#x5230;&#x5408;&#x6CD5;&#x7684;&#x6811;&#x6EE1;&#x8DB3;&#x6BCF;&#x6761;&#x8DEF;&#x5F84;&#x4E00;&#x5B9A;&#x662F;&#x5355;&#x8C03;&#x6216;&#x8005;&#x5355;&#x5CF0;&#x7684;&#xFF0C;&#x4E14;&#x6BCF;&#x6761;&#x8DEF;&#x5F84;&#x6709; 222 &#x79CD;&#x8C03;&#x6574;&#x65B9;&#x6CD5;&#xFF0C;&#x4E8E;&#x662F;&#x53EA;&#x7528;&#x6C42;&#x51FA;&#x53EF;&#x884C;&#x6811;&#x7684;&#x65B9;&#x6848;&#x6570;&#xFF0C;&#x8003;&#x8651;&#x8BBE; fi,jf_{i,j}fi,j&#x200B; &#x8868;&#x793A;&#x6574;&#x9897;&#x5B50;&#x6811;&#x6EE1;&#x8DB3;&#x513F;&#x5B50;&#x5C0F;&#x4E8E;&#x7236;&#x4EB2;&#xFF0C;&#x5B50;&#x6811; siz=isiz=isiz=i &#xFF0C;&#x6839;&#x7684;&#x5EA6;&#x6570;&#x4E3A; jjj &#x7684;&#x65B9;&#x6848;&#x6570; &#x7136;&#x540E;&#x7528;&#x4E2A;&#x524D;&#x7F00;&#x548C;&#x4F18;&#x5316;&#x80FD;&#x591F;&#x975E;&#x5E38;&#x7B80;&#x5355;&#x7684;&#x8F6C;&#x79FB;&#x51FA;&#x6765; &#x73B0;&#x5728;&#x5728;&#x6574;&#x68F5;&#x6811;&#x7684;&#x6839;&#x5904;&#x53EF;&#x4EE5;&#x5C06;&#x6EE1;&#x8DB3;&#x513F;&#x5B50;&#x5C0F;&#x4E8E;&#x7236;&#x4EB2;&#x548C;&#x513F;&#x5B50;&#x5927;&#x4E8E;&#x7236;&#x4EB2;&#x7684;&#x6811;&#x7ED9;&#x62FC;&#x63A5;&#x8D77;&#x6765;&#xFF0C;&#x7EDF;&#x8BA1;&#x65B9;&#x6848;&#x6570;&#x5373;&#x53EF; &#x6CE8;&#x610F;&#x5230;&#x540C;&#x4E00;&#x68F5;&#x6811;&#x7684;&#x53EF;&#x884C;&#x6839;&#x7531;&#x82E5;&#x5E72;&#x4E2A;&#xFF0C;&#x4F46;&#x5B83;&#x4EEC;&#x5F62;&#x6210;&#x4E86;&#x4E00;&#x6761;&#x5355;&#x8C03;&#x8DEF;&#x5F84;&#xFF0C;&#x6211;&#x4EEC;&#x5728;&#x7AEF;&#x70B9;&#x7EDF;&#x8BA1;&#x5373;&#x53EF; CODE cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;#define int long long#define ri register int#define pb push_back#define fi first#define se second#define double long doubleusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() getchar()typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}namespace modular{ int mod; inline int add(int a,int b){return a+b&lt;mod?a+b:a+b-mod;} inline int dec(int a,int b){return a&lt;b?a-b+mod:a-b;} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Add(int&amp;a,int b){a=a+b&lt;mod?a+b:a+b-mod;} inline void Dec(int&amp;a,int b){a=a&lt;b?a-b+mod:a-b;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;} inline int Inv(int a){return ksm(a,mod-2);} inline void fix(int&amp;a){a=(a%mod+mod)%mod;}}using namespace modular;const int N=205;int C[N][N],n,K,f[N][N],s[N];inline void init(){ for(ri i=0;i&lt;=n;++i){ C[i][0]=1; for(ri j=1;j&lt;=i;++j)C[i][j]=add(C[i-1][j-1],C[i-1][j]); }}signed main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(),K=read(),mod=read(); init(); s[1]=f[1][0]=1; for(ri i=2;i&lt;=n;++i){ for(ri j=1;j&lt;=K;++j){ for(ri k=1;k&lt;i;++k)Add(f[i][j],mul(mul(f[i-k][j-1],s[k]),C[i-2][k-1])); if(j&lt;K)Add(s[i],f[i][j]); } } int res=0; for(ri i=1;i&lt;=n;++i)for(ri j=0;j&lt;=K;++j)for(ri k=0;j+k&lt;=K;k?++k:k+=2)Add(res,mul(f[i][j],f[n-i+1][k])); cout&lt;&lt;mul(mul(res,2),mul(n,n-1)); return 0;} Path Counting &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x7B14;&#x8005;&#x60F3;&#x51FA;&#x4E86;&#x4E00;&#x4E2A;&#x66B4;&#x529B;&#x505A;&#x6CD5;&#xFF0C;&#x5373;&#x8003;&#x8651;&#x5229;&#x7528; lcalcalca &#x679A;&#x4E3E;&#x8DEF;&#x5F84;&#xFF0C;&#x7136;&#x540E;&#x7528; mttmttmtt &#x4F18;&#x5316;&#x505A;&#x5230; O(n2log&#x2061;n)O(n^2\\log n)O(n2logn) &#x4E0B;&#x9762;&#x662F;&#x6B63;&#x7ECF;&#x505A;&#x6CD5;&#xFF1A; &#x8003;&#x8651;&#x5BF9;&#x4E8E;&#x6BCF;&#x6761;&#x8DEF;&#x5F84;&#x4ECE;&#x7AEF;&#x70B9;&#x5904;&#x6C42;&#x65B9;&#x6848;&#x6570;&#xFF0C;&#x8BBE; fi,jf_{i,j}fi,j&#x200B; &#x8868;&#x793A;&#x4ECE;&#x6DF1;&#x5EA6; iii &#x7684;&#x67D0;&#x4E2A;&#x70B9;&#x5F00;&#x59CB;&#x5411;&#x4E0B;&#x8D70; jjj &#x6B65;&#x7684;&#x65B9;&#x6848;&#x6570;&#xFF0C; gi,jg_{i,j}gi,j&#x200B; &#x8868;&#x793A;&#x4ECE;&#x67D0;&#x4E2A;&#x6DF1;&#x5EA6;&#x4E3A; iii &#x7684;&#x70B9;&#x5F00;&#x59CB;&#x81F3;&#x5C11;&#x5411;&#x4E0A;&#x8D70;&#x4E00;&#x6B65;&#x603B;&#x5171;&#x8D70; jjj &#x6B65;&#x7684;&#x65B9;&#x6848;&#x6570; &#x663E;&#x7136;&#x6709;&#xFF1A; fi,j=fi+1,j&#x2212;1&#xD7;ai+1,gi,j=gi&#x2212;1,j&#x2212;1+fi,j&#x2212;2&#xD7;(ai&#x2212;1&#x2212;1)f_{i,j}=f_{i+1,j-1}\\times a_i+1,g_{i,j}=g_{i-1,j-1}+f_{i,j-2}\\times (a_{i-1}-1)fi,j&#x200B;=fi+1,j&#x2212;1&#x200B;&#xD7;ai&#x200B;+1,gi,j&#x200B;=gi&#x2212;1,j&#x2212;1&#x200B;+fi,j&#x2212;2&#x200B;&#xD7;(ai&#x2212;1&#x200B;&#x2212;1) &#x76F4;&#x63A5;&#x5F00;&#x4E24;&#x4E2A;&#x6570;&#x7EC4;&#x4F1A; MLEMLEMLE &#xFF0C;&#x56E0;&#x6B64;&#x5148;&#x6C42; fff &#x518D;&#x6C42; ggg CODE cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;typedef unsigned long long Ull;typedef unsigned int uii;typedef set&lt;int&gt;::iterator It;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline ll readl(){ ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s){ int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;}namespace modular{ const int mod=1e9+7; inline int add(int a,int b){return a+b&lt;mod?a+b:a+b-mod;} inline int dec(int a,int b){return a&lt;b?a-b+mod:a-b;} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Add(int&amp;a,int b){a=a+b&lt;mod?a+b:a+b-mod;} inline void Dec(int&amp;a,int b){a=a&lt;b?a-b+mod:a-b;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;} inline int Inv(int a){return ksm(a,mod-2);} inline void fix(int&amp;a){a=(a%mod+mod)%mod;}}using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b){a&gt;b?a=b:0;}template&lt;typename T&gt;inline void ckmax(T&amp;a,T b){a&lt;b?a=b:0;}const int N=5005;int n,a[N],b[N],f[N][N&lt;&lt;1],cur=0,ans[N&lt;&lt;1];int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(); b[1]=1; for(ri i=1;i&lt;n;++i)a[i]=read(),b[i+1]=mul(b[i],a[i]); f[n][0]=1; for(ri i=n-1;i;--i){ f[i][0]=1; for(ri j=0,up=n-i;j&lt;up;++j){ f[i][j+1]=mul(f[i+1][j],a[i]); Add(ans[j+1],mul(f[i][j+1],b[i])); } } for(ri i=1;i&lt;=n;++i){ for(ri j=n+i-2;j;--j){ f[i][j]=f[i-1][j-1]; if(j&gt;1&amp;&amp;i!=1)Add(f[i][j],mul(a[i-1]-1,f[i][j-2])); Add(ans[j],mul(f[i][j],b[i])); } } for(ri iv=mod+1&gt;&gt;1,i=1;i&lt;=n*2-2;++i)cout&lt;&lt;mul(ans[i],iv)&lt;&lt;&apos; &apos;; return 0;} How many trees? &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x8BE5;&#x9898;&#x53EF;&#x4EE5;&#x5C06;&#x6570;&#x636E;&#x52A0;&#x5F3A;&#x5230; n=400n=400n=400 &#x8003;&#x8651;&#x8BBE; fi,jf_{i,j}fi,j&#x200B; &#x8868;&#x793A; iii &#x4E2A;&#x70B9;&#x6DF1;&#x5EA6;&#x4E3A; jjj &#x7684;&#x6811;&#x7684;&#x65B9;&#x6848;&#x6570;&#xFF0C;&#x663E;&#x7136;&#x53EF;&#x4EE5;&#x679A;&#x4E3E;&#x5DE6;&#x53F3;&#x513F;&#x5B50;&#x7684; sizsizsiz &#x8F6C;&#x79FB;&#xFF0C;&#x5229;&#x7528;&#x524D;&#x7F00;&#x548C;&#x4F18;&#x5316;&#x80FD;&#x591F;&#x505A;&#x5230; O(n3)O(n^3)O(n3) CODE cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;#define ri int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() getchar()typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read(){ int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch==&apos;-&apos;,ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;}namespace modular{ const int mod=1e9+7; inline int add(int a,int b){return a+b&lt;mod?a+b:a+b-mod;} inline int dec(int a,int b){return a&lt;b?a-b+mod:a-b;} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Add(int&amp;a,int b){a=a+b&lt;mod?a+b:a+b-mod;} inline void Dec(int&amp;a,int b){a=a&lt;b?a-b+mod:a-b;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;} inline int Inv(int a){return ksm(a,mod-2);} inline void fix(int&amp;a){a=(a%mod+mod)%mod;}}using namespace modular;const int N=40;int n,m;ll f[N][N],g[N][N];int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(),m=read(); g[0][0]=g[1][1]=f[0][0]=f[1][1]=g[1][0]=1; for(ri i=2;i&lt;=n;++i){ for(ri j=1;j&lt;=i;++j)for(ri k=0;k&lt;i;++k) f[i][j]+=f[k][j-1]*(g[i-k-1][0]-g[i-k-1][j])*2-f[k][j-1]*f[i-k-1][j-1]; g[i][i]=f[i][i]; for(ri j=i-1;~j;--j)g[i][j]=g[i][j+1]+f[i][j]; } cout&lt;&lt;g[n][m]; return 0;}","categories":[{"name":"public","slug":"public","permalink":"http://xdl030112.github.io/categories/public/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://xdl030112.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"杂题乱做 Round2","slug":"sol2","date":"2019-10-28T14:56:09.000Z","updated":"2019-12-24T23:53:02.041Z","comments":true,"path":"sol2/","link":"","permalink":"http://xdl030112.github.io/sol2/","excerpt":"","text":"&#x5409;&#x592B;&#x7279; &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x663E;&#x7136;&#x7528; lucaslucaslucas &#x5B9A;&#x7406;&#x8F6C;&#x5316;&#x4E00;&#x4E0B;&#x6761;&#x4EF6;&#xFF0C;&#x53EF;&#x4EE5;&#x8F6C;&#x5316;&#x6210;&#x76F8;&#x90BB;&#x4E24;&#x9879;&#x7684;&#x5173;&#x7CFB;&#xFF0C;&#x7136;&#x540E;&#x6709;&#x4E86;&#x65E0;&#x8111;&#x7684; 70pts70pts70pts &#x66B4;&#x529B;&#xFF1A;&#x8BBE; fif_ifi&#x200B; &#x8868;&#x793A;&#x4EE5;&#x7B2C; iii &#x4E2A;&#x6570;&#x7ED3;&#x5C3E;&#x7684;&#x65B9;&#x6848;&#x6570;&#xFF0C;&#x76F4;&#x63A5;&#x66B4;&#x529B; checkcheckcheck &#x5373;&#x53EF;&#xFF1A; CODE cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() getchar()typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}namespace modular{ const int mod=1e9+7; inline int add(int a,int b){return (a+=b)&lt;mod?a:a-mod;} inline void Add(int&amp;a,int b){a=add(a,b);} inline int dec(int a,int b){return (a-=b)&lt;0?a+mod:a;} inline void Dec(int&amp;a,int b){a=dec(a,b);} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;}}using namespace modular;const int N=3e5+5;int f[N],a[N],n;inline bool check(int a,int b){ for(ri i=30;~i;--i)if((a&gt;&gt;i&amp;1)&lt;(b&gt;&gt;i&amp;1))return 0; return 1;}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(); int res=0; for(ri i=1;i&lt;=n;++i){ a[i]=read(); f[i]=1; for(ri j=1;j&lt;i;++j)if(check(a[j],a[i]))Add(f[i],f[j]); Add(res,dec(f[i],1)); } cout&lt;&lt;res; return 0;} &#x7136;&#x540E;&#x8003;&#x8651;&#x4F18;&#x5316; &#x7136;&#x540E;&#x8003;&#x8651;&#x4F18;&#x5316;&#xFF0C;&#x53D1;&#x73B0;&#x53EF;&#x4EE5;&#x8BBE; fif_ifi&#x200B; &#x8868;&#x793A;&#x5F53;&#x524D;&#x9009;&#x62E9;&#x5E8F;&#x5217;&#x7684;&#x7ED3;&#x5C3E;&#x7684;&#x6570;&#x4E3A; iii &#x7684;&#x5408;&#x6CD5;&#x65B9;&#x6848;&#x6570;&#xFF0C;&#x7136;&#x540E;&#x679A;&#x4E3E;&#x5B50;&#x96C6;&#x8F6C;&#x79FB;&#x66F4;&#x65B0;&#x5373;&#x53EF; &#x8FD9;&#x6837;&#x505A;&#x662F;&#x8BE2;&#x95EE; O(1)O(1)O(1) &#xFF0C;&#x4FEE;&#x6539; O(218)O(2^{18})O(218) &#x7684;&#xFF0C;&#x4E0D;&#x8FC7;&#x5DF2;&#x7ECF;&#x80FD;&#x591F;&#x901A;&#x8FC7;&#x4E86; CODE cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() getchar()typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}namespace modular{ const int mod=1e9+7; inline int add(int a,int b){return (a+=b)&lt;mod?a:a-mod;} inline void Add(int&amp;a,int b){a=add(a,b);} inline int dec(int a,int b){return (a-=b)&lt;0?a+mod:a;} inline void Dec(int&amp;a,int b){a=dec(a,b);} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;}}using namespace modular;const int N=3e5+5;int f[N],n;int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(); int res=0; for(ri x,t,i=1;i&lt;=n;++i){ x=read(); t=add(f[x],1); for(ri s=x;s;s=(s-1)&amp;x)Add(f[s],t); Add(res,dec(t,1)); } cout&lt;&lt;res; return 0;} &#x8003;&#x8651;&#x7EE7;&#x7EED;&#x4F18;&#x5316; &#x53D1;&#x73B0;&#x53EF;&#x4EE5;&#x901A;&#x8FC7;&#x5206;&#x5757;&#x644A;&#x4E0B;&#x590D;&#x6742;&#x5EA6;&#xFF0C;&#x5373;&#x8BBE; fi,jf_{i,j}fi,j&#x200B; &#x8868;&#x793A;&#x5F53;&#x524D;&#x9009;&#x62E9;&#x5E8F;&#x5217;&#x7684;&#x7ED3;&#x5C3E;&#x7684;&#x524D; 292^929 &#x4F4D;&#x7B49;&#x4E8E; iii &#xFF0C;&#x540E; 292^929 &#x4E3A; jjj &#x7684;&#x5B50;&#x96C6;&#x7684;&#x65B9;&#x6848;&#x6570;&#xFF0C;&#x8FD9;&#x6837;&#x590D;&#x6742;&#x5EA6;&#x662F; O(n&#x2217;29)O(n*2^9)O(n&#x2217;29) &#x7684; CODE cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() getchar()typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}namespace modular{ const int mod=1e9+7; inline int add(int a,int b){return (a+=b)&lt;mod?a:a-mod;} inline void Add(int&amp;a,int b){a=add(a,b);} inline int dec(int a,int b){return (a-=b)&lt;0?a+mod:a;} inline void Dec(int&amp;a,int b){a=dec(a,b);} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;}}using namespace modular;const int N=3e5+5;int f[1&lt;&lt;9|5][1&lt;&lt;9|5],n;inline int query(int x){ int a=x&gt;&gt;9,b=x&amp;511,c=511^b; int res=0; for(ri s=c;;s=(s-1)&amp;c){ Add(res,f[a][s^b]); if(!s)break; } return res;}inline void update(int x,int t){ int a=x&gt;&gt;9,b=x&amp;511; for(ri s=a;;s=(s-1)&amp;a){ Add(f[s][b],t); if(!s)break; }}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(); int res=0; for(ri x,t,i=1;i&lt;=n;++i){ x=read(); t=add(query(x),1); update(x,t); Add(res,dec(t,1)); } cout&lt;&lt;res; return 0;} &#x6E38;&#x89C8;&#x8BA1;&#x5212; &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x4F7F;&#x7528;&#x65AF;&#x5766;&#x7EB3;&#x6811;&#x7684;&#x601D;&#x60F3;&#xFF0C;&#x4E0D;&#x8FC7;&#x8FD9;&#x9053;&#x9898;&#x7ED9;&#x51FA;&#x7684;&#x662F;&#x70B9;&#x6743;&#xFF0C;&#x56E0;&#x6B64;&#x8F6C;&#x79FB;&#x5982;&#x4E0B;&#xFF1A; fp,s=min&#x2061;{fp,t+fp,s&#x2295;t&#x2212;valuep}f_{p,s}=\\min\\{f_{p,t}+f_{p,s\\oplus t}-value_p\\}fp,s&#x200B;=min{fp,t&#x200B;+fp,s&#x2295;t&#x200B;&#x2212;valuep&#x200B;} fp,s=min&#x2061;{fv,s+dist(p,v)}f_{p,s}=\\min\\{f_{v,s}+dist(p,v)\\}fp,s&#x200B;=min{fv,s&#x200B;+dist(p,v)} &#x7136;&#x540E;&#x987A;&#x4FBF;&#x8981;&#x8BB0;&#x5F55;&#x5E76;&#x8F93;&#x51FA;&#x65B9;&#x6848; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() getchar()typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}namespace modular{ const int mod=1e9+7; inline int add(int a,int b){return (a+=b)&lt;mod?a:a-mod;} inline void Add(int&amp;a,int b){a=add(a,b);} inline int dec(int a,int b){return (a-=b)&lt;0?a+mod:a;} inline void Dec(int&amp;a,int b){a=dec(a,b);} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;}}//using namespace modular;int dx[]={0,0,1,-1};int dy[]={1,-1,0,0};const int N=15,S=1&lt;&lt;10|5;int d[N][N][S],n,m,K,ct=0,vl[N][N],tr[N][N],all;struct Node{int x,y,s;}pre[N][N][S];set&lt;pair&lt;pii,int&gt; &gt;q;inline void dijkstra(int s){ while(q.size()){ pii v,x=q.begin()-&gt;fi; q.erase(q.begin()); for(ri i=0;i&lt;4;++i){ v=pii(x.fi+dx[i],x.se+dy[i]); if(d[v.fi][v.se][s]&gt;d[x.fi][x.se][s]+vl[v.fi][v.se]){ if(d[v.fi][v.se][s]!=d[0][0][0])q.erase(make_pair(v,d[v.fi][v.se][s])); d[v.fi][v.se][s]=d[x.fi][x.se][s]+vl[v.fi][v.se]; pre[v.fi][v.se][s]=(Node){x.fi,x.se,s}; q.insert(make_pair(v,d[v.fi][v.se][s])); } } }}bool vs[N][N];inline void getprint(int x,int y,int s){ if(!x)return; vs[x][y]=1; getprint(pre[x][y][s].x,pre[x][y][s].y,pre[x][y][s].s); if(pre[x][y][s].x==x&amp;&amp;pre[x][y][s].y==y)getprint(x,y,(pre[x][y][s].s^s)|tr[x][y]);}inline void print(){ for(ri i=1;i&lt;=n;++i,puts(&quot;&quot;))for(ri j=1;j&lt;=m;++j){ if(tr[i][j])cout&lt;&lt;&apos;x&apos;; else if(vs[i][j])cout&lt;&lt;&apos;o&apos;; else cout&lt;&lt;&apos;_&apos;; } exit(0);}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(),m=read(); for(ri i=1;i&lt;=n;++i){ for(ri j=1;j&lt;=m;++j){ vl[i][j]=read(); if(!vl[i][j]){ ++ct; tr[i][j]=1&lt;&lt;(ct-1); } } } all=(1&lt;&lt;ct)-1; for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=m;++j)memset(d[i][j],0x3f,sizeof(int)*(all+3)); for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=m;++j)if(tr[i][j])d[i][j][tr[i][j]]=0; d[0][0][0]=d[1][1][0]; for(ri s=0;s&lt;=all;++s){ for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=m;++j){ if(tr[i][j]&amp;&amp;!(tr[i][j]&amp;s))continue; for(ri t=(s-1)&amp;s,upd;t;t=(t-1)&amp;s){ upd=d[i][j][t|tr[i][j]]+d[i][j][(s^t)|tr[i][j]]-vl[i][j]; if(d[i][j][s]&gt;upd){ d[i][j][s]=upd; pre[i][j][s]=(Node){i,j,t|tr[i][j]}; } } if(d[i][j][s]!=d[0][0][0])q.insert(make_pair(pii(i,j),d[i][j][s])); } dijkstra(s); } for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=m;++j)if(tr[i][j]){ cout&lt;&lt;d[i][j][all]&lt;&lt;&apos;\\n&apos;; getprint(i,j,all); print(); } return 0;} Umnozak &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x9996;&#x5148;&#x4E00;&#x6253;&#x5F00;&#x9898;&#x5C31;&#x6709;&#x4E00;&#x4E2A;&#x66B4;&#x529B;&#x7684;&#x601D;&#x8DEF;&#xFF0C;&#x679A;&#x4E3E;&#x8FD9;&#x4E2A;&#x6570;&#x7531;&#x591A;&#x5C11;&#x4E2A; 1,2,...,91,2,...,91,2,...,9 &#x7EC4;&#x6210;&#x7136;&#x540E;&#x5BF9;&#x4E8E;&#x6BCF;&#x79CD;&#x60C5;&#x51B5;&#x505A;&#x6570;&#x4F4D; dpdpdp&#xFF0C;&#x4F46;&#x65B9;&#x6848;&#x6570;&#x8F83;&#x5927;&#xFF0C;&#x7EA6;&#x5728; 106&#x22EF;10710^6\\cdots10^7106&#x22EF;107 &#x7684;&#x7EA7;&#x522B;&#xFF0C;&#x65E0;&#x6CD5;&#x901A;&#x8FC7;&#x6B64;&#x9898; &#x56E0;&#x6B64;&#x8003;&#x8651;&#x5230;&#x4E0A;&#x8FF0;&#x505A;&#x6CD5;&#x4E2D;&#x8F83;&#x591A;&#x65B9;&#x6848;&#x7684;&#x6240;&#x6709;&#x6570;&#x4F4D;&#x7684;&#x4E58;&#x79EF;&#x76F8;&#x540C;&#xFF0C;&#x8FDB;&#x800C;&#x60F3;&#x5230;&#x53EA;&#x9700;&#x8981;&#x679A;&#x4E3E;&#x4E58;&#x79EF;&#x7531;&#x591A;&#x5C11;&#x4E2A; 2,3,5,72,3,5,72,3,5,7 &#x7EC4;&#x6210;&#x5373;&#x53EF;&#xFF0C;&#x7136;&#x540E;&#x5BF9;&#x6BCF;&#x79CD;&#x65B9;&#x6848;&#x8FDB;&#x884C;&#x6570;&#x4F4D; dpdpdp &#x5C31;&#x80FD;&#x591F;&#x901A;&#x8FC7;&#x6B64;&#x9898; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() getchar()typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}namespace modular{ const int mod=1e9+7; inline int add(int a,int b){return (a+=b)&lt;mod?a:a-mod;} inline void Add(int&amp;a,int b){a=add(a,b);} inline int dec(int a,int b){return (a-=b)&lt;0?a+mod:a;} inline void Dec(int&amp;a,int b){a=dec(a,b);} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;}}//using namespace modular;ll L,R;int ct[10][4]={ {0,0,0,0}, {0,0,0,0}, {1,0,0,0}, {0,1,0,0}, {2,0,0,0}, {0,0,1,0}, {1,1,0,0}, {0,0,0,1}, {3,0,0,0}, {0,2,0,0}};int vl[20],ctt[4],len;ll f[20][30][19][13][11];inline ll dfs(int ps,int*a,bool lim,bool zero){ if(ps==0)return !zero&amp;&amp;!(a[0]+a[1]+a[2]+a[3]); if(!lim&amp;&amp;!zero&amp;&amp;~f[ps][a[0]][a[1]][a[2]][a[3]])return f[ps][a[0]][a[1]][a[2]][a[3]]; ll res=0; if(zero)res+=dfs(ps-1,a,0,1); for(ri ff,i=1,up=lim?vl[ps]:9;i&lt;=up;++i){ ff=1; for(ri j=0;j&lt;4;++j)if(ct[i][j]&gt;a[j]){ ff=0; break; } if(!ff)continue; for(ri j=0;j&lt;4;++j)a[j]-=ct[i][j]; res+=dfs(ps-1,a,lim&amp;&amp;i==up,0); for(ri j=0;j&lt;4;++j)a[j]+=ct[i][j]; } if(!lim&amp;&amp;!zero)f[ps][a[0]][a[1]][a[2]][a[3]]=res; return res;}inline void init(ll tp){ len=0; while(tp)vl[++len]=tp%10,tp/=10;}inline ll solve(ll x){ if(!x)return 0; if(x==1)return 1; ll up=min(x,1000000000ll); ctt[0]=0; ll res=0; memset(f,-1,sizeof(f)); for(ll mt1=1;;mt1*=2,++ctt[0]){ ctt[1]=0; for(ll mt2=mt1;;mt2*=3,++ctt[1]){ ctt[2]=0; for(ll mt3=mt2;;mt3*=5,++ctt[2]){ ctt[3]=0; for(ll mt4=mt3;;mt4*=7,++ctt[3]){ init(x/mt4); res+=dfs(len,ctt,1,1); if(up/7&lt;mt4)break; } if(up/5&lt;mt3)break; } if(up/3&lt;mt2)break; } if(up/2&lt;mt1)break; } return res;}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif cin&gt;&gt;L&gt;&gt;R; cout&lt;&lt;solve(R)-solve(L-1); return 0;} Ksenia and Combinatorics &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x9996;&#x5148;&#x901A;&#x8FC7;&#x5F52;&#x7EB3;&#x53EF;&#x4EE5;&#x8BC1;&#x660E;&#x51FA;&#x5982;&#x4E0B;&#x7ED3;&#x8BBA;&#xFF1A; &#x5BF9;&#x4E8E;&#x6811;&#x7684;&#x5339;&#x914D;&#xFF0C;&#x8BBE; fi,0/1f_{i,0/1}fi,0/1&#x200B; &#x8868;&#x793A;&#x5BF9;&#x4E8E; iii &#x7684;&#x5B50;&#x6811;&#x7528;/&#x4E0D;&#x7528;&#x6839;&#x80FD;&#x5F97;&#x5230;&#x7684;&#x6700;&#x5927;&#x5339;&#x914D;&#x6570;&#xFF0C;&#x90A3;&#x4E48;&#x6709; fi,0&#x2264;fi,1&#x2264;fi,0+1f_{i,0}\\le f_{i,1}\\le f_{i,0}+1fi,0&#x200B;&#x2264;fi,1&#x200B;&#x2264;fi,0&#x200B;+1 &#x56E0;&#x6B64;&#x53EF;&#x4EE5;&#x5B9A;&#x4E49;&#x5982;&#x4E0B;&#x72B6;&#x6001;: fi,j,0/1f_{i,j,0/1}fi,j,0/1&#x200B; &#x8868;&#x793A; iii &#x4E2A;&#x70B9;&#x7684;&#x6811;&#xFF0C;&#x6700;&#x5927;&#x5339;&#x914D;&#x6570;&#x4E3A; jjj &#xFF0C;&#x7528;&#x6839;&#x8FDB;&#x884C;&#x5339;&#x914D;&#x7684;&#x6700;&#x5927;&#x5339;&#x914D;&#x6570;&#x51CF;&#x53BB;&#x4E0D;&#x7528;&#x6839;&#x8FDB;&#x884C;&#x5339;&#x914D;&#x7684;&#x6700;&#x5927;&#x5339;&#x914D;&#x6570;&#x7684;&#x503C;&#x4E3A; 0/10/10/1 &#x65F6;&#x7684;&#x65B9;&#x6848;&#x6570;&#xFF0C;&#x8F6C;&#x79FB;&#x6BD4;&#x8F83;&#x81EA;&#x7136;&#xFF0C;&#x56E0;&#x6B64;&#x4E0D;&#x4E00;&#x4E00;&#x8D58;&#x8FF0; CODE cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() getchar()typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}namespace modular{ const int mod=1e9+7,inv2=5e8+4; inline int add(int a,int b){return (a+=b)&lt;mod?a:a-mod;} inline void Add(int&amp;a,int b){a=add(a,b);} inline int dec(int a,int b){return (a-=b)&lt;0?a+mod:a;} inline void Dec(int&amp;a,int b){a=dec(a,b);} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;}}using namespace modular;const int N=55;int n,K,f[N][N][2],C[N][N];inline void init(){ for(ri i=0;i&lt;=n;++i){ C[i][0]=1; for(ri j=1;j&lt;=i;++j)C[i][j]=add(C[i-1][j],C[i-1][j-1]); }}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(),K=read(); f[0][0][1]=f[1][0][0]=1; init(); for(ri i=2,t;i&lt;=n;++i)for(ri j=0;j&lt;=K&amp;&amp;j+j&lt;=i;++j){ for(ri k=0;k+k+1&lt;=i;++k){ t=mul(mul(k+k+1==i?inv2:1,C[i-1][k]),mul(max(k,1),i-k-1)); for(ri p=0;p&lt;=j&amp;&amp;p+p&lt;=k;++p){ Add(f[i][j][0],mul(t,mul(f[k][p][1],f[i-k-1][j-p][1]))); if(j==p)continue; Add(f[i][j][1],mul(t,mul(f[k][p][0],f[i-k-1][j-p-1][0]))); Add(f[i][j][1],mul(t,mul(f[k][p][1],f[i-k-1][j-p-1][0]))); Add(f[i][j][1],mul(t,mul(f[k][p][0],f[i-k-1][j-p-1][1]))); } } } cout&lt;&lt;add(f[n][K][0],f[n][K][1]); return 0;} isn &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x9996;&#x5148;&#x7528; bitbitbit &#x8F85;&#x52A9;&#x6C42;&#x51FA; fi,jf_{i,j}fi,j&#x200B; &#x8868;&#x793A;&#x4EE5; iii &#x7ED3;&#x5C3E;&#x7684;&#x957F;&#x5EA6;&#x4E3A; jjj &#x7684;&#x4E0D;&#x964D;&#x5E8F;&#x5217;&#x65B9;&#x6848;&#x6570;&#xFF0C;&#x8FDB;&#x800C;&#x7EDF;&#x8BA1;&#x51FA; gig_igi&#x200B; &#x8868;&#x793A;&#x957F;&#x5EA6;&#x4E3A; iii &#x7684;&#x4E0D;&#x964D;&#x5E8F;&#x5217;&#x7684;&#x65B9;&#x6848;&#x6570; &#x7136;&#x540E;&#x8FDB;&#x884C;&#x7B80;&#x5355;&#x5BB9;&#x65A5;&#x6765;&#x6C42;&#x7B54;&#x6848; &#x5047;&#x8BBE;&#x5BF9;&#x4E8E; gig_igi&#x200B; &#x4E2D;&#x6BCF;&#x4E2A;&#x65B9;&#x6848;&#x6DFB;&#x4E0A;&#x4EFB;&#x610F;&#x4E00;&#x4E2A;&#x6570;&#x90FD;&#x4F1A;&#x4E0D;&#x6EE1;&#x8DB3;&#x4E0D;&#x964D;&#xFF0C;&#x90A3;&#x4E48; Ans=&#x2211;i=1ngi&#xD7;(n&#x2212;i)!Ans=\\sum\\limits_{i=1}^ng_i\\times(n-i)!Ans=i=1&#x2211;n&#x200B;gi&#x200B;&#xD7;(n&#x2212;i)! &#xFF0C;&#x4F46;&#x73B0;&#x5728;&#x4F1A;&#x7B97;&#x5165;&#x6DFB;&#x4E0A;&#x4E00;&#x4E2A;&#x6570;&#x4E4B;&#x540E;&#x4ECD;&#x7136;&#x4E0D;&#x964D;&#x7684;&#x65B9;&#x6848;&#x6570;&#xFF0C;&#x4E8E;&#x662F;&#x6263;&#x6389; &#x2211;i=1ngi+1&#xD7;(n&#x2212;i+1)!&#xD7;(i+1)\\sum\\limits_{i=1}^ng_{i+1}\\times(n-i+1)!\\times(i+1)i=1&#x2211;n&#x200B;gi+1&#x200B;&#xD7;(n&#x2212;i+1)!&#xD7;(i+1) &#x5373;&#x53EF; CODE cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() getchar()typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}namespace modular{ const int mod=1e9+7; inline int add(int a,int b){return (a+=b)&lt;mod?a:a-mod;} inline void Add(int&amp;a,int b){a=add(a,b);} inline int dec(int a,int b){return (a-=b)&lt;0?a+mod:a;} inline void Dec(int&amp;a,int b){a=dec(a,b);} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;}}using namespace modular;const int N=2005;int a[N],n,cur,f[2][N],g[N],vl[N],sig;inline int find(int x){return lower_bound(vl+1,vl+sig+1,x)-vl;}int bit[N];inline int lowbit(int x){return x&amp;-x;}inline void update(int x,int v){for(;x&lt;=n;x+=lowbit(x))Add(bit[x],v);}inline int query(int x){int res=0;for(;x;x^=lowbit(x))Add(res,bit[x]);return res;}int fac[N];inline void init(){ fac[0]=fac[1]=1; for(ri i=2;i&lt;=n;++i)fac[i]=mul(fac[i-1],i);}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(); init(); for(ri i=1;i&lt;=n;++i)a[i]=vl[++sig]=read(); sort(vl+1,vl+sig+1),sig=unique(vl+1,vl+sig+1)-vl-1; for(ri i=1;i&lt;=n;++i)a[i]=find(a[i]); cur=0; update(1,1); for(ri len=1;len&lt;=n;++len){ cur^=1; for(ri i=1;i&lt;=n;++i){ f[cur][i]=query(a[i]); update(a[i],f[cur^1][i]); Add(g[len],f[cur][i]); } for(ri i=1;i&lt;=n;++i)bit[i]=0; } int res=0; for(ri i=1;i&lt;=n;++i)Mul(g[i],fac[n-i]); for(ri i=1;i&lt;=n;++i){ Dec(g[i],mul(g[i+1],i+1)); Add(res,g[i]); } cout&lt;&lt;res; return 0;} &#x795E;&#x7ECF;&#x7F51;&#x7EDC; &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x9996;&#x5148;&#x8F6C;&#x5316;&#x9898;&#x610F;&#xFF0C;&#x76F8;&#x5F53;&#x4E8E;&#x662F;&#x628A;&#x6BCF;&#x68F5;&#x6811;&#x62C6;&#x6210;&#x82E5;&#x5E72;&#x6761;&#x94FE;&#x7136;&#x540E;&#x628A;&#x94FE;&#x7F29;&#x6210;&#x70B9;&#x6C42;&#x82E5;&#x5E72;&#x6392;&#x70B9;&#x4E4B;&#x95F4;&#x7684;&#x54C8;&#x5BC6;&#x987F;&#x56DE;&#x8DEF;&#x6570;&#xFF08;&#x540C;&#x4E00;&#x6392;&#x70B9;&#x4E4B;&#x95F4;&#x4E0D;&#x80FD;&#x8FDE;&#x8FB9;&#xFF09;&#xFF0C;&#x8FD9;&#x6837;&#x5BF9;&#x6BCF;&#x68F5;&#x6811;&#x6811;&#x5F62; dpdpdp &#x51FA; fif_{i}fi&#x200B; &#x8868;&#x793A;&#x628A;&#x6574;&#x68F5;&#x6811;&#x62C6;&#x6210; iii &#x6761;&#x94FE;&#x7684;&#x65B9;&#x6848;&#x6570;&#xFF0C;&#x7136;&#x540E;&#x8003;&#x8651;&#x5982;&#x4F55;&#x6C42;&#x7B54;&#x6848;&#xFF0C;&#x53D1;&#x73B0;&#x53EF;&#x4EE5;&#x5229;&#x7528;&#x8FDE;&#x901A;&#x5757;&#x5BB9;&#x65A5;&#xFF0C;&#x5373;&#x5F3A;&#x5236;&#x67D0;&#x4E00;&#x6392;&#x4E2D;&#x7684;&#x67D0;&#x4E9B;&#x94FE;&#x4E00;&#x5B9A;&#x8FDE;&#x901A;&#x6765;&#x5BB9;&#x65A5;&#xFF0C;&#x5982;&#x679C;&#x5C06;&#x54C8;&#x5BC6;&#x987F;&#x56DE;&#x8DEF;&#x7684;&#x904D;&#x5386;&#x6620;&#x5C04;&#x5230;&#x5E8F;&#x5217;&#x4E0A;&#xFF0C;&#x5219;&#x76F8;&#x5F53;&#x4E8E;&#x662F;&#x4E00;&#x4E2A;&#x8FDE;&#x7EED;&#x6BB5;&#x90FD;&#x5C5E;&#x4E8E;&#x540C;&#x4E00;&#x6392;&#x8FD9;&#x6837;&#x7684;&#x4E0D;&#x5408;&#x6CD5;&#x65B9;&#x6848;&#x6570;&#xFF0C;&#x76F4;&#x63A5;&#x679A;&#x4E3E;&#x6BB5;&#x4E0E;&#x6BB5;&#x4E4B;&#x95F4;&#x7684;&#x7A7A;&#x9699;&#x6765;&#x8FDB;&#x884C;&#x5BB9;&#x65A5;&#x5373;&#x53EF;&#x3002; &#x7136;&#x540E;&#x73B0;&#x5728;&#x8981;&#x5C06;&#x6240;&#x6709;&#x6811;&#x7ED9;&#x5408;&#x8D77;&#x6765;&#xFF0C;&#x7528; EGFEGFEGF &#x641E;&#x5373;&#x53EF;&#xFF0C;&#x6CE8;&#x610F;&#x7B2C;&#x4E00;&#x68F5;&#x6811;&#x6709;&#x9650;&#x5236;&#x6761;&#x4EF6;&#xFF1A;&#x7B2C;&#x4E00;&#x4E2A;&#x548C;&#x6700;&#x540E;&#x4E00;&#x4E2A;&#x4E0D;&#x80FD;&#x662F;&#x540C;&#x4E00;&#x6392;&#x7684; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_backusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,ll&gt; pll;typedef pair&lt;ll,int&gt; pli;typedef unsigned int uii;typedef unsigned long long Ull;typedef vector&lt;int&gt; poly;inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline ll readl(){ ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s){ int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;}namespace modular{ const int mod=998244353,inv2=499122177; inline int add(int a,int b){return a+b&lt;mod?a+b:a+b-mod;} inline int dec(int a,int b){return a-b&lt;0?a-b+mod:a-b;} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Add(int&amp;a,int b){a=add(a,b);} inline void Dec(int&amp;a,int b){a=dec(a,b);} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;} inline int Inv(int a){return ksm(a,mod-2);} inline void fix(int&amp;a){a=(a%mod+mod)%mod;}}using namespace modular;template&lt;typename T&gt;inline void ckmax(T&amp;a,T b){a&lt;b?a=b:0;}template&lt;typename T&gt;inline void ckmin(T&amp;a,T b){a&gt;b?a=b:0;}const int N=5005;int m,n,f[N][N][3],fac[N],ifac[N],siz[N],tmp[N][3];poly res(1,1);vector&lt;int&gt;e[N];int *tv,*tp;void dfs(int p,int ft){ f[p][1][0]=1,siz[p]=1; for(ri i=0,v;i&lt;e[p].size();++i){ if((v=e[p][i])==ft)continue; dfs(v,p); for(ri j=0;j&lt;=siz[v]+siz[p];++j)tmp[j][0]=tmp[j][1]=tmp[j][2]=0; for(ri j=0;j&lt;=siz[v];++j)if(f[v][j][0]||f[v][j][1]||f[v][j][2]){ tv=f[v][j]; for(ri k=0;k&lt;=siz[p];++k)if(f[p][k][0]||f[p][k][1]||f[p][k][2]){ tp=f[p][k]; for(ri a=0;a&lt;3;++a)for(ri b=0;b&lt;3;++b)Add(tmp[j+k][a],mul(tp[a],tv[b])); Add(tmp[j+k-1][1],mul(tp[0],tv[1])); Add(tmp[j+k-1][2],mul(mul(inv2,tp[1]),tv[1])); Add(tmp[j+k-1][1],mul(mul(2,tp[0]),tv[0])); Add(tmp[j+k-1][2],mul(tp[1],tv[0])); } } for(ri j=0;j&lt;=siz[v]+siz[p];++j){ f[p][j][0]=tmp[j][0]; f[p][j][1]=tmp[j][1]; f[p][j][2]=tmp[j][2]; } siz[p]+=siz[v]; }}inline void init(){ fac[0]=fac[1]=ifac[0]=ifac[1]=1; for(ri i=2;i&lt;=5000;++i){ fac[i]=mul(fac[i-1],i); ifac[i]=mul(ifac[mod-mod/i*i],mod-mod/i); } for(ri i=2;i&lt;=5000;++i)Mul(ifac[i],ifac[i-1]);}inline int C(int n,int m){return mul(fac[n],mul(ifac[m],ifac[n-m]));}inline poly operator*(poly a,poly b){ int n=a.size(),m=b.size(),t=n+m-1; poly c(t); for(ri i=0;i&lt;n;++i)if(a[i]) for(ri j=0;j&lt;m;++j)if(b[j]) Add(c[i+j],mul(a[i],b[j])); return c;}inline void update(int dt){ poly ad(n+1); for(ri t,s,sz=1;sz&lt;=n;++sz){ s=mul(fac[sz-dt],add(add(f[1][sz][0],f[1][sz][1]),f[1][sz][2])); for(ri i=1;i&lt;=sz;++i){ t=mul(C(sz-1,i-1),s); t=(sz-i)&amp;1?mod-t:t; Add(ad[i-dt],t); if(dt&amp;&amp;i&gt;1)Dec(ad[i-2],t); } } for(ri i=0;i&lt;ad.size();++i)Mul(ad[i],ifac[i]); res=res*ad;}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif m=read(); init(); for(ri tt=1;tt&lt;=m;++tt){ n=read(); for(ri i=1;i&lt;=n;++i){ e[i].clear(); for(ri j=1;j&lt;=n;++j){ f[i][j][0]=0; f[i][j][1]=0; f[i][j][2]=0; } } for(ri i=1,u,v;i&lt;n;++i){ u=read(),v=read(); e[u].pb(v); e[v].pb(u); } dfs(1,0); update(tt==1); } int ans=0; for(ri i=0;i&lt;res.size();++i)Add(ans,mul(res[i],fac[i])); cout&lt;&lt;ans; return 0;} &#x4FA6;&#x67E5;&#x5B88;&#x536B; &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x8003;&#x8651; fi,jf_{i,j}fi,j&#x200B; &#x8868;&#x793A;&#x5C06; iii &#x5B50;&#x6811;&#x4E2D;&#x5173;&#x952E;&#x70B9;&#x8986;&#x76D6;&#x5B8C;&#x4E14;&#x80FD;&#x5411; iii &#x5B50;&#x6811;&#x5916;&#x8986;&#x76D6; jjj &#x5355;&#x4F4D;&#x8DDD;&#x79BB;&#x7684;&#x6700;&#x5C0F;&#x4EE3;&#x4EF7;&#xFF0C; gi,jg_{i,j}gi,j&#x200B; &#x8868;&#x793A; iii &#x5B50;&#x6811;&#x4E2D;&#x53EA;&#x5269;&#x4E0B;&#x8DDF; iii &#x8DDD;&#x79BB;&#x5C0F;&#x4E8E; jjj &#x7684;&#x5173;&#x952E;&#x70B9;&#x672A;&#x8986;&#x76D6;&#x7684;&#x6700;&#x5C0F;&#x6743;&#x503C;&#xFF0C;&#x7136;&#x540E;&#x6709;&#x663E;&#x7136;&#x7684;&#x8F6C;&#x79FB;&#xFF0C;&#x8FD9;&#x91CC;&#x4E0D;&#x4E00;&#x4E00;&#x8D58;&#x8FF0;&#xFF0C;&#x8981;&#x63D0;&#x5230;&#x7684;&#x5219;&#x662F;&#x53EF;&#x80FD;&#x5728;&#x513F;&#x5B50;&#x5BF9;&#x7236;&#x4EB2;&#x8FDB;&#x884C;&#x66F4;&#x65B0;&#x4E4B;&#x540E;&#x51FA;&#x73B0; fi,j&gt;fi,j+1f_{i,j}&gt;f_{i,j+1}fi,j&#x200B;&gt;fi,j+1&#x200B; &#x6216;&#x8005; gi,j&gt;gi,j&#x2212;1g_{i,j}&gt;g_{i,j-1}gi,j&#x200B;&gt;gi,j&#x2212;1&#x200B; &#x7684;&#x60C5;&#x51B5;&#xFF0C;&#x56E0;&#x6B64;&#x8981;&#x628A;&#x4E24;&#x4E2A;&#x72B6;&#x6001;&#x7684;&#x5B9A;&#x4E49;&#x52A0;&#x4E0A;&#x6700;&#x5C11;&#x548C;&#x81F3;&#x591A;&#x7684;&#x9650;&#x5236;&#xFF0C;&#x7136;&#x540E;&#x524D;&#x540E;&#x7F00;&#x8FDB;&#x884C;&#x66F4;&#x65B0; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() getchar()typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}namespace modular{ const int mod=1e9+7; inline int add(int a,int b){return (a+=b)&lt;mod?a:a-mod;} inline void Add(int&amp;a,int b){a=add(a,b);} inline int dec(int a,int b){return (a-=b)&lt;0?a+mod:a;} inline void Dec(int&amp;a,int b){a=dec(a,b);} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;}}using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b){a&gt;b?a=b:0;}const int N=5e5+5,inf=0x3f3f3f3f,D=22;vector&lt;int&gt;e[N];bool is[N];int n,m,d,a[N],f[N][D],g[N][D];void dfs(int p,int ft){ if(is[p])f[p][0]=g[p][0]=a[p]; for(ri i=1;i&lt;=d;++i)f[p][i]=a[p]; f[p][d+1]=inf; for(ri i=0,v;i&lt;e[p].size();++i){ if((v=e[p][i])==ft)continue; dfs(v,p); for(ri j=d;~j;--j)f[p][j]=min(f[p][j]+g[v][j],g[p][j+1]+f[v][j+1]); for(ri j=d;~j;--j)ckmin(f[p][j],f[p][j+1]); g[p][0]=f[p][0]; for(ri j=1;j&lt;=d;++j)g[p][j]+=g[v][j-1]; for(ri j=1;j&lt;=d;++j)ckmin(g[p][j],g[p][j-1]); } ckmin(g[p][d+1],g[p][d]);}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(),d=read(); for(ri i=1;i&lt;=n;++i)a[i]=read(); m=read(); for(ri i=1;i&lt;=m;++i)is[read()]=1; for(ri i=1,u,v;i&lt;n;++i){ u=read(),v=read(); e[u].pb(v); e[v].pb(u); } dfs(1,0); cout&lt;&lt;f[1][0]; return 0;}","categories":[{"name":"public","slug":"public","permalink":"http://xdl030112.github.io/categories/public/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://xdl030112.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"杂题乱做 Round1","slug":"sol1","date":"2019-10-17T03:28:59.000Z","updated":"2019-12-27T06:48:30.602Z","comments":true,"path":"sol1/","link":"","permalink":"http://xdl030112.github.io/sol1/","excerpt":"","text":"&#x7EBF;&#x6BB5;&#x6811; &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x8003;&#x8651;&#x5230;&#x5982;&#x679C;&#x7EDF;&#x8BA1;&#x7EDF;&#x8BA1; fi,jf_{i,j}fi,j&#x200B; &#x8868;&#x793A;&#x7B2C; iii &#x4E2A;&#x4F4D;&#x7F6E;&#x7684;&#x6570;&#x6700;&#x7EC8;&#x7B49;&#x4E8E; jjj &#x7684;&#x6982;&#x7387;&#xFF0C;&#x7136;&#x540E;&#x5BF9;&#x4E8E;&#x4E00;&#x4E2A;&#x4F4D;&#x7F6E; iii &#x7B54;&#x6848;&#x5C31;&#x662F; &#x2211;jfi,jvlj\\sum\\limits_{j}f_{i,j}vl_jj&#x2211;&#x200B;fi,j&#x200B;vlj&#x200B; &#xFF0C;&#x7136;&#x540E;&#x5C31;&#x80FD;&#x591F;&#x8FDB;&#x884C;&#x8F6C;&#x5316;&#xFF0C;&#x53D8;&#x4E3A;&#x6C42;&#x6BCF;&#x4E2A;&#x4F4D;&#x7F6E;&#x6700;&#x7EC8; &#x2265;j\\ge j&#x2265;j &#x7684;&#x6982;&#x7387;&#xFF0C;&#x7136;&#x540E;&#x5C31;&#x80FD;&#x591F;&#x679A;&#x4E3E;&#x6BCF;&#x4E2A;&#x6392;&#x540D;&#x7136;&#x540E;&#x5BF9;&#x7B1B;&#x5361;&#x5C14;&#x6811;&#x7684;&#x4E00;&#x4E9B;&#x5B50;&#x6811;&#x8FDB;&#x884C;&#x5982;&#x4E0B; dpdpdp : &#x5BF9;&#x4E8E;&#x4E00;&#x4E2A;&#x6811;&#x6839;&#xFF0C;&#x8BBE;&#x5176;&#x80FD;&#x591F;&#x7BA1;&#x8F96;&#x7684;&#x8303;&#x56F4;&#x4E3A; [l,r][l,r][l,r] &#xFF0C;&#x90A3;&#x4E48;&#x6700;&#x540E;&#x533A;&#x95F4; [i&#x2265;l,j&#x2264;r][i\\ge l,j\\le r][i&#x2265;l,j&#x2264;r] &#x4E2D;&#x7684;&#x6570;&#x7684;&#x5927;&#x5C0F;&#x4E0D;&#x8D85;&#x8FC7;&#x6811;&#x6839;&#x5927;&#x5C0F;&#x7684;&#x6982;&#x7387;&#x53EF;&#x4EE5; dpdpdp &#x51FA;&#x6765;&#xFF0C;&#x8BBE; fT,i,jf_{T,i,j}fT,i,j&#x200B; &#x8868;&#x793A;&#x5728;&#x4E0A;&#x754C; xxx &#x786E;&#x5B9A;&#x540E;&#xFF0C;&#x5728;&#x7ECF;&#x8FC7; TTT &#x8F6E;&#x64CD;&#x4F5C;&#x540E;&#x533A;&#x95F4; [i,j][i,j][i,j] &#x7684;&#x7B54;&#x6848;&#x4E0D;&#x8D85;&#x8FC7; xxx &#x7684;&#x6982;&#x7387;&#xFF0C;&#x8FD9;&#x4E2A;&#x76F4;&#x63A5;&#x524D;&#x7F00;&#x548C;&#x4F18;&#x5316;&#x8F6C;&#x79FB;&#x5373;&#x53EF;&#xFF0C;&#x7531;&#x4E8E;&#x6570;&#x636E;&#x968F;&#x673A;&#xFF0C;&#x7B1B;&#x5361;&#x5C14;&#x6811;&#x9AD8;&#x53EF;&#x4EE5;&#x89C6;&#x4E3A; logloglog &#x7684;&#xFF0C;&#x8FD9;&#x6837;&#x590D;&#x6742;&#x5EA6;&#x5C31;&#x662F;&#x5BF9;&#x7684; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include&lt;bits/stdc++.h&gt;#define ri register int#define csi const int&amp;#define fi first#define se second#define pb push_backusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;vector&lt;int&gt; &gt; vii;inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline ll readl(){ ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s){ int top=0; char ch=gc(); while(ch!=&apos;*&apos;&amp;&amp;ch!=&apos;.&apos;)ch=gc(); while(ch==&apos;*&apos;||ch==&apos;.&apos;)s[++top]=ch,ch=gc(); return top;}namespace modular{ const int mod=1e9+7; inline int add(int a,int b){return (a+=b)&lt;mod?a:a-mod;} inline int dec(int a,int b){return (a-=b)&lt;0?a+mod:a;} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Add(int&amp;a,int b){a=add(a,b);} inline void Dec(int&amp;a,int b){a=dec(a,b);} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;} inline int Inv(int x){return ksm(x,mod-2);} inline void fix(int&amp;x){x=(x%mod+mod)%mod;}}using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,const T&amp;b){a&gt;b?a=b:0;}template&lt;typename T&gt;inline void ckmax(T&amp;a,const T&amp;b){a&lt;b?a=b:0;}const int N=405;int n,m,L[N],R[N],cur=0,trans[N][N],vl[N],sig,ori[N],mx[N][N];int f[2][N][N],res[N][N];inline int calc(int x){return x*(x+1)/2;}inline int find(int x){return lower_bound(vl+1,vl+sig+1,x)-vl;}inline void init(){ for(ri i=1;i&lt;=n;++i)ori[i]=find(ori[i]); ori[0]=ori[n+1]=sig+1; for(ri a=1;a&lt;=n;++a)for(ri b=a;b&lt;=n;++b){ mx[a][b]=max(mx[a][b-1],ori[b]); trans[a][b]=calc(a-1)+calc(b-a+1)+calc(n-b); }}inline void clear(int l,int r){ cur^=1; for(ri i=l;i&lt;=r;++i)for(ri j=i;j&lt;=r;++j) f[cur][i][j]=0;}inline void solve(int l,int r,int t){ int transum; clear(l,r); f[cur][l][r]=1; for(ri T=1;T&lt;=m;++T){ cur^=1; for(ri a=l;a&lt;=r;++a)for(ri b=a;b&lt;=r;++b) f[cur][a][b]=mul(f[cur^1][a][b],trans[a][b]); for(ri b=l;b&lt;=r;++b){ transum=0; for(ri a=l;a&lt;=b;++a){ Add(f[cur][a][b],transum); Add(transum,mul(f[cur^1][a][b],a-1)); } } for(ri a=r;a&gt;=l;--a){ transum=0; for(ri b=r;b&gt;=a;--b){ Add(f[cur][a][b],transum); Add(transum,mul(f[cur^1][a][b],n-b)); } } } for(ri b=l;b&lt;=r;++b){ transum=0; for(ri a=l;a&lt;=b;++a){ Add(transum,f[cur][a][b]); Add(res[a][t],transum); } }}int stk[N],tp;int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); freopen(&quot;own.out&quot;,&quot;w&quot;,stdout); #endif n=read(),m=read(); for(ri i=1;i&lt;=n;++i)ori[i]=vl[i]=read(); sort(vl+1,vl+n+1),sig=unique(vl+1,vl+n+1)-vl-1; init(); for(ri rk=1;rk&lt;=sig;++rk){ tp=0; for(ri i=0;i&lt;=n+1;++i)if(ori[i]&gt;rk)stk[++tp]=i; for(ri i=1;i&lt;tp;++i){ if(mx[stk[i]+1][stk[i+1]-1]&lt;rk){ for(ri ps=stk[i]+1;ps&lt;=stk[i+1]-1;++ps) Add(res[ps][rk],res[ps][rk-1]); } else solve(stk[i]+1,stk[i+1]-1,rk); } } for(ri p=1,sum;p&lt;=n;++p,sum=0){ for(ri rk=1;rk&lt;=sig;++rk) Add(sum,mul(vl[rk],dec(res[p][rk],res[p][rk-1]))); cout&lt;&lt;sum&lt;&lt;&apos; &apos;; } return 0;} &#x6124;&#x6012;&#x7684;&#x5143;&#x9996; &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; DAGDAGDAG &#x8BA1;&#x6570;&#x4E00;&#x822C;&#x8003;&#x8651;&#x5165;&#x5EA6;&#x4E3A; 000 &#x6216;&#x8005;&#x51FA;&#x5EA6;&#x4E3A; 000 &#x7684;&#x70B9;&#x6765;&#x8FDB;&#x884C;&#x5BB9;&#x65A5;&#xFF0C;&#x56E0;&#x4E3A;&#x5220;&#x6389;&#x8FD9;&#x4E9B;&#x70B9;&#x548C;&#x5B83;&#x4EEC;&#x6D89;&#x53CA;&#x5230;&#x7684;&#x8FB9;&#x4E4B;&#x540E;&#x8FD8;&#x662F;&#x4E2A; DAGDAGDAG &#x8BBE; fif_{i}fi&#x200B; &#x8868;&#x793A; iii &#x4E2A;&#x70B9;&#x7684; DAGDAGDAG &#x65B9;&#x6848;&#x6570;&#xFF0C; gig_igi&#x200B; &#x4E3A;&#x81F3;&#x5C11;&#x6709; iii &#x4E2A;&#x51FA;&#x5EA6;&#x4E3A; 000 &#x7684;&#x70B9;&#x7684;&#x65B9;&#x6848;&#x6570;&#xFF0C;&#x663E;&#x7136;&#x6709;&#x8F6C;&#x79FB; gj=fi&#x2212;j(ij)2j&#xD7;(i&#x2212;j)g_j=f_{i-j}\\binom{i}{j}2^{j\\times(i-j)}gj&#x200B;=fi&#x2212;j&#x200B;(ji&#x200B;)2j&#xD7;(i&#x2212;j) &#x548C; fi=&#x2211;j=1igj(&#x2212;1)j&#x2212;1f_i=\\sum\\limits_{j=1}^ig_j(-1)^{j-1}fi&#x200B;=j=1&#x2211;i&#x200B;gj&#x200B;(&#x2212;1)j&#x2212;1 &#x8FD9;&#x6837;&#x53EF;&#x4EE5; O(n2)O(n^2)O(n2) &#x641E;&#x5B9A;&#x4E86; CODE cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;bits/stdc++.h&gt;#define ri register int#define csi const int&amp;#define fi first#define se second#define pb push_backusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;vector&lt;int&gt; &gt; vii;inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline ll readl(){ ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s){ int top=0; char ch=gc(); while(ch!=&apos;*&apos;&amp;&amp;ch!=&apos;.&apos;)ch=gc(); while(ch==&apos;*&apos;||ch==&apos;.&apos;)s[++top]=ch,ch=gc(); return top;}namespace modular{ const int mod=1e9+7; inline int add(int a,int b){return (a+=b)&lt;mod?a:a-mod;} inline int dec(int a,int b){return (a-=b)&lt;0?a+mod:a;} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Add(int&amp;a,int b){a=add(a,b);} inline void Dec(int&amp;a,int b){a=dec(a,b);} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;} inline int Inv(int x){return ksm(x,mod-2);} inline void fix(int&amp;x){x=(x%mod+mod)%mod;}}using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,const T&amp;b){a&gt;b?a=b:0;}template&lt;typename T&gt;inline void ckmax(T&amp;a,const T&amp;b){a&lt;b?a=b:0;}const int N=3005;int n,f[N],fac[N],ifac[N],pw[N*N];inline void init(){ fac[0]=fac[1]=ifac[0]=ifac[1]=1; for(ri i=2;i&lt;=n;++i){ fac[i]=mul(fac[i-1],i); ifac[i]=mul(ifac[mod-mod/i*i],mod-mod/i); } pw[0]=1; for(ri i=1;i&lt;=n*n;++i)pw[i]=add(pw[i-1],pw[i-1]); for(ri i=2;i&lt;=n;++i)Mul(ifac[i],ifac[i-1]);}inline int C(int n,int m){return n&lt;m||m&lt;0?0:mul(fac[n],mul(ifac[m],ifac[n-m]));}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(); init(); f[0]=1; for(ri i=1;i&lt;=n;++i)for(ri t,j=1;j&lt;=i;++j){ t=mul(f[i-j],mul(C(i,j),pw[j*(i-j)])); j&amp;1?Add(f[i],t):Dec(f[i],t); } cout&lt;&lt;f[n]; return 0;} numbers &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x8003;&#x8651;&#x76F4;&#x63A5;&#x8F6C;&#x5316;&#x4E3A;&#x6C42;&#x5408;&#x6CD5;&#x62EC;&#x53F7;&#x5E8F;&#x5217;&#x7684;&#x65B9;&#x6848;&#x6570;&#xFF0C;&#x8FD9;&#x6837;&#x5BF9;&#x4E8E;&#x73B0;&#x5728;&#x7684;&#x533A;&#x95F4; [l,r][l,r][l,r] &#xFF0C;&#x53EF;&#x4EE5;&#x679A;&#x4E3E; lll &#x7684;&#x53F3;&#x62EC;&#x53F7;&#x653E;&#x7684;&#x4F4D;&#x7F6E;&#x7136;&#x540E;&#x8F6C;&#x79FB;&#x6210;&#x5B50;&#x533A;&#x95F4;&#x6C42;&#x89E3;&#xFF0C;&#x73B0;&#x5728;&#x53EA;&#x7528;&#x8003;&#x8651;&#x5408;&#x6CD5;&#x6027;&#x5982;&#x4F55;&#x5FEB;&#x901F;&#x5224;&#x65AD;&#xFF0C;&#x53D1;&#x73B0;&#x662F;&#x4E24;&#x4E2A;&#x4E0D;&#x76F8;&#x4EA4;&#x7684;&#x8FDE;&#x7EED;&#x533A;&#x95F4;&#x7684;&#x4FE1;&#x606F;&#x53E0;&#x52A0;&#x8D77;&#x6765;&#x7684;&#xFF0C;&#x4E8E;&#x662F;&#x7528;&#x4E8C;&#x7EF4;&#x524D;&#x7F00;&#x548C;&#x6765;&#x8BB0;&#x5F55;&#x9650;&#x5236;&#x5373;&#x53EF;&#x5224;&#x65AD;&#x5408;&#x6CD5;&#x6027; CODE cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;bits/stdc++.h&gt;#define ri register int#define csi const int&amp;#define fi first#define se second#define pb push_backusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;vector&lt;int&gt; &gt; vii;inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline ll readl(){ ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s){ int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;}namespace modular{ const int mod=1e9+7; inline int add(int a,int b){return (a+=b)&lt;mod?a:a-mod;} inline int dec(int a,int b){return (a-=b)&lt;0?a+mod:a;} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Add(int&amp;a,int b){a=add(a,b);} inline void Dec(int&amp;a,int b){a=dec(a,b);} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;} inline int Inv(int x){return ksm(x,mod-2);} inline void fix(int&amp;x){x=(x%mod+mod)%mod;}}using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,const T&amp;b){a&gt;b?a=b:0;}template&lt;typename T&gt;inline void ckmax(T&amp;a,const T&amp;b){a&lt;b?a=b:0;}const int N=305;int n,sum[N][N],m,f[N][N],tim[N][N],tot=0;inline int getsum(int x1,int x2,int y1,int y2){ return sum[x2][y2]+sum[x1-1][y1-1]-sum[x2][y1-1]-sum[x1-1][y2];}inline int dfs(int l,int r){ if(l==r)return 1; if(tim[l][r]==tot)return f[l][r]; tim[l][r]=tot; f[l][r]=0; if(!getsum(l,l,l,r))Add(f[l][r],dfs(l+1,r)); for(ri i=l+1;i&lt;=r;++i)if(!getsum(i,r,l,i-1)&amp;&amp;!getsum(l,l,l,i-1)) Add(f[l][r],mul(i==l+1?1:dfs(l+1,i-1),dfs(i,r))); return f[l][r];}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif for(ri tt=read();tt;--tt){ ++tot; n=read(),m=read(); for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=n;++j)sum[i][j]=0; for(ri a,b,i=1;i&lt;=m;++i){ a=read(),b=read(); sum[a][b]=1; } for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=n;++j) sum[i][j]+=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]; bool ff=1; for(ri i=1;i&lt;=n;++i)if(getsum(i,i,i,i)){ ff=0; break; } if(!ff)puts(&quot;0&quot;); else cout&lt;&lt;dfs(1,n)&lt;&lt;&apos;\\n&apos;; } return 0;} Dark Horse &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x628A;&#x6BD4;&#x8D5B;&#x7684;&#x8868;&#x5012;&#x7740;&#x753B;&#x51FA;&#x6765;&#xFF0C;&#x53D1;&#x73B0;&#x662F;&#x4E00;&#x68F5;&#x4E8C;&#x53C9;&#x6811;&#xFF0C;&#x8FD9;&#x6837;&#x770B;&#x6765;&#x4E0D;&#x59A8;&#x628A; 111 &#x653E;&#x5728;&#x7B2C;&#x4E00;&#x4E2A;&#x53F6;&#x5B50;&#x7ED3;&#x70B9;&#x6700;&#x540E;&#x65B9;&#x6848;&#x6570;&#x518D;&#x4E58;&#x4E0A; 2n2^n2n &#xFF0C;&#x7136;&#x540E;&#x73B0;&#x5728;&#x8981;&#x6C42;&#x7684;&#x662F;&#x4ECE;&#x7B2C;&#x4E00;&#x4E2A;&#x53F6;&#x5B50;&#x5230;&#x6839;&#x7684;&#x8DEF;&#x5F84;&#x4E0A;&#x4E0D;&#x80FD;&#x6709;&#x975E;&#x6CD5;&#x70B9;&#xFF0C;&#x4E0D;&#x96BE;&#x60F3;&#x5230;&#x4ECE;&#x5927;&#x5230;&#x5C0F;&#x679A;&#x4E3E;&#x975E;&#x6CD5;&#x70B9;&#x5728;&#x8DEF;&#x5F84;&#x4E0A;&#x51FA;&#x73B0;&#x7684;&#x72B6;&#x6001;&#xFF0C;&#x5219; fi,jf_{i,j}fi,j&#x200B; &#x8868;&#x793A;&#x5F53;&#x524D;&#x8D70;&#x5230;&#x7B2C; iii &#x4E2A;&#x70B9;&#xFF0C;&#x4ECE;&#x53F6;&#x5B50;&#x5230;&#x6839;&#x7684;&#x5FC5;&#x8F93;&#x4F4D;&#x7F6E;&#x96C6;&#x5408;&#x4E3A; jjj &#x7684;&#x65B9;&#x6848;&#x6570;&#xFF0C;&#x6700;&#x540E;&#x5BB9;&#x65A5;&#x4E00;&#x4E0B;&#x5373;&#x53EF;&#xFF08;&#x4E5F;&#x53EF;&#x4EE5;&#x50CF;&#x6211;&#x4E00;&#x6837;&#x5728;&#x8F6C;&#x79FB;&#x7684;&#x65F6;&#x5019;&#x5C31;&#x5E26;&#x5165;&#x5BB9;&#x65A5;&#x7CFB;&#x6570;&#xFF09; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;bits/stdc++.h&gt;#define ri register int#define csi const int&amp;#define fi first#define se second#define pb push_backusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;vector&lt;int&gt; &gt; vii;inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline ll readl(){ ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s){ int top=0; char ch=gc(); while(ch!=&apos;*&apos;&amp;&amp;ch!=&apos;.&apos;)ch=gc(); while(ch==&apos;*&apos;||ch==&apos;.&apos;)s[++top]=ch,ch=gc(); return top;}namespace modular{ const int mod=1e9+7; inline int add(int a,int b){return (a+=b)&lt;mod?a:a-mod;} inline int dec(int a,int b){return (a-=b)&lt;0?a+mod:a;} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Add(int&amp;a,int b){a=add(a,b);} inline void Dec(int&amp;a,int b){a=dec(a,b);} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;} inline int Inv(int x){return ksm(x,mod-2);} inline void fix(int&amp;x){x=(x%mod+mod)%mod;}}using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,const T&amp;b){a&gt;b?a=b:0;}template&lt;typename T&gt;inline void ckmax(T&amp;a,const T&amp;b){a&lt;b?a=b:0;}const int N=1&lt;&lt;20|5;int n,m,all;int fac[N],ifac[N],pw[N],a[25],f[2][N],cur;inline void init(){ fac[0]=fac[1]=ifac[0]=ifac[1]=1; for(ri i=2;i&lt;=all;++i){ fac[i]=mul(fac[i-1],i); ifac[i]=mul(ifac[mod-mod/i*i],mod-mod/i); } for(ri i=2;i&lt;=all;++i)Mul(ifac[i],ifac[i-1]); pw[0]=1; for(ri i=1;i&lt;=n;++i)pw[i]=pw[i-1]&lt;&lt;1;}inline int C(int n,int m){return n&lt;m||m&lt;0?0:mul(fac[n],mul(ifac[m],ifac[n-m]));}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(),m=read(),all=1&lt;&lt;n; init(); for(ri i=1;i&lt;=m;++i)a[i]=read(); sort(a+1,a+m+1); f[cur=0][0]=1; for(ri ps=m;ps;--ps){ cur^=1; for(ri s=0;s&lt;all;++s)f[cur][s]=f[cur^1][s]; for(ri s=0,trans;s&lt;all;++s)if(f[cur^1][s]){ trans=all-s-a[ps]; if(trans&gt;=0)for(ri i=0;i&lt;n;++i)if(!(s&amp;pw[i])) Dec(f[cur][s|pw[i]],mul(f[cur^1][s],mul(C(trans,pw[i]-1),fac[pw[i]]))); } } int res=0; for(ri s=0,t;s&lt;all;++s)Add(res,mul(f[cur][s],fac[all-s-1])); cout&lt;&lt;mul(res,all); return 0;} Popping Balls &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x7531;&#x4E8E;&#x53EF;&#x4EE5;&#x9009; 111 &#xFF0C;&#x56E0;&#x4E3A; s,ts,ts,t &#x53EA;&#x9700;&#x8981;&#x7528;&#x4E8E;&#x9009;&#x51FA;&#x84DD;&#x7403;&#xFF0C;&#x8FD9;&#x6837;&#x53EF;&#x4EE5;&#x8003;&#x8651;&#x5728; t,st,st,s &#x6709;&#x7528;&#x7684;&#x65F6;&#x5019;&#x624D;&#x653E;&#x7F6E;&#x5B83;&#x4FE9;&#x4E0A;&#x53BB;&#xFF08;&#x56E0;&#x4E3A;&#x5176;&#x4F59;&#x5408;&#x6CD5;&#x65B9;&#x6848;&#x65B9;&#x6848;&#x53EF;&#x4EE5;&#x7528;&#x8FD9;&#x79CD;&#x65B9;&#x6848;&#x9009;&#x51FA;&#xFF09;&#xFF0C;&#x8FD9;&#x6837;&#x6700;&#x540E;&#x7684;&#x5E8F;&#x5217;&#x4E00;&#x5B9A;&#x957F;&#x8FD9;&#x6837;&#xFF1A; &#x5148;&#x6709; xxx &#x4E2A;&#x7EA2;&#x7403;&#x88AB;&#x9009;&#xFF0C;&#x7136;&#x540E;&#x5728;&#x7B2C;&#x4E00;&#x4E2A;&#x84DD;&#x7403;&#x4F4D;&#x7F6E;&#x5904;&#x653E;&#x4E0B; ttt &#xFF0C;&#x5E76;&#x9009;&#x51FA;&#x8FD9;&#x4E2A;&#x84DD;&#x7403; &#xFF0C;&#x7136;&#x540E;&#x63A5;&#x4E0B;&#x6765;&#x9009;&#x51FA;&#x7684; &#x662F; aaa &#x4E2A;&#x7EA2;&#x7403;&#x548C; b&#x2212;1b-1b&#x2212;1 &#x4E2A;&#x84DD;&#x7403;&#x968F;&#x610F;&#x6392;&#x5217;&#xFF08;&#x6B64;&#x65F6;&#x5E94;&#x6EE1;&#x8DB3; a+b=ma+b=ma+b=m &#x5373;&#x4F7F;&#x5F97; ttt &#x5728;&#x4E4B;&#x540E;&#x7684;&#x64CD;&#x4F5C;&#x4E2D;&#x5931;&#x6548;&#xFF09;&#xFF0C;&#x63A5;&#x7740;&#x662F; yyy &#x4E2A;&#x7EA2;&#x7403;&#x88AB;&#x9009;&#x51FA;&#xFF0C;&#x7136;&#x540E;&#x5728;&#x7B2C;&#x4E00;&#x4E2A;&#x84DD;&#x7403;&#x4F4D;&#x7F6E;&#x5904;&#x653E;&#x4E0B; sss &#xFF0C;&#x5E76;&#x9009;&#x51FA;&#x8FD9;&#x4E2A;&#x84DD;&#x7403;&#xFF0C;&#x7136;&#x540E;&#x63A5;&#x4E0B;&#x6765;&#x9009;&#x51FA;&#x7684;&#x662F; ccc &#x4E2A;&#x7EA2;&#x7403;&#x548C; d&#x2212;1d-1d&#x2212;1 &#x4E2A;&#x84DD;&#x7403;&#x968F;&#x610F;&#x6392;&#x5217;&#xFF08;&#x6B64;&#x65F6;&#x5E94;&#x6EE1;&#x8DB3; c+d=ac+d=ac+d=a &#x7406;&#x7531;&#x540C; ttt &#x90A3;&#x90E8;&#x5206;&#xFF09;&#xFF0C;&#x6700;&#x540E;&#x7684; zzz &#x4E2A;&#x7403;&#x76F4;&#x63A5;&#x6309;&#x7167;&#x539F;&#x5E8F;&#x5217;&#x653E;&#x5373;&#x53EF; &#x7136;&#x540E;&#x53EF;&#x4EE5;&#x8003;&#x8651;&#x679A;&#x4E3E; x,a,y,cx,a,y,cx,a,y,c &#x6765;&#x8BA1;&#x7B97;&#x8D21;&#x732E;&#x7136;&#x540E;&#x591A;&#x534A;&#x5C31;TLE&#x4E86; &#x5217;&#x51FA;&#x5F0F;&#x5B50;&#x4E4B;&#x540E;&#x4F1A;&#x53D1;&#x73B0;&#x8FD9;&#x4E2A;&#x56DB;&#x7EF4;&#x7684;&#x73A9;&#x610F;&#x513F;&#x540E;&#x9762;&#x4E24;&#x7EF4;&#x7684;&#x7EC4;&#x5408;&#x6570;&#x548C;&#x53EF;&#x4EE5;&#x9884;&#x5904;&#x7406;&#x4E8C;&#x7EF4;&#x524D;&#x7F00;&#x548C;&#x4F18;&#x5316;&#xFF0C;&#x8FD9;&#x6837;&#x590D;&#x6742;&#x5EA6;&#x964D;&#x4E3A;&#x4E86; O(n2)O(n^2)O(n2) &#xFF0C;&#x53EF;&#x4EE5;&#x901A;&#x8FC7; CODE cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;bits/stdc++.h&gt;#define ri register int#define csi const int&amp;#define fi first#define se second#define pb push_backusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;vector&lt;int&gt; &gt; vii;inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline ll readl(){ ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s){ int top=0; char ch=gc(); while(ch!=&apos;*&apos;&amp;&amp;ch!=&apos;.&apos;)ch=gc(); while(ch==&apos;*&apos;||ch==&apos;.&apos;)s[++top]=ch,ch=gc(); return top;}namespace modular{ const int mod=1e9+7; inline int add(int a,int b){return (a+=b)&lt;mod?a:a-mod;} inline int dec(int a,int b){return (a-=b)&lt;0?a+mod:a;} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Add(int&amp;a,int b){a=add(a,b);} inline void Dec(int&amp;a,int b){a=dec(a,b);} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;} inline int Inv(int x){return ksm(x,mod-2);} inline void fix(int&amp;x){x=(x%mod+mod)%mod;}}using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,const T&amp;b){a&gt;b?a=b:0;}template&lt;typename T&gt;inline void ckmax(T&amp;a,const T&amp;b){a&lt;b?a=b:0;}const int N=2005;int n,m,C[N][N],g[N][N],f[N][N];inline void init(int up){ for(ri i=0;i&lt;=up;++i){ C[i][0]=1; for(ri j=1;j&lt;=i;++j) C[i][j]=add(C[i-1][j],C[i-1][j-1]); } for(ri i=0;i&lt;=up;++i){ g[i][0]=C[i][0]; for(ri j=1;j&lt;=up;++j)g[i][j]=add(g[i][j-1],C[i][j]); } for(ri i=0;i&lt;=up;++i){ f[0][i]=g[i][0]; for(ri j=1;j&lt;=up;++j)f[j][i]=add(f[j-1][i],g[i][j]); }}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(),m=read(); init(max(n,m)); int res=0; for(ri t1,t2,x=0;x&lt;=n;++x)for(ri a=0;a+x&lt;=n;++a){ t1=C[m-1][a]; t2=a?f[n-a-x][a-1]:1; Add(res,mul(t1,t2)); } cout&lt;&lt;res&lt;&lt;&apos;\\n&apos;; return 0;} Placing Squares &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x9996;&#x5148;&#x8F6C;&#x5316;&#x6A21;&#x578B;&#xFF0C;&#x770B;&#x6210;&#x6709;&#x4E00;&#x4E2A; nnn &#x4E2A;&#x70B9;&#x7684;&#x5E8F;&#x5217;&#xFF0C;&#x4F60;&#x8981;&#x5728;&#x7A7A;&#x9699;&#x4E2D;&#x63D2;&#x5165;&#x6321;&#x677F;&#xFF0C;&#x628A;&#x5E8F;&#x5217;&#x5206;&#x6210;&#x82E5;&#x5E72;&#x6BB5;&#xFF0C;&#x6BCF;&#x6BB5;&#x8981;&#x653E;&#x4E00;&#x4E2A;&#x7EA2;&#x7403;&#x548C;&#x4E00;&#x4E2A;&#x84DD;&#x7403;&#xFF0C;&#x73B0;&#x5728;&#x8FD8;&#x6709; mmm &#x4E2A;&#x5750;&#x6807; {xm}\\{x_m\\}{xm&#x200B;} &#xFF0C;&#x9650;&#x5236;&#x4F60;&#x4E0D;&#x80FD;&#x5728; xi,xi+1x_i,x_i+1xi&#x200B;,xi&#x200B;+1 &#x4E4B;&#x95F4;&#x653E;&#x6321;&#x677F;&#xFF0C;&#x95EE;&#x65B9;&#x6848;&#x6570; &#x90A3;&#x4E48;&#x53EF;&#x4EE5;&#x8BBE;&#x8BA1; fi,0/1/2/3f_{i,0/1/2/3}fi,0/1/2/3&#x200B; &#x8868;&#x793A;&#x5F53;&#x524D;&#x626B;&#x5230;&#x4E86;&#x7B2C; iii &#x4E2A;&#x70B9;&#xFF0C;&#x5B83;&#x5728;&#x7684;&#x6BB5;&#x5185;&#x6CA1;&#x653E;&#x7403;/&#x653E;&#x4E86;&#x7EA2;&#x7403;/&#x653E;&#x4E86;&#x84DD;&#x7403;/&#x653E;&#x4E86;&#x4E24;&#x79CD;&#x7403;&#x7684;&#x65B9;&#x6848;&#x6570;&#xFF0C;&#x8FD9;&#x4E2A;&#x53EF;&#x4EE5;&#x5728;&#x6709;&#x65E0;&#x9650;&#x5236;&#x7684;&#x60C5;&#x51B5;&#x4E0B;&#x8F7B;&#x677E;&#x8BBE;&#x7F6E;&#x8F6C;&#x79FB;&#xFF0C;&#x7531;&#x4E8E;&#x7B2C;&#x4E00;&#x7EF4;&#x8F83;&#x5927;&#xFF0C;&#x7528;&#x77E9;&#x9635;&#x5FEB;&#x901F;&#x5E42;&#x4F18;&#x5316;&#x5373;&#x53EF; CODE cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;bits/stdc++.h&gt;#define ri register int#define csi const int&amp;#define fi first#define se second#define pb push_backusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;vector&lt;int&gt; &gt; vii;inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline ll readl(){ ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s){ int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;}namespace modular{ const int mod=1e9+7; inline int add(int a,int b){return (a+=b)&lt;mod?a:a-mod;} inline int dec(int a,int b){return (a-=b)&lt;0?a+mod:a;} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Add(int&amp;a,int b){a=add(a,b);} inline void Dec(int&amp;a,int b){a=dec(a,b);} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;} inline int Inv(int x){return ksm(x,mod-2);} inline void fix(int&amp;x){x=(x%mod+mod)%mod;}}using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,const T&amp;b){a&gt;b?a=b:0;}template&lt;typename T&gt;inline void ckmax(T&amp;a,const T&amp;b){a&lt;b?a=b:0;}struct Mat{ int a[4][4]; Mat(int v=0){for(ri i=0;i&lt;=3;++i)for(ri j=0;j&lt;=3;++j)a[i][j]=i==j?v:0;} inline int*operator[](const int&amp;k){return a[k];} inline const int*operator[](const int&amp;k)const{return a[k];} friend inline Mat operator*(Mat a,Mat b){ Mat c; for(ri i=0;i&lt;=3;++i)for(ri k=0;k&lt;=3;++k)if(a[i][k]) for(ri j=0;j&lt;=3;++j)if(b[k][j])Add(c[i][j],mul(a[i][k],b[k][j])); return c; } friend inline Mat operator^(Mat a,int p){ Mat ret(1); for(;p;p&gt;&gt;=1,a=a*a)if(p&amp;1)ret=ret*a; return ret; }}trans1,trans2,res(1);int n,m;int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif trans1[0][0]=2,trans1[0][1]=1,trans1[0][2]=1,trans1[0][3]=1; trans1[1][0]=1,trans1[1][1]=1,trans1[1][2]=0,trans1[1][3]=1; trans1[2][0]=1,trans1[2][1]=0,trans1[2][2]=1,trans1[2][3]=1; trans1[3][0]=1,trans1[3][1]=0,trans1[3][2]=0,trans1[3][3]=1; trans2[0][0]=1,trans2[0][1]=1,trans2[0][2]=1,trans2[0][3]=1; trans2[1][0]=0,trans2[1][1]=1,trans2[1][2]=0,trans2[1][3]=1; trans2[2][0]=0,trans2[2][1]=0,trans2[2][2]=1,trans2[2][3]=1; trans2[3][0]=0,trans2[3][1]=0,trans2[3][2]=0,trans2[3][3]=1; n=read(),m=read(); int las=1; for(ri i=1,x;i&lt;=m;++i){ x=read(); if(i&gt;1){ res=(trans1^(x-las-1))*trans2*res; } else res=(trans1^(x-las))*res; las=x; } if(m)res=(trans1^(n-las-1))*trans2*res; else res=trans1^(n-1); cout&lt;&lt;add(add(res[0][0],res[0][1]),add(res[0][2],res[0][3])); return 0;} &#x968F;&#x673A;&#x4E8C;&#x5206;&#x56FE; &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x5BB9;&#x6613;&#x60F3;&#x5230;&#x53BB;&#x6C42;&#x6BCF;&#x79CD;&#x5339;&#x914D;&#x51FA;&#x73B0;&#x7684;&#x6982;&#x7387;&#xFF0C;&#x90A3;&#x4E48;&#x7B54;&#x6848;&#x5373;&#x4E3A;&#x6982;&#x7387;&#x4E4B;&#x548C;&#xFF0C;&#x73B0;&#x5728;&#x8003;&#x8651;&#x6BCF;&#x7C7B;&#x8FB9;&#x51FA;&#x73B0;&#x5728;&#x5B8C;&#x7F8E;&#x5339;&#x914D;&#x7684;&#x4E00;&#x4E2A;&#x65B9;&#x6848;&#x4E2D;&#x7684;&#x6982;&#x7387;&#xFF1A; &#x7B2C;&#x4E00;&#x7C7B;&#x8FB9;&#xFF1A; 50%50\\%50% &#x7B2C;&#x4E8C;&#x7C7B;&#x8FB9;&#xFF1A; &#x6BCF;&#x6761;&#x8FB9;&#x5355;&#x72EC;&#x51FA;&#x73B0;&#x5728;&#x4E00;&#x4E2A;&#x65B9;&#x6848;&#x4E2D;&#x7684;&#x6982;&#x7387;&#x4E3A; 50%50\\%50% &#xFF0C;&#x4F46;&#x8FD9;&#x6837;&#x7684;&#x8BDD;&#x4E24;&#x6761;&#x8FB9;&#x4E00;&#x8D77;&#x51FA;&#x73B0;&#x7684;&#x6982;&#x7387;&#x964D;&#x4E3A;&#x4E86; 25%25\\%25% &#xFF0C;&#x4E8E;&#x662F;&#x52A0;&#x5165;&#x4E00;&#x4E2A;&#x80FD;&#x8FDE;&#x63A5;&#x56DB;&#x4E2A;&#x70B9;&#x7684;&#x8FB9;&#xFF0C;&#x5176;&#x51FA;&#x73B0;&#x6982;&#x7387;&#x4E3A; 25%25\\%25% &#x7B2C;&#x4E09;&#x7C7B;&#x8FB9;&#xFF1A; &#x6BCF;&#x6761;&#x8FB9;&#x5355;&#x72EC;&#x51FA;&#x73B0;&#x5728;&#x4E00;&#x4E2A;&#x65B9;&#x6848;&#x4E2D;&#x7684;&#x6982;&#x7387;&#x4E3A; 50%50\\%50% &#xFF0C;&#x4F46;&#x8FD9;&#x6837;&#x7684;&#x8BDD;&#x4E24;&#x6761;&#x8FB9;&#x4E00;&#x8D77;&#x51FA;&#x73B0;&#x7684;&#x6982;&#x7387;&#x5347;&#x4E3A;&#x4E86; 25%25\\%25% &#xFF0C;&#x4E8E;&#x662F;&#x52A0;&#x5165;&#x4E00;&#x4E2A;&#x80FD;&#x8FDE;&#x63A5;&#x56DB;&#x4E2A;&#x70B9;&#x7684;&#x8FB9;&#xFF0C;&#x5176;&#x51FA;&#x73B0;&#x6982;&#x7387;&#x4E3A; &#x2212;25%-25\\%&#x2212;25% &#x7136;&#x540E;&#x8003;&#x8651;&#x628A;&#x5DE6;&#x53F3;&#x56FE;&#x7684;&#x5339;&#x914D;&#x60C5;&#x51B5;&#x538B;&#x6210;&#x4E00;&#x4E2A;&#x72B6;&#x6001;&#x8FDB;&#x884C;&#x8F6C;&#x79FB;&#xFF0C;&#x7531;&#x4E8E;&#x56FE;&#x6CA1;&#x6709;&#x987A;&#x5E8F;&#xFF0C;&#x6BCF;&#x6B21;&#x5F3A;&#x5236;&#x5339;&#x914D; lowbitlowbitlowbit &#x6765;&#x8F6C;&#x79FB;&#x5373;&#x53EF;&#xFF0C;&#x4ECE;&#x7EC8;&#x6001;&#x5012;&#x7740;&#x8BB0;&#x5FC6;&#x5316;&#x641C;&#x7D22;&#x4F1A;&#x8BBF;&#x95EE;&#x5230;&#x5F88;&#x5C11;&#x7684;&#x6709;&#x7528;&#x72B6;&#x6001;&#xFF0C;&#x53EF;&#x4EE5;&#x901A;&#x8FC7;&#x6B64;&#x9898; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include&lt;bits/stdc++.h&gt;#include&lt;tr1/unordered_map&gt;#define ri register int#define csi const int&amp;#define fi first#define se second#define pb push_backusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;vector&lt;int&gt; &gt; vii;inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline ll readl(){ ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s){ int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;}namespace modular{ const int mod=1e9+7; inline int add(int a,int b){return (a+=b)&lt;mod?a:a-mod;} inline int dec(int a,int b){return (a-=b)&lt;0?a+mod:a;} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Add(int&amp;a,int b){a=add(a,b);} inline void Dec(int&amp;a,int b){a=dec(a,b);} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;} inline int Inv(int x){return ksm(x,mod-2);} inline void fix(int&amp;x){x=(x%mod+mod)%mod;}}using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,const T&amp;b){a&gt;b?a=b:0;}template&lt;typename T&gt;inline void ckmax(T&amp;a,const T&amp;b){a&lt;b?a=b:0;}const int inv2=5e8+4,inv4=inv2&gt;&gt;1;const int mogic=1e7+7;int first[mogic+5];struct edge{int next,ori,vl;};vector&lt;edge&gt;E;int cnt=0;inline void add_(int u,int v){ int t=u%mogic+1; ++cnt; E.pb((edge){first[t],u,v}); first[t]=cnt;}inline int query(int x){ int t=x%mogic+1; for(ri i=first[t];i;i=E[i].next){ if(E[i].ori==x)return E[i].vl; } return -1;}int n,m,pw[31];vector&lt;pii&gt;e[1&lt;&lt;15|5];inline int dfs(int sta){ if(!sta)return 1; int t=query(sta); if(~t)return t; int res=0; int st=sta&amp;-sta; for(ri i=0,s;i&lt;e[st].size();++i){ s=e[st][i].fi; if((sta&amp;s)!=s)continue; Add(res,mul(dfs(sta^s),e[st][i].se)); } return add_(sta,res),res;}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(),m=read(); E.pb((edge){0,0,0}); for(ri i=0;i&lt;=2*n;++i)pw[i]=1&lt;&lt;i; for(ri op,x1,y1,x2,y2,i=1;i&lt;=m;++i){ op=read(); x1=read()-1,y1=read()+n-1; switch(op){ case 0:{ e[pw[x1]].pb(pii(pw[x1]^pw[y1],inv2)); break; } case 1:{ e[pw[x1]].pb(pii(pw[x1]^pw[y1],inv2)); x2=read()-1,y2=read()+n-1; e[pw[x2]].pb(pii(pw[x2]^pw[y2],inv2)); if(x1!=x2&amp;&amp;y1!=y2){ if(x1&gt;x2)swap(x1,x2),swap(y1,y2); e[pw[x1]].pb(pii(pw[x1]^pw[x2]^pw[y1]^pw[y2],inv4)); } break; } case 2:{ e[pw[x1]].pb(pii(pw[x1]^pw[y1],inv2)); x2=read()-1,y2=read()+n-1; e[pw[x2]].pb(pii(pw[x2]^pw[y2],inv2)); if(x1!=x2&amp;&amp;y1!=y2){ if(x1&gt;x2)swap(x1,x2),swap(y1,y2); e[pw[x1]].pb(pii(pw[x1]^pw[x2]^pw[y1]^pw[y2],mod-inv4)); } break; } } } cout&lt;&lt;mul(dfs(pw[n+n]-1),pw[n]); return 0;} Mod Mod Mod &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x4E00;&#x4E2A;&#x6570;&#x5BF9;&#x4E00;&#x4E2A;&#x6BD4;&#x5B83;&#x5C0F;&#x7684;&#x6570;&#x53D6;&#x6A21;&#xFF0C;&#x6700;&#x591A;&#x53D6;log&#x6B21;&#x5C31;&#x4F1A;&#x53D8;&#x6210;0&#x3002;&#x6211;&#x4EEC;&#x601D;&#x8003;&#x5982;&#x4F55;&#x5229;&#x7528;&#x8FD9;&#x4E2A;&#x6027;&#x8D28;&#x3002; &#x5982;&#x679C;&#x6211;&#x4EEC;&#x8BBE; f[x][i]f[x][i]f[x][i] &#x8868;&#x793A;&#x9898;&#x76EE;&#x4E2D;&#x7684; f(x,i)f(x,i)f(x,i) &#xFF0C;&#x90A3;&#x4E48;&#x6BCF;&#x6B21; iii &#x52A0;&#x4E00;&#x7684;&#x65F6;&#x5019;&#x6211;&#x4EEC;&#x90FD;&#x8981;&#x66F4;&#x65B0;&#x6240;&#x6709;&#x7684; fff &#x503C;&#x3002; &#x4F46;&#x7B80;&#x5355;&#x601D;&#x8003;&#x540E;&#x53EF;&#x4EE5;&#x53D1;&#x73B0;&#x7B54;&#x6848;&#x5BB9;&#x6613;&#x8868;&#x793A;&#x6210; i&#x2217;x+bi*x+bi&#x2217;x+b &#x7684;&#x5F62;&#x5F0F;&#xFF0C;&#x90A3;&#x4E48;&#x53EF;&#x4EE5;&#x8BBE; Fi,numF_{i,num}Fi,num&#x200B; &#x5C31;&#x4EE3;&#x8868;&#x5F53; x&#x2264;numx\\le numx&#x2264;num &#x65F6;&#xFF0C;&#x6700;&#x5927;&#x7684; bbb &#x503C;&#x3002; &#x4E0B;&#x9762;&#x8003;&#x8651;&#x8F6C;&#x79FB;&#xFF0C;&#x5BF9;&#x4E8E; num&#x2264;ai&#x2212;1num\\le a_i-1num&#x2264;ai&#x200B;&#x2212;1&#x663E;&#x7136;&#x4E0D;&#x7528;&#x7BA1;&#xFF0C;&#x5BF9;&#x4E8E; num&#x2265;ainum\\ge a_inum&#x2265;ai&#x200B; &#xFF0C;&#x6709;&#x4E24;&#x79CD;&#x8F6C;&#x79FB;&#xFF1A; Fi,num&#x2192;Fi+1,num%aiF_{i,num}\\rightarrow F_{i+1,num\\%a_i}Fi,num&#x200B;&#x2192;Fi+1,num%ai&#x200B;&#x200B; Fi,num&#x2192;Fi+1,ai&#x2212;1F_{i,num}\\rightarrow F_{i+1,a_i-1}Fi,num&#x200B;&#x2192;Fi+1,ai&#x200B;&#x2212;1&#x200B; &#x7528; mapmapmap &#x7EF4;&#x62A4;&#x8F6C;&#x79FB;&#x5373;&#x53EF;&#xFF0C;&#x590D;&#x6742;&#x5EA6;&#x662F; O(nlog&#x2061;a1log&#x2061;n)O(n\\log a_1\\log n)O(nloga1&#x200B;logn) CODE cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;#include&lt;tr1/unordered_map&gt;#define ri register int#define csi const int&amp;#define fi first#define se second#define pb push_backusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,ll&gt; pll;typedef vector&lt;int&gt; vi;typedef vector&lt;vector&lt;int&gt; &gt; vii;inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline ll readl(){ ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s){ int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;}namespace modular{ const int mod=1e9+7; inline int add(int a,int b){return (a+=b)&lt;mod?a:a-mod;} inline int dec(int a,int b){return (a-=b)&lt;0?a+mod:a;} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Add(int&amp;a,int b){a=add(a,b);} inline void Dec(int&amp;a,int b){a=dec(a,b);} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;} inline int Inv(int x){return ksm(x,mod-2);} inline void fix(int&amp;x){x=(x%mod+mod)%mod;}}using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,const T&amp;b){a&gt;b?a=b:0;}template&lt;typename T&gt;inline void ckmax(T&amp;a,const T&amp;b){a&lt;b?a=b:0;}const int N=2e5+5;map&lt;ll,ll&gt;f;int n;ll x,num,vl;int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(); f[readl()-1]=0; for(ri i=2;i&lt;=n;++i){ x=readl(); while(f.size()){ num=f.rbegin()-&gt;fi; vl=f.rbegin()-&gt;se; if(num&lt;x)break; f.erase(num); ckmax(f[x-1],vl+(num-num%x-x)*(i-1)); ckmax(f[num%x],vl+(num-num%x)*(i-1)); } } ll res=0; for(map&lt;ll,ll&gt;::iterator it=f.begin();it!=f.end();++it) res=max(res,it-&gt;fi*n+it-&gt;se); cout&lt;&lt;res; return 0;}","categories":[{"name":"public","slug":"public","permalink":"http://xdl030112.github.io/categories/public/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://xdl030112.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"CodeForces gym 102059 简要题解","slug":"gym102059","date":"2019-10-16T23:47:42.000Z","updated":"2019-12-27T09:23:08.035Z","comments":true,"path":"gym102059/","link":"","permalink":"http://xdl030112.github.io/gym102059/","excerpt":"","text":"Coloring Roads &#x9898;&#x610F;&#x7B80;&#x8FF0;&#xFF1A; &#x7ED9;&#x4E00;&#x68F5;&#x6811;&#xFF0C;&#x6811;&#x8FB9;&#x4E00;&#x5F00;&#x59CB;&#x90FD;&#x662F;&#x65E0;&#x8272;&#x7684;&#xFF0C;&#x6BCF;&#x6B21;&#x64CD;&#x4F5C;&#x53EF;&#x4EE5;&#x628A;&#x4E00;&#x4E2A;&#x70B9;&#x5230;&#x6839;&#x7684;&#x8DEF;&#x5F84;&#x4E0A;&#x6240;&#x6709;&#x8FB9;&#x67D3;&#x6210;&#x67D0;&#x4E2A;&#x989C;&#x8272;&#xFF0C;&#x6BCF;&#x6B21;&#x8BE2;&#x95EE;&#x5F53;&#x524D;&#x6811;&#x4E0A;&#x51FA;&#x73B0;&#x8FC7;&#x67D0;&#x4E2A;&#x6B21;&#x6570;&#x7684;&#x989C;&#x8272;&#x79CD;&#x6570; &#x6570;&#x636E;&#x8303;&#x56F4;&#xFF1A; &#x70B9;&#x6570;&#xFF0C;&#x64CD;&#x4F5C;&#x6570; &#x2264;2&#xD7;105\\le2\\times10^5&#x2264;2&#xD7;105 &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x8FD9;&#x9898;&#x505A;&#x6CD5;&#x8FD8;&#x86EE;&#x591A;&#x7684;&#xFF0C;&#x5728;&#x8FD9;&#x91CC;&#x7B80;&#x5355;&#x8BB0;&#x5F55;&#x4E00;&#x4E0B;&#xFF1A; &#x6811;&#x94FE;&#x5256;&#x5206;+&#x5355;&#x8C03;&#x6808;&#xFF1A;&#x5BF9;&#x4E8E;&#x6BCF;&#x6761;&#x91CD;&#x94FE;&#x7EF4;&#x62A4;&#x4E00;&#x4E2A;&#x5173;&#x4E8E; dfsdfsdfs &#x5E8F;&#x7684;&#x5355;&#x8C03;&#x9012;&#x51CF;&#x6808;&#x4ECE;&#x800C;&#x7EF4;&#x62A4;&#x7B54;&#x6848;&#xFF0C;&#x6BCF;&#x6B21;&#x66B4;&#x529B;&#x4FEE;&#x6539;&#xFF0C;&#x5747;&#x644A;&#x5206;&#x6790;&#x590D;&#x6742;&#x5EA6;&#x662F;&#x5BF9;&#x7684; &#x6811;&#x94FE;&#x5256;&#x5206;+ ODTODTODT &#xFF0C;&#x7531;&#x4E8E;&#x6709;&#x8DEF;&#x5F84;&#x8986;&#x76D6;&#x64CD;&#x4F5C;&#xFF0C;&#x56E0;&#x6B64;&#x53EF;&#x4EE5;&#x7528; ODTODTODT &#x7B80;&#x5355;&#x7EF4;&#x62A4;&#x7B54;&#x6848;&#xFF0C;&#x590D;&#x6742;&#x5EA6;&#x5206;&#x6790;&#x8DDF;&#x5E8F;&#x5217;&#x4E0A;&#x662F;&#x5DEE;&#x4E0D;&#x591A;&#x7684; LCTLCTLCT &#xFF0C;&#x8003;&#x8651;&#x5230;&#x8DEF;&#x5F84;&#x8986;&#x76D6;&#x5C31;&#x662F; LCTLCTLCT &#x5728; accessaccessaccess &#x7684;&#x65F6;&#x5019;&#x987A;&#x5E26;&#x4FEE;&#x6539;&#x4E00;&#x4E0B;&#x4FE1;&#x606F;&#xFF0C;&#x56E0;&#x6B64;&#x6BCF;&#x6B21;&#x6539;&#x7684;&#x65F6;&#x5019; accessaccessaccess &#x5373;&#x53EF; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;inline char gc(){ static char buf[rlen],*ib,*ob; (ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)); return ib==ob?-1:*ib++;}inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}const int N=4e5+5;set&lt;int&gt;S[N];int cnt[N];namespace lct{ #define lc (son[p][0]) #define rc (son[p][1]) int siz[N],fa[N],son[N][2],vl[N],col[N]; bool rev[N]; inline bool which(int x){return x==son[fa[x]][1];} inline bool isroot(int x){return !fa[x]||(son[fa[x]][0]!=x&amp;&amp;son[fa[x]][1]!=x);} inline void pushup(int p){siz[p]=siz[lc]+siz[rc]+vl[p];} inline void pushnow(int p,int c){col[p]=c;} inline void pushdown(int p){(lc&amp;&amp;(col[lc]=col[p])),(rc&amp;&amp;(col[rc]=col[p]));} inline void rotate(int x){ int y=fa[x],z=fa[y],t=which(x); if(!isroot(y))son[z][which(y)]=x; fa[x]=z,fa[y]=x,son[y][t]=son[x][t^1],son[x][t^1]=y; if(son[y][t])fa[son[y][t]]=y; pushup(y),pushup(x); } inline void splay(int x){ static int stk[N],top; stk[top=1]=x; for(ri i=x;!isroot(i);i=fa[i])stk[++top]=fa[i]; while(top)pushdown(stk[top--]); while(!isroot(x)){ if(!isroot(fa[x]))rotate(which(x)^which(fa[x])?x:fa[x]); rotate(x); } } inline void access(int x,int c){ int p=x; for(ri y=0;x;x=fa[y=x]){ splay(x); son[x][1]=0; pushup(x); S[cnt[col[x]]].erase(col[x]); cnt[col[x]]-=siz[x]; S[cnt[col[x]]].insert(col[x]); son[x][1]=y; pushup(x); p=x; } pushnow(p,c); S[cnt[col[p]]].erase(col[p]); cnt[col[p]]+=siz[p]; S[cnt[col[p]]].insert(col[p]); } #undef lc #undef rc}int n,C,m;vector&lt;int&gt;e[N];void dfs(int p,int fa){ for(ri i=0,v;i&lt;e[p].size();++i){ if((v=e[p][i])==fa)continue; dfs(v,p); lct::fa[lct::fa[v]=v+n]=p; lct::siz[v+n]=lct::vl[v+n]=1; }}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(),C=read(),m=read(); for(ri i=1;i&lt;=C;++i)S[0].insert(i); S[n-1].insert(0); cnt[0]=n-1; for(ri i=1,u,v;i&lt;n;++i){ u=read(),v=read(); e[u].pb(v),e[v].pb(u); } dfs(1,0); for(ri x,c,k;m;--m){ x=read(),c=read(),k=read(); lct::access(x,c); cout&lt;&lt;S[k].size()-(S[k].count(0)?1:0)&lt;&lt;&apos;\\n&apos;; } return 0;} Dev, Please Add This! &#x9898;&#x610F;&#x7B80;&#x8FF0;&#xFF1A; &#x7ED9;&#x4E00;&#x4E2A; n&#x2217;mn*mn&#x2217;m &#x7684;&#x7F51;&#x683C;&#x56FE;&#xFF0C;&#x4E00;&#x4E2A;&#x683C;&#x5B50;&#x662F;&#x7A7A;&#x5730;&#x6216;&#x5899;&#xFF0C;&#x7A7A;&#x5730;&#x4E0A;&#x53EF;&#x80FD;&#x6709;&#x9053;&#x5177;&#x3002;&#x4F60;&#x4ECE;&#x4E00;&#x4E2A;&#x4F4D;&#x7F6E;&#x51FA;&#x53D1;&#xFF0C;&#x9009;&#x4E00;&#x4E2A;&#x65B9;&#x5411;&#x7136;&#x540E;&#x4E00;&#x76F4;&#x6309;&#x90A3;&#x4E2A;&#x65B9;&#x5411;&#x8D70;&#x76F4;&#x5230;&#x78B0;&#x5230;&#x5899;&#x6216;&#x8FB9;&#x754C;&#x3002;&#x6CBF;&#x9014;&#x7684;&#x6240;&#x6709;&#x9053;&#x5177;&#x90FD;&#x4F1A;&#x88AB;&#x6536;&#x96C6;&#xFF0C;&#x95EE;&#x80FD;&#x5426;&#x6536;&#x96C6;&#x6240;&#x6709;&#x9053;&#x5177;&#x3002; &#x6570;&#x636E;&#x8303;&#x56F4;&#xFF1A; n,m&#x2264;50n,m\\le50n,m&#x2264;50 &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x6839;&#x636E;&#x9898;&#x610F;&#xFF0C;&#x6BCF;&#x884C;&#x6BCF;&#x5217;&#x90FD;&#x88AB;&#x8FB9;&#x754C;&#x548C;&#x5899;&#x5206;&#x6210;&#x4E86;&#x5F88;&#x591A;&#x5C0F;&#x6BB5;&#xFF0C;&#x6211;&#x4EEC;&#x628A;&#x8FD9;&#x4E9B;&#x6BB5;&#x8FDB;&#x884C;&#x6807;&#x53F7;&#xFF0C;&#x90A3;&#x4E48;&#x5BF9;&#x4E8E;&#x4E00;&#x4E2A;&#x9053;&#x5177;&#xFF0C;&#x5B83;&#x88AB;&#x6536;&#x96C6;&#x5F53;&#x4E14;&#x4EC5;&#x5F53;&#x5B83;&#x6240;&#x5728;&#x7684;&#x884C;&#x5217;&#x5206;&#x91CF;&#x81F3;&#x5C11;&#x6709;&#x4E00;&#x4E2A;&#x88AB;&#x9009;&#xFF0C;&#x4E8E;&#x662F;&#x60F3;&#x5230;&#x7528; 2&#x2212;sat2-sat2&#x2212;sat &#x6765;&#x8FDB;&#x884C;&#x8FD9;&#x7C7B;&#x9650;&#x5236;&#xFF0C;&#x7136;&#x540E;&#x8003;&#x8651;&#x5269;&#x4E0B;&#x7684;&#x9650;&#x5236;&#xFF0C;&#x82E5;&#x4ECE;&#x8D77;&#x70B9;&#x51FA;&#x53D1;&#x4E0D;&#x80FD;&#x5230;&#x8FBE;&#x67D0;&#x4E2A;&#x5206;&#x91CF;&#xFF0C;&#x90A3;&#x4E48;&#x6700;&#x540E;&#x5B83;&#x5FC5;&#x987B;&#x4E3A; falsefalsefalse &#xFF0C;&#x5982;&#x679C;&#x4E24;&#x4E2A;&#x5206;&#x91CF;&#x6CA1;&#x6709;&#x4E00;&#x4E2A;&#x80FD;&#x5230;&#x8FBE;&#x53E6;&#x4E00;&#x4E2A;&#xFF0C;&#x90A3;&#x4E48;&#x5C31;&#x4E0D;&#x80FD;&#x540C;&#x65F6;&#x4E3A; truetruetrue &#xFF0C;&#x5EFA;&#x5B8C;&#x56FE;&#x4E4B;&#x540E;&#x7528; 2&#x2212;sat2-sat2&#x2212;sat &#x8DD1;&#x5373;&#x53EF; &#x5408;&#x6CD5;&#x6027;&#x8BC1;&#x660E;&#xFF1A;&#x8003;&#x8651;&#x5C06;&#x5EFA;&#x51FA;&#x6765;&#x7684;&#x56FE;&#x7F29;&#x70B9;&#xFF0C;&#x90A3;&#x4E48;&#x5C31;&#x53D8;&#x6210;&#x4E86;&#x4E00;&#x5F20;&#x6709;&#x5411;&#x5B8C;&#x5168;&#x56FE;&#xFF0C;&#x4ECE;&#x4E00;&#x4E2A;&#x5165;&#x5EA6;&#x4E3A; 000 &#x7684;&#x70B9;&#x51FA;&#x53D1;&#x627E;&#x54C8;&#x5BC6;&#x987F;&#x56DE;&#x8DEF;&#xFF0C;&#x8FD9;&#x4E2A;&#x4E00;&#x5B9A;&#x80FD;&#x6784;&#x9020;&#x51FA;&#x4E00;&#x7EC4;&#x89E3; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_backusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,ll&gt; pll;typedef pair&lt;ll,int&gt; pli;typedef unsigned int uii;typedef unsigned long long Ull;typedef vector&lt;int&gt; poly;inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline ll readl(){ ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s){ int top=0; char ch=gc(); while(ch!=&apos;O&apos;&amp;&amp;ch!=&apos;#&apos;&amp;&amp;ch!=&apos;.&apos;&amp;&amp;ch!=&apos;*&apos;)ch=gc(); while(ch==&apos;O&apos;||ch==&apos;#&apos;||ch==&apos;.&apos;||ch==&apos;*&apos;)s[++top]=ch,ch=gc(); return top;}namespace modular{ const int mod=998244353,inv2=499122177; inline int add(int a,int b){return a+b&lt;mod?a+b:a+b-mod;} inline int dec(int a,int b){return a-b&lt;0?a-b+mod:a-b;} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Add(int&amp;a,int b){a=add(a,b);} inline void Dec(int&amp;a,int b){a=dec(a,b);} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;} inline int Inv(int a){return ksm(a,mod-2);} inline void fix(int&amp;a){a=(a%mod+mod)%mod;}}using namespace modular;template&lt;typename T&gt;inline void ckmax(T&amp;a,T b){a&lt;b?a=b:0;}template&lt;typename T&gt;inline void ckmin(T&amp;a,T b){a&gt;b?a=b:0;}const int N=55,M=N*N*4;char s[N][N];int n,m,sig=0,col[M],stk[M],top=0;bool vs[M];vector&lt;int&gt;e[M];int tot=0,low[M],dfn[M];bool trans[M][M];void dfs(int p){ dfn[p]=low[p]=++tot; stk[++top]=p; vs[p]=1; for(ri i=0,v;i&lt;e[p].size();++i){ if(dfn[v=e[p][i]]){ if(vs[v])low[p]=min(low[p],low[v]); continue; } dfs(v),low[p]=min(low[p],low[v]); } if(low[p]==dfn[p]){ ++sig; while(1){ int x=stk[top--]; vs[x]=0; col[x]=sig; if(x==p)break; } }}int idx1[N][N],idx2[N][N],cnt=0;inline void gettrans(int p,int rt){ trans[rt][p]=1; for(ri i=0;i&lt;e[p].size();++i) if(!trans[rt][e[p][i]])gettrans(e[p][i],rt);}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(),m=read(); for(ri i=1;i&lt;=n;++i)Read(s[i]); for(ri i=0;i&lt;=n+1;++i)s[i][0]=s[i][m+1]=&apos;#&apos;; for(ri i=0;i&lt;=m+1;++i)s[0][i]=s[n+1][i]=&apos;#&apos;; for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=m;++j){ if(s[i][j-1]==&apos;#&apos;&amp;&amp;s[i][j]!=&apos;#&apos;)++cnt; idx1[i][j]=cnt; } for(ri i=1;i&lt;=m;++i)for(ri j=1;j&lt;=n;++j){ if(s[j-1][i]==&apos;#&apos;&amp;&amp;s[j][i]!=&apos;#&apos;)++cnt; idx2[j][i]=cnt; } ++cnt; for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=m;++j){ if(s[i][j]==&apos;#&apos;)continue; if(s[i][j-1]==&apos;#&apos;||s[i][j+1]==&apos;#&apos;)e[idx1[i][j]].pb(idx2[i][j]); if(s[i-1][j]==&apos;#&apos;||s[i+1][j]==&apos;#&apos;)e[idx2[i][j]].pb(idx1[i][j]); if(s[i][j]==&apos;O&apos;)e[cnt].pb(idx1[i][j]),e[cnt].pb(idx2[i][j]); } for(ri i=1;i&lt;=cnt;++i)gettrans(i,i); for(ri i=1;i&lt;=cnt;++i)e[i].clear(); for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=m;++j)if(s[i][j]==&apos;*&apos;){ e[idx1[i][j]].pb(idx2[i][j]+cnt); e[idx2[i][j]].pb(idx1[i][j]+cnt); } for(ri i=1;i&lt;cnt;++i)if(!trans[cnt][i])e[i+cnt].pb(i); for(ri i=1;i&lt;cnt;++i)for(ri j=i+1;j&lt;cnt;++j)if(!trans[i][j]&amp;&amp;!trans[j][i]){ e[i+cnt].pb(j); e[j+cnt].pb(i); } for(ri i=1;i&lt;cnt*2;++i)if(!dfn[i])dfs(i); for(ri i=1;i&lt;cnt;++i)if(col[i]==col[i+cnt]){ puts(&quot;NO&quot;); return 0; } puts(&quot;YES&quot;); return 0;} Dstorv &#x9898;&#x610F;&#x7B80;&#x8FF0;&#xFF1A; &#x6570;&#x8F74;&#x4E0A;&#x6392;&#x5217;&#x7740; nnn &#x4E2A;&#x5DE6;/&#x53F3;&#x7BAD;&#x5934;&#xFF0C;&#x6BCF;&#x4E2A;&#x7BAD;&#x5934;&#x90FD;&#x4F1A;&#x4EE5;&#x76F8;&#x540C;&#x901F;&#x5EA6;&#x671D;&#x7740;&#x5404;&#x81EA;&#x65B9;&#x5411;&#x79FB;&#x52A8;&#x3002;&#x5F53;&#x4E00;&#x4E2A;&#x5DE6;&#x7BAD;&#x5934;&#x548C;&#x4E00;&#x4E2A;&#x53F3;&#x7BAD;&#x5934;&#x76F8;&#x9047;&#x65F6;&#x6709;&#x6982;&#x7387; ppp &#x4F7F;&#x5F97;&#x5176;&#x4E2D;&#x5DE6;&#x7BAD;&#x5934;&#x6D88;&#x5931;&#xFF0C; 1&#x2212;p1-p1&#x2212;p &#x6982;&#x7387;&#x4F7F;&#x53F3;&#x7BAD;&#x5934;&#x6D88;&#x5931;&#xFF0C;&#x95EE;&#x6700;&#x540E;&#x5269;&#x4E0B; aaa &#x4E2A;&#x53F3;&#x7BAD;&#x5934;&#x548C; bbb &#x4E2A;&#x5DE6;&#x7BAD;&#x5934;&#x7684;&#x6982;&#x7387;&#x3002; &#x6570;&#x636E;&#x8303;&#x56F4;&#xFF1A; n&#x2264;5000n\\le5000n&#x2264;5000 &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x5BF9;&#x4E8E;&#x6BCF;&#x4E00;&#x79CD;&#x5408;&#x6CD5;&#x65B9;&#x6848;&#xFF0C;&#x5BF9;&#x5E94;&#x7740;&#x5728;&#x6700;&#x53F3;&#x7684;&#x5DE6;&#x7BAD;&#x5934;&#x548C;&#x6700;&#x5DE6;&#x7684;&#x53F3;&#x7BAD;&#x5934;&#x4E4B;&#x95F4;&#x5212;&#x4E00;&#x9053;&#x5206;&#x754C;&#x7EBF;&#xFF0C;&#x7136;&#x540E;&#x5206;&#x754C;&#x7EBF;&#x5DE6;&#x4FA7;&#x7684;&#x53F3;&#x7BAD;&#x5934;&#x5168;&#x90E8; gggggg &#xFF0C;&#x5206;&#x754C;&#x7EBF;&#x53F3;&#x4FA7;&#x7684;&#x5DE6;&#x7BAD;&#x5934;&#x5168;&#x90E8; gggggg &#xFF0C;&#x8FD9;&#x6837;&#x5982;&#x679C;&#x7EDF;&#x8BA1;&#x51FA;&#x5206;&#x754C;&#x7EBF;&#x5DE6;&#x53F3;&#x90E8;&#x5206;&#x5408;&#x6CD5;&#x7684;&#x6982;&#x7387;&#x5C31;&#x53EF;&#x4EE5;&#x679A;&#x4E3E;&#x5206;&#x754C;&#x7EBF;&#x7EDF;&#x8BA1;&#x7B54;&#x6848; &#x73B0;&#x5728;&#x8003;&#x8651;&#x5982;&#x4F55;&#x6C42;&#x6982;&#x7387;&#xFF0C;&#x8BBE; fi,jf_{i,j}fi,j&#x200B; &#x8868;&#x793A;&#x4ECE;&#x5DE6;&#x5230;&#x53F3;&#x5904;&#x7406;&#x5230;&#x7B2C; iii &#x4E2A;&#x7BAD;&#x5934;&#xFF0C;&#x6700;&#x540E;&#x4F1A;&#x4ECE;&#x53F3;&#x8FB9;&#x6765; jjj &#x4E2A;&#x5DE6;&#x7BAD;&#x5934;&#x8FDB;&#x884C;&#x652F;&#x63F4;&#xFF0C;&#x6700;&#x540E;&#x5269;&#x4E0B; bbb &#x4E2A;&#x5DE6;&#x7BAD;&#x5934;&#x7684;&#x6982;&#x7387;&#xFF0C;&#x7136;&#x540E;&#x8F6C;&#x79FB;&#x5373;&#x53EF;&#xFF0C;&#x53F3;&#x4FA7;&#x7684;&#x8F6C;&#x79FB;&#x540C;&#x7406; CODE cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;bits/stdc++.h&gt;#define int long long#define ri register int#define fi first#define se second#define pb push_backusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,ll&gt; pll;typedef pair&lt;ll,int&gt; pli;typedef unsigned int uii;typedef unsigned long long Ull;typedef vector&lt;int&gt; poly;inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline ll readl(){ ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s){ int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;}namespace modular{ const int mod=1e9+7; inline int add(int a,int b){return a+b&lt;mod?a+b:a+b-mod;} inline int dec(int a,int b){return a-b&lt;0?a-b+mod:a-b;} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Add(int&amp;a,int b){a=add(a,b);} inline void Dec(int&amp;a,int b){a=dec(a,b);} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;} inline int Inv(int a){return ksm(a,mod-2);} inline void fix(int&amp;a){a=(a%mod+mod)%mod;}}using namespace modular;template&lt;typename T&gt;inline void ckmax(T&amp;a,T b){a&lt;b?a=b:0;}template&lt;typename T&gt;inline void ckmin(T&amp;a,T b){a&gt;b?a=b:0;}const int N=5005;int f[N][N],g[N][N],pa,pb,p,n,A,B;char s[N];signed main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(),pa=read(),pb=read(); Mul(pa,Inv(pa+pb)); pb=dec(1,pa); Read(s); A=read(),B=read(); f[0][B]=1; for(ri i=1;i&lt;=n;++i){ if(s[i]==&apos;H&apos;)for(ri j=0;j&lt;n;++j)f[i][j]=f[i-1][j+1]; else for(ri j=1;j&lt;=n;++j)f[i][j]=add(mul(f[i][j-1],pb),mul(f[i-1][j],pa)); } g[n+1][A]=1; for(ri i=n;i;--i){ if(s[i]==&apos;R&apos;)for(ri j=0;j&lt;n;++j)g[i][j]=g[i+1][j+1]; else for(ri j=1;j&lt;=n;++j)g[i][j]=add(mul(g[i][j-1],pa),mul(g[i+1][j],pb)); } int res=0; for(ri i=0;i&lt;=n;++i)Add(res,mul(f[i][0],g[i+1][0])); cout&lt;&lt;res; return 0;} Dumae &#x5EFA;&#x62D3;&#x6251;&#x56FE;+&#x8D2A;&#x5FC3;&#x5373;&#x53EF; CODE cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;#define gc getchartypedef long long ll;inline int read(){ int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch==&apos;-&apos;,ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;}inline ll readl(){ ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}const int mod=1e9+7;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,ll&gt; pll;inline int add(int a,int b){return (a+=b)&lt;mod?a:a-mod;}inline int dec(int a,int b){return (a-=b)&lt;0?a+mod:a;}inline int mul(int a,int b){return (ll)a*b%mod;}inline void Add(int&amp;a,int b){(a+=b)&lt;mod?a:(a-=mod);}inline void Dec(int&amp;a,int b){(a-=b)&lt;0?(a+=mod):a;}inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;}inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))if(p&amp;1)Mul(ret,a);return ret;}const int N=3e5+5;int n,m,L[N],R[N],du[N],q[N],hd,tl,Du[N];vector&lt;int&gt;e[N];vector&lt;pii&gt;a[N];int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(),m=read(); for(ri i=1;i&lt;=n;++i)L[i]=read(),R[i]=read(); for(ri i=1,u,v;i&lt;=m;++i){ u=read(),v=read(); e[u].pb(v),++du[v],++Du[v]; } int cnt=n; hd=1,tl=0; for(ri i=1;i&lt;=n;++i)if(!du[i])q[++tl]=i; while(hd&lt;=tl){ int x=q[hd++]; --cnt; for(ri i=0,v;i&lt;e[x].size();++i){ --du[v=e[x][i]]; if(!du[v])q[++tl]=v; } } if(cnt)return puts(&quot;-1&quot;),0; for(ri p,i=n;i;--i){ p=q[i]; for(ri j=0,v;j&lt;e[p].size();++j)R[p]=min(R[p],R[v=e[p][j]]-1); } set&lt;pii&gt;S,qu; vector&lt;int&gt;ans; for(ri i=1;i&lt;=n;++i)if(!Du[i]){ if(L[i]==1)qu.insert(pii(R[i],i)); else S.insert(pii(L[i],i)); } while(qu.size()){ int x=qu.begin()-&gt;se; qu.erase(qu.begin()); ++cnt; if(R[x]&lt;cnt)return puts(&quot;-1&quot;),0; ans.pb(x); while(S.size()&amp;&amp;S.begin()-&gt;fi&lt;=cnt+1)qu.insert(pii(R[S.begin()-&gt;se],S.begin()-&gt;se)),S.erase(S.begin()); for(ri i=0,v;i&lt;e[x].size();++i){ --Du[v=e[x][i]]; if(!Du[v]){ if(L[v]&lt;=cnt+1)qu.insert(pii(R[v],v)); else S.insert(pii(L[v],v)); } } } if(ans.size()!=n)return puts(&quot;-1&quot;),0; for(ri i=0;i&lt;ans.size();++i)cout&lt;&lt;ans[i]&lt;&lt;&apos;\\n&apos;; return 0;} Electronic Circuit &#x9006;&#x5411;&#x8003;&#x8651;&#x7136;&#x540E;&#x6309;&#x7167;&#x9898;&#x610F;&#x6A21;&#x62DF; CODE cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;#define gc getchartypedef long long ll;inline int read(){ int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch==&apos;-&apos;,ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;}inline ll readl(){ ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}const int mod=1e9+7;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,ll&gt; pll;inline int add(int a,int b){return (a+=b)&lt;mod?a:a-mod;}inline int dec(int a,int b){return (a-=b)&lt;0?a+mod:a;}inline int mul(int a,int b){return (ll)a*b%mod;}inline void Add(int&amp;a,int b){(a+=b)&lt;mod?a:(a-=mod);}inline void Dec(int&amp;a,int b){(a-=b)&lt;0?(a+=mod):a;}inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;}inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))if(p&amp;1)Mul(ret,a);return ret;}const int N=1e5+5;set&lt;int&gt;e[N];bool ban[N];int n,m,cnt;inline void modify(int p){ if(ban[p])return; if(e[p].size()^2)return; --cnt; ban[p]=1; int pre=*e[p].begin(),suf=*e[p].rbegin(); e[pre].erase(p); e[pre].insert(suf); e[suf].erase(p); e[suf].insert(pre); modify(pre),modify(suf);}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(),m=read(); cnt=n; for(ri i=1,u,v;i&lt;=m;++i){ u=read(),v=read(); e[u].insert(v); e[v].insert(u); } for(ri i=1;i&lt;=n;++i)modify(i); puts(cnt==2?&quot;Yes&quot;:&quot;No&quot;); return 0;} Fake Plastic Trees &#x6BCF;&#x6B21;&#x5747;&#x5206;&#x53F6;&#x5B50;&#x7ED9;&#x5B50;&#x6811;&#xFF0C;&#x8BB0;&#x5FC6;&#x5316;&#x4E00;&#x4E0B;&#x5C31;&#x884C;&#x4E86; CODE cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;#define gc getchartypedef long long ll;inline int read(){ int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch==&apos;-&apos;,ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;}inline ll readl(){ ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}const int mod=1e9+7;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,ll&gt; pll;inline int add(int a,int b){return (a+=b)&lt;mod?a:a-mod;}inline int dec(int a,int b){return (a-=b)&lt;0?a+mod:a;}inline int mul(int a,int b){return (ll)a*b%mod;}inline void Add(int&amp;a,int b){(a+=b)&lt;mod?a:(a-=mod);}inline void Dec(int&amp;a,int b){(a-=b)&lt;0?(a+=mod):a;}inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;}inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))if(p&amp;1)Mul(ret,a);return ret;}vector&lt;ll&gt;vl;map&lt;ll,int&gt;idx;map&lt;ll,bool&gt;vs;inline void dfs(ll x){ if(vs[x])return; vs[x]=1; vl.pb(x); if(x==1)return; dfs(x-(x&gt;&gt;1)),dfs(x&gt;&gt;1);}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif ll x; int tot; for(ri tt=read();tt;--tt){ x=readl(); vl.clear(); vs.clear(); dfs(x); sort(vl.begin(),vl.end()); idx.clear(); tot=-1; for(ri i=0;i&lt;vl.size();++i)idx[vl[i]]=++tot; cout&lt;&lt;tot+1&lt;&lt;&apos;\\n&apos;; cout&lt;&lt;-1&lt;&lt;&apos; &apos;&lt;&lt;-1&lt;&lt;&apos;\\n&apos;; for(ri i=1;i&lt;vl.size();++i)cout&lt;&lt;idx[vl[i]-(vl[i]&gt;&gt;1)]&lt;&lt;&apos; &apos;&lt;&lt;idx[vl[i]&gt;&gt;1]&lt;&lt;&apos;\\n&apos;; cout&lt;&lt;idx[vl.back()]&lt;&lt;&apos;\\n&apos;; } return 0;} Fascination Street &#x9898;&#x610F;&#x7B80;&#x8FF0;&#xFF1A; &#x8857;&#x9053;&#x4E0A;&#x6709;&#x4E00;&#x6392;&#x706F;&#xFF0C;&#x4E00;&#x5F00;&#x59CB;&#x5168;&#x706D;&#xFF0C;&#x70B9;&#x4EAE;&#x6BCF;&#x76CF;&#x706F;&#x6709;&#x4E00;&#x5B9A;&#x4EE3;&#x4EF7;&#xFF0C;&#x8981;&#x6C42;&#x6700;&#x540E;&#x5BF9;&#x4E8E;&#x6BCF;&#x4E2A;&#x4F4D;&#x7F6E;&#x8DDD;&#x79BB;&#x81EA;&#x5DF1;&#x4E0D;&#x8D85;&#x8FC7; 111 &#x7684;&#x706F;&#x81F3;&#x5C11;&#x70B9;&#x4EAE;&#x4E00;&#x76CF;&#x3002;&#x9664;&#x6B64;&#x4E4B;&#x5916;&#xFF0C;&#x6709; kkk &#x6B21;&#x673A;&#x4F1A;&#x4EA4;&#x6362;&#x4E24;&#x76CF;&#xFF0C;&#x95EE;&#x6700;&#x5C0F;&#x4EE3;&#x4EF7;&#x3002; &#x6570;&#x636E;&#x8303;&#x56F4;&#xFF1A; n&#x2264;250000,k&#x2264;9n\\le250000,k\\le9n&#x2264;250000,k&#x2264;9 &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x4E00;&#x9053;&#x6BD4;&#x8F83;&#x6709;&#x610F;&#x601D;&#x7684;&#x4E8F;&#x6B20;&#x578B; dpdpdp &#xFF0C;&#x8003;&#x8651;&#x5230;&#x4EA4;&#x6362;&#x7684;&#x4E00;&#x5B9A;&#x662F;&#x4E00;&#x76CF;&#x4EAE;&#x7684;&#x548C;&#x4E00;&#x76CF;&#x706D;&#x7684;&#xFF0C;&#x53EF;&#x4EE5;&#x5B9A;&#x4E49;&#x72B6;&#x6001; fi,0/1,0/1,x,yf_{i,0/1,0/1,x,y}fi,0/1,0/1,x,y&#x200B; &#x8868;&#x793A;&#x8003;&#x8651;&#x5230;&#x7B2C; iii &#x76CF;&#x706F;&#xFF0C;&#x6700;&#x540E;&#x4E24;&#x76CF;&#x706F;&#x7684;&#x4EAE;&#x706D;&#x72B6;&#x6001;&#xFF0C;&#x73B0;&#x5728;&#x5DF2;&#x7ECF;&#x6362;&#x4E86; xxx &#x76CF;&#x4EAE;&#x7684;&#x706F;&#xFF0C; yyy &#x76CF;&#x706D;&#x7684;&#x706F;&#xFF0C;&#x7136;&#x540E;&#x679A;&#x4E3E;&#x5F53;&#x524D;&#x706F;&#x4EAE;&#x4E0D;&#x4EAE;&#xFF0C;&#x6362;&#x4E0D;&#x6362;&#x5373;&#x53EF; CODE cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;#define gc getchartypedef long long ll;inline int read(){ int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch==&apos;-&apos;,ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;}const int N=250005;int n,K,vl[N],cur=0;ll f[2][2][2][10][10],inf;inline void ckmin(ll&amp;x,ll y){x=x&lt;y?x:y;}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(),K=read(); for(ri i=1;i&lt;=n;++i)vl[i]=read(); memset(f[cur=0],0x3f,sizeof(f[0])); inf=f[cur][1][0][0][0],f[cur][1][0][0][0]=0; ll t; for(ri i=0;i&lt;n;++i){ memset(f[cur^1],0x3f,sizeof(f[cur^1])); for(ri j=0;j&lt;2;++j)for(ri k=0;k&lt;2;++k)for(ri a=0;a&lt;=K;++a)for(ri b=0;b&lt;=K;++b){ if(f[cur][j][k][a][b]==inf)continue; t=f[cur][j][k][a][b]; ckmin(f[cur^1][k][1][a][b],t+vl[i+1]); if(j|k)ckmin(f[cur^1][k][0][a][b],t); if(a&lt;K)ckmin(f[cur^1][k][1][a+1][b],t); if(b&lt;K&amp;&amp;(j|k))ckmin(f[cur^1][k][0][a][b+1],t+vl[i+1]); } cur^=1; } ll ans=inf; for(ri i=0;i&lt;2;++i)for(ri j=0;j&lt;2;++j)for(ri k=0;k&lt;=K;++k)if(i|j)ckmin(ans,f[cur][i][j][k][k]); cout&lt;&lt;ans; return 0;} Fractions &#x66B4;&#x529B;&#x679A;&#x4E3E;&#x5373;&#x53EF; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;#define gc getcharinline int read(){ int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch==&apos;-&apos;,ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;}const int mod=1e9+7;typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int add(int a,int b){return (a+=b)&lt;mod?a:a-mod;}inline int dec(int a,int b){return (a-=b)&lt;0?a+mod:a;}inline int mul(int a,int b){return (ll)a*b%mod;}inline void Add(int&amp;a,int b){(a+=b)&lt;mod?a:(a-=mod);}inline void Dec(int&amp;a,int b){(a-=b)&lt;0?(a+=mod):a;}inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;}inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))if(p&amp;1)Mul(ret,a);return ret;}const int N=1e5+5;int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif ll a,b,c,d,xl,xr,yl,yr,ans=0; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d; for(ri j,i=1;i&lt;=1000;++i){ j=1; for(;;++j){ if(__gcd(i,j)!=1)continue; if(i+j&gt;=1000)break; xl=a%i?a/i+1:a/i,xr=b/i; yl=c%j?c/j+1:c/j,yr=d/j; if(max(xl,yl)&lt;=min(xr,yr))ans+=min(xr,yr)-max(xl,yl)+1; } } cout&lt;&lt;ans; return 0;} Game on Plane &#x6309;&#x7167;&#x9898;&#x610F;&#x679A;&#x4E3E;&#x65AD;&#x8FB9;&#xFF0C;&#x53D1;&#x73B0;&#x5269;&#x4E0B;&#x4E24;&#x4E2A;&#x6210;&#x4E86;&#x5B50;&#x95EE;&#x9898;&#xFF0C;&#x4E8E;&#x662F;&#x7528; SGSGSG &#x51FD;&#x6570;&#x5373;&#x53EF; CODE cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;#define gc getcharinline int read(){ int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch==&apos;-&apos;,ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;}const int mod=1e9+7;typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int add(int a,int b){return (a+=b)&lt;mod?a:a-mod;}inline int dec(int a,int b){return (a-=b)&lt;0?a+mod:a;}inline int mul(int a,int b){return (ll)a*b%mod;}inline void Add(int&amp;a,int b){(a+=b)&lt;mod?a:(a-=mod);}inline void Dec(int&amp;a,int b){(a-=b)&lt;0?(a+=mod):a;}inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;}inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))if(p&amp;1)Mul(ret,a);return ret;}const int N=5005;int n,a[N],sg[N];bool vis[N];inline void init(){ sg[2]=sg[3]=1; for(ri i=4;i&lt;=5000;++i){ memset(vis,0,sizeof(vis)); for(ri j=0;j&lt;=i-2;++j)vis[sg[j]^sg[i-2-j]]=1; for(ri j=0;;++j)if(!vis[j]){sg[i]=j;break;} }}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif init(); for(ri tt=read();tt;--tt)puts(sg[read()]?&quot;First&quot;:&quot;Second&quot;); return 0;} Histogram Sequence &#x4E8C;&#x5206;+&#x5355;&#x8C03;&#x6808;+&#x5806;&#x5373;&#x53EF; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include&lt;bits/stdc++.h&gt;#define int long long#define ri register int#define fi first#define se second#define pb push_backusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,ll&gt; pll;typedef pair&lt;ll,int&gt; pli;typedef unsigned int uii;typedef unsigned long long Ull;typedef vector&lt;int&gt; poly;inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline ll readl(){ ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s){ int top=0; char ch=gc(); while(ch!=&apos;O&apos;&amp;&amp;ch!=&apos;#&apos;&amp;&amp;ch!=&apos;.&apos;&amp;&amp;ch!=&apos;*&apos;)ch=gc(); while(ch==&apos;O&apos;||ch==&apos;#&apos;||ch==&apos;.&apos;||ch==&apos;*&apos;)s[++top]=ch,ch=gc(); return top;}namespace modular{ const int mod=998244353,inv2=499122177; inline int add(int a,int b){return a+b&lt;mod?a+b:a+b-mod;} inline int dec(int a,int b){return a-b&lt;0?a-b+mod:a-b;} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Add(int&amp;a,int b){a=add(a,b);} inline void Dec(int&amp;a,int b){a=dec(a,b);} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;} inline int Inv(int a){return ksm(a,mod-2);} inline void fix(int&amp;a){a=(a%mod+mod)%mod;}}using namespace modular;template&lt;typename T&gt;inline void ckmax(T&amp;a,T b){a&lt;b?a=b:0;}template&lt;typename T&gt;inline void ckmin(T&amp;a,T b){a&gt;b?a=b:0;}const int N=300005;int n,a[N],pl[N],pr[N],stk[N],tp;ll L,R;inline void init(){ stk[tp=1]=pl[1]=1; for(ri i=2;i&lt;=n;++i){ while(tp&amp;&amp;a[stk[tp]]&gt;=a[i])--tp; pl[i]=stk[tp]+1; stk[++tp]=i; } stk[0]=n+1; stk[tp=1]=pr[n]=n; for(ri i=n-1;i;--i){ while(tp&amp;&amp;a[stk[tp]]&gt;a[i])--tp; pr[i]=stk[tp]-1; stk[++tp]=i; }}inline ll calc(ll lm,ll len){ ll s=max(1ll,len-lm+1); return (len+s)*(len-s+1)/2;}inline ll calc(ll lm){ ll res=0; for(ri i=1;i&lt;=n;++i){ if(a[i]&gt;lm)continue; res+=calc(lm/a[i],pr[i]-pl[i]+1)-calc(lm/a[i],pr[i]-i)-calc(lm/a[i],i-pl[i]); } return res;}inline int calc(int p,int l,int r,int len){ return max((r-l+1)-len+1,0ll)-max((r-p)-len+1,0ll)-max((p-l)-len+1,0ll);}struct Node{ ll h,w; int id; Node(ll h=0,ll w=0,int id=0):h(h),w(w),id(id){} friend inline bool operator&lt;(Node a,Node b){return a.h*a.w&gt;b.h*b.w;}}tmp;signed main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(); for(ri i=1;i&lt;=n;++i)a[i]=read(); L=readl(),R=readl(); init(); ll l=0,r=1e18,res=1e18; while(l&lt;=r){ ll mid=l+r&gt;&gt;1; if(calc(mid)&gt;=L)r=mid-1,res=mid; else l=mid+1; } ll lm=calc(res); while(L&lt;=R&amp;&amp;L&lt;=lm){ ++L; cout&lt;&lt;res&lt;&lt;&apos; &apos;; } priority_queue&lt;Node&gt;q; for(ri i=1;i&lt;=n;++i)q.push(Node(a[i],res/a[i]+1,i)); while(L&lt;=R){ tmp=q.top(); q.pop(); int num=calc(tmp.id,pl[tmp.id],pr[tmp.id],tmp.w); if(!num)continue; while(num&amp;&amp;L&lt;=R){ cout&lt;&lt;tmp.h*tmp.w&lt;&lt;&apos; &apos;; ++L; --num; } ++tmp.w; q.push(tmp); } return 0;} Interesting Drug &#x9898;&#x610F;&#x7B80;&#x8FF0;&#xFF1A; &#x4E00;&#x6761;&#x8DEF;&#x4E0A;&#x6309;&#x987A;&#x5E8F;&#x6709; nnn &#x74F6;&#x6BD2;&#x836F;&#xFF0C;&#x5BF9;&#x4E8E; i&#x2208;[1,n]i&#x2208;[1,n]i&#x2208;[1,n] &#xFF0C;&#x6C42;&#x51FA;&#x5982;&#x4E0B;&#x7684;&#x503C;&#xFF1A;&#x4ECE; iii &#x51FA;&#x53D1;&#xFF0C;&#x6BCF;&#x4E2A;&#x65F6;&#x523B;&#x5403;&#x6389;&#x5F53;&#x524D;&#x4F4D;&#x7F6E;&#x7684;&#x6BD2;&#x836F;&#xFF0C;&#x7136;&#x540E;&#x9009;&#x62E9;&#x4E0B;&#x4E00;&#x6B65;&#x5403;&#x5DE6;&#x6216;&#x53F3;&#x7684;&#x6BD2;&#x836F;&#xFF0C;&#x5C06;&#x6BCF;&#x6B21;&#x9009;&#x62E9;&#x7684;&#x4F4D;&#x7F6E;&#x641E;&#x6210;&#x4E00;&#x4E2A;&#x6392;&#x5217; ppp &#xFF0C;&#x5176;&#x4F24;&#x5BB3;&#x5B9A;&#x4E49;&#x4E3A; &#x2211;j=1ndj[pcj=j]\\sum\\limits_{j=1}^nd_j[p_{c_j}=j]j=1&#x2211;n&#x200B;dj&#x200B;[pcj&#x200B;&#x200B;=j] &#xFF0C;&#x6C42;&#x53EF;&#x80FD;&#x7684;&#x6392;&#x5217;&#x4E2D;&#x6700;&#x5927;&#x7684;&#x4F24;&#x5BB3;&#x503C;&#x3002; &#x6570;&#x636E;&#x8303;&#x56F4;&#xFF1A; n&#x2264;3&#xD7;105n\\le3\\times10^5n&#x2264;3&#xD7;105 &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x5BB9;&#x6613;&#x770B;&#x51FA;&#x4E00;&#x4E2A; dpdpdp &#x5373; fi,jf_{i,j}fi,j&#x200B; &#x8868;&#x793A;&#x5DF2;&#x7ECF;&#x5403;&#x6389;&#x533A;&#x95F4; [i,j][i,j][i,j] &#x7684;&#x6BD2;&#x836F;&#x5230;&#x5403;&#x5B8C;&#x7684;&#x6700;&#x5927;&#x503C;&#xFF0C;&#x8FD9;&#x6837;&#x653E;&#x5230;&#x4E8C;&#x7EF4;&#x5E73;&#x9762;&#x4E0A;&#x6BCF;&#x6B21;&#x8F6C;&#x79FB;&#x5BF9;&#x5E94;&#x5411;&#x4E0B;&#x6216;&#x8005;&#x5411;&#x53F3;&#x8D70;&#xFF0C;&#x800C;&#x7531;&#x4E8E;&#x6700;&#x591A;&#x6709; 2n2n2n &#x6761;&#x8F6C;&#x79FB;&#x8FB9;&#xFF0C;&#x56E0;&#x6B64;&#x679A;&#x4E3E;&#x7EB5;&#x5750;&#x6807;&#xFF0C;&#x7528;&#x6811;&#x72B6;&#x6570;&#x7EC4;&#x4FEE;&#x6539;&#x540E;&#x7F00;&#x53D6; maxmaxmax &#x548C;&#x67E5;&#x8BE2;&#x524D;&#x7F00; maxmaxmax &#x5373;&#x53EF; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;bits/stdc++.h&gt;#define int long long#define ri register int#define fi first#define se second#define pb push_backusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,ll&gt; pll;typedef pair&lt;ll,int&gt; pli;typedef unsigned int uii;typedef unsigned long long Ull;typedef vector&lt;int&gt; poly;inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline ll readl(){ ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s){ int top=0; char ch=gc(); while(ch!=&apos;O&apos;&amp;&amp;ch!=&apos;#&apos;&amp;&amp;ch!=&apos;.&apos;&amp;&amp;ch!=&apos;*&apos;)ch=gc(); while(ch==&apos;O&apos;||ch==&apos;#&apos;||ch==&apos;.&apos;||ch==&apos;*&apos;)s[++top]=ch,ch=gc(); return top;}namespace modular{ const int mod=998244353,inv2=499122177; inline int add(int a,int b){return a+b&lt;mod?a+b:a+b-mod;} inline int dec(int a,int b){return a-b&lt;0?a-b+mod:a-b;} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Add(int&amp;a,int b){a=add(a,b);} inline void Dec(int&amp;a,int b){a=dec(a,b);} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;} inline int Inv(int a){return ksm(a,mod-2);} inline void fix(int&amp;a){a=(a%mod+mod)%mod;}}using namespace modular;template&lt;typename T&gt;inline void ckmax(T&amp;a,T b){a&lt;b?a=b:0;}template&lt;typename T&gt;inline void ckmin(T&amp;a,T b){a&gt;b?a=b:0;}const int N=3e5+5;int n,c[N],d[N];ll bit[N];inline int lowbit(int x){return x&amp;-x;}inline void update(int x,ll v){for(;x;x^=lowbit(x))ckmax(bit[x],v);}inline ll query(int x){ll res=0;for(;x&lt;=n;x+=lowbit(x))ckmax(res,bit[x]);return res;}vector&lt;int&gt;ps[N];signed main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(); for(ri i=1;i&lt;=n;++i){ c[i]=read(); if(c[i]!=1&amp;&amp;c[i]&lt;=i)ps[i-c[i]+1].pb(i); } for(ri i=1;i&lt;=n;++i)d[i]=read(); for(ri i=1;i&lt;=n;++i){ for(ri j=(int)ps[i].size()-1;~j;--j) update(ps[i][j]-1,query(ps[i][j])+d[ps[i][j]]); cout&lt;&lt;query(i)+(c[i]==1?d[i]:0)&lt;&lt;&apos; &apos;; if(i+c[i]-1&lt;=n)update(i+c[i]-1,query(i+c[i]-1)+d[i]); } return 0;} Timsort &#x76F4;&#x63A5;&#x66B4;&#x529B;&#x5373;&#x53EF;&#xFF0C;&#x590D;&#x6742;&#x5EA6;&#x662F;&#x8C03;&#x548C;&#x7EA7;&#x6570; CODE cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;#define gc getcharinline int read(){ int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch==&apos;-&apos;,ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;}const int mod=1e9+7;typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int add(int a,int b){return (a+=b)&lt;mod?a:a-mod;}inline int dec(int a,int b){return (a-=b)&lt;0?a+mod:a;}inline int mul(int a,int b){return (ll)a*b%mod;}inline void Add(int&amp;a,int b){(a+=b)&lt;mod?a:(a-=mod);}inline void Dec(int&amp;a,int b){(a-=b)&lt;0?(a+=mod):a;}inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;}inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))if(p&amp;1)Mul(ret,a);return ret;}const int N=1e5+5;int n,a[N],f[N][2];pii ans[N];int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(); for(ri i=1;i&lt;=n;++i)a[i]=read(); f[n][0]=f[n][1]=1; for(ri i=n-1;i;--i){ f[i][0]=a[i]&lt;=a[i+1]?f[i+1][0]+1:1; f[i][1]=a[i]&gt;a[i+1]?f[i+1][1]+1:1; } for(ri tt=read(),len;tt;--tt){ len=read(); if(ans[len].fi)cout&lt;&lt;ans[len].fi&lt;&lt;&apos; &apos;&lt;&lt;ans[len].se&lt;&lt;&apos;\\n&apos;; else{ for(ri t,i=1;i&lt;=n;++i){ ++ans[len].fi; if(f[i][0]&gt;=len){ i+=f[i][0]-1; continue; } if(f[i][1]&gt;=len){ i+=f[i][1]-1; continue; } t=max(f[i][0],f[i][1]); ans[len].se+=min(n-i+1-t,len-t); i+=min(n-i+1,len)-1; } cout&lt;&lt;ans[len].fi&lt;&lt;&apos; &apos;&lt;&lt;ans[len].se&lt;&lt;&apos;\\n&apos;; } } return 0;} Utilitarianism &#x76F4;&#x63A5;&#x7528; wqswqswqs &#x4E8C;&#x5206;+&#x7B80;&#x5355;&#x6811;&#x5F62; dpdpdp &#x5373;&#x53EF; CODE cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;inline char gc(){ static char buf[rlen],*ib,*ob; (ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)); return ib==ob?-1:*ib++;}inline int read(){ int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch==&apos;-&apos;,ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;}typedef pair&lt;int,int&gt; pii;typedef long long ll;const int N=250005;int n,k;vector&lt;pii&gt;e[N];struct dat{ ll a; int b; dat(ll a=0,int b=0):a(a),b(b){} friend inline dat operator+(const dat&amp;a,const dat&amp;b){return dat(a.a+b.a,a.b+b.b);} friend inline dat operator-(const dat&amp;a,const dat&amp;b){return dat(a.a-b.a,a.b-b.b);} friend inline bool operator&gt;(const dat&amp;a,const dat&amp;b){return a.a==b.a?a.b&gt;b.b:a.a&gt;b.a;}}f[N][2];inline dat max(const dat&amp;a,const dat&amp;b){return a&gt;b?a:b;}void dfs(int p,int fa,ll tmp){ f[p][0]=f[p][1]=dat(0,0); for(ri i=0,v;i&lt;e[p].size();++i){ if((v=e[p][i].fi)==fa)continue; dfs(v,p,tmp),f[p][0]=f[p][0]+max(f[v][0],f[v][1]); } ll w; for(ri i=0,v;i&lt;e[p].size();++i){ if((v=e[p][i].fi)==fa)continue; w=e[p][i].se+tmp; f[p][1]=max(f[p][1],f[p][0]-max(f[v][0],f[v][1])+f[v][0]+dat(w,1)); }}inline bool check(const double tmp){ dfs(1,0,tmp); dat t=max(f[1][0],f[1][1]); return t.b&gt;=k;}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(),k=read(); for(ri i=1;i&lt;=n;++i)e[i].clear(); for(ri i=1,u,v,w;i&lt;n;++i){ u=read(),v=read(),w=read(); e[u].push_back(pii(v,w)); e[v].push_back(pii(u,w)); } ll L=-1e14,R=1e14,ans=1e14; while(L&lt;R){ ll mid=(L+R+1)/2; if(check(mid))ans=mid,R=mid-1; else L=mid+1; } dfs(1,0,ans); dat t=max(f[1][0],f[1][1]); if(t.b&lt;k)puts(&quot;Impossible&quot;); else cout&lt;&lt;(t.a-ans*k)&lt;&lt;&apos;\\n&apos;; return 0;} &#x603B;&#x7ED3;&#xFF1A; &#x6211; dpdpdp &#x4E0D;&#x8FC7;&#x5173; &#x6211;&#x56FE;&#x8BBA;&#x56FE;&#x8BBA;&#x56FE;&#x8BBA;&#x4E0D;&#x8FC7;&#x5173; &#x6211;&#x82F1;&#x8BED;&#x82F1;&#x8BED;&#x82F1;&#x8BED;&#x4E0D;&#x8FC7;&#x5173;","categories":[{"name":"public","slug":"public","permalink":"http://xdl030112.github.io/categories/public/"}],"tags":[{"name":"比赛题解","slug":"比赛题解","permalink":"http://xdl030112.github.io/tags/%E6%AF%94%E8%B5%9B%E9%A2%98%E8%A7%A3/"}]},{"title":"2019.10.15 模拟测试题解","slug":"191015test","date":"2019-10-15T13:13:46.000Z","updated":"2019-10-16T00:46:52.914Z","comments":true,"path":"191015test/","link":"","permalink":"http://xdl030112.github.io/191015test/","excerpt":"","text":"&#x9898;&#x76EE;&#x6765;&#x6E90;&#xFF1A; A:CF643DA: CF643DA:CF643D B:TCO&#xA0;BearDestroyB:TCO\\ BearDestroyB:TCO&#xA0;BearDestroy A &#x9898;&#x610F;&#x7B80;&#x8FF0;&#xFF1A; &#x7ED9;&#x4F60;&#x4E00;&#x4E2A;&#x6709;&#x5411;&#x57FA;&#x73AF;&#x68EE;&#x6797;&#xFF0C;&#x6BCF;&#x4E2A;&#x70B9;&#x6709;&#x4E00;&#x4E2A;&#x540E;&#x7EE7;&#xFF0C;&#x7136;&#x540E;&#x5BF9;&#x4E8E;&#x4E00;&#x4E2A;&#x70B9;&#x4F1A;&#x7ED9;&#x51FA;&#x4E00;&#x4E2A; $ vl_i $ &#xFF0C;&#x5B9A;&#x4E49; $ E_i=\\frac{vl_i}{i&#x5165;&#x5EA6;+i&#x51FA;&#x5EA6;+1},res_i=vl_i%E_i+\\sum\\limits_{dist(i,v)\\le 1}E_v $ &#x8981;&#x6C42;&#x652F;&#x6301;&#x5982;&#x4E0B;&#x64CD;&#x4F5C;&#xFF1A; &#x4FEE;&#x6539;&#x4E00;&#x4E2A;&#x70B9;&#x7684;&#x540E;&#x7EE7; &#x95EE;&#x4E00;&#x4E2A;&#x70B9;&#x7684; resresres &#x67E5;&#x8BE2;&#x5168;&#x5C40; resresres &#x7684;&#x6700;&#x503C; &#x6570;&#x636E;&#x8303;&#x56F4;: n&#x2264;100000n\\le100000n&#x2264;100000 m&#x2264;100000m\\le100000m&#x2264;100000 &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x8003;&#x8651;&#x7528;&#x53EF;&#x5220;&#x5806;&#x7EF4;&#x62A4;&#x5168;&#x5C40;&#x8BE2;&#x95EE;&#xFF0C;&#x7136;&#x540E;&#x5BF9;&#x6BCF;&#x4E2A;&#x70B9;&#x8BB0;&#x4E00;&#x4E2A; deltadeltadelta &#x8868;&#x793A;&#x5B83;&#x5BF9;&#x524D;&#x9A71;&#x7684;&#x5F71;&#x54CD;&#xFF0C;&#x7136;&#x540E;&#x5C31;&#x53D8;&#x6210;&#x4E86;&#x6A21;&#x62DF;&#x9898; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167#include&lt;bits/stdc++.h&gt;#define ri register int#define csi const int#define fi first#define se second#define pb push_backusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline ll readl(){ ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s){ int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;}namespace modular{ int mod; inline int add(int a,int b){return (a+=b)&lt;mod?a:a-mod;} inline int dec(int a,int b){return (a-=b)&lt;0?a+mod:a;} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Add(int&amp;a,int b){a=add(a,b);} inline void Dec(int&amp;a,int b){a=dec(a,b);} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;}}template&lt;typename T&gt;inline void ckmin(T&amp;a,const T&amp;b){a&gt;b?a=b:0;}template&lt;typename T&gt;inline void ckmax(T&amp;a,const T&amp;b){a&lt;b?a=b:0;}const int N=1e5+5;int du[N],n,m,a[N];ll det[N],vl[N],E[N],res[N];struct Set1{ priority_queue&lt;ll&gt;a,b; inline void ins(ll x){a.push(x);} inline void del(ll x){b.push(x);} inline void pop(){while(b.size()&amp;&amp;a.top()==b.top())a.pop(),b.pop();a.pop();} inline ll top(){while(b.size()&amp;&amp;a.top()==b.top())a.pop(),b.pop();return a.top();} inline int size()const{return a.size()-b.size();}}Mx[N],Ansmx;struct Set2{ priority_queue&lt;ll,vector&lt;ll&gt;,greater&lt;ll&gt; &gt;a,b; inline void ins(ll x){a.push(x);} inline void del(ll x){b.push(x);} inline void pop(){while(b.size()&amp;&amp;a.top()==b.top())a.pop(),b.pop();a.pop();} inline ll top(){while(b.size()&amp;&amp;a.top()==b.top())a.pop(),b.pop();return a.top();} inline int size()const{return a.size()-b.size();}}Mn[N],Ansmn;int main(){ n=read(),m=read(); for(ri i=1;i&lt;=n;++i)vl[i]=readl(); for(ri i=1;i&lt;=n;++i){ a[i]=read(); ++du[i],++du[a[i]]; } for(ri i=1;i&lt;=n;++i)E[i]=vl[i]/(du[i]+1); for(ri i=1;i&lt;=n;++i){ res[a[i]]+=E[i]-E[a[i]]; res[i]+=E[a[i]]-E[i]; res[i]+=vl[i]; } for(ri i=1;i&lt;=n;++i){ Mn[a[i]].ins(res[i]); Mx[a[i]].ins(res[i]); } for(ri i=1;i&lt;=n;++i){ if(Mx[i].size())Ansmx.ins(Mx[i].top()); if(Mn[i].size())Ansmn.ins(Mn[i].top()); } ll dt; for(ri p,fp,ffp,x,y,op;m;--m){ op=read(); if(op==1){ x=read(),y=read(); p=a[x],fp=a[p],ffp=a[fp]; Ansmx.del(Mx[p].top()+det[p]); Ansmn.del(Mn[p].top()+det[p]); dt=vl[p]/du[p]-vl[p]/(du[p]+1); Mx[p].del(res[x]); Mn[p].del(res[x]); res[x]+=det[p]-E[p]; det[p]+=dt; if(Mx[p].size())Ansmx.ins(Mx[p].top()+det[p]); if(Mn[p].size())Ansmn.ins(Mn[p].top()+det[p]); Ansmx.del(Mx[fp].top()+det[fp]); Ansmn.del(Mn[fp].top()+det[fp]); Mx[fp].del(res[p]); Mn[fp].del(res[p]); res[p]-=dt*(du[p]-1); res[p]-=E[x]-E[p]; E[p]+=dt; Mx[fp].ins(res[p]); Mn[fp].ins(res[p]); Ansmx.ins(Mx[fp].top()+det[fp]); Ansmn.ins(Mn[fp].top()+det[fp]); Ansmx.del(Mx[ffp].top()+det[ffp]); Ansmn.del(Mn[ffp].top()+det[ffp]); Mx[ffp].del(res[fp]); Mn[ffp].del(res[fp]); res[fp]+=dt; Mx[ffp].ins(res[fp]); Mn[ffp].ins(res[fp]); Ansmx.ins(Mx[ffp].top()+det[ffp]); Ansmn.ins(Mn[ffp].top()+det[ffp]); --du[p]; a[x]=y; p=a[x],fp=a[p],ffp=a[fp]; if(Mx[p].size())Ansmx.del(Mx[p].top()+det[p]); if(Mn[p].size())Ansmn.del(Mn[p].top()+det[p]); dt=vl[p]/(du[p]+2)-vl[p]/(du[p]+1); det[p]+=dt; E[p]+=dt; res[x]-=det[p]-E[p]; Mx[p].ins(res[x]); Mn[p].ins(res[x]); Ansmx.ins(Mx[p].top()+det[p]); Ansmn.ins(Mn[p].top()+det[p]); Ansmx.del(Mx[fp].top()+det[fp]); Ansmn.del(Mn[fp].top()+det[fp]); Mx[fp].del(res[p]); Mn[fp].del(res[p]); res[p]-=dt*du[p]; res[p]+=E[x]-E[p]; Mx[fp].ins(res[p]); Mn[fp].ins(res[p]); Ansmx.ins(Mx[fp].top()+det[fp]); Ansmn.ins(Mn[fp].top()+det[fp]); Ansmx.del(Mx[ffp].top()+det[ffp]); Ansmn.del(Mn[ffp].top()+det[ffp]); Mx[ffp].del(res[fp]); Mn[ffp].del(res[fp]); res[fp]+=dt; Mx[ffp].ins(res[fp]); Mn[ffp].ins(res[fp]); Ansmx.ins(Mx[ffp].top()+det[ffp]); Ansmn.ins(Mn[ffp].top()+det[ffp]); ++du[p]; } else if(op==2){ x=read(); cout&lt;&lt;(res[x]+det[a[x]])&lt;&lt;&apos;\\n&apos;; } else cout&lt;&lt;Ansmn.top()&lt;&lt;&apos; &apos;&lt;&lt;Ansmx.top()&lt;&lt;&apos;\\n&apos;; } return 0;} B &#x9898;&#x610F;&#x7B80;&#x8FF0;&#xFF1A; &#x7ED9;&#x4E00;&#x4E2A; n&#xD7;mn&#xD7;mn&#xD7;m &#x7684;&#x65B9;&#x683C;&#x56FE;,&#x6BCF;&#x4E2A;&#x683C;&#x5B50;&#x586B;&#x4E0A;E&#x6216;&#x8005;S&#xFF0C;&#x4E00;&#x4E2A;&#x4EBA;&#x4ECE; (0,0)(0,0)(0,0) &#x5F00;&#x59CB;&#x6309;&#x884C;&#x4F18;&#x5148;&#x884C;&#x52A8;&#xFF0C;&#x6BCF;&#x6B21;&#x5230;&#x4E00;&#x4E2A;&#x683C;&#x5B50; (i,j)(i,j)(i,j) &#x5C31;&#x6267;&#x884C;&#x4EE5;&#x4E0B;&#x64CD;&#x4F5C;&#xFF1A; &#x5982;&#x679C;&#x8BE5;&#x683C;&#x5B50;&#x5DF2;&#x7ECF;&#x653E;&#x7F6E;&#x4E86;&#x9AA8;&#x724C;,&#x90A3;&#x4E48;&#x4E0D;&#x64CD;&#x4F5C; &#x82E5;&#x8BE5;&#x683C;&#x5B50;&#x6CA1;&#x6709;&#x653E;&#x7F6E;&#x9AA8;&#x724C;&#x4E14;&#x8BE5;&#x683C;&#x5B50;&#x5199;&#x7684;&#x662F;E&#xFF0C;&#x90A3;&#x4E48;&#x4F18;&#x5148;&#x653E;&#x4E00;&#x5757; 1&#xD7;21&#xD7;21&#xD7;2 &#x7684;&#x9AA8;&#x724C;&#xFF0C;&#x4E0D;&#x884C;&#x5C31;&#x653E;&#x4E00;&#x5757; 2&#xD7;12&#xD7;12&#xD7;1 &#x7684;&#x9AA8;&#x724C;&#xFF0C;&#x518D;&#x4E0D;&#x884C;&#x5C31;&#x4E0D;&#x64CD;&#x4F5C; &#x82E5;&#x8BE5;&#x683C;&#x5B50;&#x6CA1;&#x6709;&#x653E;&#x7F6E;&#x9AA8;&#x724C;&#x4E14;&#x8BE5;&#x683C;&#x5B50;&#x5199;&#x7684;&#x662F;S&#xFF0C;&#x90A3;&#x4E48;&#x4F18;&#x5148;&#x653E;&#x4E00;&#x5757; 2&#xD7;12&#xD7;12&#xD7;1 &#x7684;&#x9AA8;&#x724C;&#xFF0C;&#x4E0D;&#x884C;&#x5C31;&#x653E;&#x4E00;&#x5757; 1&#xD7;21&#xD7;21&#xD7;2 &#x7684;&#x9AA8;&#x724C;&#xFF0C;&#x518D;&#x4E0D;&#x884C;&#x5C31;&#x4E0D;&#x64CD;&#x4F5C; &#x4E00;&#x4E2A;&#x56FE;&#x7684;&#x5F97;&#x5206;&#x4E3A;&#x653E;&#x7F6E;&#x7684;&#x9AA8;&#x724C;&#x6570;&#x91CF;,&#x6C42; 2n&#xD7;m2^{n&#xD7;m}2n&#xD7;m &#x79CD;&#x56FE;&#x7684;&#x5F97;&#x5206;&#x7684;&#x548C;&#x5BF9;MOD&#x53D6;&#x4F59; &#x6570;&#x636E;&#x8303;&#x56F4;&#xFF1A; n&#x2264;12n\\le12n&#x2264;12 m&#x2264;30m\\le30m&#x2264;30 &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x8003;&#x8651;&#x6BCF;&#x4E2A;&#x9AA8;&#x724C;&#x8981;&#x4E48;&#x8986;&#x76D6; (i,j),(i,j+1)(i,j),(i,j+1)(i,j),(i,j+1) &#xFF0C;&#x8981;&#x4E48;&#x8986;&#x76D6; (i,j),(i+1,j)(i,j),(i+1,j)(i,j),(i+1,j) &#xFF0C;&#x90A3;&#x4E48;&#x5982;&#x679C;&#x6309;&#x7167;&#x5BF9;&#x89D2;&#x7EBF;&#x5206;&#x5C42;&#x7684;&#x8BDD;&#x8FD9;&#x663E;&#x7136;&#x662F;&#x4E00;&#x4E2A;&#x5206;&#x5C42;&#x56FE; dpdpdp &#xFF0C;&#x8FD9;&#x6837;&#x5C31;&#x53EF;&#x4EE5;&#x8BBE; fi,jf_{i,j}fi,j&#x200B; &#x8868;&#x793A;&#x7B2C; iii &#x5C42;&#x72B6;&#x6001;&#x4E3A; jjj &#x7684;&#x7B54;&#x6848;&#xFF0C;&#x7136;&#x540E;&#x5C31;&#x53EF;&#x4EE5;&#x7528;&#x72B6;&#x538B; dpdpdp &#x7684;&#x601D;&#x60F3;&#x8F6C;&#x79FB;&#x4E86;&#xFF08;&#x5B9E;&#x8D28;&#x4E0A;&#x8FD9;&#x4E2A;&#x5730;&#x65B9;&#x5229;&#x7528;&#x7684;&#x662F;&#x63D2;&#x5934; dpdpdp &#x7684;&#x60F3;&#x6CD5; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_backusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;vector&lt;int&gt; &gt; vii;inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline ll readl(){ ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s){ int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;}namespace modular{ int mod; inline int add(int a,int b){return (a+=b)&lt;mod?a:a-mod;} inline int dec(int a,int b){return (a-=b)&lt;0?a+mod:0;} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Add(int&amp;a,int b){a=add(a,b);} inline void Dec(int&amp;a,int b){a=dec(a,b);} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;} inline int Inv(int x){return ksm(x,mod-2);} inline void fix(int&amp;x){x=(x%mod+mod)%mod;}}using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,const T&amp;b){a&gt;b?a=b:0;}template&lt;typename T&gt;inline void ckmax(T&amp;a,const T&amp;b){a&lt;b?a=b:0;}int n,m,lm;#define getsta(x,y) ((x)&gt;&gt;((y)-1)&amp;1)#define sub(x) (1&lt;&lt;((x)-1))#define trans0 cf,cg,f,g#define trans1 add(cf,cf),add(cg,cg),f,g#define trans2 add(cf,cf),add(add(cf,cf),add(cg,cg)),f,g#define trans3 cf,add(cf,cg),f,ginline void update(int ps,int s1,int s2,int cf,int cg,vi&amp;f,vi&amp;g){ if(ps==n+1){ Add(f[s2],cf); Add(g[s2],cg); return; } if(lm-ps&lt;0||lm-ps+1&gt;m)return update(ps+1,s1,s2,trans0); if(getsta(s1,ps))return update(ps+1,s1,s2,trans1); if(lm-ps+1==m||getsta(s2,ps)){ if(ps==n)update(ps+1,s1,s2,trans1); else update(ps+1,s1|sub(ps),s2|sub(ps+1),trans2); } else{ if(ps==n)update(ps+1,s1|sub(ps),s2|sub(ps),trans2); else{ update(ps+1,s1|sub(ps),s2|sub(ps),trans3); update(ps+1,s1|sub(ps),s2|sub(ps+1),trans3); } }}#undef sub#undef trans0#undef trans1#undef trans2#undef getstainline int solve(){ vii f(n+m+1),g(n+m+1); int all=1&lt;&lt;n; f[1].resize(all),g[1].resize(all); f[1][0]=1,g[1][0]=0; for(ri dep=1;dep&lt;n+m;++dep){ lm=dep; f[dep+1].resize(all); g[dep+1].resize(all); for(ri sta=0;sta&lt;all;++sta) update(1,sta,0,f[dep][sta],g[dep][sta],f[dep+1],g[dep+1]); } return g[n+m][0];}class BearDestroys{ public: inline int sumUp(int n_,int m_,int mod_){ mod=mod_,n=n_,m=m_; return solve(); }}; C &#x9898;&#x610F;&#x7B80;&#x8FF0;&#xFF1A; &#x6709; nnn &#x79CD;&#x4E0D;&#x540C;&#x7684;&#x679C;&#x6C41;&#xFF0C;&#x7B2C; iii &#x79CD;&#x6709; cic_ici&#x200B; &#x5347;&#x3002;&#x73B0;&#x5728;&#x8981;&#x5C06;&#x6240;&#x6709;&#x679C;&#x6C41;&#x653E;&#x8FDB; mmm &#x4E2A;&#x74F6;&#x5B50;&#x91CC;&#xFF0C;&#x6EE1;&#x8DB3;&#x6BCF;&#x4E2A;&#x74F6;&#x5B50;&#x91CC;&#x4E0D;&#x8D85;&#x8FC7;&#x4E24;&#x79CD;&#x679C;&#x6C41;&#x4E14;&#x6240;&#x6709;&#x74F6;&#x5B50;&#x88C5;&#x7684;&#x679C;&#x6C41;&#x91CF;&#x4E00;&#x6837;&#xFF0C;&#x95EE; mmm &#x6700;&#x5C0F;&#x503C;&#xFF0C;(&#x679C;&#x6C41;&#x91CF;&#x5141;&#x8BB8;&#x4E3A;&#x5206;&#x6570; &#x6570;&#x636E;&#x8303;&#x56F4;&#xFF1A; n&#x2264;20n\\le20n&#x2264;20 ci&#x2264;109c_i\\le10^9ci&#x200B;&#x2264;109 &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x5148;&#x8003;&#x8651;&#x7B54;&#x6848;&#x7684;&#x4E0A;&#x754C;&#xFF0C;&#x5BB9;&#x6613;&#x53D1;&#x73B0;&#x662F; n&#x2212;1n-1n&#x2212;1 &#xFF0C;&#xFF08;&#x53EF;&#x4EE5;&#x901A;&#x8FC7;&#x5F52;&#x7EB3;&#x6CD5;&#x8BC1;&#x660E;&#x4E00;&#x5B9A;&#x5B58;&#x5728; n&#x2212;1n-1n&#x2212;1 &#x4E2A;&#x74F6;&#x5B50;&#x7684;&#x5408;&#x6CD5;&#x65B9;&#x6848;)&#xFF0C;&#x7136;&#x540E;&#x5047;&#x8BBE;&#x73B0;&#x5728;&#x4E00;&#x4E2A;&#x74F6;&#x5B50;&#x4E2D;&#x6709;&#x4E24;&#x79CD;&#x679C;&#x6C41; a,ba,ba,b &#xFF0C;&#x6211;&#x4EEC;&#x5728; a,ba,ba,b &#x4E2D;&#x8FDE;&#x4E0A;&#x4E00;&#x6761;&#x8FB9;&#xFF0C;&#x5047;&#x8BBE;&#x7B54;&#x6848;&#x4E3A; mmm &#xFF0C;&#x90A3;&#x4E48;&#x4E00;&#x5B9A;&#x4F1A;&#x5C06; nnn &#x4E2A;&#x70B9;&#x5206;&#x6210;&#x81F3;&#x5C11; n&#x2212;mn-mn&#x2212;m &#x4E2A;&#x8FDE;&#x901A;&#x5757;&#xFF0C;&#x8FD9;&#x6837;&#x76F8;&#x5F53;&#x4E8E;&#x53EF;&#x4EE5;&#x679A;&#x4E3E; mmm &#x7136;&#x540E;&#x9012;&#x5F52;&#x6210;&#x5B50;&#x95EE;&#x9898;&#xFF0C;&#x5BF9;&#x4E8E;&#x4E00;&#x4E2A; n&#x2032;n&apos;n&#x2032; &#x4E2A;&#x70B9;&#x7684;&#x70B9;&#x96C6;&#x5982;&#x679C;&#x5176;&#x53EF;&#x4EE5;&#x88AB;&#x5206;&#x5230; n&#x2032;&#x2212;1n&apos;-1n&#x2032;&#x2212;1 &#x4E2A;&#x74F6;&#x5B50;&#x91CC;&#x90A3;&#x4E48;&#x5C31;&#x662F;&#x5408;&#x6CD5;&#x7684;&#xFF0C;&#x4E8E;&#x662F;&#x5C31;&#x80FD;&#x591F;&#x679A;&#x4E3E;&#x5B50;&#x96C6;&#x8F6C;&#x79FB;&#xFF0C;&#x590D;&#x6742;&#x5EA6;O(3n&#x2217;n)O(3^n*n)O(3n&#x2217;n) &#xFF0C;&#x5F53;&#x7136;&#x53EF;&#x4EE5;&#x7528;&#x5B50;&#x96C6;&#x5377;&#x79EF;&#x7EE7;&#x7EED;&#x4F18;&#x5316;&#x4F46;&#x662F;&#x7531;&#x4E8E;&#x6570;&#x636E;&#x4E0D;&#x5F3A;&#x56E0;&#x6B64;&#x61D2;&#x5F97;&#x5199;&#x4E86;~ CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_backusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;vector&lt;int&gt; &gt; vii;inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline ll readl(){ ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s){ int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;}namespace modular{ int mod; inline int add(int a,int b){return (a+=b)&lt;mod?a:a-mod;} inline int dec(int a,int b){return (a-=b)&lt;0?a+mod:0;} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Add(int&amp;a,int b){a=add(a,b);} inline void Dec(int&amp;a,int b){a=dec(a,b);} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;} inline int Inv(int x){return ksm(x,mod-2);} inline void fix(int&amp;x){x=(x%mod+mod)%mod;}}using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,const T&amp;b){a&gt;b?a=b:0;}template&lt;typename T&gt;inline void ckmax(T&amp;a,const T&amp;b){a&lt;b?a=b:0;}const int N=25;int n,vl[N];int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(); int all=1&lt;&lt;n; vi ct(all),id(all); vector&lt;ll&gt;ss(all); if(n&lt;=2)return puts(&quot;1&quot;),0; for(ri i=1;i&lt;=n;++i)id[1&lt;&lt;(i-1)]=i,vl[i]=read(); for(ri i=1;i&lt;all;++i){ ct[i]=ct[i^(i&amp;-i)]+1; ss[i]=ss[i^(i&amp;-i)]+vl[id[i&amp;-i]]; } for(ri i=n+1&gt;&gt;1;i&lt;n-1;++i){ bool ff=0,tg; int s=all-1; while(1){ tg=0; if((ll)ss[all-1]*(ct[s]-1)==(ll)ss[s]*i){ ff=1; break; } for(ri t=s;t;t=(t-1)&amp;s) if((ll)ss[all-1]*(ct[t]-1)==(ll)ss[t]*i){ tg=1; s^=t; break; } if(!tg)break; } if(ff){ cout&lt;&lt;i; return 0; } } cout&lt;&lt;n-1; return 0;}","categories":[{"name":"private","slug":"private","permalink":"http://xdl030112.github.io/categories/private/"}],"tags":[{"name":"考试题解","slug":"考试题解","permalink":"http://xdl030112.github.io/tags/%E8%80%83%E8%AF%95%E9%A2%98%E8%A7%A3/"}]},{"title":"CodeForces 1244 简要题解","slug":"CF1244","date":"2019-10-14T08:59:39.000Z","updated":"2019-10-22T23:48:31.189Z","comments":true,"path":"CF1244/","link":"","permalink":"http://xdl030112.github.io/CF1244/","excerpt":"","text":"A &#x6A21;&#x62DF; CODE cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly;inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline ll readl(){ ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s){ int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;}namespace modular{ const int mod=998244353; inline int add(int a,int b){return (a+=b)&lt;mod?a:a-mod;} inline void Add(int&amp;a,int b){a=add(a,b);} inline int dec(int a,int b){return (a-=b)&lt;0?a+mod:a;} inline void Dec(int&amp;a,int b){a=dec(a,b);} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;}}using namespace modular;int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif for(ri tt=read();tt;--tt){ int a=read(),b=read(),c=read(),d=read(),k=read(); int res=a%c?a/c+1:a/c,ress=b%d?b/d+1:b/d; if(res+ress&gt;k)puts(&quot;-1&quot;); else cout&lt;&lt;res&lt;&lt;&apos; &apos;&lt;&lt;ress&lt;&lt;&apos;\\n&apos;; } return 0;} B &#x7B80;&#x5355;&#x8D2A;&#x5FC3; CODE cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly;inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline ll readl(){ ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s){ int top=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))s[++top]=ch,ch=gc(); return top;}namespace modular{ const int mod=998244353; inline int add(int a,int b){return (a+=b)&lt;mod?a:a-mod;} inline void Add(int&amp;a,int b){a=add(a,b);} inline int dec(int a,int b){return (a-=b)&lt;0?a+mod:a;} inline void Dec(int&amp;a,int b){a=dec(a,b);} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;}}using namespace modular;const int N=1005;char s[N];int n;int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif for(ri tt=read();tt;--tt){ n=read(); Read(s); int ans=n,sum=n; for(ri i=1;i&lt;=n;++i){ if(s[i]==&apos;1&apos;){ ++sum; ans=max(ans,i*2); ans=max(ans,(n-i+1)*2); } } ans=max(ans,sum); cout&lt;&lt;ans&lt;&lt;&apos;\\n&apos;; } return 0;} C exgcdexgcdexgcd &#x677F;&#x9898; CODE cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly;inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline ll readl(){ ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s){ int top=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))s[++top]=ch,ch=gc(); return top;}namespace modular{ const int mod=998244353; inline int add(int a,int b){return (a+=b)&lt;mod?a:a-mod;} inline void Add(int&amp;a,int b){a=add(a,b);} inline int dec(int a,int b){return (a-=b)&lt;0?a+mod:a;} inline void Dec(int&amp;a,int b){a=dec(a,b);} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;}}using namespace modular;const int N=1005;ll n,p,d,w;inline void exgcd(ll a,ll b,ll&amp;x,ll&amp;y){ if(!b){ x=1; y=0; return; } exgcd(b,a%b,x,y); ll t=x; x=y,y=t-a/b*y;}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif for(ri tt=1;tt;--tt){ n=readl(),p=readl(),w=readl(),d=readl(); ll g=__gcd(d,w); if(p%g){ puts(&quot;-1&quot;); continue; } p/=g,d/=g,w/=g; ll x,y; exgcd(w,d,x,y); y=(y%w+w)%w; y=y*(p%w)%w; x=(p-d*y)/w; if(x&lt;0){ puts(&quot;-1&quot;); continue; } if(n-x-y&lt;0){ puts(&quot;-1&quot;); continue; } cout&lt;&lt;x&lt;&lt;&apos; &apos;&lt;&lt;y&lt;&lt;&apos; &apos;&lt;&lt;n-x-y&lt;&lt;&apos;\\n&apos;; } return 0;} D &#x5408;&#x6CD5;&#x60C5;&#x51B5;&#x4E00;&#x5B9A;&#x662F;&#x6761;&#x94FE; &#x8C8C;&#x4F3C;&#x76F4;&#x63A5;&#x679A;&#x4E3E;&#x5DE6;&#x7AEF;&#x7684;&#x989C;&#x8272;&#x5176;&#x4F59;&#x989C;&#x8272;&#x5C31;&#x56FA;&#x5B9A;&#x4E86; &#x4F46;&#x4E5F;&#x53EF;&#x4EE5;&#x5F3A;&#x884C; dpdpdp &#x597D;&#x597D;&#x7684;&#x786E;&#x662F;&#x6211;&#x6BD4;&#x8D5B;&#x7684;&#x65F6;&#x5019;&#x88AB;&#x964D;&#x667A;&#x4E86; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly;inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline ll readl(){ ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s){ int top=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))s[++top]=ch,ch=gc(); return top;}namespace modular{ const int mod=998244353; inline int add(int a,int b){return (a+=b)&lt;mod?a:a-mod;} inline void Add(int&amp;a,int b){a=add(a,b);} inline int dec(int a,int b){return (a-=b)&lt;0?a+mod:a;} inline void Dec(int&amp;a,int b){a=dec(a,b);} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;}}using namespace modular;const int N=100005;int n,vl[N][4],q[N],hd,tl,vs[N],col[N];ll f[N][4][4];pii pre[N][4][4];vector&lt;int&gt;e[N];int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(); for(ri i=1;i&lt;=3;++i)for(ri j=1;j&lt;=n;++j)vl[j][i]=read(); for(ri i=1,u,v;i&lt;n;++i){ u=read(),v=read(); e[u].pb(v); e[v].pb(u); } for(ri i=1;i&lt;=n;++i)if(e[i].size()&gt;2)return puts(&quot;-1&quot;),0; for(ri i=1;i&lt;=n;++i){ if(e[i].size()==1){ q[hd=tl=1]=i; break; } } while(hd&lt;=tl){ int x=q[hd++]; vs[x]=1; for(ri i=0,v;i&lt;e[x].size();++i){ if(vs[v=e[x][i]])continue; q[++tl]=v; } } memset(f,0x3f,sizeof(f)); for(ri i=1;i&lt;=3;++i)for(ri j=1;j&lt;=3;++j)if(i!=j)f[1][i][j]=vl[q[1]][j]; for(ri i=2;i&lt;=n;++i){ for(ri j=1;j&lt;=3;++j){ for(ri k=1;k&lt;=3;++k){ for(ri l=1;l&lt;=3;++l){ if(j!=k&amp;&amp;k!=l&amp;&amp;j!=l){ if(f[i-1][l][j]+vl[q[i]][k]&lt;f[i][j][k]){ f[i][j][k]=f[i-1][l][j]+vl[q[i]][k]; pre[i][j][k]=pii(l,j); } } } } } } ll res=1e18; pii las; for(ri i=1;i&lt;=3;++i)for(ri j=1;j&lt;=3;++j){ if(i!=j)if(f[n][i][j]&lt;res){ res=f[n][i][j]; las=pii(i,j); } } int ps=n; while(ps){ col[q[ps]]=las.se; las=pre[ps][las.fi][las.se]; --ps; } cout&lt;&lt;res&lt;&lt;&apos;\\n&apos;; for(ri i=1;i&lt;=n;++i)cout&lt;&lt;col[i]&lt;&lt;&apos; &apos;; return 0;} E &#x5148;&#x628A;&#x6570;&#x7EC4;&#x6392;&#x5E8F;&#xFF0C;&#x7136;&#x540E;&#x5904;&#x7406;&#x4E00;&#x4E0B;&#x524D;&#x540E;&#x7F00;&#x5C31;&#x80FD;&#x4E0A;&#x53CC;&#x6307;&#x9488;&#x4E86; CODE cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly;inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline ll readl(){ ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s){ int top=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))s[++top]=ch,ch=gc(); return top;}namespace modular{ const int mod=998244353; inline int add(int a,int b){return (a+=b)&lt;mod?a:a-mod;} inline void Add(int&amp;a,int b){a=add(a,b);} inline int dec(int a,int b){return (a-=b)&lt;0?a+mod:a;} inline void Dec(int&amp;a,int b){a=dec(a,b);} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;}}using namespace modular;const int N=100005;int n,a[N],b[N],sig,pre[N],suf[N];ll Pre[N],Suf[N],pvl[N],svl[N];ll K;int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(); K=readl(); for(ri i=1;i&lt;=n;++i)a[i]=read(); sort(a+1,a+n+1); sig=0; for(ri i=1;i&lt;=n;++i){ if(a[i]!=a[i-1])a[++sig]=a[i],b[sig]=1; else ++b[sig]; } for(ri i=1;i&lt;=sig;++i)pre[i]=pre[i-1]+b[i],Pre[i]=Pre[i-1]+(ll)b[i]*a[i],pvl[i]=(ll)pre[i]*a[i]-Pre[i]; for(ri i=sig;i;--i)suf[i]=suf[i+1]+b[i],Suf[i]=Suf[i+1]+(ll)b[i]*a[i],svl[i]=(ll)Suf[i]-(ll)suf[i]*a[i]; ll res=a[sig]-a[1]; for(ri ps1=1,ps2=1;ps1&lt;=sig;++ps1){ while(ps2&lt;=sig&amp;&amp;pvl[ps1]+svl[ps2]&gt;K)++ps2; if(ps2&gt;sig)break; if(ps1&gt;=ps2)return puts(&quot;0&quot;),0; res=min(res,a[ps2]-a[ps1]-(K-pvl[ps1]-svl[ps2])/suf[ps2]); } for(ri ps1=sig,ps2=sig;ps2;--ps2){ while(ps1&amp;&amp;pvl[ps1]+svl[ps2]&gt;K)--ps1; if(!ps1)break; if(ps1&gt;=ps2)return puts(&quot;0&quot;),0; res=min(res,a[ps2]-a[ps1]-(K-pvl[ps1]-svl[ps2])/pre[ps1]); } cout&lt;&lt;res; return 0;} F &#x968F;&#x4FBF;&#x627E;&#x4E2A;&#x89C4;&#x5F8B;&#x5C31;&#x884C;&#x4E86;&#xFF0C;&#x7136;&#x540E;&#x5206;&#x5947;&#x5076;&#x8BA8;&#x8BBA;&#x4E00;&#x4E0B; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly;inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline ll readl(){ ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s){ int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;}namespace modular{ const int mod=998244353; inline int add(int a,int b){return (a+=b)&lt;mod?a:a-mod;} inline void Add(int&amp;a,int b){a=add(a,b);} inline int dec(int a,int b){return (a-=b)&lt;0?a+mod:a;} inline void Dec(int&amp;a,int b){a=dec(a,b);} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;}}using namespace modular;const int N=6e5+5;int n,k;char s[N];inline void check1(){ if(n&amp;1)return; for(ri i=2;i&lt;=n;++i)if(s[i]==s[i-1])return; k&amp;=1; for(ri i=1;i&lt;=n;++i){ if(k==1){ if(s[i]==&apos;W&apos;)cout&lt;&lt;&apos;B&apos;; else cout&lt;&lt;&apos;W&apos;; } else cout&lt;&lt;s[i]; } exit(0);}inline void check2(){ for(ri i=2;i&lt;=n;++i)if(s[i]!=s[i-1])return; for(ri i=1;i&lt;=n;++i)cout&lt;&lt;s[i]; exit(0);}bool ban[N];char res[N];int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(),k=read(); Read(s); check1(); check2(); for(ri i=1;i&lt;=n;++i)s[i+n]=s[i+n*2]=s[i]; int st; for(ri i=1;i&lt;=n;++i){ if(s[i]==s[i+1]){ st=i; break; } } int mid,L=st,R=st+n-1,l,r; for(l=L;l&lt;=R;l=r+1){ r=l; while(r&lt;R&amp;&amp;s[r+1]==s[r])++r; if(r==R)break; mid=r; while(r&lt;=R&amp;&amp;s[r+1]!=s[r])++r; --r; if(mid==r)continue; if(r-mid&lt;=k*2)for(ri p1=mid+1,p2=r;p1&lt;=p2;++p1,--p2){ s[p1]=s[l],s[p2]=s[r+1]; } else{ int p1,p2,i; for(p1=mid+1,p2=r,i=1;i&lt;=k;++i,++p1,--p2){ s[p1]=s[l],s[p2]=s[r+1]; } if(k&amp;1)for(ri i=p1;i&lt;=p2;++i)s[i]=s[i]==&apos;B&apos;?&apos;W&apos;:&apos;B&apos;; } } for(ri i=L;i&lt;=R;++i){ if(i&gt;n)s[i-n]=s[i]; } for(ri i=1;i&lt;=n;++i)cout&lt;&lt;s[i]; return 0;} G &#x968F;&#x4FBF;&#x8D2A;&#x4E2A;&#x5FC3;&#x5C31;&#x8FC7;&#x4E86;&#xFF0C;&#x8BC1;&#x660E;&#x5F88;&#x7B80;&#x5355;&#xFF08;&#x867D;&#x7136;&#x6211;&#x76F4;&#x63A5;&#x778E;&#x8D2A;&#x7684;&#x4F46;&#x540E;&#x6765; cyktxdycyktxdycyktxdy &#x8DDF;&#x6211;&#x8BF4;&#x4E86;&#x4E00;&#x4E2A;&#x8BC1;&#x660E;&#x65B9;&#x6CD5;&#x611F;&#x89C9;&#x8FD8;&#x633A; naiivenaiivenaiive &#x7684; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly;inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline ll readl(){ ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s){ int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;}namespace modular{ const int mod=998244353; inline int add(int a,int b){return (a+=b)&lt;mod?a:a-mod;} inline void Add(int&amp;a,int b){a=add(a,b);} inline int dec(int a,int b){return (a-=b)&lt;0?a+mod:a;} inline void Dec(int&amp;a,int b){a=dec(a,b);} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;}}using namespace modular;const int N=1e6+5;int n;ll K;#define lc (p&lt;&lt;1)#define rc (p&lt;&lt;1|1)#define mid (l+r&gt;&gt;1)int siz[N&lt;&lt;2];inline void build(int p,int l,int r){ siz[p]=r-l+1; if(l==r)return; build(lc,l,mid),build(rc,mid+1,r);}inline int query(int p,int l,int r){ if(!siz[p])return -1; if(l==r)return l; return siz[lc]?query(lc,l,mid):query(rc,mid+1,r);}inline void update(int p,int l,int r,int k){ if(l==r){ siz[p]=0; return; } k&lt;=mid?update(lc,l,mid,k):update(rc,mid+1,r,k); siz[p]=siz[lc]+siz[rc];}inline int query(int p,int l,int r,int ql,int qr){ if(ql&lt;=l&amp;&amp;r&lt;=qr)return query(p,l,r); if(qr&lt;=mid)return query(lc,l,mid,ql,qr); if(ql&gt;mid)return query(rc,mid+1,r,ql,qr); int res=query(lc,l,mid,ql,qr); if(~res)return res; return query(rc,mid+1,r,ql,qr); }#undef lc#undef rc#undef midint ans[N];int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(); K=readl(); ll ss=0; if(K&lt;(ll)n*(n+1)/2)return puts(&quot;-1&quot;),0; ll T=K; K-=(ll)n*(n+1)/2; build(1,1,n); for(ri i=n;i;--i){ int ql=max(1ll,i-K),qr=i; int x=query(1,1,n,ql,qr); if(~x)ans[x]=i,K-=i-x; else ans[x=query(1,1,n,qr+1,n)]=i; update(1,1,n,x); } cout&lt;&lt;T-K&lt;&lt;&apos;\\n&apos;; for(ri i=1;i&lt;=n;++i)cout&lt;&lt;i&lt;&lt;&apos; &apos;; puts(&quot;&quot;); for(ri i=1;i&lt;=n;++i)cout&lt;&lt;ans[i]&lt;&lt;&apos; &apos;; return 0;}","categories":[{"name":"public","slug":"public","permalink":"http://xdl030112.github.io/categories/public/"}],"tags":[{"name":"比赛题解","slug":"比赛题解","permalink":"http://xdl030112.github.io/tags/%E6%AF%94%E8%B5%9B%E9%A2%98%E8%A7%A3/"}]},{"title":"LibreOJ NOI Round2 Day1 简要题解","slug":"LNRR2D1","date":"2019-10-14T08:41:11.000Z","updated":"2019-10-14T08:54:13.697Z","comments":true,"path":"LNRR2D1/","link":"","permalink":"http://xdl030112.github.io/LNRR2D1/","excerpt":"","text":"A &#x5BB9;&#x6613;&#x53D1;&#x73B0;&#x539F;&#x9898;&#x4E2D;&#x7684;&#x8FD0;&#x7B97;&#x53EF;&#x4EE5;&#x7528;&#x77E9;&#x9635;&#x5B8C;&#x6210; O(n)O(n)O(n) &#x7EF4;&#x62A4;&#x77E9;&#x9635;&#x548C;&#x9006;&#x77E9;&#x9635;&#x5373;&#x53EF; CODE cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_backusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch==&apos;-&apos;,ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;}inline ll readl(){ ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s){ int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch; return top;}namespace modular{ const int mod=998244353; inline int add(int a,int b){return (a+=b)&lt;mod?a:a-mod;} inline int dec(int a,int b){return (a-=b)&lt;0?a+mod:a;} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Add(int&amp;a,int b){a=add(a,b);} inline void Dec(int&amp;a,int b){a=dec(a,b);} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;} inline int findInv(int a){return ksm(a,mod-2);}}using namespace modular;const int N=1e6+5;vector&lt;int&gt;e[N];struct Mat{ int a[2][2]; inline int*operator[](const int&amp;k){return a[k];} Mat(){a[0][0]=a[0][1]=a[1][0]=a[1][1]=0;} Mat(int x,int typ){ typ==0? (a[0][0]=x,a[0][1]=1,a[1][0]=1,a[1][1]=0): (a[0][0]=0,a[0][1]=1,a[1][0]=1,a[1][1]=x?mod-x:0); } friend inline Mat operator+(Mat a,Mat b){ Mat ret; ret[0][0]=((ll)a[0][0]*b[0][0]+(ll)a[0][1]*b[1][0])%mod; ret[0][1]=((ll)a[0][0]*b[0][1]+(ll)a[0][1]*b[1][1])%mod; ret[1][0]=((ll)a[1][0]*b[0][0]+(ll)a[1][1]*b[1][0])%mod; ret[1][1]=((ll)a[1][0]*b[0][1]+(ll)a[1][1]*b[1][1])%mod; return ret; }}pre[N][2];int n,m,opt,a[N];int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(),m=read(),opt=read(); for(ri i=1;i&lt;=n;++i)a[i]=read(); pre[0][0]=Mat(0,0),pre[0][1]=Mat(0,1); for(ri i=1;i&lt;=n;++i){ pre[i][0]=pre[i-1][0]+Mat(a[i],0); pre[i][1]=Mat(a[i],1)+pre[i-1][1]; } for(ri ansx=0,ansy=0,op,l,r,i=1;i&lt;=m;++i){ op=read(); if(op==1){ a[++n]=read()^ansx^ansy; pre[n][0]=pre[n-1][0]+Mat(a[n],0); pre[n][1]=Mat(a[n],1)+pre[n-1][1]; } else{ l=read()^ansx^ansy,r=read()^ansx^ansy; Mat coe=pre[l-1][1]+pre[r-1][0]; ansx=((ll)coe[0][0]*a[r]+coe[0][1])%mod; cout&lt;&lt;ansx&lt;&lt;&apos; &apos;; ansy=((ll)coe[1][0]*a[r]+coe[1][1])%mod; cout&lt;&lt;ansy&lt;&lt;&apos;\\n&apos;; } ansx*=opt; ansy*=opt; } return 0;} B &#x5BB9;&#x6613;&#x60F3;&#x5230;&#x8D39;&#x7528;&#x6D41;&#x505A;&#x6CD5;&#xFF0C;&#x7136;&#x540E;&#x53D1;&#x73B0;&#x53EF;&#x4EE5;&#x7528; HLDHLDHLD +&#x8D2A;&#x5FC3;&#x6A21;&#x62DF;&#x8D39;&#x7528;&#x6D41;&#x6765;&#x89E3;&#x51B3;&#x6389;&#x5148;&#x51FA;&#x73B0;&#x6240;&#x6709;&#x91D1;&#x77FF;&#x7684;&#x6570;&#x636E;&#x70B9; &#x4E0B;&#x9762;&#x5C06;&#x91D1;&#x77FF;&#x6210;&#x4E3A;&#x6D1E;&#xFF0C;&#x77FF;&#x5DE5;&#x79F0;&#x4E3A;&#x8001;&#x9F20; &#x8003;&#x8651;&#x7528;&#x7EBF;&#x6BB5;&#x6811;&#x5206;&#x6CBB;&#x6765;&#x5C06;&#x95EE;&#x9898;&#x8F6C;&#x5316;&#x6210;&#x4E0A;&#x8FF0;&#x60C5;&#x51B5;&#xFF0C;&#x8003;&#x8651;&#x5BF9;&#x6BCF;&#x4E2A;&#x6D1E;&#x5EFA;&#x4E00;&#x4E2A;&#x865A;&#x7684;&#x8001;&#x9F20;&#x8FDB;&#x884C;&#x5339;&#x914D;&#xFF0C;&#x4F7F;&#x5F97;&#x4EE3;&#x4EF7;&#x548C;&#x4E3A;&#x4E00;&#x4E2A;&#x786E;&#x5B9A;&#x7684;&#x6781;&#x5927;&#x503C; infinfinf &#xFF0C;&#x7136;&#x540E;&#x7ED9;&#x539F;&#x672C;&#x653E;&#x6D1E;&#x7684;&#x5730;&#x65B9;&#x5EFA;&#x4E00;&#x4E2A;&#x865A;&#x513F;&#x5B50; xxx &#xFF0C;&#x5C06;&#x8FD9;&#x4E2A;&#x6D1E;&#x548C;&#x8001;&#x9F20;&#x90FD;&#x653E;&#x5165; xxx &#x5373;&#x53EF;&#xFF0C;&#x6B63;&#x786E;&#x6027;&#x663E;&#x7136; &#x7136;&#x540E;&#x5C06; HLDHLDHLD +&#x7EBF;&#x6BB5;&#x6811;&#x6362;&#x6210;&#x5168;&#x5C40;&#x5E73;&#x8861;&#x4E8C;&#x53C9;&#x6811;&#x5373;&#x53EF;&#xFF0C;&#x590D;&#x6742;&#x5EA6; O(nlog&#x2061;2n)O(n\\log^2 n)O(nlog2n) &#x7136;&#x540E;&#x6211;&#x548C;cyk&#x4E24;&#x4E2A;&#x4EBA;&#x4E00;&#x8D77;&#x5361;&#x5E38;&#x6570;&#x5361;&#x4E86;&#x4E00;&#x4E0B;&#x5348;&#x6CA1;&#x5361;&#x8FC7;&#x53BB;&#xFF0C;&#x53EA;&#x80FD; 96pts96pts96pts &#x6EDA;&#x4E86;&#xFF0C;&#x63D0;&#x51FA;&#x8FD9;&#x4E2A;&#x7B97;&#x6CD5;&#x7684;&#x7528;&#x6237;hychyc&#x7684;ac&#x4EE3;&#x7801;&#x8C8C;&#x4F3C;&#x653E;&#x5BBD;&#x4E86;&#x65F6;&#x9650;&#x624D;&#x8FC7;&#x6389;&#x4E86;&#x6700;&#x540E;&#x4E00;&#x4E2A;&#x70B9;&#xFF0C;&#x6211;&#x672C;&#x5730;&#x6D4B;&#x4E86;&#x4E00;&#x4E0B;&#x4ED6;&#x6700;&#x540E;&#x4E00;&#x4E2A;&#x70B9;&#x6BD4;&#x6211;&#x6162;7s &#x7559;&#x4E2A;&#x94FE;&#x5206;&#x6CBB;&#x7684;&#x5751;&#x4EE5;&#x540E;&#x6765;&#x586B;&#x5427; 96ptsCODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly;inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline ll readl(){ ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s){ int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;}namespace modular{ const int mod=998244353; inline int add(int a,int b){return (a+=b)&lt;mod?a:a-mod;} inline void Add(int&amp;a,int b){a=add(a,b);} inline int dec(int a,int b){return (a-=b)&lt;0?a+mod:a;} inline void Dec(int&amp;a,int b){a=dec(a,b);} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;}}using namespace modular;const int N=2e5+5;int n,m,dist[N];vector&lt;pii&gt;e[N];int siz[N],dep[N],dis[N],fa[N],top[N],bot[N],num[N],hson[N],pred[N],tot=0;void dfs1(int p){ siz[p]=1; for(ri i=0,v;i&lt;(int)e[p].size();++i){ v=e[p][i].fi,fa[v]=p; dis[v]=dis[p]+e[p][i].se; dep[v]=dep[p]+1,dfs1(v); siz[p]+=siz[v]; if(siz[v]&gt;siz[hson[p]])hson[p]=v; }}void dfs2(int p,int tp){ top[p]=tp,pred[num[p]=++tot]=p; if(!hson[p]){ bot[p]=p; return; } dfs2(hson[p],tp),bot[p]=bot[hson[p]]; for(ri i=0,v;i&lt;(int)e[p].size();++i){ if((v=e[p][i].fi)==hson[p])continue; dfs2(v,v); }}const int inf=1e9;struct Set{ priority_queue&lt;ll&gt;a,b; inline void ins(int x){a.push(x);} inline void del(int x){b.push(x);} inline void pop(){while(b.size()&amp;&amp;a.top()==b.top())a.pop(),b.pop();a.pop();} inline int size()const{return a.size()-b.size();} inline int top(){while(b.size()&amp;&amp;a.top()==b.top())a.pop(),b.pop();return a.top();}}S[N];namespace sgt{ #define lc (p&lt;&lt;1) #define rc (p&lt;&lt;1|1) #define mid (l+r&gt;&gt;1) int M; pii mx[1&lt;&lt;20|5]; inline void build(int n){ for(M=1;M&lt;=n+1;M&lt;&lt;=1); for(ri i=1;i&lt;=M*2-1;++i)mx[i]=pii(-inf,-inf); for(ri i=1;i&lt;=n;++i)mx[i+M]=pii(-inf,pred[i]); for(ri p=M-1;p;--p)mx[p]=max(mx[lc],mx[rc]); cerr&lt;&lt;mx[1].fi&lt;&lt;&apos; &apos;&lt;&lt;mx[1].se&lt;&lt;&apos;\\n&apos;; } inline void update(int p,int vl){ mx[p+=M].fi=vl; for(p&gt;&gt;=1;p;p&gt;&gt;=1)mx[p]=max(mx[lc],mx[rc]); } inline pii query(int l,int r){ pii res=mx[l+M]; for(l+=M-1,r+=M+1;l^r^1;l&gt;&gt;=1,r&gt;&gt;=1){ if(l&amp;1^1)res=max(res,mx[l^1]); if(r&amp;1)res=max(res,mx[r^1]); } if(!res.se){ cerr&lt;&lt;res.fi&lt;&lt;&apos;\\n&apos;; } return res; } #undef lc #undef rc #undef mid}//namespace sgt{// #define lc (p&lt;&lt;1)// #define rc (p&lt;&lt;1|1)// #define mid (l+r&gt;&gt;1)// pli mx[N&lt;&lt;2];// inline void build(int p,int l,int r){// if(l==r){// mx[p]=pli(-inf,pred[l]);// return;// }// build(lc,l,mid),build(rc,mid+1,r);// mx[p]=max(mx[lc],mx[rc]);// }// inline void update(int p,int l,int r,int k,ll vl){// if(l==r){// mx[p].fi=vl;// return;// }// k&lt;=mid?update(lc,l,mid,k,vl):update(rc,mid+1,r,k,vl);// mx[p]=max(mx[lc],mx[rc]);// }// inline pli query(int p,int l,int r,int ql,int qr){// if(ql&lt;=l&amp;&amp;r&lt;=qr)return mx[p];// if(qr&lt;=mid)return query(lc,l,mid,ql,qr);// if(ql&gt;mid)return query(rc,mid+1,r,ql,qr);// return max(query(lc,l,mid,ql,qr),query(rc,mid+1,r,ql,qr));// }// #undef lc// #undef rc// #undef mid//}inline pii operator+(pii a,pii b){ if(a.fi!=b.fi)return min(a,b); return dep[a.se]&gt;dep[b.se]?a:b;}namespace bst{ #define lc (son[p][0]) #define rc (son[p][1]) int ft[N],tg[N&lt;&lt;2],son[N][2]; pii vl[N&lt;&lt;2],mn[N&lt;&lt;2]; inline void pushup(int p){ if(lc&amp;&amp;rc)mn[p]=mn[lc]+vl[p]+mn[rc]; else if(lc)mn[p]=mn[lc]+vl[p]; else if(rc)mn[p]=vl[p]+mn[rc]; else mn[p]=vl[p]; } inline bool isroot(int x){return !ft[x]||(son[ft[x]][0]!=x&amp;&amp;son[ft[x]][1]!=x);} inline void pushnow(int x,int v){vl[x].fi+=v,mn[x].fi+=v,tg[x]+=v;} inline void pushdown(int p){ if(tg[p]){ if(lc)pushnow(lc,tg[p]); if(rc)pushnow(rc,tg[p]); tg[p]=0; } } inline int build(int l,int r,int dt=0){ if(l&gt;r)return 0; if(l==r)return pred[l]; for(ri p,i=r;i&gt;=l;--i){ if(siz[pred[i]]*2&gt;=siz[pred[l]]+dt){ p=pred[i]; lc=build(l,i-1,siz[p]); rc=build(i+1,r,dt); ft[lc]=ft[rc]=p; pushup(p); return p; } } } inline int build(int p){ for(ri x=p;x;x=hson[x]){ vl[x]=mn[x]=pii(0,x); for(ri i=0,v;i&lt;(int)e[x].size();++i) if((v=e[x][i].fi)!=hson[x])ft[build(v)]=x; } return build(num[p],num[bot[p]]); } int Stk[N],Tp; inline void update(int p,int v){ while(p){ Stk[Tp=1]=p; for(ri x=p;!isroot(x);x=ft[x])Stk[++Tp]=ft[x]; while(Tp)pushdown(Stk[Tp--]); vl[p].fi+=v; if(lc)pushnow(lc,v); pushup(p); while(!isroot(p)){ if(son[ft[p]][1]==p){ vl[ft[p]].fi+=v; if(son[ft[p]][0])pushnow(son[ft[p]][0],v); } p=ft[p]; pushup(p); } p=ft[p]; } } inline pii query(int p){ pii res=pii(inf,0); while(p){ Stk[Tp=1]=p; for(ri x=p;!isroot(x);x=ft[x])Stk[++Tp]=ft[x]; while(Tp)pushdown(Stk[Tp--]); res=res+vl[p]; if(lc)res=res+mn[lc]; while(!isroot(p)){ if(son[ft[p]][1]==p){ res=res+vl[ft[p]]; if(son[ft[p]][0])res=res+mn[son[ft[p]][0]]; } p=ft[p]; } p=ft[p]; } return res; } int Dep[N]; inline int querydep(int x){ if(!ft[x])return Dep[x]=1; if(Dep[x])return Dep[x]; return Dep[x]=querydep(ft[x])+1; } #undef lc #undef rc}int rt,suf[N];struct Qry{int op,id,vl;}qry[N];bool vs[N];#define lc (p&lt;&lt;1)#define rc (p&lt;&lt;1|1)#define mid (l+r&gt;&gt;1)vector&lt;pii&gt;upd[N&lt;&lt;2];inline void update(int p,int l,int r,int ql,int qr,pii v){ if(ql&lt;=l&amp;&amp;r&lt;=qr)return upd[p].pb(v); if(qr&lt;=mid)update(lc,l,mid,ql,qr,v); else if(ql&gt;mid)update(rc,mid+1,r,ql,qr,v); else update(lc,l,mid,ql,qr,v),update(rc,mid+1,r,ql,qr,v);}ll ss=0,curss;struct node{ int op,id,vl; node(){op=id=vl=0;} node(int op,int id,ll vl):op(op),id(id),vl(vl){}};vector&lt;node&gt;stk;inline void change(pii F){ pii tp=bst::query(F.se); int p=tp.fi&gt;0?rt:tp.se; //pli tp=sgt::query(1,1,n,num[p],num[p]+siz[p]-1); tp=sgt::query(num[p],num[p]+siz[p]-1); if(tp.fi+F.fi&lt;=0)return; ss+=tp.fi+F.fi; S[F.se].ins(-F.fi); //sgt::update(1,1,n,num[F.se],S[F.se].top()); sgt::update(num[F.se],S[F.se].top()); bst::update(F.se,-1); stk.pb(node(1,F.se,-F.fi)); stk.pb(node(3,F.se,1)); S[tp.se].del(tp.fi); //sgt::update(1,1,n,num[tp.se],S[tp.se].top()); sgt::update(num[tp.se],S[tp.se].top()); bst::update(tp.se,1); stk.pb(node(2,tp.se,tp.fi)); stk.pb(node(3,tp.se,-1));}inline void Pop(){ node t=stk.back(); stk.pop_back(); if(t.op==1){ S[t.id].del(t.vl); //sgt::update(1,1,n,num[t.id],S[t.id].top()); sgt::update(num[t.id],S[t.id].top()); } if(t.op==2){ S[t.id].ins(t.vl); //sgt::update(1,1,n,num[t.id],S[t.id].top()); sgt::update(num[t.id],S[t.id].top()); } if(t.op==3)bst::update(t.id,t.vl);}inline void solve(int p,int l,int r){ int sz=stk.size(); ll curss=ss; for(ri i=(int)upd[p].size()-1;~i;--i)change(upd[p][i]); if(l==r)cout&lt;&lt;ss-(ll)suf[l]*inf&lt;&lt;&apos;\\n&apos;; else solve(lc,l,mid),solve(rc,mid+1,r); while(stk.size()!=sz)Pop(); ss=curss;}#undef lc#undef rc#undef midsigned main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); freopen(&quot;std.out&quot;,&quot;w&quot;,stdout); #endif int tt=clock(); n=read(),m=read(); for(ri i=1,u,v,w;i&lt;n;++i){ u=read(),v=read(),w=read(); vs[v]=1; e[u].pb(pii(v,w)); } for(ri i=1;i&lt;=n;++i)if(!vs[i]){ rt=i; break; } for(ri i=1;i&lt;=m;++i){ qry[i].op=read(); qry[i].id=read(); qry[i].vl=read(); if(qry[i].op==2){ ++n; e[qry[i].id].pb(pii(n,0)); qry[i].id=n; } } for(ri i=1;i&lt;=n;++i)S[i].ins(-inf); dep[rt]=1; dfs1(rt); dfs2(rt,rt); //sgt::build(1,1,n); sgt::build(n); bst::build(rt); int mxdep=0; for(ri i=1;i&lt;=n;++i)mxdep=max(mxdep,bst::querydep(i)); for(ri i=1;i&lt;=m;++i){ if(qry[i].op==1){ qry[i].vl-=dis[qry[i].id]; update(1,1,m,i,m,pii(qry[i].vl,qry[i].id)); } else{ qry[i].vl+=dis[qry[i].id]; if(i!=1)update(1,1,m,1,i-1,pii(inf-qry[i].vl,qry[i].id)); S[qry[i].id].ins(qry[i].vl); //sgt::update(1,1,n,num[qry[i].id],S[qry[i].id].top()); sgt::update(num[qry[i].id],S[qry[i].id].top()); } } suf[m]=0; for(ri i=m-1;i;--i)suf[i]=suf[i+1]+(qry[i+1].op==2); solve(1,1,m); return 0;} C &#x4E00;&#x4E2A;&#x6BD4;&#x8F83;&#x5957;&#x8DEF;&#x5316;&#x7684;&#x5BB9;&#x65A5;&#xFF0C;&#x57FA;&#x672C;&#x4E0A;&#x8DDF; PEPEPE &#x7684; permuted&#xA0;matricespermuted\\ matricespermuted&#xA0;matrices &#x662F;&#x4E00;&#x6837;&#x7684;&#xFF0C;&#x5C31;&#x4E0D;&#x7EC6;&#x8BB2;&#x4E86; &#x7136;&#x540E;&#x8981;&#x52A0;&#x4E0A;&#x4E00;&#x4E2A;&#x5206;&#x6CBB; nttnttntt CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly;inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(int*s){ int top=0; char ch=gc(); while(ch!=&apos;&lt;&apos;&amp;&amp;ch!=&apos;&gt;&apos;)ch=gc(); while(ch==&apos;&lt;&apos;||ch==&apos;&gt;&apos;)s[++top]=ch==&apos;&gt;&apos;,ch=gc(); return top;}namespace modular{ const int mod=998244353; inline int add(int a,int b){return (a+=b)&lt;mod?a:a-mod;} inline void Add(int&amp;a,int b){a=add(a,b);} inline int dec(int a,int b){return (a-=b)&lt;0?a+mod:a;} inline void Dec(int&amp;a,int b){a=dec(a,b);} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;}}using namespace modular;int lim,tim,w[22],invv[22];vector&lt;int&gt;rev[22];inline void init_ntt(){ invv[0]=1; for(ri iv=mod+1&gt;&gt;1,i=1;i&lt;22;++i)invv[i]=mul(invv[i-1],iv); w[21]=ksm(3,(mod-1)&gt;&gt;22); for(ri i=20;~i;--i)w[i]=mul(w[i+1],w[i+1]);}inline void init(const int&amp;up){ lim=1,tim=0; while(lim&lt;up)lim&lt;&lt;=1,++tim; if(rev[tim].size())return; rev[tim].resize(lim); for(ri i=1;i&lt;lim;++i)rev[tim][i]=(rev[tim][i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(tim-1));}inline void ntt(poly&amp;a,int typ){ for(ri i=0;i&lt;lim;++i)if(i&lt;rev[tim][i])swap(a[i],a[rev[tim][i]]); for(ri i=1,t=0,a0,a1;i&lt;lim;i&lt;&lt;=1,++t)for(ri j=0,len=i&lt;&lt;1;j&lt;lim;j+=len) for(ri k=0,mt=1;k&lt;i;++k,Mul(mt,w[t]))a0=a[j+k],a1=mul(mt,a[j+k+i]),a[j+k]=add(a0,a1),a[j+k+i]=dec(a0,a1); if(~typ)return; reverse(++a.begin(),a.end()); for(ri i=0;i&lt;lim;++i)Mul(a[i],invv[tim]);}inline poly operator*(poly a,poly b){ int n=a.size(),m=b.size(),t=n+m-1; if(t&lt;=64){ poly c(t); for(ri i=0;i&lt;n;++i)for(ri j=0;j&lt;m;++j)Add(c[i+j],mul(a[i],b[j])); return c; } init(t); a.resize(lim),ntt(a,1); b.resize(lim),ntt(b,1); for(ri i=0;i&lt;lim;++i)Mul(a[i],b[i]); return ntt(a,-1),a.resize(t),a;}poly f,g;const int N=1e5+5;int s[N];int n,cnt[N],fac[N],ifac[N];inline void init(){ fac[0]=fac[1]=ifac[0]=ifac[1]=1; for(ri i=2;i&lt;=n;++i){ fac[i]=mul(fac[i-1],i); ifac[i]=mul(ifac[mod-mod/i*i],mod-mod/i); } for(ri i=2;i&lt;=n;++i)Mul(ifac[i],ifac[i-1]); ifac[0]=0;}inline void solve(int l,int r){ if(l==r)return; int mid=l+r&gt;&gt;1; solve(l,mid); poly a(mid-l+1),b(r-l+1); for(ri i=l;i&lt;=mid;++i)a[i-l]=mul(f[i],mul(s[i],cnt[i])); b.resize(r-l+1); for(ri i=0;i&lt;=r-l;++i)b[i]=ifac[i]; a=a*b; for(ri i=mid+1;i&lt;=r;++i)Add(f[i],mul(a[i-l],cnt[i-1])); solve(mid+1,r);}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif init_ntt(); n=Read(s)+1; f.resize(n+1); init(); s[0]=1,cnt[0]=0; f[0]=1; for(ri i=1;i&lt;=n;++i)cnt[i]=cnt[i-1]+s[i]; for(ri i=0;i&lt;=n;++i)cnt[i]=cnt[i]&amp;1?mod-1:1; solve(0,n); cout&lt;&lt;mul(f[n],fac[n]); return 0;} &#x544A;&#x8F9E;","categories":[{"name":"public","slug":"public","permalink":"http://xdl030112.github.io/categories/public/"}],"tags":[{"name":"比赛题解","slug":"比赛题解","permalink":"http://xdl030112.github.io/tags/%E6%AF%94%E8%B5%9B%E9%A2%98%E8%A7%A3/"}]},{"title":"CodeForces 1228 简要题解","slug":"CF1228","date":"2019-10-12T15:45:41.000Z","updated":"2019-10-22T23:48:26.300Z","comments":true,"path":"CF1228/","link":"","permalink":"http://xdl030112.github.io/CF1228/","excerpt":"","text":"A &#x6A21;&#x62DF; CODE cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly;inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline ll readl(){ ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}namespace modular{ const int mod=1e9+7; inline int add(int a,int b){return (a+=b)&lt;mod?a:a-mod;} inline void Add(int&amp;a,int b){a=add(a,b);} inline int dec(int a,int b){return (a-=b)&lt;0?a+mod:a;} inline void Dec(int&amp;a,int b){a=dec(a,b);} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;}}using namespace modular;int l,r;inline bool check(int x){ int cnt[15]; for(ri i=0;i&lt;10;++i)cnt[i]=0; while(x)++cnt[x%10],x/=10; for(ri i=0;i&lt;10;++i)if(cnt[i]&gt;1)return 0; return 1;}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif l=read(),r=read(); for(ri i=l;i&lt;=r;++i){ if(check(i))return cout&lt;&lt;i,0; } puts(&quot;-1&quot;); return 0;} B &#x6A21;&#x62DF; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly;inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}namespace modular{ const int mod=1e9+7; inline int add(int a,int b){return (a+=b)&lt;mod?a:a-mod;} inline void Add(int&amp;a,int b){a=add(a,b);} inline int dec(int a,int b){return (a-=b)&lt;0?a+mod:a;} inline void Dec(int&amp;a,int b){a=dec(a,b);} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;}}using namespace modular;const int N=1005;int n,m,f[N][N],a[N],b[N];int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(),m=read(); for(ri i=1;i&lt;=n;++i)a[i]=read(); for(ri i=1;i&lt;=m;++i)b[i]=read(); int res=1; for(ri i=1;i&lt;=n;++i){ for(ri j=1;j&lt;=m;++j){ if(a[i]&gt;=j&amp;&amp;b[j]+1==i)return puts(&quot;0&quot;),0; if(a[i]+1==j&amp;&amp;b[j]&gt;=i)return puts(&quot;0&quot;),0; if(b[j]+1==i||a[i]+1==j||a[i]&gt;=j||b[j]&gt;=i)continue; res=add(res,res); } } cout&lt;&lt;res; return 0;} C &#x5206;&#x89E3;&#x8D28;&#x56E0;&#x6570; CODE cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly;inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline ll readl(){ ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}namespace modular{ const int mod=1e9+7; inline int add(int a,int b){return (a+=b)&lt;mod?a:a-mod;} inline void Add(int&amp;a,int b){a=add(a,b);} inline int dec(int a,int b){return (a-=b)&lt;0?a+mod:a;} inline void Dec(int&amp;a,int b){a=dec(a,b);} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;}}using namespace modular;int x;ll n;vector&lt;int&gt;divv;inline void divid(int x){ for(ri i=2,lm=sqrt(x);i&lt;=lm&amp;&amp;x!=1;++i){ if(x!=x/i*i)continue; divv.pb(i); while(x==x/i*i)x/=i; } if(x^1)divv.pb(x);}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif x=read(); n=readl(); divid(x); int res=1; for(ri i=divv.size()-1;~i;--i){ ll mt=divv[i]; while(1){ int tot=(n/mt-n/mt/divv[i])%(mod-1); Mul(res,ksm((ll)mt%mod,tot)); if(!(n/mt/divv[i]))break; mt*=divv[i]; } } cout&lt;&lt;res; return 0;} D &#x666E;&#x53CA;-&#x9898;&#x4E3A;&#x5565;&#x4E0D;&#x653E; AAA &#x554A;&#xFF1F;&#xFF1F;&#xFF1F; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly;inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}namespace modular{ const int mod=1e9+7; inline int add(int a,int b){return (a+=b)&lt;mod?a:a-mod;} inline void Add(int&amp;a,int b){a=add(a,b);} inline int dec(int a,int b){return (a-=b)&lt;0?a+mod:a;} inline void Dec(int&amp;a,int b){a=dec(a,b);} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;}}using namespace modular;const int N=3e5+5;int n,m,col[N];vector&lt;int&gt;e[N],tp[4];bool vs[N];int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(),m=read(); for(ri i=1;i&lt;=n;++i)col[i]=-1; for(ri u,v,i=1;i&lt;=m;++i){ u=read(),v=read(); e[u].pb(v); e[v].pb(u); } for(ri i=0;i&lt;e[1].size();++i)vs[e[1][i]]=1; for(ri i=1;i&lt;=n;++i)if(!vs[i])tp[1].pb(i),col[i]=1; int ps=-1; for(ri i=1;i&lt;=n;++i){ if(vs[i]){ ps=i; break; } } if(ps==-1)return puts(&quot;-1&quot;),0; for(ri i=0;i&lt;e[ps].size();++i)if(vs[e[ps][i]])tp[3].pb(e[ps][i]),col[e[ps][i]]=3; for(ri i=1;i&lt;=n;++i)if(col[i]==-1)col[i]=2,tp[2].pb(i); if(!tp[2].size()||!tp[3].size())return puts(&quot;-1&quot;),0; if((ll)tp[1].size()*tp[2].size()+(ll)tp[2].size()*tp[3].size()+(ll)tp[3].size()*tp[1].size()!=m)return puts(&quot;-1&quot;),0; for(ri i=1;i&lt;=n;++i)for(ri j=0;j&lt;e[i].size();++j)if(col[i]==col[e[i][j]])return puts(&quot;-1&quot;),0; for(ri i=1;i&lt;=n;++i)cout&lt;&lt;col[i]&lt;&lt;&apos; &apos;; return 0;} E &#x7B80;&#x5355;&#x5BB9;&#x65A5;&#x5373;&#x53EF; O(n2)O(n^2)O(n2) &#xFF0C;&#x628A;&#x5F0F;&#x5B50;&#x62C6;&#x5F00;&#x4E5F;&#x53EF;&#x4EE5;&#x505A;&#x5230; O(nlog&#x2061;n)O(n\\log n)O(nlogn) CODE cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly;inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}namespace modular{ const int mod=1e9+7; inline int add(int a,int b){return (a+=b)&lt;mod?a:a-mod;} inline void Add(int&amp;a,int b){a=add(a,b);} inline int dec(int a,int b){return (a-=b)&lt;0?a+mod:a;} inline void Dec(int&amp;a,int b){a=dec(a,b);} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;}}using namespace modular;const int N=255*255;int n,K,fac[N],ifac[N],pw1[N],pw2[N];inline void init(){ fac[0]=fac[1]=ifac[0]=ifac[1]=1,pw1[0]=pw2[0]=1,pw1[1]=K,pw2[1]=K-1; for(ri i=2;i&lt;=n*n;++i){ fac[i]=mul(fac[i-1],i); ifac[i]=mul(ifac[mod-mod/i*i],mod-mod/i); pw1[i]=mul(pw1[i-1],K); pw2[i]=mul(pw2[i-1],K-1); } for(ri i=2;i&lt;=n*n;++i)Mul(ifac[i],ifac[i-1]);}inline int C(int n,int m){return mul(fac[n],mul(ifac[m],ifac[n-m]));} int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(),K=read(); init(); int res=0; for(ri t,x,i=0;i&lt;=n;++i)for(ri j=0;j&lt;=n;++j){ t=mul(pw1[(n-i)*(n-j)],pw2[n*n-(n-i)*(n-j)]); Mul(t,mul(C(n,i),C(n,j))); (i+j)&amp;1?Dec(res,t):Add(res,t); } cout&lt;&lt;res&lt;&lt;&apos;\\n&apos;; return 0;} F &#x5927;&#x5206;&#x7C7B;&#x8BA8;&#x8BBA;&#xFF0C;&#x4E0D;&#x77E5;&#x9053;&#x4E3A;&#x5565;&#x6211;&#x5199;&#x7684;&#x90A3;&#x4E48;&#x9EBB;&#x70E6;=.=&#xFF0C;&#x770B;&#x522B;&#x4EBA;&#x8BA8;&#x8BBA;&#x7684;&#x597D;&#x50CF;&#x5F88;&#x7B80;&#x5355;&#xFF0C;&#x76F4;&#x63A5;&#x53BB;&#x4E16;&#x4E86; &#x6211;&#x7684;&#x8BA8;&#x8BBA;&#xFF1A; &#x81EA;&#x5DF1;&#x662F;&#x53F6;&#x5B50; &#x7236;&#x4EB2;&#x662F;&#x6839; &#x81EA;&#x5DF1;&#x4E0D;&#x662F;&#x53F6;&#x5B50;&#x4E14;&#x7236;&#x4EB2;&#x4E0D;&#x662F;&#x6839; &#x4EE3;&#x7801;&#x4E11;&#x6B7B;&#x4E86; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly;inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline ll readl(){ ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}namespace modular{ const int mod=1e9+7; inline int add(int a,int b){return (a+=b)&lt;mod?a:a-mod;} inline void Add(int&amp;a,int b){a=add(a,b);} inline int dec(int a,int b){return (a-=b)&lt;0?a+mod:a;} inline void Dec(int&amp;a,int b){a=dec(a,b);} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;}}using namespace modular;const int N=1&lt;&lt;18|5;int n,m,siz[N],Fa[N];vector&lt;int&gt;e[N],RT;#define fail puts(&quot;0&quot;),exit(0)void dfs(int p,int ft){ siz[p]=1; for(ri i=0,v;i&lt;e[p].size();++i){ if((v=e[p][i])==ft)continue; Fa[v]=p; dfs(v,p); siz[p]+=siz[v]; } if(siz[p]*2==n)RT.pb(p),RT.pb(ft);}int ban,ad[N];bool check(int p,int ft){ if(siz[p]==1)return 1; if(p==ban){ vector&lt;pii&gt;tp; for(ri i=0,v;i&lt;e[p].size();++i){ if((v=e[p][i])==ft)continue; tp.pb(pii(siz[v],v)); } sort(tp.begin(),tp.end()); if(tp[0].fi!=tp[1].fi)fail; if(tp[0].fi+tp[1].fi+1!=tp[2].fi)fail; return check(tp[0].se,p)&amp;&amp;check(tp[1].se,p)&amp;&amp;check(tp[2].se,p); } else{ int son1=0,son2=0; for(ri i=0,v;i&lt;e[p].size();++i){ if((v=e[p][i])==ft)continue; if(!son1)son1=v; else son2=v; } if(!son2)return 0; if(siz[son1]+ad[son1]!=siz[son2]+ad[son2])return 0; return check(son1,p)&amp;&amp;check(son2,p); }}bool checkk(int p,int ft){ if(siz[p]==1)return 1; if(p==ban){ vector&lt;pii&gt;tp; for(ri i=0,v;i&lt;e[p].size();++i){ if((v=e[p][i])==ft)continue; tp.pb(pii(siz[v],v)); } return tp[0].fi==1; } else{ int son1=0,son2=0; for(ri i=0,v;i&lt;e[p].size();++i){ if((v=e[p][i])==ft)continue; if(!son1)son1=v; else son2=v; } if(!son2)return 0; if(siz[son1]+ad[son1]!=siz[son2]+ad[son2])return 0; return checkk(son1,p)&amp;&amp;checkk(son2,p); }}void dfss(int p,int ft){ siz[p]=1; int son1=0,son2=0; for(ri i=0,v;i&lt;e[p].size();++i){ if((v=e[p][i])==ft)continue; if(!son1)son1=v; else son2=v; dfss(v,p),siz[p]+=siz[v]; } if(siz[son1]!=siz[son2])fail;}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif m=read(),n=(1&lt;&lt;m)-2; if(n==2)return cout&lt;&lt;2&lt;&lt;&apos;\\n&apos;&lt;&lt;1&lt;&lt;&apos; &apos;&lt;&lt;2,0; for(ri i=1,u,v;i&lt;n;++i){ u=read(),v=read(); e[u].pb(v); e[v].pb(u); } int ct1=0,ct2=0,ct3=0; for(ri i=1;i&lt;=n;++i){ if(e[i].size()&gt;4)fail; if(e[i].size()==4)++ct1; if(e[i].size()==2)++ct2; if(e[i].size()==3)++ct3; } if(ct1&gt;1)fail; if(ct1==1){ if(ct2!=1)fail; int ps; for(ps=1;ps&lt;=n;++ps)if(e[ps].size()==2)break; for(ri i=1;i&lt;=n;++i)if(e[i].size()==4)ban=i; dfs(ps,0); int tp=ban; while(tp!=ps){ ad[tp]=1; tp=Fa[tp]; } if(!check(ps,0))fail; cout&lt;&lt;1&lt;&lt;&apos;\\n&apos;; cout&lt;&lt;ban; return 0; } if(ct2&amp;&amp;ct2!=2)fail; if(ct2==2){ int a=0,b=0; for(ri i=1;i&lt;=n;++i)if(e[i].size()==2){ if(!a)a=i; else b=i; } dfs(a,0); ban=b; while(ban!=a){ ad[ban]=1; ban=Fa[ban]; } ban=b; if(checkk(a,0))return cout&lt;&lt;1&lt;&lt;&apos;\\n&apos;&lt;&lt;ban,0; while(ban!=a){ ad[ban]=0; ban=Fa[ban]; } dfs(b,0); ban=a; while(ban!=b){ ad[ban]=1; ban=Fa[ban]; } ban=a; if(checkk(b,0))return cout&lt;&lt;1&lt;&lt;&apos;\\n&apos;&lt;&lt;ban,0; fail; } if(!ct3)fail; dfs(1,0); if(RT.size()!=2)fail; dfss(RT[0],RT[1]),dfss(RT[1],RT[0]); cout&lt;&lt;2&lt;&lt;&apos;\\n&apos;; cout&lt;&lt;min(RT[0],RT[1])&lt;&lt;&apos; &apos;&lt;&lt;max(RT[0],RT[1]); return 0;}","categories":[{"name":"public","slug":"public","permalink":"http://xdl030112.github.io/categories/public/"}],"tags":[{"name":"比赛题解","slug":"比赛题解","permalink":"http://xdl030112.github.io/tags/%E6%AF%94%E8%B5%9B%E9%A2%98%E8%A7%A3/"}]},{"title":"CodeForces 1101 简要题解","slug":"CF1101","date":"2019-10-12T15:31:54.000Z","updated":"2019-10-22T23:48:07.686Z","comments":true,"path":"CF1101/","link":"","permalink":"http://xdl030112.github.io/CF1101/","excerpt":"","text":"A &#x6309;&#x7167;&#x9898;&#x610F;&#x6A21;&#x62DF; CODE cpp1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;const int N=105;int mod,n,m,k;inline int add(int a,int b){return (a+=b)&lt;mod?a:a-mod;}inline void Add(int&amp;a,int b){a=add(a,b);}inline int dec(int a,int b){return (a-=b)&lt;0?a+mod:a;}inline void Dec(int&amp;a,int b){a=dec(a,b);}inline int mul(int a,int b){return (ll)a*b%mod;}inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;}inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;}inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif for(ri l,r,d,tt=read();tt;--tt){ l=read(),r=read(),d=read(); if(l&gt;d)cout&lt;&lt;d&lt;&lt;&apos;\\n&apos;; else cout&lt;&lt;((r/d+1)*d)&lt;&lt;&apos;\\n&apos;; } return 0;} B &#x4ECE;&#x4E24;&#x8FB9;&#x5F00;&#x59CB;&#x5404;&#x626B;&#x4E00;&#x904D;&#x5373;&#x53EF; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;const int N=105;int mod,n,m,k;inline int add(int a,int b){return (a+=b)&lt;mod?a:a-mod;}inline void Add(int&amp;a,int b){a=add(a,b);}inline int dec(int a,int b){return (a-=b)&lt;0?a+mod:a;}inline void Dec(int&amp;a,int b){a=dec(a,b);}inline int mul(int a,int b){return (ll)a*b%mod;}inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;}inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;}inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}char s[500005];int len;int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif scanf(&quot;%s&quot;,s+1); len=strlen(s+1); int ps1=-1,ps2=-1,ps3=-1,ps4=-1; for(ri i=1;i&lt;=len;++i){ if(s[i]==&apos;[&apos;&amp;&amp;ps1==-1){ ps1=i; } if(s[i]==&apos;:&apos;&amp;&amp;ps1!=-1){ ps2=i; break; } } for(ri i=len;i;--i){ if(s[i]==&apos;]&apos;&amp;&amp;ps3==-1){ ps3=i; } if(s[i]==&apos;:&apos;&amp;&amp;ps3!=-1){ ps4=i; break; } } if(ps1==-1||ps2==-1||ps3==-1||ps4==-1||ps2&gt;=ps4)return cout&lt;&lt;-1,0; int res=4; for(ri i=ps2+1;i&lt;ps4;++i)if(s[i]==&apos;|&apos;)++res; cout&lt;&lt;res; return 0;} C &#x7528;&#x4E2A;&#x6808;&#x6765;&#x6A21;&#x62DF;&#x8D2A;&#x5FC3;&#x5373;&#x53EF; CODE cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;int mod;inline int add(int a,int b){return (a+=b)&lt;mod?a:a-mod;}inline void Add(int&amp;a,int b){a=add(a,b);}inline int dec(int a,int b){return (a-=b)&lt;0?a+mod:a;}inline void Dec(int&amp;a,int b){a=dec(a,b);}inline int mul(int a,int b){return (ll)a*b%mod;}inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;}inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;}inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}const int N=2e5+5;int n;struct Node{ int l,r,id; friend inline bool operator&lt;(Node a,Node b){return a.r^b.r?a.r&lt;b.r:a.l&lt;b.l;}}a[N];int ans[N],vl[N&lt;&lt;1],sig;inline int find(int x){return lower_bound(vl+1,vl+sig+1,x)-vl;}pii stk[N];int top=0,tot=0;inline void insert(int l,int r){ ++tot; int idl=tot,idr=tot; while(top){ if(l&gt;a[stk[top].se].r)break; if(l&gt;=a[stk[top].fi].l){ stk[top].se=tot; return; } idl=stk[top].fi; --top; } stk[++top]=pii(idl,idr);}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif for(ri tt=read();tt;--tt){ n=read(); sig=0; for(ri i=1;i&lt;=n;++i)vl[++sig]=a[i].l=read(),vl[++sig]=a[i].r=read(); sort(vl+1,vl+sig+1); sig=unique(vl+1,vl+sig+1)-vl-1; for(ri i=1;i&lt;=n;++i)a[i].l=find(a[i].l),a[i].r=find(a[i].r),a[i].id=i; sort(a+1,a+n+1); top=tot=0; for(ri i=1;i&lt;=n;++i)insert(a[i].l,a[i].r); if(top==1){ cout&lt;&lt;-1; } else{ for(ri i=1;i&lt;=top;++i){ for(ri j=stk[i].fi;j&lt;=stk[i].se;++j){ ans[a[j].id]=2-(i&amp;1); } } for(ri i=1;i&lt;=n;++i)cout&lt;&lt;ans[i]&lt;&lt;&apos; &apos;; } puts(&quot;&quot;); } return 0;} D &#x4EE4;&#x8FB9;&#x6743;&#x7B49;&#x4E8E;&#x8FDE;&#x63A5;&#x4E24;&#x4E2A;&#x70B9;&#x7684; gcd&#x2061;(i,j)\\gcd(i,j)gcd(i,j) &#xFF0C;&#x7136;&#x540E;&#x53EF;&#x4EE5;&#x679A;&#x4E3E;&#x6BCF;&#x4E2A;&#x6570;&#x7684;&#x500D;&#x6570;&#x7136;&#x540E;&#x505A;&#x6811;&#x5F62; dpdpdp &#x6C42;&#x76F4;&#x5F84; CODE cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;int mod;inline int add(int a,int b){return (a+=b)&lt;mod?a:a-mod;}inline void Add(int&amp;a,int b){a=add(a,b);}inline int dec(int a,int b){return (a-=b)&lt;0?a+mod:a;}inline void Dec(int&amp;a,int b){a=dec(a,b);}inline int mul(int a,int b){return (ll)a*b%mod;}inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;}inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;}inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}const int N=2e5+5;int n,a[N],tim[N],timm[N];vector&lt;pii&gt;E[N];vector&lt;int&gt;e[N];int dist=0,len[N];void dfs(int p,int ft,int ct){ len[p]=1; timm[p]=ct; for(ri i=0,v;i&lt;e[p].size();++i){ if((v=e[p][i])==ft)continue; dfs(v,p,ct); dist=max(dist,len[p]+len[v]); len[p]=max(len[p],len[v]+1); }}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(); for(ri i=1;i&lt;=n;++i){ a[i]=read(); if(a[i]&gt;1){ dist=1; } } for(ri i=1,u,v;i&lt;n;++i){ u=read(),v=read(); E[__gcd(a[u],a[v])].pb(pii(u,v)); } for(ri i=2;i&lt;=200000;++i){ vector&lt;int&gt;t; for(ri j=i;j&lt;=200000;j+=i){ for(ri u,v,k=0;k&lt;E[j].size();++k){ u=E[j][k].fi,v=E[j][k].se; if(tim[u]!=i){ t.pb(u); tim[u]=i; e[u].clear(); } if(tim[v]!=i){ t.pb(v); tim[v]=i; e[v].clear(); } e[u].pb(v),e[v].pb(u); } } for(ri k=0;k&lt;t.size();++k){ if(timm[t[k]]!=i)dfs(t[k],0,i); } t.clear(); } cout&lt;&lt;dist; return 0;} E &#x666E;&#x53CA;-&#x9898;&#xFF0C;&#x4E3A;&#x5565;&#x4E0D;&#x653E; AAA &#x554A;&#xFF1F;&#xFF1F;&#xFF1F; &#x8BFB;&#x61C2;&#x9898;&#x610F;&#x5373;&#x53EF; CODE cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;int mod;inline int add(int a,int b){return (a+=b)&lt;mod?a:a-mod;}inline void Add(int&amp;a,int b){a=add(a,b);}inline int dec(int a,int b){return (a-=b)&lt;0?a+mod:a;}inline void Dec(int&amp;a,int b){a=dec(a,b);}inline int mul(int a,int b){return (ll)a*b%mod;}inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;}inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;}inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}const int N=5e5+5;int n;char op;int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(); int mx1=0,mx2=0; for(ri i=1;i&lt;=n;++i){ op=gc(); while(op!=&apos;+&apos;&amp;&amp;op!=&apos;?&apos;)op=gc(); if(op==&apos;+&apos;){ int a=read(),b=read(); if(a&gt;b)swap(a,b); mx1=max(mx1,a); mx2=max(mx2,b); } else{ int a=read(),b=read(); if(a&gt;b)swap(a,b); puts(a&gt;=mx1&amp;&amp;b&gt;=mx2?&quot;YES&quot;:&quot;NO&quot;); } } return 0;} F &#x8C8C;&#x4F3C;&#x6709;&#x533A;&#x95F4; dpdpdp +&#x5355;&#x8C03;&#x961F;&#x5217;&#x7684;&#x505A;&#x6CD5;&#xFF0C;&#x4F46;&#x6211;&#x76F4;&#x63A5;&#x968F;&#x673A;&#x5316;+&#x526A;&#x679D;+&#x4E8C;&#x5206;+&#x5355;&#x8C03;&#x961F;&#x5217;&#x8279;&#x8FC7;&#x4E86; CODE cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_backusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline ll readl(){ ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s){ int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch; return top;}namespace modular{ int mod; inline int add(int a,int b){return (a+=b)&lt;mod?a:a-mod;} inline int dec(int a,int b){return (a-=b)&lt;0?a+mod:a;} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Add(int&amp;a,int b){a=add(a,b);} inline void Dec(int&amp;a,int b){a=dec(a,b);} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;}}using namespace modular;const int N=405,M=250005;int n,m,ps[N],s,t,C,r,f[N];inline bool check(ll V){ static int q[N],hd,tl; f[s]=0; q[hd=tl=1]=s; for(ri coe,i=s+1;i&lt;=t;++i){ while(hd&lt;=tl&amp;&amp;(ll)(ps[i]-ps[q[hd]])*C&gt;V)++hd; coe=hd&gt;tl?1e9:f[q[hd]]; if(i==t)return coe&lt;=r; f[i]=coe+1; while(hd&lt;=tl&amp;&amp;f[q[tl]]&gt;=f[i])--tl; q[++tl]=i; }}struct Node{int a,b,c,d;}a[M];int main(){ srand(time(0)); #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(),m=read(); for(ri i=1;i&lt;=n;++i)ps[i]=read(); for(ri i=1;i&lt;=m;++i)a[i].a=read(),a[i].b=read(),a[i].c=read(),a[i].d=read(); random_shuffle(a+1,a+m+1); ll res=0; for(ri i=1;i&lt;=m;++i){ s=a[i].a,t=a[i].b,C=a[i].c,r=a[i].d; if(check(res))continue; ll l=res+1,r=1e18,ress=1e18; while(l&lt;=r){ ll mid=l+r&gt;&gt;1; if(check(mid))ress=mid,r=mid-1; else l=mid+1; } res=ress; } cout&lt;&lt;res; return 0;} G bzoj2460bzoj2460bzoj2460 &#x5F31;&#x5316;&#x7248;&#xFF0C;&#x76F4;&#x63A5;&#x6C42;&#x51FA;&#x524D;&#x7F00;&#x548C;&#x7136;&#x540E;&#x7EBF;&#x6027;&#x57FA;&#x5373;&#x53EF; CODE cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline ll readl(){ ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s){ int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;}namespace modular{ int mod=998244353; inline int add(int a,int b){return (a+=b)&lt;mod?a:a-mod;} inline void Add(int&amp;a,int b){a=add(a,b);} inline int dec(int a,int b){return (a-=b)&lt;0?a+mod:a;} inline void Dec(int&amp;a,int b){a=dec(a,b);} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;} };using namespace modular;const int N=2e5+5;int n,a[N],ok[N];int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(); for(ri i=1,x;i&lt;=n;++i){ a[i]=read()^a[i-1]; x=a[i]; for(ri j=31;~j;--j){ if(x&gt;&gt;j&amp;1){ if(ok[j])x^=ok[j]; else{ ok[j]=x; break; } if(!x)break; } } } if(!a[n])return puts(&quot;-1&quot;),0; int res=0; for(ri i=31;~i;--i)if(ok[i])++res; cout&lt;&lt;res; return 0;} &#x611F;&#x89C9;&#x4EE5;&#x540E;&#x8FD8;&#x662F;&#x5F97; vpvpvp div1div1div1 &#x573A; &#x544A;&#x8F9E;","categories":[{"name":"public","slug":"public","permalink":"http://xdl030112.github.io/categories/public/"}],"tags":[{"name":"比赛题解","slug":"比赛题解","permalink":"http://xdl030112.github.io/tags/%E6%AF%94%E8%B5%9B%E9%A2%98%E8%A7%A3/"}]},{"title":"AtCoder Grand Contest 039 简要题解","slug":"AGC039","date":"2019-10-10T03:43:21.000Z","updated":"2019-10-11T15:33:29.541Z","comments":true,"path":"AGC039/","link":"","permalink":"http://xdl030112.github.io/AGC039/","excerpt":"","text":"A &#x7B80;&#x5355;&#x5206;&#x7C7B;&#x8BA8;&#x8BBA;&#x5373;&#x53EF; CODE cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}typedef pair&lt;int,int&gt; pii;typedef long long ll;typedef unsigned long long Ull;inline int Read(char*s){ int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;}char s[105];int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif int len=Read(s),k=read(); if(s[1]!=s[len]){ int res=0; for(ri l=1,r;l&lt;=len;l=r+1){ r=l; while(r!=len&amp;&amp;s[r+1]==s[r])++r; res+=(r-l+1)/2; } cout&lt;&lt;(ll)res*k; return 0; } bool ff=1; for(ri i=2;i&lt;=len;++i)if(s[i]!=s[i-1]){ ff=0; break; } if(ff){ cout&lt;&lt;(ll)len*k/2; return 0; } int ct=2,ps1,ps2; for(ri i=2;i&lt;=len;++i){ if(s[i]==s[i-1])++ct; else{ ps1=i; break; } } for(ri i=len-1;i;--i){ if(s[i]==s[i+1])++ct; else{ ps2=i; break; } } int res=ct/2; for(ri l=ps1,r;l&lt;=ps2;l=r+1){ r=l; while(r!=ps2&amp;&amp;s[r+1]==s[r])++r; res+=(r-l+1)/2; } ll ans=(ll)res*(k-1); for(ri l=1,r;l&lt;=len;l=r+1){ r=l; while(r!=len&amp;&amp;s[r+1]==s[r])++r; ans+=(r-l+1)/2; } cout&lt;&lt;ans; return 0;} B &#x5148;&#x5224;&#x6389;&#x5947;&#x73AF;&#xFF0C;&#x7136;&#x540E;&#x679A;&#x4E3E;&#x6BCF;&#x4E2A;&#x70B9;&#x505A;&#x6839;&#x6C42; bfsbfsbfs &#x6811;&#x7684; mxdepmxdepmxdep &#x66F4;&#x65B0;&#x6700;&#x5927;&#x503C;&#x5373;&#x53EF; CODE cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_backusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}typedef pair&lt;int,int&gt; pii;typedef long long ll;typedef unsigned long long Ull;inline int Read(char*s){ int top=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))s[++top]=ch,ch=gc(); return top;}char s[205];int n,dep[205];bool vs[205];vector&lt;int&gt;e[205];void check(int p){ vs[p]=1; for(ri i=0,v;i&lt;e[p].size();++i){ if(vs[v=e[p][i]]){ if((dep[v]+dep[p])&amp;1)continue; puts(&quot;-1&quot;); exit(0); } dep[v]=dep[p]+1;check(v); }}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(); for(ri i=1;i&lt;=n;++i){ Read(s); for(ri j=1;j&lt;=n;++j)if(s[j]==&apos;1&apos;)e[i].pb(j); } check(1); int mx=0; for(ri s=1;s&lt;=n;++s){ memset(dep,0,sizeof(dep)); memset(vs,0,sizeof(vs)); queue&lt;int&gt;q; q.push(s),dep[s]=1; while(q.size()){ int x=q.front(); q.pop(); vs[x]=1; for(ri i=0,v;i&lt;e[x].size();++i){ if(vs[v=e[x][i]])continue; dep[v]=dep[x]+1; vs[v]=1; q.push(v); } } for(ri i=1;i&lt;=n;++i)mx=max(mx,dep[i]); } cout&lt;&lt;mx; return 0;} C &#x6A21;&#x62DF;&#x4E00;&#x4E0B;&#x4F1A;&#x53D1;&#x73B0;&#x6BCF;&#x6B21;&#x628A;&#x6700;&#x540E;&#x4E00;&#x4F4D;&#x5220;&#x6389;&#xFF0C;&#x7136;&#x540E;&#x5728;&#x7B2C;&#x4E00;&#x4F4D;&#x52A0;&#x4E0A;&#x76F8;&#x53CD;&#x7684;&#x6570;&#x5B57;&#xFF0C;&#x6253;&#x8868;&#x518D;&#x8BC1;&#x660E;&#x53EF;&#x4EE5;&#x53D1;&#x73B0;&#x6240;&#x6709;&#x975E; nnn &#x7684;&#x7EA6;&#x6570;&#x5B83;&#x4EEC;&#x7684;&#x8D21;&#x732E;&#x76F8;&#x540C;&#x90FD;&#x662F; 2n2n2n &#xFF0C;&#x5BF9;&#x4E8E; nnn &#x6EE1;&#x8DB3; n/xn/xn/x &#x4E3A;&#x5947;&#x6570;&#x7684;&#x7EA6;&#x6570; xxx &#x5176;&#x8D21;&#x732E;&#x4E3A; 2x2x2x &#x90A3;&#x4E48;&#x6211;&#x4EEC;&#x679A;&#x4E3E; xxx &#x7136;&#x540E;&#x8DDF;&#x5B83;&#x7684;&#x500D;&#x6570;&#x6216;&#x8005;&#x7EA6;&#x6570;&#x5BB9;&#x65A5;&#x5373;&#x53EF; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s){ int top=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))s[++top]=ch,ch=gc(); return top;}const int mod=998244353;inline int add(int a,int b){return (a+=b)&lt;mod?a:a-mod;}inline void Add(int&amp;a,int b){a=add(a,b);}inline int dec(int a,int b){return (a-=b)&lt;0?a+mod:a;}inline void Dec(int&amp;a,int b){a=dec(a,b);}inline int mul(int a,int b){return (ll)a*b%mod;}inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;}inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;}const int N=2e5+5;char s[N],t[N];int n;int pre[N],f[N];inline int solve(int len){ int res=pre[len]; for(ri i=1;i&lt;=len;++i)t[i]=s[i]; for(ri l=len+1,r=len&lt;&lt;1;l&lt;=n;l+=len,r+=len){ for(ri i=l;i&lt;=r;++i){ t[i]=t[i-len]^1; if(s[i]&gt;t[i])return res+1; if(s[i]&lt;t[i])return res; } } return res+1;}int pri[N],tot=0;bool vs[N];inline void init(){ for(ri i=2;i&lt;=n;++i){ if(!vs[i])pri[++tot]=i; for(ri j=1,up=n/i;j&lt;=tot&amp;&amp;pri[j]&lt;=up;++j){ vs[i*pri[j]]=1; if(i==i/pri[j]*pri[j])break; } }}int a[N],b[N],top;vector&lt;int&gt;divv;void dfs(int ps,int mt){ divv.pb(mt); for(ri mlt=a[ps],i=ps;i&lt;=top;++i,mlt=a[i])for(ri j=1;j&lt;=b[i];++j,mlt*=a[i])dfs(i+1,mt*mlt);}inline int calc(int lm){ int x=lm; top=0; for(ri i=1,up=sqrt(lm);i&lt;=tot&amp;&amp;pri[i]&lt;=up&amp;&amp;lm!=1;++i){ if(lm!=lm/pri[i]*pri[i])continue; ++top,a[top]=pri[i],b[top]=0; while(lm==lm/pri[i]*pri[i])lm/=pri[i],++b[top]; } if(lm^1)a[++top]=lm,b[top]=1; divv.clear(); dfs(1,1); int res=0; for(ri i=divv.size()-1;~i;--i)if(divv[i]!=1)if((n/(x/divv[i]))&amp;1)Add(res,f[x/divv[i]]); return res;}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(),Read(s); init(); int res=0; for(ri i=1;i&lt;=n;++i)pre[i]=add(add(pre[i-1],pre[i-1]),s[i]-&apos;0&apos;); res=add(pre[n],1); Mul(res,n*2); for(ri tp,i=1;i*3&lt;=n;++i){ if(n%i)continue; if(!((n/i)&amp;1))continue; f[i]=dec(solve(i),calc(i)); Dec(res,mul(2*(n-i),f[i])); } cout&lt;&lt;res; return 0;} D &#x4E3A;&#x5565;&#x662F;MO&#x9898;&#x554A;2333 &#x5BF9;&#x4E8E;&#x4E00;&#x4E2A; &#x394;ABC\\Delta ABC&#x394;ABC &#xFF0C;&#x4EE4; A&#x2032;A&apos;A&#x2032; &#x4E3A; BCBCBC &#x4E0D;&#x5305;&#x542B; AAA &#x7684;&#x5F27;&#x7684;&#x4E2D;&#x70B9;&#xFF0C; B&#x2032;C&#x2032;B&apos;C&apos;B&#x2032;C&#x2032; &#x540C;&#x7406;&#xFF0C;&#x8FD9;&#x6837; &#x394;A&#x2032;B&#x2032;C&#x2032;\\Delta A&apos;B&apos;C&apos;&#x394;A&#x2032;B&#x2032;C&#x2032; &#x7684;&#x91CD;&#x5FC3;&#x5373;&#x4E3A; &#x394;ABC\\Delta ABC&#x394;ABC &#x7684;&#x5185;&#x5FC3;&#xFF0C;&#x7136;&#x540E;&#x5229;&#x7528;&#x6B27;&#x62C9;&#x7EBF;&#x7684;&#x6027;&#x8D28;&#x5206;&#x7C7B;&#x8BA8;&#x8BBA;&#x8BA1;&#x7B97;&#x8D21;&#x732E;&#x5373;&#x53EF; CODE cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s){ int top=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))s[++top]=ch,ch=gc(); return top;}const int mod=998244353;inline int add(int a,int b){return (a+=b)&lt;mod?a:a-mod;}inline void Add(int&amp;a,int b){a=add(a,b);}inline int dec(int a,int b){return (a-=b)&lt;0?a+mod:a;}inline void Dec(int&amp;a,int b){a=dec(a,b);}inline int mul(int a,int b){return (ll)a*b%mod;}inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;}inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;}const int N=3005;int t[N],n,L;const double pi=acos(-1.0);int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(),L=read(); for(ri i=1;i&lt;=n;++i)t[i]=read(); double resx=0,resy=0,Ang=pi/L; for(ri i=1;i&lt;n;++i)for(ri j=i+1;j&lt;=n;++j){ resx+=cos(Ang*(t[i]+t[j]))*(n-(j-i+1)); resy+=sin(Ang*(t[i]+t[j]))*(n-(j-i+1)); resx+=cos(Ang*(t[i]+t[j])+pi)*(j-i-1); resy+=sin(Ang*(t[i]+t[j])+pi)*(j-i-1); } printf(&quot;%.10lf %.10lf&quot;,resx*6.0/n/(n-1)/(n-2),resy*6.0/n/(n-1)/(n-2)); return 0;} E fl,r,pf_{l,r,p}fl,r,p&#x200B; &#x8868;&#x793A;&#x5BF9;&#x4E8E;&#x533A;&#x95F4; [l,r][l,r][l,r] &#xFF0C;&#x70B9; ppp &#x8FDE;&#x5411;&#x4E86; [l,r][l,r][l,r] &#x5916;&#x7684;&#x533A;&#x95F4;&#x7684;&#x65B9;&#x6848;&#x6570;&#xFF0C;&#x7136;&#x540E; O(n4)O(n^4)O(n4) &#x679A;&#x4E3E;&#x65B0;&#x7684;&#x5C0F;&#x533A;&#x95F4;&#x5373;&#x53EF;,&#x65F6;&#x95F4;&#x590D;&#x6742;&#x5EA6; O(n7)O(n^7)O(n7) CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;details&gt;&lt;summary&gt;CODE&lt;/summary&gt;#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}typedef long long ll;inline ll readl(){ ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(bool*s){ int top=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))s[++top]=ch^48,ch=gc(); return top;}const int N=45;int n;ll f[N][N][N],res=0;bool trans[N][N];ll dfs(int l,int r,int p){ if(~f[l][r][p])return f[l][r][p]; if(l==r)return f[l][r][p]=1; if(l==p||r==p)return f[l][r][p]=0; ll res=0ll; for(ri _l=l;_l&lt;p;++_l)for(ri _r=r;_r&gt;p;--_r)if(trans[_l][_r]) for(ri a=_l;a&lt;p;++a)for(ri b=_r;b&gt;p;--b)res+=dfs(l,a,_l)*dfs(a+1,b-1,p)*dfs(b,r,_r); return f[l][r][p]=res;}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(); memset(f,-1,sizeof(f)); for(ri i=1;i&lt;=n*2;++i)Read(trans[i]); if(n==1)return cout&lt;&lt;trans[1][2],0; for(ri i=3;i&lt;n*2;++i)(trans[1][i])&amp;&amp;(res+=dfs(2,n*2,i)); cout&lt;&lt;res; return 0;} F &#x8003;&#x8651;&#x8F6C;&#x5316;&#x95EE;&#x9898;&#x6210;&#x4E3A;&#x5982;&#x4E0B;&#x65B0;&#x6A21;&#x578B;&#xFF1A; &#x8981;&#x6C42;&#x586B;&#x4E0A;&#x4E24;&#x4E2A;&#x77E9;&#x9635; A,BA,BA,B &#xFF0C;&#x6EE1;&#x8DB3; AAA &#x7684;&#x884C;&#x6700;&#x5927;&#x503C;&#x4E0D;&#x8D85;&#x8FC7; BBB &#x7684;&#x884C;&#x6700;&#x5C0F;&#x503C;&#xFF0C; AAA &#x7684;&#x5217;&#x6700;&#x5927;&#x503C;&#x4E0D;&#x8D85;&#x8FC7; BBB &#x7684;&#x5217;&#x6700;&#x5C0F;&#x503C;&#xFF0C;&#x6C42;&#x65B9;&#x6848;&#x6570; &#x90A3;&#x4E48;&#x5C31;&#x53EF;&#x4EE5;&#x8BBE;&#x8BA1;&#x51FA;&#x679A;&#x4E3E;&#x4E24;&#x7EF4;&#x8F6C;&#x79FB;&#x7684; dpdpdp &#xFF0C;&#x53D1;&#x73B0;&#x597D;&#x50CF;&#x8FD8;&#x80FD;&#x7528; fftfftfft &#x4F18;&#x5316;&#x5230; O(n4log&#x2061;n)O(n^4\\log n)O(n4logn) &#x4F46;&#x4ECD;&#x7136;&#x4E0D;&#x591F;&#xFF0C;&#x6211;&#x4EEC;&#x9700;&#x8981;&#x4E00;&#x4E2A; O(n4)O(n^4)O(n4) &#x505A;&#x6CD5;&#xFF0C;&#x56E0;&#x4E3A;&#x6709;&#x6743;&#x503C;&#x7684;&#x9650;&#x5236;&#x72B6;&#x6001;&#x5E94;&#x8BE5;&#x662F; O(n3)O(n^3)O(n3) &#x7684;&#xFF0C;&#x56E0;&#x6B64;&#x9700;&#x8981;&#x5B9A;&#x4E49;&#x53EF;&#x4EE5;&#x5C06;&#x6A2A;&#x7EB5;&#x5750;&#x6807;&#x5206;&#x5F00;&#x6216;&#x8005;&#x5206;&#x6B65;&#x8F6C;&#x79FB;&#x7684;&#x72B6;&#x6001; &#x4E8E;&#x662F;&#x4EE4; xix_ixi&#x200B; &#x4E3A; AAA &#x7B2C; iii &#x884C;&#x6700;&#x5927;&#x503C;&#xFF0C; yiy_iyi&#x200B; &#x4E3A; BBB &#x7B2C; iii &#x5217;&#x6700;&#x5C0F;&#x503C; &#x8BBE; fi,j,kf_{i,j,k}fi,j,k&#x200B; &#x8868;&#x793A;&#x5DF2;&#x7ECF;&#x679A;&#x4E3E;&#x4E86; iii &#x884C; jjj &#x5217;&#xFF0C;&#x5DF2;&#x7ECF;&#x586B;&#x4E0A;&#x4E86; AAA &#x6570;&#x7EC4;&#x8FD9; iii &#x884C; jjj &#x5217;&#x5E76;&#x96C6;&#x7684;&#x4F4D;&#x7F6E;&#xFF0C;&#x5DF2;&#x63A5;&#x8FD1;&#x586B;&#x4E0A;&#x4E86; BBB &#x6570;&#x7EC4;&#x8FD9; iii &#x884C; jjj &#x5217;&#x4EA4;&#x96C6;&#x7684;&#x4F4D;&#x7F6E;&#xFF0C;&#x4E14;&#x6EE1;&#x8DB3;&#x5DF2;&#x7ECF;&#x586B;&#x597D;&#x7684; xi,yi&#x2264;kx_i,y_i\\le kxi&#x200B;,yi&#x200B;&#x2264;k &#x7684;&#x53EF;&#x884C;&#x72B6;&#x6001;&#x7684;&#x65B9;&#x6848;&#x6570; &#x7136;&#x540E;&#x5C31;&#x53EF;&#x4EE5;&#x5206;&#x6B65;&#x679A;&#x4E3E;&#x884C;&#x5217;&#x7684;&#x589E;&#x91CF;&#x8F6C;&#x79FB;&#x5230; fi+a,j+b,k+1f_{i+a,j+b,k+1}fi+a,j+b,k+1&#x200B; &#x4E86; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}namespace modular{ int mod=1e9+7; inline int add(int a,int b){return (a+=b)&lt;mod?a:a-mod;} inline void Add(int&amp;a,int b){a=add(a,b);} inline int dec(int a,int b){return (a-=b)&lt;0?a+mod:a;} inline void Dec(int&amp;a,int b){a=dec(a,b);} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;}}using namespace modular;const int N=105;int n,m,L,f[N][N][N][2],C[N][N],pw[4][N];inline void init(){ for(ri i=0,up=max(n,m);i&lt;=up;++i){ C[i][0]=1; for(ri j=1;j&lt;=i;++j)C[i][j]=add(C[i-1][j-1],C[i-1][j]); }}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(),m=read(),L=read(),mod=read(); init(); f[0][0][0][0]=1; for(ri i=0;i&lt;4;++i)pw[i][0]=1; for(ri vl=0;vl&lt;L;++vl){ for(ri i=1,up=max(n,m);i&lt;=up;++i){ pw[0][i]=pw[1][i]; pw[1][i]=mul(pw[1][i-1],vl+1); pw[2][i]=mul(pw[2][i-1],L-vl); pw[3][i]=mul(pw[3][i-1],L-vl-1); } for(ri mt,mlt,a=0;a&lt;=n;++a)for(ri b=0;b&lt;=m;++b)if(f[vl][a][b][0]){ mt=1,mlt=mul(pw[2][b],dec(pw[1][m-b],pw[0][m-b])); for(ri t=0;a+t&lt;=n;++t,Mul(mt,mlt)) Add(f[vl][a+t][b][1],mul(f[vl][a][b][0],mul(mt,C[n-a][t]))); } for(ri mt,mlt,a=0;a&lt;=n;++a)for(ri b=0;b&lt;=m;++b)if(f[vl][a][b][1]){ mt=1,mlt=mul(pw[1][n-a],dec(pw[2][a],pw[3][a])); for(ri t=0;b+t&lt;=m;++t,Mul(mt,mlt)) Add(f[vl+1][a][b+t][0],mul(f[vl][a][b][1],mul(mt,C[m-b][t]))); } } cout&lt;&lt;f[L][n][m][0]; return 0;}","categories":[{"name":"public","slug":"public","permalink":"http://xdl030112.github.io/categories/public/"}],"tags":[{"name":"比赛题解","slug":"比赛题解","permalink":"http://xdl030112.github.io/tags/%E6%AF%94%E8%B5%9B%E9%A2%98%E8%A7%A3/"}]},{"title":"2019.10.09 模拟测试题解","slug":"191009test","date":"2019-10-10T03:27:23.000Z","updated":"2019-10-11T15:33:33.345Z","comments":true,"path":"191009test/","link":"","permalink":"http://xdl030112.github.io/191009test/","excerpt":"","text":"A &#x9898;&#x610F;&#x7B80;&#x8FF0;&#xFF1A; &#x7ED9;&#x4E00;&#x4E2A;&#x957F;&#x5EA6;&#x4E3A; nnn &#x7684;&#x6570;&#x7EC4;&#xFF0C;&#x6BCF;&#x4E2A;&#x6570;&#x90FD;&#x4E3A; 0,1,&#x22EF;&#x2009;,90,1,\\cdots,90,1,&#x22EF;,9 &#x4E2D;&#x7684;&#x4E00;&#x4E2A;&#xFF0C;&#x7ED9;&#x51FA; QQQ &#x4E2A;&#x9650;&#x5236; (l,r,v)(l,r,v)(l,r,v) &#x8868;&#x793A;&#x533A;&#x95F4; [l,r][l,r][l,r] &#x7684;&#x4E58;&#x79EF;&#x6A21; 101010 &#x7684;&#x4F59;&#x6570;&#x4E3A; vvv &#xFF0C;&#x95EE;&#x5408;&#x6CD5;&#x6570;&#x7EC4;&#x6570; &#x6570;&#x636E;&#x8303;&#x56F4;&#xFF1A; n&#x2264;100n\\le100n&#x2264;100 q&#x2264;50q\\le50q&#x2264;50 &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x8003;&#x8651;&#x8F6C;&#x5316;&#x4E3A;&#x8BA1;&#x7B97;&#x6A21; 222 &#x548C;&#x6A21; 555 &#x7684;&#x65B9;&#x6848;&#x6570;&#x518D;&#x4E58;&#x8D77;&#x6765; &#x7136;&#x540E;&#x53D1;&#x73B0;&#x9664;&#x4E86; 000 &#x90FD;&#x6709;&#x9006;&#x5143;&#xFF0C;&#x5BB9;&#x6613;&#x60F3;&#x5230;&#x628A;&#x5F3A;&#x5236;&#x4E0D;&#x4E3A; 000 &#x7684;&#x4F4D;&#x7F6E;&#x548C;&#x53EF;&#x80FD;&#x4E3A; 000 &#x7684;&#x4F4D;&#x7F6E;&#x5206;&#x5F00;&#x8003;&#x8651;&#xFF0C;&#x524D;&#x8005;&#x5728;&#x7ED9;&#x533A;&#x95F4;&#x8FDB;&#x884C;&#x7B80;&#x5355;&#x64CD;&#x4F5C;&#x540E;&#x53EF;&#x4EE5;&#x76F4;&#x63A5;&#x7B97;&#xFF0C;&#x540E;&#x8005;&#x53EF;&#x4EE5;&#x7528;&#x7B80;&#x5355; dpdpdp &#x7B97; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}namespace modular{ const int mod=1e9+7; inline int add(int a,int b){return (a+=b)&lt;mod?a:a-mod;} inline void Add(int&amp;a,int b){a=add(a,b);} inline int dec(int a,int b){return (a-=b)&lt;0?a+mod:a;} inline void Dec(int&amp;a,int b){a=dec(a,b);} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;}}using namespace modular;const int N=105,Q=55;struct F{ int l,r,v; F(int l=0,int r=0,int v=0):l(l),r(r),v(v){} friend inline bool operator&lt;(F a,F b){return a.l^b.l?a.l&lt;b.l:a.r&lt;b.r;}}a[N],ori[N],vl[N];int n,q,ps[N],top,coe,sig,tot,Inv[5]={0,1,3,2,4},f[N],pw[N];pii L[N],R[N];bool ban[N];inline bool insert(F x){ while(1){ if(!L[x.l].fi&amp;&amp;!R[x.r].fi)break; if(L[x.l].fi==x.r)return x.v==L[x.l].se; if(L[x.l].fi){ if(L[x.l].fi&gt;x.r){ swap(x.v,L[x.l].se); R[L[x.l].fi]=pii(0,0); swap(x.r,L[x.l].fi); R[L[x.l].fi]=pii(x.l,L[x.l].se); } (x.v*=Inv[L[x.l].se])%=coe; x.l=L[x.l].fi+1; } else{ if(R[x.r].fi&lt;x.l){ swap(x.v,R[x.r].se); L[R[x.r].fi]=pii(0,0); swap(x.l,R[x.r].fi); L[R[x.r].fi]=pii(x.r,R[x.r].se); } (x.v*=Inv[R[x.r].se])%=coe; x.r=R[x.r].fi-1; } } ++sig; L[x.l]=pii(x.r,x.v); R[x.r]=pii(x.l,x.v); return 1;}inline int solve1(){ if(coe==2)return 1; sig=0; for(ri i=1;i&lt;=top;++i)L[i]=R[i]=pii(0,0); for(ri i=1;i&lt;=tot;++i)if(!insert(vl[i]))return 0; return ksm(coe-1,top-sig);}inline bool check(int len,int ps){ for(ri i=tot;i&amp;&amp;vl[i].l&gt;ps;--i)if(vl[i].r&lt;=len)return 0; return 1;}inline int solve2(){ sort(vl+1,vl+tot+1); pw[0]=1; f[0]=1; for(ri len=1;len&lt;=top;++len){ pw[len]=mul(pw[len-1],coe-1); f[len]=0; for(ri ps=0;ps&lt;=len;++ps)check(len,ps)&amp;&amp;(Add(f[len],mul(pw[len-ps],ps?f[ps-1]:1)),1); } return f[top];}inline void fix1(){ tot=0; for(ri i=1;i&lt;=q;++i)if(a[i].v){ ++tot; vl[tot].l=lower_bound(ps+1,ps+top+1,a[i].l)-ps; vl[tot].r=lower_bound(ps+1,ps+top+1,a[i].r)-ps; vl[tot].v=a[i].v; }}inline void fix2(){ tot=0; for(ri t,i=1;i&lt;=q;++i)if(!a[i].v){ ++tot; for(t=1;t&lt;=top&amp;&amp;ps[t]&lt;a[i].l;++t); vl[tot].l=t; for(t=top;t&amp;&amp;ps[t]&gt;a[i].r;--t); vl[tot].r=t; vl[tot].v=a[i].v; }}inline int solve(){ for(ri i=1;i&lt;=n;++i)ban[i]=0; for(ri i=1;i&lt;=q;++i)if(a[i].v) for(ri j=a[i].l;j&lt;=a[i].r;++j)ban[j]=1; for(ri i=1;i&lt;=q;++i)if(!a[i].v){ bool ff=0; for(ri j=a[i].l;j&lt;=a[i].r;++j)if(!ban[j]){ff=1;break;} if(!ff)return 0; } top=0; for(ri i=1;i&lt;=n;++i)if(ban[i])ps[++top]=i; fix1(); int res=solve1(); top=0; for(ri i=1;i&lt;=n;++i)if(!ban[i])ps[++top]=i; fix2(); return mul(res,solve2());}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(),q=read(); for(ri l,r,v,i=1;i&lt;=q;++i){ l=read()+1,r=read()+1,v=read(); ori[i]=F(l,r,v); } for(ri i=1;i&lt;=q;++i)a[i]=ori[i],a[i].v%=2; coe=2; int res=solve(); for(ri i=1;i&lt;=q;++i)a[i]=ori[i],a[i].v%=5; coe=5; cout&lt;&lt;mul(res,solve()); return 0;} B &#x9898;&#x610F;&#x7B80;&#x8FF0;&#xFF1A; &#x5BF9;&#x4E8E;&#x4E00;&#x5F20; nnn &#x4E2A;&#x70B9;&#x7684;&#x65E0;&#x5411;&#x5B8C;&#x5168;&#x56FE;&#xFF0C;&#x6BCF;&#x6761;&#x8FB9;&#x6709; PPP &#x7684;&#x6982;&#x7387;&#x51FA;&#x73B0;&#xFF0C;&#x95EE;&#x7B49;&#x6982;&#x7387;&#x968F;&#x673A;&#x4E00;&#x4E2A;&#x70B9;&#xFF0C;&#x4ECE; 111 &#x53F7;&#x70B9;&#x5230;&#x5176;&#x7684;&#x6700;&#x77ED;&#x8DEF;&#x957F;&#x5EA6;&#xFF08;&#x4E0D;&#x8FDE;&#x901A;&#x7B54;&#x6848;&#x4E3A; 10910^9109 )&#x7684;&#x671F;&#x671B; &#x6570;&#x636E;&#x8303;&#x56F4;: n&#x2264;400n\\le400n&#x2264;400 &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x8003;&#x8651;&#x5B9A;&#x4E49;&#x72B6;&#x6001; Pi,jP_{i,j}Pi,j&#x200B; &#x8868;&#x793A;&#x8003;&#x8651;&#x4E86; iii &#x4E2A;&#x70B9;&#x7684;&#x5206;&#x5C42;&#x56FE;&#xFF0C;&#x6700;&#x540E;&#x4E00;&#x5C42;&#x6709; jjj &#x4E2A;&#x70B9;&#xFF0C;&#x5230;&#x8FBE;&#x8FD9;&#x4E2A;&#x72B6;&#x6001;&#x7684;&#x6982;&#x7387;&#xFF0C; Ei,jE_{i,j}Ei,j&#x200B; &#x540C;&#x7406;&#x4E0D;&#x8FC7;&#x6362;&#x6210;&#x4E86;&#x671F;&#x671B;&#xFF0C;&#x8FD9;&#x6837;&#x5C31;&#x80FD;&#x8FB9; dpdpdp &#x8FB9;&#x7EDF;&#x8BA1;&#x7B54;&#x6848;&#xFF0C;&#x8F6C;&#x79FB;&#x53EF;&#x4EE5;&#x8003;&#x8651;&#x65B0;&#x52A0;&#x8FDB;&#x6765;&#x7684;&#x4E00;&#x5C42;&#x548C;&#x5F53;&#x524D;&#x6700;&#x540E;&#x4E00;&#x5C42;&#x7684;&#x8FDE;&#x8FB9;&#x60C5;&#x51B5;&#xFF0C;&#x590D;&#x6742;&#x5EA6; O(n3)O(n^3)O(n3) CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}typedef long long ll;namespace modular{ const int mod=998244353; inline int add(int a,int b){return (a+=b)&lt;mod?a:a-mod;} inline int dec(int a,int b){return (a-=b)&lt;0?a+mod:a;} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Add(int&amp;a,int b){a=add(a,b);} inline void Dec(int&amp;a,int b){a=dec(a,b);} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;} }using namespace modular;const int N=405;int n,E[N][N],P[N][N],fac[N],ifac[N],pw2[N*N],coe[N][N],_P;inline int C(int n,int m){return n&lt;m||m&lt;0?0:mul(fac[n],mul(ifac[m],ifac[n-m]));}inline void init(){ fac[0]=fac[1]=ifac[0]=ifac[1]=1,pw2[0]=1; pw2[1]=dec(1,_P); for(ri i=2;i&lt;=n;++i){ fac[i]=mul(fac[i-1],i); ifac[i]=mul(ifac[mod-mod/i*i],mod-mod/i); } for(ri i=2;i&lt;=n*n;++i)pw2[i]=mul(pw2[i-1],pw2[1]); for(ri i=2;i&lt;=n;++i)Mul(ifac[i],ifac[i-1]); for(ri i=1;i&lt;=n;++i){ coe[i][0]=1; coe[i][1]=dec(1,pw2[i]); for(ri j=2;j&lt;=n;++j)coe[i][j]=mul(coe[i][j-1],coe[i][1]); }}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(),_P=mul(ksm(1000000,mod-2),read()); init(); int res=0; P[1][1]=1; for(ri i=1;i&lt;n;++i)for(ri j=1;j&lt;=i;++j){ if(i&gt;1&amp;&amp;i==j)continue; Add(res,mul(add(E[i][j],P[i][j]),coe[j][1])); Add(res,mul(1000000000%mod,mul(pw2[j*(n-i)],P[i][j]))); for(ri k=1;k+i&lt;n;++k){ Add(P[i+k][k],mul(mul(P[i][j],coe[j][k]),mul(C(n-i-1,k),pw2[j*(n-i-k)]))); Add(E[i+k][k],mul(mul(add(P[i][j],E[i][j]),coe[j][k]),mul(C(n-i-1,k),pw2[j*(n-i-k)]))); } } cout&lt;&lt;mul(res,mul(n-1,ksm(1000000,n*n))); return 0;} C &#x9898;&#x610F;&#x7B80;&#x8FF0;&#xFF1A; &#x6C42;&#x6709;&#x591A;&#x5C11;&#x672C;&#x8D28;&#x4E0D;&#x540C;&#x7684;&#x4E0D;&#x8D85;&#x8FC7; nnn &#x4E2A;&#x70B9;&#x7684;&#x3001;&#x65E0;&#x91CD;&#x8FB9;&#x3001;&#x53EF;&#x4EE5;&#x6709;&#x81EA;&#x73AF;&#x3001;&#x5B58;&#x5728;&#x81F3;&#x5C11;&#x4E00;&#x6761;&#x6B27;&#x62C9;&#x56DE;&#x8DEF;&#x7684;&#x5E26;&#x6807;&#x53F7;&#x8FDE;&#x901A;&#x65E0;&#x5411;&#x56FE; &#x6570;&#x636E;&#x8303;&#x56F4;&#xFF1A; n&#x2264;45n\\le45n&#x2264;45 &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x9996;&#x5148;&#x7528;&#x6700;&#x5C0F;&#x8868;&#x793A;&#x6CD5; + burnsideburnsideburnside &#x6C42;&#x51FA;&#x4E0D;&#x8981;&#x6C42;&#x8FDE;&#x4F53;&#x6876;&#x7684;&#x7B54;&#x6848;&#xFF0C;&#x8FD9;&#x4E2A;&#x65B9;&#x6CD5;&#x53C2;&#x89C1;&#x6D1B;&#x8C37;&#x4E00;&#x9053;&#x53EB;&#x505A;&#x753B;&#x753B;&#x7684;&#x9898;&#x76EE;&#xFF0C;&#x7136;&#x540E;&#x5C31;&#x53EF;&#x4EE5;&#x7528;&#x8865;&#x96C6;&#x8F6C;&#x5316;&#x7684;&#x601D;&#x60F3;&#x679A;&#x4E3E;&#x4E0D;&#x8FDE;&#x901A;&#x7684;&#x60C5;&#x51B5;&#x6C42;&#x51FA;&#x7B54;&#x6848; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}namespace modular{ int mod=1e9+7; inline int add(int a,int b){return (a+=b)&lt;mod?a:a-mod;} inline void Add(int&amp;a,int b){a=add(a,b);} inline int dec(int a,int b){return (a-=b)&lt;0?a+mod:a;} inline void Dec(int&amp;a,int b){a=dec(a,b);} inline int mul(int a,int b){return (ll)a*b%mod;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;} inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;}}using namespace modular;const int N=55;int n,fac[N],ifac[N],inv[N],pw[N*N*2];inline void init(){ inv[1]=fac[0]=fac[1]=ifac[0]=ifac[1]=1; for(ri i=2;i&lt;=n;++i){ fac[i]=mul(fac[i-1],i); inv[i]=mul(inv[mod-mod/i*i],mod-mod/i); ifac[i]=mul(ifac[i-1],inv[i]); } pw[0]=1; for(ri i=1;i&lt;=n*n*2;++i)pw[i]=add(pw[i-1],pw[i-1]);}int res,a[N],cnt[N],vl[N],top=0,ft[N],up;inline int find(int x){return x^ft[x]?ft[x]=find(ft[x]):x;}inline int gcd(int a,int b){int t;while(b)t=a,a=b,b=t-t/a*a;return a;}inline void update(){ int coe=1,ss=0; for(ri i=1;i&lt;=up;++i)Mul(coe,ifac[cnt[i]]),ft[i]=i; for(ri i=1;i&lt;=top;++i){ ss+=(a[i]-1)/2; vl[i]=!(a[i]&amp;1); Mul(coe,inv[a[i]]); } for(ri x,y,fx,fy,g,i=1;i&lt;top;++i)for(ri j=i+1;j&lt;=top;++j){ g=gcd(a[i],a[j]); x=(a[j]/g)&amp;1,y=(a[i]/g)&amp;1; if(x^y)(x?vl[i]:vl[j])+=g; else{ ss+=g; if(x&amp;y){ fx=find(i); fy=find(j); if(fx^fy)ft[fx]=fy; } } } for(ri i=1;i&lt;=top;++i)if(find(i)!=i)vl[find(i)]+=vl[i]; for(ri i=1;i&lt;=top;++i)if(find(i)==i)ss+=max(vl[i],1); Add(res,mul(coe,pw[ss]));}inline void dfs(int sz,int all){ if(!all)return update(); if(sz&gt;all)return; for(ri i=sz;i&lt;=all;++i){ ++cnt[i]; a[++top]=i; dfs(i,all-i); --cnt[i]; --top; }}inline int C(int n,int m){ if(n&lt;m)return 0; int ret=ifac[m]; for(ri i=0;i&lt;m;++i)Mul(ret,n-i); return ret;}int f[N],g[N],h[N];inline void IEP(){ res=0; g[0]=1; for(ri i=1;i&lt;=n;++i){ h[i]=dec(f[i],g[i]); for(ri j=n;j;--j)for(ri k=1;i*k&lt;=j;++k)Add(g[j],mul(g[j-i*k],C(add(h[i],k-1),k))); } for(ri i=1;i&lt;=n;++i)Add(res,h[i]); cout&lt;&lt;dec(res,1);}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(),mod=read(); init(); for(up=1;up&lt;=n;++up){ res=0; dfs(1,up); f[up]=res; } IEP(); return 0;}","categories":[{"name":"private","slug":"private","permalink":"http://xdl030112.github.io/categories/private/"}],"tags":[{"name":"考试题解","slug":"考试题解","permalink":"http://xdl030112.github.io/tags/%E8%80%83%E8%AF%95%E9%A2%98%E8%A7%A3/"}]},{"title":"2019.10.07 模拟测试题解","slug":"191007test","date":"2019-10-10T03:08:47.000Z","updated":"2019-10-11T15:33:34.569Z","comments":true,"path":"191007test/","link":"","permalink":"http://xdl030112.github.io/191007test/","excerpt":"","text":"&#x9898;&#x76EE;&#x6765;&#x6E90;&#xFF1A; A:CF793GA:CF793GA:CF793G B:CF335EB:CF335EB:CF335E C:CF809EC:CF809EC:CF809E A &#x9898;&#x610F;&#x7B80;&#x8FF0;&#xFF1A; &#x7ED9;&#x4F60;&#x4E00;&#x4E2A; n&#xD7;nn\\times nn&#xD7;n &#x7684;&#x7F51;&#x683C;&#x56FE;&#x548C; qqq &#x4E2A;&#x4E0D;&#x76F8;&#x4EA4;&#x7684;&#x77E9;&#x5F62;&#xFF0C;&#x95EE;&#x9664;&#x5F00;&#x8FD9; qqq &#x4E2A;&#x77E9;&#x5F62;&#x5269;&#x4E0B;&#x7684;&#x683C;&#x5B50;&#x4E2D;&#x6700;&#x591A;&#x80FD;&#x653E;&#x591A;&#x5C11;&#x4E2A;&#x4E92;&#x4E0D;&#x5F71;&#x54CD;&#x7684;&#x8ECA; &#x6570;&#x636E;&#x8303;&#x56F4;&#xFF1A; n&#x2264;10000n\\le10000n&#x2264;10000 q&#x2264;10000q\\le10000q&#x2264;10000 &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x66B4;&#x529B;&#x662F;&#x5F88;&#x663E;&#x7136;&#x7684;&#x6309;&#x7167;&#x884C;&#x5217;&#x5EFA;&#x4E8C;&#x5206;&#x56FE;&#x7136;&#x540E;&#x6700;&#x5927;&#x5339;&#x914D;&#xFF0C;&#x6B63;&#x89E3;&#x53EF;&#x4EE5;&#x8003;&#x8651;&#x7528;&#x6570;&#x636E;&#x7ED3;&#x6784;&#x4F18;&#x5316;&#x5EFA;&#x56FE;&#xFF0C;&#x7B80;&#x5355;&#x601D;&#x8003;&#x540E;&#x5BB9;&#x6613;&#x60F3;&#x5230;&#x626B;&#x63CF;&#x7EBF;+&#x4E3B;&#x5E2D;&#x6811;&#xFF0C;WOJ&#x4E0A;&#x88AB;&#x5361;&#x5E38;&#x4E86;&#x4EC0;&#x4E48;&#x8FA3;&#x9E21;&#x8BC4;&#x6D4B;&#x59EC; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_backusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}typedef long long ll;const int N=10005,M=6e6+5,inf=0x3f3f3f3f;int n,m;struct edge{int v,next,c;};namespace dinic{ int s,t,first[M],cnt,d[M],cur[M]; edge e[M]; inline void addedge(int u,int v,int c){e[++cnt]=(edge){v,first[u],c},first[u]=cnt;} inline void add(int u,int v,int c){if(!c)return;addedge(u,v,c),addedge(v,u,0);} inline bool bfs(){ static int que[M],hd,tl; for(ri i=s;i&lt;=t;++i)d[i]=-1; d[s]=0,que[hd=tl=1]=s; while(hd&lt;=tl){ int x=que[hd++]; for(ri i=first[x],v;~i;i=e[i].next){ v=e[i].v; if(~d[v]||e[i].c&lt;=0)continue; d[v]=d[x]+1; if(v==t)return 1; que[++tl]=v; } } return 0; } inline int dfs(int p,int f){ if(!f||p==t)return f; int flow=f; for(ri i=first[p],v,tp;~i;i=e[i].next){ if(!flow)return f; v=e[i].v; if(d[v]&gt;d[p]&amp;&amp;e[i].c&gt;0){ tp=dfs(v,min(flow,e[i].c)); (!tp)&amp;&amp;(d[v]=-1); e[i].c-=tp,e[i^1].c+=tp,flow-=tp; } } return f-flow; } inline int solve(){ int res=0,tp=0; while(bfs())while((tp=dfs(s,inf)))res+=tp; return res; }}namespace subtask1{ int det[105][105]; inline void Main(){ dinic::cnt=-1; dinic::s=0,dinic::t=2*n+1; for(ri i=0;i&lt;=n*2+1;++i)dinic::first[i]=-1; for(ri i=1;i&lt;=n;++i)dinic::add(0,i,1),dinic::add(i+n,n*2+1,1); for(ri x1,x2,y1,y2,i=1;i&lt;=m;++i){ x1=read(),y1=read(),x2=read(),y2=read(); ++det[x1][y1],--det[x1][y2+1],--det[x2+1][y1],++det[x2+1][y2+1]; } for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=n;++j){ det[i][j]+=det[i-1][j]+det[i][j-1]-det[i-1][j-1]; if(!det[i][j])dinic::add(i,j+n,1); } cout&lt;&lt;dinic::solve(); exit(0); }}int all=0,idx[M],rt[N],tot=0,son[M][2],siz[M];#define lc (son[p][0])#define rc (son[p][1])#define mid (l+r&gt;&gt;1)inline void build(int&amp;p,int l,int r){ p=++tot,siz[p]=r-l+1; idx[p]=++all,dinic::first[all]=-1; if(l==r){ dinic::add(idx[p],l+n,1); return; } build(lc,l,mid),build(rc,mid+1,r); dinic::add(idx[p],idx[lc],siz[lc]); dinic::add(idx[p],idx[rc],siz[rc]);}inline void update(int&amp;p,int o,int O,int l,int r,int ql,int qr,int v){ p=++tot; siz[p]=siz[o]+v*(min(qr,r)-max(ql,l)+1),lc=son[o][0],rc=son[o][1]; idx[p]=++all,dinic::first[all]=-1; if(ql&lt;=l&amp;&amp;r&lt;=qr){ if(l==r)dinic::add(idx[p],l+n,1); else{ dinic::add(idx[p],idx[son[O][0]],siz[son[O][0]]); dinic::add(idx[p],idx[son[O][1]],siz[son[O][1]]); } return; } if(qr&lt;=mid)update(lc,lc,son[O][0],l,mid,ql,qr,v); else if(ql&gt;mid)update(rc,rc,son[O][1],mid+1,r,ql,qr,v); else update(lc,lc,son[O][0],l,mid,ql,qr,v),update(rc,rc,son[O][1],mid+1,r,ql,qr,v); dinic::add(idx[p],idx[lc],siz[lc]); dinic::add(idx[p],idx[rc],siz[rc]);}#undef lc#undef rc#undef midstruct F{int l,r,typ;friend inline bool operator&lt;(F a,F b){return a.typ&lt;b.typ;};};vector&lt;F&gt;upd[N];int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(),m=read(); for(ri x1,y1,x2,y2,i=1;i&lt;=m;++i){ x1=read(),y1=read(),x2=read(),y2=read(); upd[x1].pb((F){y1,y2,-1}),upd[x2+1].pb((F){y1,y2,1}); } all=n*2; dinic::s=0; dinic::cnt=-1; for(ri i=0;i&lt;=all;++i)dinic::first[i]=-1; for(ri i=1;i&lt;=n;++i)dinic::add(0,i,1); build(rt[0],1,n); for(ri i=1;i&lt;=n;++i){ rt[i]=rt[i-1]; sort(upd[i].begin(),upd[i].end()); for(ri j=upd[i].size()-1;~j;--j) update(rt[i],rt[i],rt[0],1,n,upd[i][j].l,upd[i][j].r,upd[i][j].typ); dinic::add(i,idx[rt[i]],siz[rt[i]]); } dinic::t=++all,dinic::first[all]=-1; for(ri i=1;i&lt;=n;++i)dinic::add(i+n,all,1); cout&lt;&lt;dinic::solve(); return 0;} B &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x9996;&#x5148;&#x8003;&#x8651;&#x7ED9;&#x4F60;&#x4E00;&#x4E2A; BobBobBob &#x7684;&#x60C5;&#x51B5;&#xFF0C;&#x6839;&#x636E;&#x6837;&#x4F8B;&#x4E0D;&#x96BE;&#x731C;&#x51FA;&#x7B54;&#x6848;&#x4E3A; nnn &#x7136;&#x540E;&#x8003;&#x8651;&#x7ED9;&#x4F60;&#x4E00;&#x4E2A; AliceAliceAlice &#x7684;&#x60C5;&#x51B5;&#xFF0C;&#x53D1;&#x73B0;&#x53EF;&#x4EE5;&#x679A;&#x4E3E;&#x9AD8;&#x5EA6;&#x4EE4;&#x5176;&#x4E00;&#x70B9;&#x70B9;&#x589E;&#x52A0;&#x7136;&#x540E;&#x7B97;&#x65B0;&#x6ED1;&#x7D22;&#x51CF;&#x539F;&#x6765;&#x6ED1;&#x7D22;&#x7684;&#x671F;&#x671B;&#x589E;&#x91CF; CODE cpp123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;char s[10];int n,H,pw[35];double ipw[35];int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif scanf(&quot;%s%d%d&quot;,s,&amp;n,&amp;H); if(s[0]==&apos;B&apos;){ cout&lt;&lt;n; return 0; } pw[0]=ipw[0]=1; for(ri i=1;i&lt;=H;++i)pw[i]=pw[i-1]*2,ipw[i]=1.0/pw[i]; double res=0,mt; for(ri h=1;h&lt;=H;++h){ mt=ipw[h]*ipw[h]; for(ri len=1;len&lt;n;++len){ res+=(n-len)*mt*(pw[h]-pw[h-1]*(1.0+(double)(len-1)/(double)(pw[h]-1))); mt*=1-ipw[h]; } } printf(&quot;%.10lf&quot;,res+n); return 0;} C &#x9898;&#x610F;&#x7B80;&#x8FF0;&#xFF1A; &#x7ED9;&#x51FA;&#x4E00;&#x68F5;&#x6811;&#x548C;&#x6BCF;&#x4E2A;&#x70B9;&#x70B9;&#x6743; aia_iai&#x200B; &#x6C42; &#x2211;i=1n&#x2211;j=1n&#x3D5;(aiaj)dist(i,j)\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^n\\phi(a_ia_j)dist(i,j)i=1&#x2211;n&#x200B;j=1&#x2211;n&#x200B;&#x3D5;(ai&#x200B;aj&#x200B;)dist(i,j) &#x6570;&#x636E;&#x8303;&#x56F4;&#xFF1A; n&#x2264;200000n\\le200000n&#x2264;200000 &#x4FDD;&#x8BC1; {a}\\{a\\}{a} &#x662F;&#x4E00;&#x4E2A;&#x6392;&#x5217; &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x8003;&#x8651;&#x5230;&#x6709;&#x7B49;&#x5F0F; &#x3D5;(ij)=&#x3D5;(i)&#x3D5;(j)gcd&#x2061;(i,j)&#x3D5;(gcd&#x2061;(i,j))\\phi(ij)=\\phi(i)\\phi(j)\\frac{\\gcd(i,j)}{\\phi(\\gcd(i,j))}&#x3D5;(ij)=&#x3D5;(i)&#x3D5;(j)&#x3D5;(gcd(i,j))gcd(i,j)&#x200B; &#x4E8E;&#x662F;&#x5BB9;&#x6613;&#x60F3;&#x5230;&#x53EF;&#x4EE5;&#x83AB;&#x6BD4;&#x4E4C;&#x65AF;&#x53CD;&#x6F14;+&#x8C03;&#x548C;&#x7EA7;&#x6570;&#x679A;&#x4E3E;&#x70B9;+&#x865A;&#x6811;&#x7EDF;&#x8BA1;&#x7B54;&#x6848; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}const int mod=1e9+7;inline int add(int a,int b){return (a+=b)&lt;mod?a:a-mod;}inline int dec(int a,int b){return (a-=b)&lt;0?a+mod:a;}inline int mul(int a,int b){return (ll)a*b%mod;}inline void Add(int&amp;a,int b){a=add(a,b);}inline void Dec(int&amp;a,int b){a=dec(a,b);}inline void Mul(int&amp;a,int b){a=mul(a,b);}inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;}const int N=2e5+5;vector&lt;int&gt;e[N],E[N];int n,a[N],b[N],mu[N],phi[N],pri[N],inv[N],tot=0,F[N];bool vs[N];inline void init(){ phi[1]=inv[1]=mu[1]=1; for(ri i=2;i&lt;=n;++i){ inv[i]=mul(inv[mod-mod/i*i],mod-mod/i); if(!vs[i])pri[++tot]=i,phi[i]=i-1,mu[i]=mod-1; for(ri j=1,up=n/i;j&lt;=tot&amp;&amp;pri[j]&lt;=up;++j){ vs[i*pri[j]]=1; if(i==i/pri[j]*pri[j]){ mu[i*pri[j]]=0; phi[i*pri[j]]=phi[i]*pri[j]; break; } phi[i*pri[j]]=phi[i]*(pri[j]-1); mu[i*pri[j]]=mu[i]?mod-mu[i]:0; } } for(ri i=1;i&lt;=n;++i)for(ri j=i,t=1;j&lt;=n;j+=i,++t)Add(F[j],mul(i,mul(inv[phi[i]],mu[t])));}int siz[N],top[N],dep[N],fa[N],hson[N],dfntot=0,dfn[N];void dfs1(int p){ siz[p]=1; for(ri i=0,v;i&lt;e[p].size();++i){ if((v=e[p][i])==fa[p])continue; fa[v]=p,dep[v]=dep[p]+1,dfs1(v),siz[p]+=siz[v]; (siz[v]&gt;siz[hson[p]])&amp;&amp;(hson[p]=v); }}void dfs2(int p,int tp){ dfn[p]=++dfntot,top[p]=tp; if(!hson[p])return; dfs2(hson[p],tp); for(ri i=0,v;i&lt;e[p].size();++i)((v=e[p][i])!=hson[p]&amp;&amp;v!=fa[p])&amp;&amp;(dfs2(v,v),1);}inline int lca(int x,int y){ while(top[x]^top[y]){ if(dep[top[x]]&lt;dep[top[y]])swap(x,y); x=fa[top[x]]; } return dep[x]&lt;dep[y]?x:y;}bool key[N];int tp=0,stk[N];inline void insert(int x){ if(tp&lt;2){stk[++tp]=x;return;} int t=lca(x,stk[tp]); if(t==stk[tp]){stk[++tp]=x;return;} while(dfn[stk[tp]]&gt;dfn[t]){ if(dfn[t]&gt;=dfn[stk[tp-1]]){ E[t].pb(stk[tp]),--tp; if(t^stk[tp])stk[++tp]=t; stk[++tp]=x; return; } E[stk[tp-1]].pb(stk[tp]),--tp; }}int res=0,ss,ss1[N],ss2[N];void dfs(int p){ ss1[p]=ss2[p]=0; for(ri i=0,v;i&lt;E[p].size();++i){ v=E[p][i]; dfs(v); Add(ss2[p],ss2[v]); Add(ss1[p],ss1[v]); } if(key[p]){ Add(ss,dec(mul(ss2[p],phi[a[p]]),mul(ss1[p],mul(phi[a[p]],dep[p])))); Add(ss2[p],mul(phi[a[p]],dep[p])); Add(ss1[p],phi[a[p]]); } for(ri i=0,v;i&lt;E[p].size();++i){ v=E[p][i]; Dec(ss2[p],ss2[v]); Dec(ss1[p],ss1[v]); Add(ss,mul(ss1[v],ss2[p])); Add(ss,mul(ss1[p],ss2[v])); Dec(ss,mul(mul(2,dep[p]),mul(ss1[v],ss1[p]))); Add(ss2[p],ss2[v]); Add(ss1[p],ss1[v]); }}void clear(int p){ key[p]=0; for(ri i=0;i&lt;E[p].size();++i)clear(E[p][i]); E[p].clear();}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(); init(); for(ri i=1;i&lt;=n;++i)b[a[i]=read()]=i; for(ri i=1,u,v;i&lt;n;++i){ u=read(),v=read(); e[u].pb(v),e[v].pb(u); } dfs1(1),dfs2(1,1); vector&lt;pii&gt;t; for(ri d=1;d&lt;=n;++d){ t.clear(); for(ri p=d;p&lt;=n;p+=d)t.pb(pii(dfn[b[p]],b[p])),key[b[p]]=1; sort(t.begin(),t.end()); tp=0; if(!key[1])insert(1); for(ri i=0;i&lt;t.size();++i)insert(t[i].se); while(tp&gt;1)E[stk[tp-1]].pb(stk[tp]),--tp; ss=0; dfs(1),clear(1); Add(res,mul(ss,F[d])); } cout&lt;&lt;mul(res,mul(inv[n],inv[n-1])); return 0;}","categories":[{"name":"private","slug":"private","permalink":"http://xdl030112.github.io/categories/private/"}],"tags":[{"name":"考试题解","slug":"考试题解","permalink":"http://xdl030112.github.io/tags/%E8%80%83%E8%AF%95%E9%A2%98%E8%A7%A3/"}]},{"title":"CodeForces 1220 简要题解","slug":"CF1220","date":"2019-10-04T08:43:54.000Z","updated":"2019-10-22T23:48:20.283Z","comments":true,"path":"CF1220/","link":"","permalink":"http://xdl030112.github.io/CF1220/","excerpt":"","text":"A &#x663E;&#x7136;&#x5C3D;&#x91CF;&#x591A;&#x9009; 111 CODE cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;typedef pair&lt;int,int&gt; pii;typedef long long ll;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; char ch=gc(); bool f=1; while(!isdigit(ch))f^=ch==&apos;-&apos;,ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;}inline ll readl(){ ll ans=0; char ch=gc(); bool f=1; while(!isdigit(ch))f^=ch==&apos;-&apos;,ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;}inline int Read(char*s){ int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;}int n,c[5];char s[100005];int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(); Read(s); for(ri i=1;i&lt;=n;++i){ if(s[i]==&apos;z&apos;)++c[0]; if(s[i]==&apos;e&apos;)++c[1]; if(s[i]==&apos;r&apos;)++c[2]; if(s[i]==&apos;o&apos;)++c[3]; if(s[i]==&apos;n&apos;)++c[4]; } for(ri i=1,up=min(c[4],min(c[3],c[1]));i&lt;=up;++i)--c[4],--c[3],--c[1],cout&lt;&lt;1&lt;&lt;&apos; &apos;; for(ri i=1,up=min(min(c[0],c[1]),min(c[2],c[3]));i&lt;=up;++i)cout&lt;&lt;0&lt;&lt;&apos; &apos;; return 0;} B &#x6309;&#x7167;&#x9898;&#x610F;&#x6A21;&#x62DF;&#xFF0C;&#x5148;&#x7B97;&#x51FA; a1a_1a1&#x200B; &#xFF0C;&#x7136;&#x540E;&#x53EF;&#x4EE5;&#x7528; ai,1/a1a_{i,1}/a_1ai,1&#x200B;/a1&#x200B; &#x5F97;&#x51FA;&#x5269;&#x4F59;&#x7684;&#x6570; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;typedef pair&lt;int,int&gt; pii;typedef long long ll;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; char ch=gc(); bool f=1; while(!isdigit(ch))f^=ch==&apos;-&apos;,ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;}inline ll readl(){ ll ans=0; char ch=gc(); bool f=1; while(!isdigit(ch))f^=ch==&apos;-&apos;,ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;}inline int Read(char*s){ int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;}int n;int res[1005],a[1005][1005];int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(); for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=n;++j)a[i][j]=read(); res[1]=sqrt((ll)a[1][2]*a[1][3]/a[2][3]); for(ri i=2;i&lt;=n;++i)res[i]=a[1][i]/res[1]; for(ri i=1;i&lt;=n;++i)cout&lt;&lt;res[i]&lt;&lt;&apos; &apos;; puts(&quot;&quot;); return 0;} C &#x663E;&#x7136;&#x53EA;&#x7528;&#x8003;&#x8651;&#x9996;&#x5B57;&#x6BCD;&#x5927;&#x5C0F;&#xFF0C;&#x53D6;&#x524D;&#x7F00;&#x6700;&#x5C0F;&#x503C;&#x6BD4;&#x4E00;&#x6BD4;&#x5373;&#x53EF; CODE cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;typedef pair&lt;int,int&gt; pii;typedef long long ll;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; char ch=gc(); bool f=1; while(!isdigit(ch))f^=ch==&apos;-&apos;,ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;}inline ll readl(){ ll ans=0; char ch=gc(); bool f=1; while(!isdigit(ch))f^=ch==&apos;-&apos;,ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;}inline int Read(char*s){ int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;}const int N=5e5+5;char s[N];int n;int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=Read(s); int premn=26; for(ri i=1;i&lt;=n;++i){ int x=s[i]-&apos;a&apos;; if(premn&lt;x){ puts(&quot;Ann&quot;); } else puts(&quot;Mike&quot;); premn=min(premn,x); } return 0;} D &#x624B;&#x73A9;&#x4E00;&#x4E0B;&#x53EF;&#x4EE5;&#x53D1;&#x73B0;&#x89C4;&#x5F8B;&#xFF0C;&#x8BBE;&#x6700;&#x540E;&#x4FDD;&#x7559;&#x7684;&#x96C6;&#x5408;&#x4E3A; {a1,a2,&#x22EF;&#x2009;,an}\\{a_1,a_2,\\cdots,a_n\\}{a1&#x200B;,a2&#x200B;,&#x22EF;,an&#x200B;}&#xFF0C;&#x90A3;&#x4E48;&#x6EE1;&#x8DB3; &#x2200;i,j,lcm(ai,aj)/gcd&#x2061;(ai,aj)%2==1\\forall i,j,lcm(a_i,a_j)/\\gcd(a_i,a_j)\\%2==1&#x2200;i,j,lcm(ai&#x200B;,aj&#x200B;)/gcd(ai&#x200B;,aj&#x200B;)%2==1 &#x4E8E;&#x662F;&#x6309; 222 &#x7684;&#x5E42;&#x6B21;&#x5206;&#x7EC4;&#x5373;&#x53EF; CODE cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;typedef pair&lt;int,int&gt; pii;typedef long long ll;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; char ch=gc(); bool f=1; while(!isdigit(ch))f^=ch==&apos;-&apos;,ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;}inline ll readl(){ ll ans=0; char ch=gc(); bool f=1; while(!isdigit(ch))f^=ch==&apos;-&apos;,ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;}inline int Read(char*s){ int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;}const int N=2e5+5;int n;bool vs[N];ll a[N];bool in[N];vector&lt;ll&gt;vl[105];int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(); set&lt;int&gt;A,B; for(ri i=1;i&lt;=n;++i){ ll x=readl(),s=x,t=0; while(!(s&amp;1))s&gt;&gt;=1,++t; vl[t].pb(x); } int mx=0; for(ri i=0;i&lt;63;++i)mx=max(mx,(int)vl[i].size()); cout&lt;&lt;n-mx&lt;&lt;&apos;\\n&apos;; bool ff=1; for(ri i=0;i&lt;63;++i){ if(vl[i].size()==mx&amp;&amp;ff){ff=0;continue;} for(ri j=0;j&lt;vl[i].size();++j)cout&lt;&lt;vl[i][j]&lt;&lt;&apos; &apos;; } return 0;} E &#x5148; tarjantarjantarjan &#x4E00;&#x6B21;&#xFF0C;&#x7136;&#x540E;&#x7528;&#x6811;&#x5F62; dpdpdp &#x5373;&#x53EF; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;typedef pair&lt;int,int&gt; pii;typedef long long ll;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; char ch=gc(); bool f=1; while(!isdigit(ch))f^=ch==&apos;-&apos;,ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;}inline ll readl(){ ll ans=0; char ch=gc(); bool f=1; while(!isdigit(ch))f^=ch==&apos;-&apos;,ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;}inline int Read(char*s){ int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;}const int N=2e5+5;int S,n,m,w[N],dfn[N],low[N],tot=0,stk[N],top=0,siz[N],col[N],sig=0;bool vs[N];ll sum[N];vector&lt;int&gt;e[N],E[N];void tarjan(int p,int fa){ dfn[p]=low[p]=++tot,stk[++top]=p; vs[p]=1; for(ri i=0,v;i&lt;e[p].size();++i){ if(dfn[v=e[p][i]]){ if(v==fa||!vs[v])continue; low[p]=min(low[p],dfn[v]); } else tarjan(v,p),low[p]=min(low[p],low[v]); } if(low[p]==dfn[p]){ int x; ++sig; while(1){ x=stk[top--]; ++siz[sig]; col[x]=sig; vs[x]=0; sum[sig]+=w[x]; if(x==p)break; } }}ll F[N][2];bool ok[N];void dfs(int p,int fa){ ok[p]=siz[p]&gt;1; F[p][0]=sum[p]; for(ri i=0,v;i&lt;E[p].size();++i){ if((v=E[p][i])==fa)continue; dfs(v,p); if(ok[v])F[p][0]+=F[v][0],ok[p]=1; } F[p][1]=F[p][0]; for(ri i=0,v;i&lt;E[p].size();++i){ if((v=E[p][i])==fa)continue; if(ok[v])F[p][0]-=F[v][0]; F[p][1]=max(F[p][1],F[p][0]+F[v][1]); if(ok[v])F[p][0]+=F[v][0]; }}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(),m=read(); for(ri i=1;i&lt;=n;++i)w[i]=read(); for(ri u,v,i=1;i&lt;=m;++i){ u=read(),v=read(); e[u].pb(v),e[v].pb(u); } S=read(); tarjan(S,0); for(ri u=1,v;u&lt;=n;++u)for(ri i=0;i&lt;e[u].size();++i){ v=e[u][i]; if(col[u]==col[v])continue; E[col[u]].pb(col[v]); } dfs(col[S],0); cout&lt;&lt;max(F[col[S]][0],F[col[S]][1]); return 0;} F &#x7528;&#x7EBF;&#x6BB5;&#x6811;&#x7EF4;&#x62A4;&#x9898;&#x610F;&#x5373;&#x53EF; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}const int N=4e5+5;int a[N],n,b[N],dep[N];namespace sgt1{ #define lc (p&lt;&lt;1) #define rc (p&lt;&lt;1|1) #define mid (l+r&gt;&gt;1) int mx[N&lt;&lt;2],dt[N&lt;&lt;2]; inline void pushup(int p){mx[p]=max(mx[lc],mx[rc]);} inline void pushnow(int p,int v){ mx[p]+=v; dt[p]+=v; } inline void pushdown(int p){ if(dt[p]){ pushnow(lc,dt[p]); pushnow(rc,dt[p]); dt[p]=0; } } inline void build(int p,int l,int r){ if(l==r){mx[p]=dep[a[l]];return;} build(lc,l,mid),build(rc,mid+1,r); pushup(p); } inline void modify(int p,int l,int r,int k,int v){ if(l==r){mx[p]=v;return;} pushdown(p); k&lt;=mid?modify(lc,l,mid,k,v):modify(rc,mid+1,r,k,v); pushup(p); } inline void update(int p,int l,int r,int ql,int qr,int v){ if(ql&lt;=l&amp;&amp;r&lt;=qr)return pushnow(p,v); pushdown(p); if(qr&lt;=mid)update(lc,l,mid,ql,qr,v); else if(ql&gt;mid)update(rc,mid+1,r,ql,qr,v); else update(lc,l,mid,ql,qr,v),update(rc,mid+1,r,ql,qr,v); pushup(p); } inline int query(int p,int l,int r,int k){ if(l==r)return mx[p]; pushdown(p); return k&lt;=mid?query(lc,l,mid,k):query(rc,mid+1,r,k); }}namespace sgt2{ int mn[N&lt;&lt;2]; inline void pushup(int p){mn[p]=min(mn[lc],mn[rc]);} inline void build(int p,int l,int r){ if(l==r){mn[p]=a[l];return;} build(lc,l,mid),build(rc,mid+1,r); pushup(p); } inline int Ql(int p,int l,int r,int v){ if(mn[p]&gt;=v)return -1; if(l==r)return l; if(mn[lc]&lt;v)return Ql(lc,l,mid,v); return Ql(rc,mid+1,r,v); } inline int Ql(int p,int l,int r,int ql,int qr,int v){ if(ql&lt;=l&amp;&amp;r&lt;=qr)return Ql(p,l,r,v); if(qr&lt;=mid)return Ql(lc,l,mid,ql,qr,v); if(ql&gt;mid)return Ql(rc,mid+1,r,ql,qr,v); int res=Ql(lc,l,mid,ql,qr,v); if(~res)return res; return Ql(rc,mid+1,r,ql,qr,v); } inline int Qr(int p,int l,int r,int v){ if(mn[p]&gt;=v)return -1; if(l==r)return l; if(mn[rc]&lt;v)return Qr(rc,mid+1,r,v); return Qr(lc,l,mid,v); } inline int Qr(int p,int l,int r,int ql,int qr,int v){ if(ql&lt;=l&amp;&amp;r&lt;=qr)return Qr(p,l,r,v); if(qr&lt;=mid)return Qr(lc,l,mid,ql,qr,v); if(ql&gt;mid)return Qr(rc,mid+1,r,ql,qr,v); int res=Qr(rc,mid+1,r,ql,qr,v); if(~res)return res; return Qr(lc,l,mid,ql,qr,v); } #undef lc #undef rc #undef mid}int stk[N],top=0,son[N][2];void dfs(int p){ if(son[p][0])dep[son[p][0]]=dep[p]+1,dfs(son[p][0]); if(son[p][1])dep[son[p][1]]=dep[p]+1,dfs(son[p][1]);}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(); for(ri i=1;i&lt;=n;++i)a[i]=a[i+n]=read(),b[a[i]]=i; sgt2::build(1,1,n&lt;&lt;1); stk[top=1]=a[1]; for(ri i=2;i&lt;=n;++i){ int x=0; while(top&amp;&amp;stk[top]&gt;a[i])x=stk[top--]; son[a[i]][0]=x; top&amp;&amp;(son[stk[top]][1]=a[i]); stk[++top]=a[i]; } dep[1]=1; dfs(1); sgt1::build(1,1,n); int ans=n+1,res=-1; for(ri l=1,dt=0,r=n;l&lt;=n;++l,++r,++dt){ if(ans&gt;sgt1::mx[1])ans=sgt1::mx[1],res=dt; int ps1=sgt2::Ql(1,1,n&lt;&lt;1,l,r,a[l]); if(~ps1){ if(ps1&lt;=n+1)sgt1::update(1,1,n,l,ps1-1,-1); else sgt1::update(1,1,n,l,n,-1),sgt1::update(1,1,n,1,ps1-1-n,-1); } else sgt1::pushnow(1,-1); int ps2=sgt2::Qr(1,1,n&lt;&lt;1,l+1,r+1,a[l]); if(~ps2){ if(ps2&lt;n)sgt1::update(1,1,n,ps2+1,n,1),sgt1::update(1,1,n,1,r+1-n,1); else sgt1::update(1,1,n,ps2+1-n,r+1-n,1); } else sgt1::pushnow(1,1); sgt1::modify(1,1,n,l,~ps2?sgt1::query(1,1,n,ps2&lt;=n?ps2:ps2-n)+1:1); } cout&lt;&lt;ans&lt;&lt;&apos; &apos;&lt;&lt;res; return 0;} G &#x8003;&#x8651;&#x5230;&#x4E00;&#x4E2A;&#x7B49;&#x5F0F;&#xFF1A; &#x2211;i=1ndi=&#x2211;i=1n(x&#x2212;xi)2+(y&#x2212;yi)2=n(x2+y2)&#x2212;2x&#x2211;i=1nxi&#x2212;2y&#x2211;i=1nyi+&#x2211;i=1nxi2+yi2\\begin{aligned} \\sum\\limits_{i=1}^nd_i=&amp;\\sum\\limits_{i=1}^n(x-x_i)^2+(y-y_i)^2\\\\ =&amp;n(x^2+y^2)-2x\\sum\\limits_{i=1}^nx_i-2y\\sum\\limits_{i=1}^ny_i+\\sum\\limits_{i=1}^nx_i^2+y_i^2 \\end{aligned} i=1&#x2211;n&#x200B;di&#x200B;==&#x200B;i=1&#x2211;n&#x200B;(x&#x2212;xi&#x200B;)2+(y&#x2212;yi&#x200B;)2n(x2+y2)&#x2212;2xi=1&#x2211;n&#x200B;xi&#x200B;&#x2212;2yi=1&#x2211;n&#x200B;yi&#x200B;+i=1&#x2211;n&#x200B;xi2&#x200B;+yi2&#x200B;&#x200B; &#x7136;&#x540E;&#x628A;&#x91CD;&#x5FC3; GGG &#x8BBE;&#x7F6E;&#x6210;&#x65B0;&#x7684;&#x539F;&#x70B9;&#xFF0C;&#x8FD9;&#x6837;&#x4E2D;&#x95F4;&#x4E24;&#x5768;&#x5C31;&#x6CA1;&#x4E86;&#xFF0C;&#x53D8;&#x4E3A;&#xFF1A; (x&#x2212;Gx)2+(x&#x2212;Gy)2=1n&#x2211;i=1ndi&#x2212;(xi&#x2212;Gx)2&#x2212;(yi&#x2212;Gy)2\\begin{aligned} (x-G_x)^2+(x-G_y)^2=\\frac1n\\sum\\limits_{i=1}^nd_i-(x_i-G_x)^2-(y_i-G_y)^2 \\end{aligned} (x&#x2212;Gx&#x200B;)2+(x&#x2212;Gy&#x200B;)2=n1&#x200B;i=1&#x2211;n&#x200B;di&#x200B;&#x2212;(xi&#x200B;&#x2212;Gx&#x200B;)2&#x2212;(yi&#x200B;&#x2212;Gy&#x200B;)2&#x200B; &#x4E0D;&#x96BE;&#x770B;&#x51FA;&#x8FD9;&#x662F;&#x4E00;&#x4E2A;&#x5706;&#x7684;&#x65B9;&#x7A0B;&#xFF0C;&#x5373;&#x6240;&#x6709;&#x6EE1;&#x8DB3;&#x8981;&#x6C42;&#x7684;&#x89E3;&#x90FD;&#x5728;&#x8FD9;&#x4E2A;&#x5706;&#x4E0A;&#xFF0C;&#x7136;&#x540E;&#x6211;&#x4EEC;&#x679A;&#x4E3E; a1a_1a1&#x200B; &#x6240;&#x5BF9;&#x7684;&#x534A;&#x5F84;&#x4E3A; did_idi&#x200B; &#x6765;&#x5F97;&#x5230;&#x4E00;&#x4E2A;&#x65B0;&#x7684;&#x5706;&#xFF0C;&#x6C42;&#x51FA;&#x6240;&#x6709;&#x5706;&#x7684;&#x4EA4;&#x70B9;&#x4E00;&#x4E00;&#x5E26;&#x5165;&#x9A8C;&#x8BC1;&#x662F;&#x5426;&#x5408;&#x6CD5;&#x5373;&#x53EF; &#x7531;&#x4E8E;&#x6570;&#x636E;&#x968F;&#x673A;&#x56E0;&#x6B64;&#x590D;&#x6742;&#x5EA6;&#x662F;&#x5BF9;&#x7684; &#x6CE8;&#x610F;&#x76F4;&#x63A5; longlonglong doubledoubledouble &#x6709;&#x53EF;&#x80FD;&#x4F1A;&#x70B8;&#x7CBE;&#x5EA6;&#xFF0C;&#x4E8E;&#x662F;&#x53EF;&#x4EE5;&#x5C01;&#x88C5;&#x4E00;&#x4E2A;&#x6A21;&#x610F;&#x4E49;&#x4E0B;&#x7684;&#x5B9E;&#x6570;&#x6765;&#x8FDB;&#x884C;&#x8FD0;&#x7B97; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline ll readl(){ ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}const int N=1e5+5;const long double eps=1e-10;inline int sgn(long double x){return (x&gt;eps)-(x&lt;-eps);}const int mod=1e9+7;inline int add(int a,int b){return (a+=b)&lt;mod?a:a-mod;}inline void Add(int&amp;a,int b){a=add(a,b);}inline int dec(int a,int b){return (a-=b)&lt;0?a+mod:a;}inline void Dec(int&amp;a,int b){a=dec(a,b);}inline int mul(int a,int b){return (ll)a*b%mod;}inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;}inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;}template&lt;class T&gt;struct modular{ T vl; explicit operator T()const{return vl;} modular(){vl=0;} modular(const ll&amp;v){vl=v&gt;=-mod&amp;&amp;v&lt;=mod?v:v%mod,vl&lt;0?vl+=mod:0;} friend inline bool operator==(const modular&amp;a,const modular&amp;b){return a.vl==b.vl;} friend inline bool operator!=(const modular&amp;a,const modular&amp;b){return a.vl!=b.vl;} friend inline bool operator&lt;(const modular&amp;a,const modular&amp;b){return a.vl&lt;b.vl;} friend inline bool operator&gt;(const modular&amp;a,const modular&amp;b){return a.vl&gt;b.vl;} friend inline bool operator&lt;=(const modular&amp;a,const modular&amp;b){return a.vl&lt;=b.vl;} friend inline bool operator&gt;=(const modular&amp;a,const modular&amp;b){return a.vl&gt;=b.vl;} inline modular operator-()const{return mod-vl;} friend inline modular operator+(const modular&amp;a,const modular&amp;b){return modular(a.vl+b.vl&lt;mod?a.vl+b.vl:a.vl+b.vl-mod);} friend inline void operator+=(modular&amp;a,const modular&amp;b){a=a+b;} friend inline modular operator-(const modular&amp;a,const modular&amp;b){return modular(a.vl&lt;b.vl?a.vl-b.vl+mod:a.vl-b.vl);} friend inline void operator-=(modular&amp;a,const modular&amp;b){a=a-b;} friend inline modular operator*(const modular&amp;a,const modular&amp;b){return modular((ll)a.vl*b.vl%mod);} friend inline void operator*=(modular&amp;a,const modular&amp;b){a=a*b;} friend inline modular operator^(modular a,ll p){modular ans=1;for(;p;p&gt;&gt;=1,a*=a)if(p&amp;1)ans*=a;return ans;} friend inline void operator^=(modular&amp;a,const ll&amp;p){a=a^p;} friend inline modular operator^(modular a,int p){modular ans=1;for(;p;p&gt;&gt;=1,a*=a)if(p&amp;1)ans*=a;return ans;} friend inline void operator^=(modular&amp;a,const int&amp;p){a=a^p;} friend inline modular inv(const modular&amp;a){return a^(mod-2);} friend inline modular operator/(const modular&amp;a,const modular&amp;b){return modular(a*inv(b));} friend inline void operator/=(modular&amp;a,const modular&amp;b){a=a/b;} };typedef modular&lt;int&gt; mi;struct F{ mi x,y; F(mi x=mi(0),mi y=mi(0)):x(x),y(y){} friend inline F operator+(F a,F b){return F(a.x+b.x,a.y+b.y);} friend inline void operator+=(F&amp;a,F b){a=a+b;} friend inline F operator-(F a,F b){return F(a.x-b.x,a.y-b.y);} friend inline void operator-=(F&amp;a,F b){a=a-b;} friend inline F operator/(F a,mi b){return F(a.x/b,a.y/b);} friend inline void operator/=(F&amp;a,mi b){a=a/b;} friend inline F operator*(F a,mi b){return F(a.x*b,a.y*b);} friend inline void operator*=(F&amp;a,mi b){a=a*b;} friend inline bool operator&lt;(F a,F b){return a.x!=b.x?a.x&lt;b.x:a.y&lt;b.y;} friend inline bool operator==(F a,F b){return a.x==b.x&amp;&amp;a.y==b.y;} inline mi mod()const{return x*x+y*y;}}a[N],G,O1,O2;int W;inline int rd(){return rand()|(rand()&lt;&lt;15);}struct cp{ int x,y; cp(int x=0,int y=0):x(x),y(y){} friend inline cp operator*(cp a,cp b){return cp(add(mul(a.x,b.x),mul(W,mul(a.y,b.y))),add(mul(a.x,b.y),mul(a.y,b.x)));} friend inline cp operator^(cp a,ll p){cp res=cp(1,0);for(;p;p&gt;&gt;=1,a=a*a)if(p&amp;1)res=res*a;return res;}};inline int Sqrt(int x){ if(x==0)return 0; if(ksm(x,(mod-1)&gt;&gt;1)==mod-1)return -1; int a; while(1){ a=(rd()%mod+mod)%mod,W=dec(mul(a,a),x); if(ksm(W,(mod-1)&gt;&gt;1)==mod-1){ int res=(cp(a,1)^((mod+1)&gt;&gt;1)).x; return min(res,mod-res); } }}int n;inline mi sq(mi x){return x*x;}inline ll fix(mi x){ int res=(int)x; if(res&gt;abs(res-mod))res-=mod; return res;}vector&lt;pair&lt;ll,ll&gt; &gt;res;ll d[N],_d[N];inline ll dist(ll x,ll y,ll a,ll b){return (x-a)*(x-a)+(y-b)*(y-b);}inline void check(F pt,ll dis){ ll dx=fix(pt.x),dy=fix(pt.y); if(dist(dx,dy,(int)a[1].x,(int)a[1].y)!=dis)return; for(ri i=1;i&lt;=n;++i)_d[i]=dist(dx,dy,(int)a[i].x,(int)a[i].y); sort(_d+1,_d+n+1); for(ri i=1;i&lt;=n;++i)if(_d[i]!=d[i])return; res.pb(make_pair(dx,dy));}inline void modify(F o1,mi r1,F o2,mi r2,ll dis){ mi a=(o1.x-o2.x)*2,b=(o1.y-o2.y)*2,c=r2-r1+o1.mod()-o2.mod(); if(a!=0){ b=b/a,c=c/a; mi A=b*b+1,B=(b*o1.x-b*c-o1.y)*2,C=(c-o1.x)*(c-o1.x)+o1.y*o1.y-r1,delta; B/=A,C/=A; delta=B*B-C*4; int res=Sqrt(delta.vl); mi x,y; if(res==-1)return; y=(-B+res)/2,x=c-y*b; check(F(x,y),dis); y=(-B-res)/2,x=c-y*b; check(F(x,y),dis); } else{ mi y=c/b; int s=Sqrt((r1-sq(o1.y-y)).vl); if(s==-1)return; check(F(o1.x+s,y),dis); check(F(o1.x-s,y),dis); }}mi dall=mi(0),Dall=mi(0),R1,R2;int main(){ srand(time(NULL)); #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(); for(ri i=1;i&lt;=n;++i)a[i].x=read(),a[i].y=read(),G=G+a[i],dall-=a[i].mod(); G=G/mi(n); if(a[1]==G)swap(a[1],a[2]); O1=G; O2=a[1]; dall+=n*G.mod(); for(ri tt=read();tt;--tt){ Dall=dall; for(ri i=1;i&lt;=n;++i)d[i]=readl(),Dall+=d[i]; sort(d+1,d+n+1); res.clear(); R1=Dall/n; for(ri i=1;i&lt;=n;++i){ if(i!=1&amp;&amp;d[i]==d[i-1])continue; R2=d[i]; modify(O1,R1,O2,R2,d[i]); } sort(res.begin(),res.end()); res.erase(unique(res.begin(),res.end()),res.end()); cout&lt;&lt;res.size()&lt;&lt;&apos; &apos;; for(ri i=0;i&lt;res.size();++i)cout&lt;&lt;res[i].fi&lt;&lt;&apos; &apos;&lt;&lt;res[i].se&lt;&lt;&apos; &apos;; puts(&quot;&quot;); } return 0;} &#x544A;&#x8F9E;","categories":[{"name":"public","slug":"public","permalink":"http://xdl030112.github.io/categories/public/"}],"tags":[{"name":"比赛题解","slug":"比赛题解","permalink":"http://xdl030112.github.io/tags/%E6%AF%94%E8%B5%9B%E9%A2%98%E8%A7%A3/"}]},{"title":"2019.10.03 模拟测试题解","slug":"191003test","date":"2019-10-03T07:07:45.000Z","updated":"2019-10-11T15:33:35.719Z","comments":true,"path":"191003test/","link":"","permalink":"http://xdl030112.github.io/191003test/","excerpt":"","text":"A &#x9898;&#x610F;&#x7B80;&#x8FF0;&#xFF1A; &#x7ED9;&#x51FA;&#x4E00;&#x4E2A; nnn &#x4E2A;&#x70B9; mmm &#x6761;&#x8FB9;&#x7684;&#x5E26;&#x6743;&#x6709;&#x5411;&#x56FE;&#xFF0C;&#x8981;&#x6C42;&#x5220;&#x53BB;&#x67D0;&#x4E9B;&#x8FB9;&#x4F7F;&#x5F97;&#x6700;&#x540E;&#x7684;&#x56FE;&#x6BCF;&#x4E2A;&#x70B9;&#x7684;&#x5165;&#x5EA6;&#x51FA;&#x5EA6;&#x5747;&#x4E0D;&#x80FD;&#x8D85;&#x8FC7; 111 &#xFF0C;&#x95EE;&#x5220;&#x53BB;&#x7684;&#x8FB9;&#x6743;&#x548C;&#x6700;&#x5C0F;&#x503C; &#x6570;&#x636E;&#x8303;&#x56F4;&#xFF1A; n&#x2264;200n\\le200n&#x2264;200 m&#x2264;10000m\\le10000m&#x2264;10000 &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x8003;&#x8651;&#x7B80;&#x5355;&#x8865;&#x96C6;&#x8F6C;&#x5316;&#xFF0C;&#x53D8;&#x4E3A;&#x6C42;&#x4FDD;&#x7559;&#x7684;&#x8FB9;&#x6743;&#x548C;&#x6700;&#x5927;&#x503C;&#xFF0C;&#x7136;&#x540E;&#x8003;&#x8651;&#x6309;&#x7167;&#x9898;&#x610F;&#x5EFA;&#x56FE;&#x53D8;&#x6210;&#x6700;&#x5927;&#x8D39;&#x7528;&#x6D41;&#x95EE;&#x9898;&#x6216;&#x8005;&#x8BF4;&#x4E8C;&#x5206;&#x56FE;&#x6700;&#x5927;&#x5339;&#x914D;&#x95EE;&#x9898; CODE cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_backusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch==&apos;-&apos;,ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;}typedef long long ll;typedef pair&lt;int,int&gt; pii;#define fi first#define se secondconst int N=10005,M=2e6+5,inf=0x3f3f3f3f;struct edge{int v,c,w,next;};int n,m;namespace mcmf{ ll dis[N],res,sum; int ps[N],cnt,first[N],s,t; bool in[N]; edge e[M]; inline void addedge(int u,int v,int c,int w){ e[++cnt]=(edge){v,c,w,first[u]}; first[u]=cnt; } inline void add(int u,int v,int c,int w){ addedge(u,v,c,w); addedge(v,u,0,-w); } inline void init(){memset(first,-1,sizeof(first)),cnt=-1,s=0,t=2*n+1,res=sum=0;} inline bool bfs(){ queue&lt;int&gt;q; for(ri i=s;i&lt;=t;++i)dis[i]=-inf,ps[i]=-1; in[s]=1,dis[s]=0,q.push(s); while(q.size()){ int x=q.front(); q.pop(); in[x]=0; for(ri i=first[x],v;~i;i=e[i].next){ v=e[i].v; if(e[i].c&gt;0&amp;&amp;dis[v]&lt;dis[x]+e[i].w){ dis[v]=dis[x]+e[i].w; ps[v]=i; if(!in[v])in[v]=1,q.push(v); } } } if(dis[t]==-inf)return 0; sum+=dis[t]; res=max(res,sum); int p=t; while(p^s)--e[ps[p]].c,++e[ps[p]^1].c,p=e[ps[p]^1].v; return 1; } inline ll solve(){ while(bfs()); return res; }}int main(){ n=read(),m=read(); ll ss=0; mcmf::init(); for(ri i=1;i&lt;=n;++i){ mcmf::add(mcmf::s,i,1,0); mcmf::add(i+n,mcmf::t,1,0); } for(ri i=1,u,v,w;i&lt;=m;++i){ u=read(),v=read(),w=read(); ss+=w; if(w&lt;=0)continue; mcmf::add(u,v+n,1,w); } cout&lt;&lt;ss-mcmf::solve(); return 0;} B &#x9898;&#x610F;&#x7B80;&#x8FF0;&#xFF1A; &#x7ED9;&#x51FA;&#x4E00;&#x4E2A; n&#x2217;mn*mn&#x2217;m &#x7684;&#x683C;&#x5B50;&#x8BA9;&#x4F60;&#x67D3;&#x8272;&#x5E76;&#x7ED9;&#x51FA;&#x67D3;&#x8272;&#x7684;&#x7EC8;&#x6001;&#xFF0C;&#x4FDD;&#x8BC1;&#x6BCF;&#x4E2A;&#x4F4D;&#x7F6E;&#x989C;&#x8272;&#x6570;&#x503C;&#x4E0D;&#x8D85;&#x8FC7; CCC &#xFF0C;&#x73B0;&#x5728;&#x6700;&#x521D;&#x683C;&#x5B50;&#x4E0A;&#x90FD;&#x672A;&#x88AB;&#x67D3;&#x8FC7;&#x8272;&#xFF0C;&#x6BCF;&#x6B21;&#x53EF;&#x4EE5;&#x628A;&#x67D0;&#x4E00;&#x884C;&#x6216;&#x8005;&#x67D0;&#x4E00;&#x5217;&#x67D3;&#x6210;&#x4E00;&#x4E2A;&#x76F8;&#x540C;&#x7684;&#x989C;&#x8272;&#xFF0C;&#x6C42;&#x67D3;&#x8272;&#x6B21;&#x6570;&#x6700;&#x5C11;&#x7684;&#x4EFB;&#x610F;&#x65B9;&#x6848;&#xFF0C;&#x65E0;&#x89E3;&#x8F93;&#x51FA; &#x2212;1-1&#x2212;1 &#x6570;&#x636E;&#x8303;&#x56F4;&#xFF1A; n,m&#x2264;50n,m\\le50n,m&#x2264;50 C&#x2264;100C\\le100C&#x2264;100 &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x5148;&#x601D;&#x8003;&#x5982;&#x4F55;&#x5F97;&#x5230;&#x53EF;&#x884C;&#x89E3;&#xFF0C;&#x7136;&#x540E;&#x5BF9;&#x67D3;&#x8272;&#x6B21;&#x6570;&#x8FDB;&#x884C;&#x4F18;&#x5316; &#x8003;&#x8651;&#x65F6;&#x95F4;&#x5012;&#x6D41;&#xFF0C;&#x6700;&#x540E;&#x67D3;&#x4E0A;&#x989C;&#x8272;&#x540E;&#x4E00;&#x5B9A;&#x67D0;&#x4E00;&#x884C;&#x6216;&#x8005;&#x67D0;&#x4E00;&#x5217;&#x662F;&#x540C;&#x4E00;&#x79CD;&#x989C;&#x8272;&#xFF0C;&#x8003;&#x8651;&#x5220;&#x53BB;&#x8FD9;&#x6837;&#x7684;&#x884C;&#x6216;&#x8005;&#x5217;&#x7136;&#x540E;&#x5BF9;&#x5269;&#x4E0B;&#x7684;&#x77E9;&#x9635;&#x8FED;&#x4EE3;&#x8BE5;&#x64CD;&#x4F5C;&#xFF0C;&#x6700;&#x540E;&#x5982;&#x679C;&#x5408;&#x6CD5;&#x4E00;&#x5B9A;&#x5269;&#x4E0B;&#x4E00;&#x4E2A;&#x5168;&#x96F6;&#x77E9;&#x9635;&#xFF0C;&#x5426;&#x5219;&#x5C31;&#x975E;&#x6CD5; &#x8FD9;&#x6837;&#x5C31;&#x6210;&#x529F;&#x5F97;&#x5230;&#x4E86;&#x4E00;&#x4E2A;&#x53EF;&#x884C;&#x89E3;&#xFF0C;&#x7136;&#x540E;&#x4E0B;&#x9762;&#x8003;&#x8651;&#x4E24;&#x4E2A;&#x7B80;&#x5355;&#x4F18;&#x5316;&#xFF1A; &#x5047;&#x5982;&#x5F53;&#x524D;&#x975E;&#x96F6;&#x884C;&#x7684;&#x4E2A;&#x6570;&#x4E0D;&#x8D85;&#x8FC7;&#x975E;&#x96F6;&#x5217;&#x7684;&#x4E2A;&#x6570;&#xFF0C;&#x90A3;&#x4E48;&#x4F18;&#x5148;&#x6D88;&#x53BB;&#x4E00;&#x884C;&#xFF0C;&#x5426;&#x5219;&#x4F18;&#x5148;&#x6D88;&#x53BB;&#x4E00;&#x5217; &#x5047;&#x5982;&#x5F53;&#x524D;&#x6709;&#x82E5;&#x5E72;&#x4E2A;&#x5408;&#x6CD5;&#x7684;&#x884C;/&#x5217;&#xFF0C;&#x5C06;&#x5176;&#x6309;&#x7167;&#x989C;&#x8272;&#x5206;&#x7C7B;&#xFF0C;&#x7136;&#x540E;&#x4F18;&#x5148;&#x6D88;&#x53BB;&#x67D0;&#x79CD;&#x53EF;&#x884C;&#x6B21;&#x6570;&#x6700;&#x5C11;&#x7684;&#x989C;&#x8272;&#x5BF9;&#x5E94;&#x7684;&#x4EFB;&#x610F;&#x4E00;&#x884C;/&#x5217; &#x8FD9;&#x6837;&#x53EF;&#x4EE5;&#x901A;&#x8FC7;&#x73B0;&#x6709;&#x7684;&#x6240;&#x6709;&#x6570;&#x636E;&#x70B9; &#x60F3;&#x5FC5;&#x4F1A;&#x6709;&#x6570;&#x636E;&#x80FD;&#x591F;&#xD7;&#x6389;&#x4E0A;&#x8FF0;&#x505A;&#x6CD5;&#xFF0C;&#x6BD5;&#x7ADF;&#x6B63;&#x89E3;&#x8981;&#x52A0;&#x4E00;&#x4E2A;topsoort&#x5E76;&#x4E14;&#x7B14;&#x8005;&#x5E76;&#x4E0D;&#x4F1A;&#x8BC1;&#x660E;&#x4E0A;&#x8FF0;&#x505A;&#x6CD5;&#x6B63;&#x786E;&#x6027; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch==&apos;-&apos;,ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;}typedef long long ll;typedef pair&lt;int,int&gt; pii;int n,m,a[55][55],C;struct F{ int op,x,y; F(int op=0,int x=0,int y=0):op(op),x(x),y(y){}};int cnt1[155],cnt2[155],Ps1[155],Ps2[155];vector&lt;F&gt;res;int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(),m=read(),C=read(); for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=m;++j)a[i][j]=read(); vector&lt;int&gt;X,Y; for(ri i=1;i&lt;=n;++i)X.pb(i); for(ri i=1;i&lt;=m;++i)Y.pb(i); while(X.size()&amp;&amp;Y.size()){ int ct1=0,ct2=0; for(ri i=1;i&lt;=C;++i)cnt1[i]=0,cnt2[i]=0; for(ri i=0;i&lt;X.size();++i){ bool ff=1; for(ri j=0;j&lt;Y.size();++j)if(a[X[i]][Y[j]]){ ff=0; break; } if(ff)++ct1; } for(ri i=0;i&lt;Y.size();++i){ bool ff=1; for(ri j=0;j&lt;X.size();++j)if(a[X[j]][Y[i]]){ ff=0; break; } if(ff)++ct2; } if(ct1==X.size())break; int ps1=-1; for(ri i=0;i&lt;X.size();++i){ bool ff=1; for(ri j=0;j&lt;Y.size();++j){ if(!a[X[i]][Y[j]]||(j&amp;&amp;a[X[i]][Y[j]]!=a[X[i]][Y[j-1]])){ ff=0; break; } } if(ff){ ps1=i; ++cnt1[a[X[i]][Y[0]]]; Ps1[a[X[i]][Y[0]]]=i; } } int ps2=-1; for(ri i=0;i&lt;Y.size();++i){ bool ff=1; for(ri j=0;j&lt;X.size();++j){ if(!a[X[j]][Y[i]]||(j&amp;&amp;a[X[j]][Y[i]]!=a[X[j-1]][Y[i]])){ ff=0; break; } } if(ff){ ps2=i; ++cnt2[a[X[0]][Y[i]]]; Ps2[a[X[0]][Y[i]]]=i; } } if(ps1==-1&amp;&amp;ps2==-1){ puts(&quot;-1&quot;); return 0; } if(X.size()-ct1&lt;Y.size()-ct2){ if(~ps1){ int mn=0x3f3f3f3f; for(ri i=1;i&lt;=C;++i)if(cnt1[i])mn=min(mn,cnt1[i]); for(ri i=1;i&lt;=C;++i)if(cnt1[i]==mn){ps1=Ps1[i];break;} res.pb(F(1,X[ps1],a[X[ps1]][Y[0]])); for(ri i=ps1+1;i&lt;X.size();++i)X[i-1]=X[i]; X.pop_back(); continue; } else{ int mn=0x3f3f3f3f; for(ri i=1;i&lt;=C;++i)if(cnt2[i])mn=min(mn,cnt2[i]); for(ri i=1;i&lt;=C;++i)if(cnt2[i]==mn){ps2=Ps2[i];break;} res.pb(F(0,Y[ps2],a[X[0]][Y[ps2]])); for(ri i=ps2+1;i&lt;Y.size();++i)Y[i-1]=Y[i]; Y.pop_back(); continue; } } else{ if(~ps2){ int mn=0x3f3f3f3f; for(ri i=1;i&lt;=C;++i)if(cnt2[i])mn=min(mn,cnt2[i]); for(ri i=1;i&lt;=C;++i)if(cnt2[i]==mn){ps2=Ps2[i];break;} res.pb(F(0,Y[ps2],a[X[0]][Y[ps2]])); for(ri i=ps2+1;i&lt;Y.size();++i)Y[i-1]=Y[i]; Y.pop_back(); continue; } else{ int mn=0x3f3f3f3f; for(ri i=1;i&lt;=C;++i)if(cnt1[i])mn=min(mn,cnt1[i]); for(ri i=1;i&lt;=C;++i)if(cnt1[i]==mn){ps1=Ps1[i];break;} res.pb(F(1,X[ps1],a[X[ps1]][Y[0]])); for(ri i=ps1+1;i&lt;X.size();++i)X[i-1]=X[i]; X.pop_back(); continue; } } } cout&lt;&lt;res.size()&lt;&lt;&apos;\\n&apos;; for(ri i=res.size()-1;~i;--i){ if(res[i].op)cout&lt;&lt;&quot;R &quot;; else cout&lt;&lt;&quot;C &quot;; cout&lt;&lt;res[i].x&lt;&lt;&apos; &apos;&lt;&lt;res[i].y&lt;&lt;&apos;\\n&apos;; } return 0;} C &#x9898;&#x610F;&#x7B80;&#x8FF0;&#xFF1A; &#x7ED9;&#x4F60;&#x4E00;&#x68F5;&#x5E26;&#x6743;&#x6811;&#xFF0C;&#x6BCF;&#x4E2A;&#x70B9;&#x6709;&#x4E00;&#x4E2A;&#x9650;&#x5236; did_idi&#x200B; &#xFF0C;&#x73B0;&#x5728;&#x4ECE;&#x65F6;&#x523B; 000 &#x5F00;&#x59CB;&#x7684;&#x6BCF;&#x4E2A;&#x65F6;&#x523B;&#xFF0C;&#x5BF9;&#x4E8E;&#x6BCF;&#x4E2A;&#x9650;&#x5236;&#x88AB;&#x6253;&#x7834;&#x7684;&#x8282;&#x70B9;&#x4F1A;&#x6709;&#x4E00;&#x4E2A;&#x4EBA;&#x51FA;&#x53D1;&#x5411;&#x6839;&#x8D70;&#xFF0C;&#x6BCF;&#x4E2A;&#x5355;&#x4F4D;&#x65F6;&#x95F4;&#x884C;&#x8D70;&#x4E00;&#x4E2A;&#x5355;&#x4F4D;&#x957F;&#x5EA6;&#xFF0C;&#x5F53;&#x4E00;&#x4E2A;&#x4EBA;&#x7ECF;&#x8FC7;&#x67D0;&#x4E2A;&#x70B9;&#x65F6;&#xFF0C;&#x5982;&#x679C;&#x5176;&#x9650;&#x5236;&#x672A;&#x88AB;&#x6253;&#x7834;&#xFF0C;&#x90A3;&#x4E48;&#x8BE5;&#x70B9;&#x9650;&#x5236;&#x51CF;&#x4E00;&#xFF0C;&#x5F53;&#x9650;&#x5236;&#x4E3A; 000 &#x65F6;&#x5C31;&#x89C6;&#x4E3A;&#x88AB;&#x6253;&#x7834;&#xFF0C;&#x4FDD;&#x8BC1;&#x53F6;&#x5B50;&#x7684;&#x9650;&#x5236;&#x4E00;&#x5B9A;&#x662F; 000 &#xFF0C;&#x8BE2;&#x95EE;&#x6811;&#x4E0A;&#x7684;&#x6240;&#x6709;&#x53F6;&#x5B50;&#x7684;&#x9650;&#x5236;&#x5168;&#x90E8;&#x88AB;&#x6253;&#x7834;&#x7684;&#x65F6;&#x523B; &#x6570;&#x636E;&#x8303;&#x56F4;&#xFF1A; n&#x2264;105n\\le10^5n&#x2264;105 wi&#x2264;1000w_i\\le1000wi&#x200B;&#x2264;1000 di&#x2264;108d_i\\le10^8di&#x200B;&#x2264;108 &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x8003;&#x8651;&#x5BF9;&#x6BCF;&#x4E2A;&#x8282;&#x70B9;&#x5EFA;&#x7ACB;&#x65F6;&#x523B;&#x4E3A;&#x6A2A;&#x8F74;&#xFF0C;&#x5DF2;&#x7ECF;&#x8FC7;&#x4EBA;&#x6570;&#x4E3A;&#x7EB5;&#x8F74;&#x7684;&#x51FD;&#x6570;&#x56FE;&#x50CF;&#xFF0C;&#x8FD9;&#x6837;&#x7684;&#x8BDD;&#x5BF9;&#x4E8E;&#x6BCF;&#x4E2A;&#x8282;&#x70B9;&#x76F8;&#x5F53;&#x4E8E;&#x8981;&#x652F;&#x6301;&#x5982;&#x4E0B;&#x64CD;&#x4F5C;&#xFF1A; &#x5C06;&#x67D0;&#x4E2A;&#x5B50;&#x6811;&#x7684;&#x51FD;&#x6570;&#x56FE;&#x50CF;&#x7684;&#x6A2A;&#x5750;&#x6807;&#x6574;&#x4F53;&#x53F3;&#x79FB;&#x4E00;&#x4E2A;&#x503C; &#x5C06;&#x6240;&#x6709;&#x5B50;&#x6811;&#x7684;&#x51FD;&#x6570;&#x56FE;&#x50CF;&#x7ED9;&#x53E0;&#x52A0;&#x8D77;&#x6765; &#x5728;&#x5DF2;&#x7ECF;&#x53E0;&#x52A0;&#x597D;&#x7684;&#x56FE;&#x50CF;&#x4E2D;&#x6C42;&#x51FA;&#x81EA;&#x5DF1;&#x6253;&#x7834;&#x9650;&#x5236;&#x7684;&#x65F6;&#x95F4; &#x5C06;&#x81EA;&#x5DF1;&#x6253;&#x7834;&#x9650;&#x5236;&#x4E4B;&#x540E;&#x7684;&#x4E00;&#x6B21;&#x51FD;&#x6570;&#x52A0;&#x5230;&#x56FE;&#x50CF;&#x4E2D; &#x90A3;&#x4E48;&#x8FD9;&#x5C31;&#x6210;&#x4E86;&#x4E00;&#x9053;&#x7ECF;&#x5178;&#x7684;&#x6298;&#x7EBF;&#x9898;&#xFF0C;&#x8003;&#x8651;&#x7EF4;&#x62A4;&#x6240;&#x6709;&#x62D0;&#x70B9;&#xFF0C;&#x90A3;&#x4E48;&#x8981;&#x7EF4;&#x62A4;&#x7684;&#x5C31;&#x662F;&#x6574;&#x4F53;&#x6253;&#x6807;&#x8BB0;&#xFF0C;&#x5E73;&#x8861;&#x6811;+&#x542F;&#x53D1;&#x5F0F;&#x5408;&#x5E76;&#xFF0C;&#x4E8C;&#x5206;&#x6C42;&#x7B54;&#x6848;&#x548C;&#x5355;&#x70B9;&#x63D2;&#x5165;&#xFF0C;&#x76F4;&#x63A5;&#x7528; TreapTreapTreap &#x7EF4;&#x62A4;&#x5373;&#x53EF; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch==&apos;-&apos;,ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;}typedef long long ll;typedef pair&lt;int,int&gt; pii;const int N=1e5+5;inline int rnd(){return rand()|(rand()&lt;&lt;15);}int rt[N],n,lm[N],tim[N],det[N];vector&lt;pii&gt;e[N];vector&lt;int&gt;tp;namespace bst{ #define lc (son[p][0]) #define rc (son[p][1]) int rd[N],vl[N],siz[N],tot=0,top=0,stk[N*20],son[N][2]; ll ss[N]; inline int newidx(){return top?stk[top--]:++tot;} inline int newnode(int v){ int p=newidx(); lc=rc=0,vl[p]=ss[p]=v,rd[p]=rnd(),siz[p]=1; return p; } inline void pushup(int p){ siz[p]=siz[lc]+1+siz[rc]; ss[p]=ss[lc]+vl[p]+ss[rc]; } inline int merge(int a,int b){ if(!a||!b)return a|b; if(rd[a]&lt;rd[b])return son[a][1]=merge(son[a][1],b),pushup(a),a; return son[b][0]=merge(a,son[b][0]),pushup(b),b; } inline pii split(int p,int k){ if(!p)return pii(0,0); pii res; if(siz[lc]&gt;=k)return res=split(lc,k),lc=res.se,pushup(p),pii(res.fi,p); return res=split(rc,k-siz[lc]-1),rc=res.fi,pushup(p),pii(p,res.se); } inline int rank(int p,int v){ if(!p)return 0; if(vl[p]&lt;=v)return siz[lc]+1+rank(rc,v); return rank(lc,v); } inline void insert(int _rt,int v){ int k=rank(rt[_rt],v); pii x=split(rt[_rt],k); rt[_rt]=merge(x.fi,merge(newnode(v),x.se)); } inline void update(int p,int det){ if(!p)return; update(lc,det),update(rc,det); stk[++top]=p; tp.pb(vl[p]+det); } inline int query(int _rt,int lm){ int l=-1e9,r=1e9,res=1e9,mid,k; while(l&lt;=r){ mid=l+r&gt;&gt;1,k=rank(rt[_rt],mid); pii x=split(rt[_rt],k); if((ll)mid*siz[x.fi]-ss[x.fi]&gt;=lm)r=mid-1,res=mid; else l=mid+1; rt[_rt]=merge(x.fi,x.se); } return res; } #undef lc #undef rc}inline void Merge(int a,int b){ if(bst::siz[rt[a]]&lt;bst::siz[rt[b]])swap(rt[a],rt[b]),swap(det[a],det[b]); bst::update(rt[b],det[b]-det[a]); while(tp.size())bst::insert(a,tp.back()),tp.pop_back();}int ans=0,q[N],fa[N],vll[N],hd,tl;int main(){ srand(time(NULL)); #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(); for(ri i=1;i&lt;=n;++i)lm[i]=read(); for(ri i=1,u,v,w;i&lt;n;++i){ u=read(),v=read(),w=read(); e[u].pb(pii(v,w)); e[v].pb(pii(u,w)); } q[hd=tl=1]=1; while(hd&lt;=tl){ int x=q[hd++]; for(ri i=0,v;i&lt;e[x].size();++i){ if((v=e[x][i].fi)==fa[x])continue; vll[v]=e[x][i].se,fa[v]=x,q[++tl]=v; } } for(ri p,ft,i=n;i;--i){ p=q[i],ft=fa[p]; if(!lm[p])tim[p]=-det[p]; else tim[p]=bst::query(p,lm[p]); ans=max(ans,det[p]+tim[p]); bst::insert(p,tim[p]); det[p]+=vll[p]; if(ft)Merge(ft,p); } cout&lt;&lt;ans; return 0;}","categories":[{"name":"private","slug":"private","permalink":"http://xdl030112.github.io/categories/private/"}],"tags":[{"name":"考试题解","slug":"考试题解","permalink":"http://xdl030112.github.io/tags/%E8%80%83%E8%AF%95%E9%A2%98%E8%A7%A3/"}]},{"title":"2019.10.02 模拟测试题解","slug":"191002test","date":"2019-10-02T12:49:11.000Z","updated":"2019-10-11T15:33:36.965Z","comments":true,"path":"191002test/","link":"","permalink":"http://xdl030112.github.io/191002test/","excerpt":"","text":"&#x9898;&#x76EE;&#x6765;&#x6E90;&#xFF1A; A:TCO499A:TCO499A:TCO499 1000pts1000pts1000pts B:CF613EB:CF613EB:CF613E C:&#x51FA;&#x9898;&#x4EBA;&#x539F;&#x521B;C:&#x51FA;&#x9898;&#x4EBA;&#x539F;&#x521B;C:&#x51FA;&#x9898;&#x4EBA;&#x539F;&#x521B; A &#x9898;&#x610F;&#x7B80;&#x8FF0;&#xFF1A; &#x5728;&#x521D;&#x59CB;&#x4F60;&#x81EA;&#x5DF1;&#x521B;&#x9020;&#x4E00;&#x4E2A;&#x7531; A,B,C,DA,B,C,DA,B,C,D &#x7EC4;&#x6210;&#x7684;&#x957F;&#x5EA6;&#x4E3A; nnn &#x7684;&#x5B57;&#x7B26;&#x4E32;&#xFF0C;&#x7ED9;&#x51FA;&#x6709; mmm &#x79CD;&#x8F6C;&#x79FB;&#xFF0C;&#x6BCF;&#x79CD;&#x8F6C;&#x79FB;&#x7528;&#x4E24;&#x4E2A;&#x957F;&#x5EA6;&#x76F8;&#x540C;&#x7684; ABCDABCDABCD &#x4E32;&#x6765;&#x8868;&#x793A;&#xFF0C;&#x524D;&#x8005;&#x53EF;&#x4EE5;&#x53D8;&#x6210;&#x540E;&#x8005;&#xFF0C;&#x7136;&#x540E;&#x8FDB;&#x884C;&#x82E5;&#x5E72;&#x6B21;&#x5982;&#x4E0B;&#x4E24;&#x79CD;&#x64CD;&#x4F5C;&#xFF1A; &#x4EA4;&#x6362;&#x5176;&#x4E2D;&#x4E24;&#x4E2A;&#x76F8;&#x90BB;&#x5B57;&#x7B26; &#x8FDB;&#x884C;&#x4E00;&#x6B21;&#x8F6C;&#x79FB; &#x95EE;&#x5F97;&#x5230;&#x7684;&#x4E0D;&#x540C;&#x5B57;&#x7B26;&#x4E32;&#x6570;&#x7684;&#x6700;&#x5927;&#x503C; &#x6570;&#x636E;&#x8303;&#x56F4;&#xFF1A; n&#x2264;30n\\le30n&#x2264;30 m&#x2264;50m\\le50m&#x2264;50 &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x5206;&#x6790;&#x4E24;&#x79CD;&#x64CD;&#x4F5C;&#xFF0C;&#x7B2C;&#x4E00;&#x4E2A;&#x64CD;&#x4F5C;&#x76F8;&#x5F53;&#x4E8E;&#x544A;&#x8BC9;&#x6211;&#x4EEC;&#x4E00;&#x4E2A;&#x5B57;&#x7B26;&#x4E32;&#x53EF;&#x4EE5;&#x7531;&#x4EE5;&#x4E0B;&#x4FE1;&#x606F;&#x8868;&#x793A; (cnta,cntb,cntc,cntd)(cnt_a,cnt_b,cnt_c,cnt_d)(cnta&#x200B;,cntb&#x200B;,cntc&#x200B;,cntd&#x200B;) &#xFF0C;&#x800C;&#x65B9;&#x6848;&#x6570;&#x5219;&#x662F; Caa&#xD7;Ca+bb&#xD7;Ca+b+cc&#x2217;Ca+b+c+ddC_{a}^a\\times C_{a+b}^b\\times C_{a+b+c}^c*C_{a+b+c+d}^dCaa&#x200B;&#xD7;Ca+bb&#x200B;&#xD7;Ca+b+cc&#x200B;&#x2217;Ca+b+c+dd&#x200B; &#xFF0C;&#x7B2C;&#x4E8C;&#x4E2A;&#x64CD;&#x4F5C;&#x76F8;&#x5F53;&#x4E8E;&#x662F;&#x5EFA;&#x7ACB;&#x8FB9;&#xFF0C;&#x8FD9;&#x6837;&#x76F8;&#x5F53;&#x4E8E;&#x6C42;&#x4E00;&#x4E2A;&#x6709;&#x5411;&#x56FE;&#x7684;&#x5E26;&#x6743;&#x6700;&#x957F;&#x94FE;&#x957F;&#x5EA6;&#xFF0C;&#x53EA;&#x9700;&#x8981;&#x6309;&#x7167;&#x9898;&#x610F;&#x5EFA;&#x51FA;&#x56FE;&#x6765;&#x7136;&#x540E;&#x7528; tarjan+topsorttarjan+topsorttarjan+topsort &#x5373;&#x53EF; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_backusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s){ int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;}typedef long long ll;const int mod=998244353;inline int add(int a,int b){return (a+=b)&lt;mod?a:a-mod;}inline void Add(int&amp;a,int b){a=add(a,b);}inline int dec(int a,int b){return (a-=b)&lt;0?a+mod:a;}inline void Dec(int&amp;a,int b){a=dec(a,b);}inline int mul(int a,int b){return (ll)a*b%mod;}inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;}inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;}const int N=1e6+5;int n,m,all,col[N],trans[2][55][5];bool in[N];ll res=0,F[N],vl[N],C[35][35],mx[N];vector&lt;int&gt;e[N],E[N];char s[35];inline int idx(int a,int b,int c,int d){return (n+1)*(n+1)*(n+1)*a+(n+1)*(n+1)*b+(n+1)*c+d;}inline void init(){ for(ri i=0;i&lt;=n;++i){ C[i][0]=1; for(ri j=1;j&lt;=i;++j)C[i][j]=C[i-1][j-1]+C[i-1][j]; } for(ri a=0,d;a&lt;=n;++a)for(ri b=0;a+b&lt;=n;++b) for(ri c=0;a+b+c&lt;=n;++c){ d=n-a-b-c; F[idx(a,b,c,d)]=C[a][a]*C[a+b][b]*C[n-d][c]*C[n][d]; }}int tot=0,top=0,sig=0,dfn[N],low[N],stk[N],du[N];inline void dfs(int p){ dfn[p]=low[p]=++tot; in[stk[++top]=p]=1; for(ri i=0,v;i&lt;e[p].size();++i){ if(!dfn[v=e[p][i]])dfs(v),low[p]=min(low[p],low[v]); else if(in[v])low[p]=min(low[p],dfn[v]); } if(dfn[p]==low[p]){ ++sig; int x; while(1){ x=stk[top--]; col[x]=sig,in[x]=0; vl[sig]+=F[x]; if(x==p)break; } }}inline void topsort(){ queue&lt;int&gt;q; for(ri i=1;i&lt;=sig;++i)if(!du[i])q.push(i),mx[i]=vl[i]; while(q.size()){ int x=q.front(); q.pop(); for(ri i=0,v;i&lt;E[x].size();++i){ v=E[x][i]; mx[v]=max(mx[v],mx[x]+vl[v]); if(!(--du[v]))q.push(v); } } for(ri i=1;i&lt;=sig;++i)res=max(res,mx[i]); cout&lt;&lt;res;}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(),m=read(); init(); for(ri len,i=1;i&lt;=m;++i)for(ri t=0;t&lt;2;++t){len=Read(s);for(ri j=1;j&lt;=len;++j)++trans[t][i][s[j]-&apos;A&apos;+1];} int all=n*(n+1)*(n+1)*(n+1); for(ri a=0,d,_a,_b,_c,_d;a&lt;=n;++a)for(ri b=0;a+b&lt;=n;++b) for(ri c=0;a+b+c&lt;=n;++c){ d=n-a-b-c; for(ri i=1;i&lt;=m;++i){ _a=a-trans[0][i][1]; if(_a&lt;0)continue; _a+=trans[1][i][1]; _b=b-trans[0][i][2]; if(_b&lt;0)continue; _b+=trans[1][i][2]; _c=c-trans[0][i][3]; if(_c&lt;0)continue; _c+=trans[1][i][3]; _d=d-trans[0][i][4]; if(_d&lt;0)continue; _d+=trans[1][i][4]; e[idx(a,b,c,d)].pb(idx(_a,_b,_c,_d)); } } for(ri i=1;i&lt;=all;++i)if(!dfn[i])dfs(i); for(ri i=1;i&lt;=all;++i)for(ri j=0;j&lt;e[i].size();++j)if(col[i]^col[e[i][j]])E[col[i]].pb(col[e[i][j]]),++du[col[e[i][j]]]; topsort(); return 0;} B &#x9898;&#x610F;&#x7B80;&#x8FF0;&#xFF1A; &#x7ED9;&#x51FA;&#x4E00;&#x4E2A; 2&#xD7;n2\\times n2&#xD7;n &#x7684;&#x77E9;&#x9635; A\\boldsymbol{A}A &#xFF0C;&#x77E9;&#x9635;&#x4E2D;&#x6BCF;&#x4E2A;&#x683C;&#x5B50;&#x90FD;&#x662F;&#x4E00;&#x4E2A;&#x5C0F;&#x5199;&#x5B57;&#x6BCD;&#xFF0C;&#x540C;&#x65F6;&#x6709;&#x4E00;&#x4E2A;&#x957F;&#x5EA6;&#x4E3A; MMM &#x7684;&#x5B57;&#x7B26;&#x4E32; SSS&#x95EE;&#x5728;&#x77E9;&#x9635;&#x4E2D;&#x8D77;&#x70B9;&#x548C;&#x7EC8;&#x70B9;&#x4EFB;&#x610F;&#xFF0C;&#x53EA;&#x5141;&#x8BB8;&#x5411;&#x4E0A;&#x3001;&#x4E0B;&#x3001;&#x5DE6;&#x3001;&#x53F3;&#x8D70;&#xFF0C;&#x4E0D;&#x7ECF;&#x8FC7;&#x91CD;&#x590D;&#x683C;&#x5B50;&#xFF0C;&#x4E14;&#x4F9D;&#x6B21;&#x7ECF;&#x8FC7;&#x7684;&#x5B57;&#x6BCD;&#x8FDE;&#x8D77;&#x6765;&#x662F; SSS &#x7684;&#x8DEF;&#x5F84;&#x6709;&#x591A;&#x5C11;&#x79CD;&#x3002; &#x6570;&#x636E;&#x8303;&#x56F4;&#xFF1A; n&#x2264;2000n\\le2000n&#x2264;2000 m&#x2264;2000m\\le2000m&#x2264;2000 &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x8BBE;&#x8DEF;&#x5F84;&#x7684;&#x5F00;&#x5934;&#x7ED3;&#x5C3E;&#x662F; S,TS,TS,T &#xFF0C;&#x90A3;&#x4E48;&#x6240;&#x6709;&#x5408;&#x6CD5;&#x8DEF;&#x5F84;&#x53EF;&#x4EE5;&#x5212;&#x5206;&#x6210;&#x4E09;&#x6BB5; &#xFF1B; &#x4ECE; SSS &#x5F00;&#x59CB;&#x5411;&#x5DE6;&#x8D70;&#x4E00;&#x6BB5;&#x7136;&#x540E;&#x8D70;&#x56DE;&#x6765; &#x4ECE; TTT &#x5F00;&#x59CB;&#x5411;&#x53F3;&#x8D70;&#x4E00;&#x6BB5;&#x7136;&#x540E;&#x8D70;&#x56DE;&#x6765; &#x4E2D;&#x95F4;&#x6BB5;&#x4E0A;&#x4E0B;&#x4E0A;&#x4E0B;&#x7684;&#x5411;&#x53F3;&#x8D70; &#x7136;&#x540E;&#x8003;&#x8651;&#x5BF9;&#x4E2D;&#x95F4;&#x7684;&#x8FDB;&#x884C; dpdpdp&#xFF0C;&#x8BBE; fi,j,kf_{i,j,k}fi,j,k&#x200B; &#x8868;&#x793A;&#x8D70;&#x5230;&#x7B2C; iii &#x884C; jjj &#x5217;&#x5339;&#x914D;&#x5230;&#x7B2C; kkk &#x4E2A;&#x5B57;&#x7B26;&#x7684;&#x65B9;&#x6848;&#x6570;&#xFF0C;&#x5DE6;&#x8FB9;&#x548C;&#x53F3;&#x8FB9;&#x76F4;&#x63A5;&#x7528; hashhashhash &#x641E;&#x4E00;&#x4E0B;&#xFF0C;&#x6CE8;&#x610F;&#x7EC6;&#x8282;&#x5373;&#x53EF; CODE cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;const int mod=1e9+7,N=2005,bas=137;inline int add(const int&amp;a,const int&amp;b){return a+b&gt;=mod?a+b-mod:a+b;}inline int dec(const int&amp;a,const int&amp;b){return a&gt;=b?a-b:a-b+mod;}inline int mul(const int&amp;a,const int&amp;b){return (ll)a*b%mod;}inline void update(int&amp;a,const int&amp;b){a=add(a,b);}inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,a=mul(a,a))if(p&amp;1)ret=mul(ret,a);return ret;}int n,m;int ans,fl[2][N][N],fr[2][N][N],pre[2][N],suf[2][N],h1[N],h2[N],hs[N],ihs[N];char s[2][N],t[N];inline int get_nl(int id,int l,int r){return mul(dec(pre[id][r],mul(pre[id][l-1],hs[r-l+1])),ihs[r-l+1]);}inline int get_nr(int id,int l,int r){return mul(dec(suf[id][r],mul(suf[id][l+1],hs[l-r+1])),ihs[l-r+1]);}inline int get_ml(int l,int r){return mul(dec(h1[r],mul(h1[l-1],hs[r-l+1])),ihs[r-l+1]);}inline int get_mr(int l,int r){return mul(dec(h2[r],mul(h2[l+1],hs[l-r+1])),ihs[l-r+1]);}inline void init_n(){ for(ri i=1;i&lt;=n;++i)for(ri j=0;j&lt;2;++j)pre[j][i]=add(mul(pre[j][i-1],bas),s[j][i]); for(ri i=n;i;--i)for(ri j=0;j&lt;2;++j)suf[j][i]=add(mul(suf[j][i+1],bas),s[j][i]);}inline void init_m(){ for(ri i=1;i&lt;=m;++i)h1[i]=add(mul(h1[i-1],bas),t[i]); for(ri i=m;i;--i)h2[i]=add(mul(h2[i+1],bas),t[i]);}inline void init(){ hs[0]=ihs[0]=1; for(ri i=1;i&lt;=n;++i)hs[i]=mul(hs[i-1],bas),ihs[i]=ksm(hs[i],mod-2); init_n(); init_m();}int main(){ scanf(&quot;%s%s%s&quot;,s[0]+1,s[1]+1,t+1); n=strlen(s[0]+1),m=strlen(t+1); init(); for(ri i=1;i&lt;=n;++i){ for(ri id=0;id&lt;2;++id)update(fl[id][i+1][2],s[id][i]==t[1]),update(fr[id][i+1][m-1],(m^1)&amp;&amp;s[id][i]==t[m]); for(ri j=2,up=min(n-i+1,m/2);j&lt;=up;++j)for(ri id=0;id&lt;2;++id){ update(ans,get_nl(id^1,i,i+j-1)==get_mr(m,m-j+1)&amp;&amp;get_nr(id,i+j-1,i)==get_mr(m-j,m-j*2+1)&amp;&amp;j*2==m); update(ans,get_nl(id^1,i,i+j-1)==get_mr(m,m-j+1)&amp;&amp;get_nr(id,i+j-1,i)==get_mr(m-j,m-j*2+1)?fl[id][i][m-j*2+1]:0); update(ans,get_nl(id^1,i,i+j-1)==get_ml(1,j)&amp;&amp;get_nr(id,i+j-1,i)==get_ml(j+1,j*2)?fr[id][i][j*2]:0); } for(ri j=1;j&lt;=m;++j)for(ri id=0;id&lt;2;++id)if(s[id][i]==t[j]){ update(fl[id][i+1][j+1],fl[id][i][j]),update(fl[id^1][i+1][j+2],(j^m)&amp;&amp;s[id^1][i]==t[j+1]?fl[id][i][j]:0); update(fr[id][i+1][j-1],fr[id][i][j]),update(fr[id^1][i+1][j-2],(j^1)&amp;&amp;s[id^1][i]==t[j-1]?fr[id][i][j]:0); } for(ri id=0;id&lt;2;++id)update(ans,add(fl[id][i+1][m+1],fr[id][i+1][0])); for(ri j=1,up=min(i,m/2);j&lt;=up;++j)for(ri id=0;id&lt;2;++id){ update(ans,get_nr(id^1,i,i-j+1)==get_ml(1,j)&amp;&amp;get_nl(id,i-j+1,i)==get_ml(j+1,j*2)&amp;&amp;j*2==m); update(fl[id][i+1][j*2+1],get_nr(id^1,i,i-j+1)==get_ml(1,j)&amp;&amp;get_nl(id,i-j+1,i)==get_ml(j+1,j*2)); update(fr[id][i+1][m-j*2],get_nr(id^1,i,i-j+1)==get_mr(m,m-j+1)&amp;&amp;get_nl(id,i-j+1,i)==get_mr(m-j,m-j*2+1)); } } cout&lt;&lt;ans; return 0;} C &#x9898;&#x610F;&#x7B80;&#x8FF0;&#xFF1A; &#x6C42; &#x2211;i=1n&#x3BC;(i)im\\sum\\limits_{i=1}^n\\mu(i)i^mi=1&#x2211;n&#x200B;&#x3BC;(i)im &#x6570;&#x636E;&#x8303;&#x56F4;&#xFF1A; n&#x2264;109n\\le10^9n&#x2264;109 m&#x2264;2&#x2217;105m\\le2*10^5m&#x2264;2&#x2217;105 &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x4EE4; f(x)=&#x3BC;(x)xm,S(x)=&#x2211;i=1xf(i)f(x)=\\mu(x)x^m,S(x)=\\sum\\limits_{i=1}^xf(i)f(x)=&#x3BC;(x)xm,S(x)=i=1&#x2211;x&#x200B;f(i) &#x8003;&#x8651;&#x6784;&#x9020; g(x)=xm,h=f&#xD7;g&#x21D2;h(x)=[i==1]im=&#x3F5;(x)g(x)=x^m,h=f\\times g\\Rightarrow h(x)=[i==1]i^m=\\epsilon(x)g(x)=xm,h=f&#xD7;g&#x21D2;h(x)=[i==1]im=&#x3F5;(x) &#x6545;&#x53EF;&#x4EE5;&#x7528;&#x675C;&#x6559;&#x7B5B;&#xFF0C;&#x73B0;&#x5728;&#x95EE;&#x9898;&#x8F6C;&#x6362;&#x6210;&#x6C42; n\\sqrt nn&#x200B; &#x4E2A; &#x2211;i=1xim\\sum\\limits_{i=1}^xi^mi=1&#x2211;x&#x200B;im &#x7684;&#x503C;&#xFF0C;&#x5728;&#x7A7A;&#x95F4;&#x9650;&#x5236;&#x4E0D;&#x4E25;&#x7684;&#x60C5;&#x51B5;&#x4E0B;&#x53EF;&#x4EE5;&#x5408;&#x7406;&#x7684;&#x5E73;&#x8861;&#x7ED3;&#x5408;&#x9884;&#x5904;&#x7406;&#x8303;&#x56F4;+&#x62C9;&#x683C;&#x6717;&#x65E5;&#x63D2;&#x503C;&#x6216;&#x8005;&#x76F4;&#x63A5;&#x7528;&#x591A;&#x9879;&#x5F0F;&#x591A;&#x70B9;&#x63D2;&#x503C; CODE cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}typedef long long ll;const int mod=998244353;inline int add(int a,int b){return (a+=b)&lt;mod?a:a-mod;}inline void Add(int&amp;a,int b){a=add(a,b);}inline int dec(int a,int b){return (a-=b)&lt;0?a+mod:a;}inline void Dec(int&amp;a,int b){a=dec(a,b);}inline int mul(int a,int b){return (ll)a*b%mod;}inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;}inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;}const int N=3e6+5;int mu[N],pri[N],ss[N],F1[N],tot=0,up,n,m,lm,lagup,lagf[N],fac[N],ifac[N],F2[N];bool vs[N],Vs1[N],Vs2[N];map&lt;int,int&gt;S;inline int lagrange(int x){ if(x&lt;=up)return lagf[x]; if(S.count(x))return S[x]; static int pre[N],suf[N]; int res=0; pre[0]=suf[lagup+1]=1; for(ri i=1;i&lt;=lagup;++i)pre[i]=mul(pre[i-1],(x-i)%mod); for(ri i=lagup;i;--i)suf[i]=mul(suf[i+1],(x-i)%mod); for(ri t,i=1;i&lt;=lagup;++i){ t=mul(lagf[i],mul(mul(ifac[i-1],ifac[lagup-i]),mul(pre[i-1],suf[i+1]))); (lagup-i)&amp;1?Dec(res,t):Add(res,t); } return S[x]=res;}inline void init(){ lagup=m+2,lagf[1]=fac[0]=fac[1]=ifac[0]=ifac[1]=1; for(ri i=2;i&lt;=lagup;++i)fac[i]=mul(fac[i-1],i),ifac[i]=mul(ifac[mod-mod/i*i],mod-mod/i); for(ri i=2;i&lt;=lagup;++i)Mul(ifac[i],ifac[i-1]); mu[1]=ss[1]=1; for(ri i=2;i&lt;=up;++i){ if(!vs[i])pri[++tot]=i,mu[i]=mod-1; lagf[i]=ksm(i,m); ss[i]=add(ss[i-1],mul(mu[i],lagf[i])); Add(lagf[i],lagf[i-1]); for(ri j=1,lm=up/i;j&lt;=tot&amp;&amp;pri[j]&lt;=lm;++j){ vs[i*pri[j]]=1; if(i==i/pri[j]*pri[j]){mu[i*pri[j]]=0;break;} mu[i*pri[j]]=dec(0,mu[i]); } }}map&lt;int,int&gt;F;inline int Sum1(int x){ if(x&lt;=up)return ss[x]; if(F.count(x))return F[x]; int res=1; for(ri l=2,r;l&lt;=x;l=r+1){ r=x/(x/l); Dec(res,mul(dec(lagrange(r),lagrange(l-1)),Sum1(x/l))); } return F[x]=res;}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(),m=read(); up=3e6,init(); cout&lt;&lt;Sum1(n); return 0;} &#x591A;&#x9879;&#x5F0F;&#x591A;&#x70B9;&#x63D2;&#x503C;&#x4F30;&#x8BA1;&#x7B49;&#x535A;&#x4E3B;&#x8EAB;&#x4F53;&#x597D;&#x4E86;&#x518D;&#x66F4; &#x6709;&#x751F;&#x4E4B;&#x5E74;","categories":[{"name":"private","slug":"private","permalink":"http://xdl030112.github.io/categories/private/"}],"tags":[{"name":"考试题解","slug":"考试题解","permalink":"http://xdl030112.github.io/tags/%E8%80%83%E8%AF%95%E9%A2%98%E8%A7%A3/"}]},{"title":"2019.09.30 模拟测试题解","slug":"190930test","date":"2019-10-01T03:57:51.000Z","updated":"2019-10-11T15:33:38.015Z","comments":true,"path":"190930test/","link":"","permalink":"http://xdl030112.github.io/190930test/","excerpt":"","text":"A &#x9898;&#x610F;&#x7B80;&#x8FF0;&#xFF1A; &#x7ED9;&#x51FA; nnn &#x4E2A;&#x957F;&#x5EA6;&#x76F8;&#x540C;&#x7684;&#x4E32;&#xFF0C;&#x73B0;&#x5728;&#x5728;&#x8FD9; nnn &#x4E2A;&#x4E32;&#x4E2D;&#x968F;&#x673A;&#x9009;&#x62E9;&#x4E00;&#x4E2A;&#x4F5C;&#x4E3A;&#x7B54;&#x6848;&#x4E32;&#xFF0C;&#x7136;&#x540E;&#x4F60;&#x73B0;&#x5728;&#x6BCF;&#x6B21;&#x968F;&#x673A;&#x731C;&#x4E00;&#x4E2A;&#x4E4B;&#x524D;&#x672A;&#x731C;&#x8FC7;&#x7684;&#x4F4D;&#x7F6E;&#xFF0C;&#x5728;&#x80FD;&#x591F;&#x51ED;&#x501F;&#x5DF2;&#x6709;&#x7684;&#x4FE1;&#x606F;&#x786E;&#x5B9A;&#x51FA;&#x7B54;&#x6848;&#x4E32;&#x7684;&#x65F6;&#x5019;&#x6E38;&#x620F;&#x7ED3;&#x675F;&#xFF0C;&#x95EE;&#x731C;&#x4F4D;&#x7F6E;&#x7684;&#x671F;&#x671B;&#x6B21;&#x6570; &#x6570;&#x636E;&#x8303;&#x56F4;&#xFF1A; n&#x2264;50n\\le50n&#x2264;50 len&#x2264;20len\\le20len&#x2264;20 &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x8003;&#x8651;&#x4E00;&#x4E2A; O(nl2l)O(nl2^l)O(nl2l) &#x7684;&#x66B4;&#x529B;&#x72B6;&#x538B; dpdpdp &#xFF0C;&#x5373;&#x679A;&#x4E3E;&#x7B54;&#x6848;&#x4E32;&#x662F;&#x5565;&#xFF0C;&#x7136;&#x540E; fsf_{s}fs&#x200B; &#x8868;&#x793A;&#x8BE5;&#x60C5;&#x51B5;&#x4E0B;&#x731C;&#x8FC7;&#x4F4D;&#x7F6E;&#x96C6;&#x5408;&#x4E3A; sss &#x65F6;&#x79BB;&#x7ED3;&#x675F;&#x7684;&#x671F;&#x671B;&#x6B65;&#x6570;&#xFF0C;&#x5E76;&#x4EE4; cntcntcnt &#x662F;&#x5F53;&#x524D;&#x96C6;&#x5408;&#x731C;&#x8FC7;&#x7684;&#x4F4D;&#x7F6E;&#x6570;&#x91CF;&#xFF0C;&#x90A3;&#x4E48;&#x53EF;&#x4EE5;&#x8FDB;&#x884C;&#x5982;&#x4E0B;&#x8F6C;&#x79FB;&#xFF1A; &#x96C6;&#x5408; sss &#x4E2D;&#x7684;&#x4F4D;&#x7F6E;&#x53EF;&#x4EE5;&#x533A;&#x5206;&#x51FA;&#x7B54;&#x6848;&#x4E32;&#x548C;&#x5176;&#x4F59;&#x4E32;&#xFF0C;&#x5219;&#x6709; fs=0f_{s}=0fs&#x200B;=0 &#x96C6;&#x5408; sss &#x4E2D;&#x7684;&#x4F4D;&#x7F6E;&#x4E0D;&#x80FD;&#x533A;&#x5206;&#x51FA;&#x7B54;&#x6848;&#x4E32;&#x548C;&#x5176;&#x4F59;&#x4E32;&#xFF0C;&#x90A3;&#x4E48; fs=1+1len&#x2212;cnt&#x2211;i,i&#x2208;&#x338;sfs&#x222A;if_s=1+\\frac1{len-cnt}\\sum\\limits_{i,i\\not \\in s}f_{s\\cup i}fs&#x200B;=1+len&#x2212;cnt1&#x200B;i,i&#xE020;&#x200B;&#x2208;s&#x2211;&#x200B;fs&#x222A;i&#x200B; &#x8FD9;&#x6837;&#x53EF;&#x4EE5;&#x62FF;&#x5230; 60+pts60^+pts60+pts &#x73B0;&#x5728;&#x8003;&#x8651;&#x4F18;&#x5316;&#xFF0C;&#x5BB9;&#x6613;&#x53D1;&#x73B0;&#x53EF;&#x4EE5;&#x628A; nnn &#x4E2A;&#x4E32;&#x538B;&#x5728;&#x4E00;&#x8D77;&#x8F6C;&#x79FB;&#xFF0C;&#x5177;&#x4F53;&#x6765;&#x8BF4;&#xFF0C;&#x8003;&#x8651;&#x9884;&#x5904;&#x7406;&#x51FA; CntsCnt_sCnts&#x200B; &#x8868;&#x793A;&#x96C6;&#x5408; sss &#x4E0D;&#x80FD;&#x533A;&#x5206;&#x5F00;&#x7684;&#x4E32;&#x7684;&#x4E2A;&#x6570;&#xFF0C;&#x8FD9;&#x6837;&#x7B2C;&#x4E8C;&#x79CD;&#x8F6C;&#x79FB;&#x53D8;&#x4E3A; fs=Cnts+1len&#x2212;cnt&#x2211;i,i&#x2208;&#x338;sfs&#x222A;if_s=Cnt_s+\\frac1{len-cnt}\\sum\\limits_{i,i\\not \\in s}f_{s\\cup i}fs&#x200B;=Cnts&#x200B;+len&#x2212;cnt1&#x200B;i,i&#xE020;&#x200B;&#x2208;s&#x2211;&#x200B;fs&#x222A;i&#x200B; &#x6700;&#x540E;&#x7B54;&#x6848;&#x4E3A; f0n\\frac{f_0}nnf0&#x200B;&#x200B; &#xFF0C;&#x56E0;&#x4E3A;&#x6211;&#x4EEC;&#x628A;&#x6240;&#x6709;&#x4E32;&#x538B;&#x5728;&#x4E86;&#x4E00;&#x8D77;&#x56E0;&#x6B64;&#x671F;&#x671B;&#x8981;&#x5E26;&#x4E00;&#x4E2A; 1n\\frac 1nn1&#x200B; CODE cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_backusing namespace std;typedef long long ll;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; char ch=gc(); bool f=1; while(!isdigit(ch))f^=ch==&apos;-&apos;,ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;}inline int Read(char*s){ int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;}const int N=1e5+5;int n,K,len;char s[55][25];double f[1&lt;&lt;20];int cnt[1&lt;&lt;20];bool vs[1&lt;&lt;20];ll sm[1&lt;&lt;20];inline int lowbit(int x){return x&amp;-x;}inline double dfs(int sta,int ct){ if(vs[sta])return f[sta]; vs[sta]=1,f[sta]=0; if(cnt[sta]==n)return f[sta]=0; int s=((1&lt;&lt;len)-1)^sta,t; while(s){ t=lowbit(s); f[sta]+=dfs(sta|t,ct+1); s^=t; } return (f[sta]/=(len-ct))+=n-cnt[sta];}int main(){ n=read(); for(ri i=1;i&lt;=n;++i)len=Read(s[i]); for(ri i=1;i&lt;=n;++i)for(ri st=0,j=1;j&lt;=n;++j,st=0)if(i!=j){ for(ri k=1;k&lt;=len;++k)if(s[i][k]==s[j][k])st|=1&lt;&lt;(k-1); sm[st]|=1ll&lt;&lt;(i-1); } sm[0]=(1ll&lt;&lt;n)-1; for(ri a,b,s=(1&lt;&lt;len)-1;~s;--s){ for(ri i=1;i&lt;=n;++i)if(!(sm[s]&gt;&gt;(i-1)&amp;1))++cnt[s]; a=s; while(a){ b=lowbit(a); sm[s^b]|=sm[s]; a^=b; } } printf(&quot;%.10lf&quot;,dfs(0,0)/n); return 0;} B &#x9898;&#x610F;&#x7B80;&#x8FF0;&#xFF1A; &#x7ED9;&#x4F60; nnn &#x4E2A;&#x70B9;&#xFF0C;&#x73B0;&#x5728;&#x8BE2;&#x95EE; m=1,2,3,&#x22EF;&#x2009;,nm=1,2,3,\\cdots,nm=1,2,3,&#x22EF;,n &#x4E2A;&#x70B9;&#x7684;&#x751F;&#x6210;&#x6811;&#x4E2A;&#x6570;&#xFF0C;&#x5982;&#x679C; iii &#x5728;&#x751F;&#x6210;&#x6811;&#x91CC;&#xFF0C;&#x5176;&#x5EA6;&#x6570;&#x4E0D;&#x8D85;&#x8FC7; did_idi&#x200B; &#x6570;&#x636E;&#x8303;&#x56F4;&#xFF1A; n&#x2264;100n\\le100n&#x2264;100 &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x8003;&#x8651;&#x5229;&#x7528; pruferpruferprufer &#x5E8F;&#x5217;&#x7684;&#x5982;&#x4E0B;&#x6027;&#x8D28;&#xFF1A; &#x5BF9;&#x4E8E;&#x4E00;&#x68F5; nnn &#x4E2A;&#x70B9;&#x7684;&#x6811;&#xFF0C; &#x2211;dui=2n&#x2212;2\\sum du_i=2n-2&#x2211;dui&#x200B;=2n&#x2212;2 &#x5BF9;&#x4E8E;&#x4E00;&#x68F5; nnn &#x4E2A;&#x70B9;&#x7684;&#x6811;&#xFF0C;&#x6BCF;&#x4E2A;&#x70B9;&#x5728; pruferpruferprufer &#x5E8F;&#x5217;&#x4E2D;&#x51FA;&#x73B0; dui&#x2212;1du_i-1dui&#x200B;&#x2212;1 &#x6B21; &#x6BCF;&#x68F5;&#x6811;&#x548C;&#x5176; pruferpruferprufer &#x5E8F;&#x5217;&#x6EE1;&#x8DB3;&#x53CC;&#x5C04;&#x5173;&#x7CFB; &#x90A3;&#x4E48;&#x95EE;&#x9898;&#x8F6C;&#x5316;&#x6210;&#x4E86;&#x4E00;&#x4E2A;&#x975E;&#x5E38;&#x663E;&#x7136;&#x7684;&#x4E8C;&#x5143;&#x751F;&#x6210;&#x51FD;&#x6570;&#x95EE;&#x9898;&#xFF0C;&#x7531;&#x4E8E;&#x6570;&#x636E;&#x8303;&#x56F4;&#x5F88;&#x5C0F;&#x53EF;&#x4EE5;&#x76F4;&#x63A5;&#x7528;&#x80CC;&#x5305;&#x4EE3;&#x66FF;&#x591A;&#x9879;&#x5F0F;&#x4E58;&#x6CD5; CODE cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_backusing namespace std;typedef long long ll;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; char ch=gc(); bool f=1; while(!isdigit(ch))f^=ch==&apos;-&apos;,ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;}const int mod=1e9+7;typedef vector&lt;int&gt; poly;inline int add(int a,int b){return (a+=b)&lt;mod?a:a-mod;}inline int dec(int a,int b){return (a-=b)&lt;mod?a+mod:a;}inline int mul(int a,int b){return (ll)a*b%mod;}inline void Add(int&amp;a,int b){a=add(a,b);}inline void Dec(int&amp;a,int b){a=dec(a,b);}inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;}inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;}const int N=105;int n,f[2][N][N],cur=0,C[N][N];inline void init(){ for(ri i=0;i&lt;=n;++i){ C[i][0]=1; for(ri j=1;j&lt;=i;++j)C[i][j]=add(C[i-1][j],C[i-1][j-1]); }}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(); f[cur=0][0][0]=1; init(); for(ri t=1,du;t&lt;=n;++t){ cur^=1; du=read(); for(ri i=0;i&lt;=t;++i)for(ri j=0;j&lt;=n-2;++j)f[cur][i][j]=f[!cur][i][j]; for(ri i=0;i&lt;=t;++i)for(ri j=0;j&lt;=n-2;++j)if(f[!cur][i][j]) for(ri k=0;k&lt;du&amp;&amp;j+k&lt;=n-2;++k)Add(f[cur][i+1][j+k],mul(f[!cur][i][j],C[j+k][j])); } for(ri i=1;i&lt;=n;++i)cout&lt;&lt;(i==1?n:f[cur][i][i-2])&lt;&lt;&apos; &apos;; return 0;} C &#x9898;&#x610F;&#x7B80;&#x8FF0;&#xFF1A; &#x7ED9;&#x51FA;&#x4E00;&#x4E2A;&#x5B57;&#x7B26;&#x4E32;&#xFF0C;&#x8981;&#x6C42;&#x5F3A;&#x5236;&#x5728;&#x7EBF;&#x652F;&#x6301;&#x5982;&#x4E0B;&#x64CD;&#x4F5C;&#xFF1A; &#x5728;&#x5F53;&#x524D;&#x4E32;&#x5C3E;&#x52A0;&#x4E0A;&#x4E00;&#x4E2A;&#x5B57;&#x7B26; ccc &#x8BE2;&#x95EE;&#x533A;&#x95F4; [l,r][l,r][l,r] &#x4E2D;&#x7684;&#x4E0D;&#x540C;&#x5B50;&#x4E32;&#x6570; &#x6570;&#x636E;&#x8303;&#x56F4;&#xFF1A; n,m&#x2264;50000n,m\\le50000n,m&#x2264;50000 &#x89E3;&#x9898;&#x601D;&#x8DEF;&#xFF1A; &#x663E;&#x7136;&#x9700;&#x8981;&#x8865;&#x96C6;&#x8F6C;&#x5316;&#x53D8;&#x6210;&#x6C42;&#x91CD;&#x590D;&#x5B50;&#x4E32;&#x6570;&#xFF0C;&#x8003;&#x8651;&#x5EFA;&#x51FA; link&#x2212;cut&#x2212;parentlink-cut-parentlink&#x2212;cut&#x2212;parent treetreetree&#xFF0C;&#x7136;&#x540E;&#x8003;&#x8651;&#x5728;&#x5B57;&#x7B26;&#x4E32;&#x7ED3;&#x5C3E;&#x52A0;&#x4E00;&#x4E2A;&#x5B57;&#x7B26;&#x5BF9;&#x5B50;&#x4E32;&#x6570;&#x5F71;&#x54CD;&#xFF0C;&#x53D1;&#x73B0;&#x5C31;&#x662F;&#x628A;&#x5176;&#x5BF9;&#x5E94;&#x52A8;&#x6001;&#x6811;&#x4E0A;&#x7684;&#x4E00;&#x6761;&#x94FE;&#x7684;&#x4FE1;&#x606F;&#x6539;&#x6389;&#xFF0C;&#x800C;&#x5BF9;&#x4E8E; endposendposendpos &#x76F8;&#x540C;&#x7684;&#x96C6;&#x5408;&#x5B83;&#x4EEC;&#x5BF9;&#x5E94;&#x7684;&#x5B50;&#x4E32;&#x7684;&#x5DE6;&#x7AEF;&#x70B9;&#x4E5F;&#x662F;&#x8FDE;&#x7EED;&#x7684;&#xFF0C;&#x4E8E;&#x662F;&#x53EF;&#x4EE5;&#x628A; endposendposendpos &#x76F8;&#x540C;&#x7684;&#x653E;&#x5230;&#x4E00;&#x68F5; splaysplaysplay &#x91CC;&#xFF0C;&#x7136;&#x540E;&#x6BCF;&#x6B21;&#x52A0;&#x70B9;&#x5C31;&#x6210;&#x4E86; accessaccessaccess &#x64CD;&#x4F5C;&#xFF0C;&#x663E;&#x7136;&#x80FD;&#x7528;&#x4E3B;&#x5E2D;&#x6811;&#x8F85;&#x52A9;&#x7EF4;&#x62A4;&#x7B54;&#x6848; &#x4F46;&#x76F4;&#x63A5;&#x8FD9;&#x6837;&#x505A;&#x6709;&#x4E2A;&#x5C0F;&#x6BDB;&#x75C5;&#xFF0C;&#x662F;&#x5BF9;&#x4E8E;&#x7EF4;&#x62A4;&#x7B54;&#x6848;&#x4FE1;&#x606F;&#x4E0D;&#x80FD;&#x968F;&#x610F;&#x7684;&#x8FDB;&#x884C; accessaccessaccess &#x64CD;&#x4F5C;&#xFF0C;&#x4E8E;&#x662F; cutcutcut &#x64CD;&#x4F5C;&#x4E5F;&#x4E0D;&#x80FD;&#x7528;&#x4E86;&#xFF0C;&#x8FD9;&#x6837;&#x7684;&#x8BDD;&#x5728; clonecloneclone &#x8282;&#x70B9;&#x9700;&#x8981;&#x5F04;&#x4E00;&#x4E2A;&#x5C0F; tricktricktrick &#xFF0C;&#x5C31;&#x662F;&#x6BCF;&#x6B21;&#x6211;&#x4EEC;&#x5148; accessaccessaccess &#x65B0;&#x7684; endposendposendpos &#x5BF9;&#x5E94;&#x7684;&#x94FE;&#xFF0C;&#x8FD9;&#x4E2A;&#x65F6;&#x5019;&#x88AB; clonecloneclone &#x7684;&#x70B9;&#x6210;&#x4E3A;&#x865A;&#x513F;&#x5B50;&#xFF0C;&#x53EF;&#x4EE5;&#x76F4;&#x63A5;&#x5C06; cutcutcut &#x53D8;&#x6210;&#x6362;&#x7236;&#x4EB2;&#x64CD;&#x4F5C; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_backusing namespace std;typedef long long ll;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; char ch=gc(); bool f=1; while(!isdigit(ch))f^=ch==&apos;-&apos;,ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;}inline int Read(char*s){ int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;}const int N=2e5+5,M=N*100;int lm;namespace sgt{ #define lc (son[p][0]) #define rc (son[p][1]) #define mid (l+r&gt;&gt;1) int son[M][2],tg[M],tot=0; ll ss[M]; inline void update(int&amp;o,int l,int r,int ql,int qr,int v){ if(ql&gt;qr)return; int p=++tot; lc=son[o][0],rc=son[o][1],ss[p]=ss[o],tg[p]=tg[o]; o=p; ss[p]+=(ll)(min(qr,r)-max(ql,l)+1)*v; if(ql&lt;=l&amp;&amp;r&lt;=qr){tg[p]+=v;return;} if(qr&lt;=mid)update(lc,l,mid,ql,qr,v); else if(ql&gt;mid)update(rc,mid+1,r,ql,qr,v); else update(lc,l,mid,ql,qr,v),update(rc,mid+1,r,ql,qr,v); } inline ll query(int p,int l,int r,int ql,int qr){ if(!p)return 0ll; if(ql&lt;=l&amp;&amp;r&lt;=qr)return ss[p]; int res=(ll)(min(qr,r)-max(ql,l)+1)*tg[p]; if(qr&lt;=mid)return res+query(lc,l,mid,ql,qr); if(ql&gt;mid)return res+query(rc,mid+1,r,ql,qr); return res+query(lc,l,mid,ql,qr)+query(rc,mid+1,r,ql,qr); } #undef mid #undef lc #undef rc}int rt[N],n;namespace lct{ #define lc (son[p][0]) #define rc (son[p][1]) int son[N][2],fa[N],edpos[N],tg[N],len[N]; inline void pushnow(int p,int v){tg[p]=edpos[p]=v;} inline void pushdown(int p){tg[p]&amp;&amp;(pushnow(lc,tg[p]),pushnow(rc,tg[p]),tg[p]=0);} inline bool isroot(int x){return !fa[x]||((son[fa[x]][0]^x)&amp;&amp;(son[fa[x]][1]^x));} inline bool which(int x){return x==son[fa[x]][1];} inline void rotate(int x){ int y=fa[x],z=fa[y],t=which(x); if(!isroot(y))son[z][which(y)]=x; fa[x]=z,fa[y]=x,son[y][t]=son[x][t^1],son[x][t^1]=y; son[y][t]&amp;&amp;(fa[son[y][t]]=y); } inline void splay(int x){ static int stk[N],top=0; stk[top=1]=x; for(ri i=x;!isroot(i);i=fa[i])stk[++top]=fa[i]; while(top)pushdown(stk[top--]); while(!isroot(x)){ if(!isroot(fa[x]))rotate(which(x)^which(fa[x])?x:fa[x]); rotate(x); } } inline void access(int x,int ps){ int y=0; for(;x;x=fa[y=x]){ splay(x),son[x][1]=y; edpos[x]&amp;&amp;(sgt::update(rt[ps],1,lm,edpos[x]-len[x]+1,edpos[x]-len[fa[x]],1),1); } pushnow(y,ps); } inline int queryid(int x){return splay(x),edpos[x];} inline void link(int x,int y){splay(x),fa[x]=y;} #undef lc #undef rc}namespace sam{ int son[N][26],tot,last,len[N],link[N]; inline void init(){tot=last=1;} inline void insert(int x,int id){ int np=++tot,p=last; rt[id]=rt[id-1]; last=np,lct::len[np]=len[np]=len[p]+1; while(p&amp;&amp;!son[p][x])son[p][x]=np,p=link[p]; if(!p){lct::link(np,link[np]=1),lct::access(np,id);return;} int q=son[p][x],nq; if(len[q]==len[p]+1){lct::link(np,link[np]=q),lct::access(np,id);return;} nq=++tot,len[nq]=lct::len[nq]=len[p]+1,memcpy(son[nq],son[q],sizeof(son[q])); lct::edpos[nq]=lct::queryid(q); lct::link(nq,link[nq]=link[q]); lct::link(np,link[np]=nq),lct::access(np,id); lct::link(q,link[q]=nq); while(p&amp;&amp;son[p][x]==q)son[p][x]=nq,p=link[p]; }}int D,m;char s[N],ch;int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif D=read(),n=Read(s),m=read(); ll lastans=0; lm=m+n; sam::init(); for(ri i=1;i&lt;=n;++i)sam::insert(s[i]-&apos;a&apos;,i); for(ri op,l,r;m;--m){ op=read(); if(op==1){ ch=gc(); while(!isalpha(ch))ch=gc(); ++n; sam::insert(((ll)(ch-&apos;a&apos;)+lastans)%26,n); } else{ l=(lastans-1+read())%n+1; r=(lastans-1+read())%n+1; cout&lt;&lt;(lastans=(((ll)(r-l+1)*(r-l+2)/2)-sgt::query(rt[r],1,lm,l,r)))&lt;&lt;&apos;\\n&apos;; } lastans*=D; } return 0;}","categories":[{"name":"private","slug":"private","permalink":"http://xdl030112.github.io/categories/private/"}],"tags":[{"name":"考试题解","slug":"考试题解","permalink":"http://xdl030112.github.io/tags/%E8%80%83%E8%AF%95%E9%A2%98%E8%A7%A3/"}]},{"title":"CodeForces 1208 简要题解","slug":"CF1208","date":"2019-09-29T07:31:41.000Z","updated":"2019-10-22T23:48:12.081Z","comments":true,"path":"CF1208/","link":"","permalink":"http://xdl030112.github.io/CF1208/","excerpt":"","text":"A &#x6309;&#x7167;&#x6A21; 333 &#x4F59;&#x6570;&#x5206;&#x7C7B;&#x5373;&#x53EF; CODE cpp1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se secondusing namespace std;inline int read(){ #define gc getchar int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch==&apos;-&apos;,ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;}const int mod=998244353;typedef pair&lt;int,int&gt; pii;typedef long long ll;inline int add(int a,int b){return (a+=b)&lt;mod?a:a-mod;}inline int dec(int a,int b){return (a-=b)&lt;0?a+mod:a;}inline int mul(int a,int b){return (ll)a*b%mod;}inline void Add(int&amp;a,int b){(a+=b)&lt;mod?a:(a-=mod);}inline void Dec(int&amp;a,int b){(a-=b)&lt;0?(a+=mod):a;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;}inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))if(p&amp;1)Mul(ret,a);return ret;}int a[3];int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif for(ri tt=read();tt;--tt){ a[0]=read(),a[1]=read(),a[2]=a[1]^a[0]; cout&lt;&lt;a[read()%3]&lt;&lt;&apos;\\n&apos;; } return 0;} B &#x53CC;&#x6307;&#x9488;&#x6A21;&#x62DF;&#x5373;&#x53EF; CODE cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se secondusing namespace std;inline int read(){ #define gc getchar int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch==&apos;-&apos;,ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;}const int mod=998244353;typedef pair&lt;int,int&gt; pii;typedef long long ll;inline int add(int a,int b){return (a+=b)&lt;mod?a:a-mod;}inline int dec(int a,int b){return (a-=b)&lt;0?a+mod:a;}inline int mul(int a,int b){return (ll)a*b%mod;}inline void Add(int&amp;a,int b){(a+=b)&lt;mod?a:(a-=mod);}inline void Dec(int&amp;a,int b){(a-=b)&lt;0?(a+=mod):a;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;}inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))if(p&amp;1)Mul(ret,a);return ret;}const int N=2005;int a[N],n;map&lt;int,int&gt;id;int cnt[N],sum=0;int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(); int tot=0; for(ri i=1;i&lt;=n;++i){ a[i]=read(); if(!id[a[i]])id[a[i]]=++tot; ++cnt[id[a[i]]]; if(cnt[id[a[i]]]==2)++sum; } if(!sum)return puts(&quot;0&quot;),0; int ans=n; for(ri l=1;l&lt;=n;++l){ for(ri r=l;r&lt;=n;++r){ --cnt[id[a[r]]]; if(cnt[id[a[r]]]==1)--sum; if(!sum)ans=min(ans,r-l+1); } for(ri r=l;r&lt;=n;++r){ ++cnt[id[a[r]]]; if(cnt[id[a[r]]]==2)++sum; } } cout&lt;&lt;ans; return 0;} C &#x6BCF; 161616 &#x4E2A;&#x6570;&#x4E3A;&#x4E00;&#x7EC4;&#x6784;&#x9020;&#x5373;&#x53EF; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se secondusing namespace std;inline int read(){ #define gc getchar int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch==&apos;-&apos;,ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;}const int mod=998244353;typedef pair&lt;int,int&gt; pii;typedef long long ll;inline int add(int a,int b){return (a+=b)&lt;mod?a:a-mod;}inline int dec(int a,int b){return (a-=b)&lt;0?a+mod:a;}inline int mul(int a,int b){return (ll)a*b%mod;}inline void Add(int&amp;a,int b){(a+=b)&lt;mod?a:(a-=mod);}inline void Dec(int&amp;a,int b){(a-=b)&lt;0?(a+=mod):a;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;}inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))if(p&amp;1)Mul(ret,a);return ret;}const int N=2005;int n,ans[N][N];int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(); for(ri l=0,r=15,a,b,i=0;i&lt;n;i+=4)for(ri j=0;j&lt;n;j+=4){ a=i,b=j; ans[a][b]=l; ans[a][b+1]=l+1; ans[a+1][b]=l+2; ans[a+1][b+1]=l+3; a=i,b=j+2; l+=4; ans[a][b]=l+2; ans[a][b+1]=l+3; ans[a+1][b]=l; ans[a+1][b+1]=l+1; a=i+2,b=j; l+=4; ans[a][b]=l+1; ans[a][b+1]=l; ans[a+1][b]=l+3; ans[a+1][b+1]=l+2; a=i+2,b=j+2; l+=4; ans[a][b]=l+3; ans[a][b+1]=l+2; ans[a+1][b]=l+1; ans[a+1][b+1]=l; l+=4; } for(ri i=0;i&lt;n;++i,puts(&quot;&quot;))for(ri j=0;j&lt;n;++j)cout&lt;&lt;ans[i][j]&lt;&lt;&apos; &apos;; return 0;} D &#x7528;&#x4E2A;&#x7EBF;&#x6BB5;&#x6811;&#x6A21;&#x62DF;&#x5373;&#x53EF; CODE cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se secondusing namespace std;inline int read(){ #define gc getchar int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch==&apos;-&apos;,ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;}const int mod=998244353;typedef pair&lt;int,int&gt; pii;typedef long long ll;inline ll readl(){ #define gc getchar ll ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch==&apos;-&apos;,ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;}inline int add(int a,int b){return (a+=b)&lt;mod?a:a-mod;}inline int dec(int a,int b){return (a-=b)&lt;0?a+mod:a;}inline int mul(int a,int b){return (ll)a*b%mod;}inline void Add(int&amp;a,int b){(a+=b)&lt;mod?a:(a-=mod);}inline void Dec(int&amp;a,int b){(a-=b)&lt;0?(a+=mod):a;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;}inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))if(p&amp;1)Mul(ret,a);return ret;}const int N=2e5+5;int n,w;namespace sgt{ #define lc (p&lt;&lt;1) #define rc (p&lt;&lt;1|1) #define mid (l+r&gt;&gt;1) ll ss[N&lt;&lt;2]; inline void build(int p,int l,int r){ if(l==r){ss[p]=l;return;} build(lc,l,mid),build(rc,mid+1,r); ss[p]=ss[lc]+ss[rc]; } inline void update(int p,int l,int r,int k){ if(l==r){ss[p]=0;return;} if(k&lt;=mid)update(lc,l,mid,k); else update(rc,mid+1,r,k); ss[p]=ss[lc]+ss[rc]; } inline int query(int p,int l,int r,ll v){ if(l==r)return l; if(ss[lc]&gt;v)return query(lc,l,mid,v); return query(rc,mid+1,r,v-ss[lc]); } #undef lc #undef rc #undef mid}int a[N];ll s[N];int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(); sgt::build(1,1,n); for(ri i=1;i&lt;=n;++i)s[i]=readl(); for(ri i=n;i;--i){ a[i]=sgt::query(1,1,n,s[i]); sgt::update(1,1,n,a[i]); } for(ri i=1;i&lt;=n;++i)cout&lt;&lt;a[i]&lt;&lt;&apos; &apos;; return 0;} E &#x89C2;&#x5BDF;&#x4E00;&#x4E0B;&#x53D1;&#x73B0;&#x53EF;&#x4EE5;&#x5BF9;&#x6BCF;&#x4E00;&#x884C;&#x7528;&#x7684;&#x8D21;&#x732E;&#x7528;&#x5355;&#x8C03;&#x961F;&#x5217;/&#x7EBF;&#x6BB5;&#x6811;/st&#x8868;&#x7EDF;&#x8BA1;&#xFF0C;&#x4F46;&#x662F;&#x6700;&#x540E;&#x8981;&#x7EDF;&#x8BA1; mmm &#x884C;&#x7684;&#x603B;&#x8D21;&#x732E;&#xFF0C;&#x7136;&#x540E;&#x53D1;&#x73B0;&#x6BCF;&#x884C;&#x7684;&#x72B6;&#x6001;&#x6709;&#x4EE5;&#x4E0B;&#x51E0;&#x7C7B;&#xFF1A; &#x5F00;&#x59CB;&#x7684;&#x524D; kkk &#x4E2A; &#x7ED3;&#x5C3E;&#x7684;&#x524D; kkk &#x4E2A; &#x4E2D;&#x95F4;&#x90E8;&#x5206; &#x8FD9;&#x4E09;&#x6BB5;&#x7684;&#x8D21;&#x732E;&#x662F;&#x7C7B;&#x4F3C;&#x7684;&#xFF0C;&#x53EF;&#x4EE5;&#x5206;&#x7C7B;+&#x5DEE;&#x5206;&#x7EDF;&#x8BA1; CODE cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;inline char gc(){ static char buf[rlen],*ib,*ob; (ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)); return ib==ob?-1:*ib++;}inline int read(){ int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch==&apos;-&apos;,ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;}const int mod=998244353;typedef pair&lt;int,int&gt; pii;typedef long long ll;inline int add(int a,int b){return (a+=b)&lt;mod?a:a-mod;}inline int dec(int a,int b){return (a-=b)&lt;0?a+mod:a;}inline int mul(int a,int b){return (ll)a*b%mod;}inline void Add(int&amp;a,int b){(a+=b)&lt;mod?a:(a-=mod);}inline void Dec(int&amp;a,int b){(a-=b)&lt;0?(a+=mod):a;} inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;}inline int ksm(int a,int p){int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))if(p&amp;1)Mul(ret,a);return ret;}const int N=1e6+50;int n,w,a[N];ll ans[N],ad[N];namespace sgt{ #define lc (p&lt;&lt;1) #define rc (p&lt;&lt;1|1) #define mid (l+r&gt;&gt;1) ll mx[N&lt;&lt;2]; inline void build(int p,int l,int r){ if(l==r){mx[p]=a[l];return;} build(lc,l,mid),build(rc,mid+1,r); mx[p]=max(mx[lc],mx[rc]); } inline int query(int p,int l,int r,int ql,int qr){ if(ql&lt;=l&amp;&amp;r&lt;=qr)return mx[p]; if(qr&lt;=mid)return query(lc,l,mid,ql,qr); if(ql&gt;mid)return query(rc,mid+1,r,ql,qr); return max(query(lc,l,mid,ql,qr),query(rc,mid+1,r,ql,qr)); } #undef lc #undef rc #undef mid}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(),w=read()+2; for(ri tt=1,m;tt&lt;=n;++tt){ m=read(); for(ri i=2;i&lt;=m+1;++i)a[i]=read(); m+=2; a[1]=a[m]=0; sgt::build(1,1,m); if(w&lt;=m*3-1)for(ri i=1;i&lt;=w;++i)ans[i]+=sgt::query(1,1,m,max(1,i-w+m),min(i,m)); else{ for(ri i=1;i&lt;m;++i)ans[i]+=sgt::query(1,1,m,1,i); for(ri i=w;i&gt;w-m+1;--i)ans[i]+=sgt::query(1,1,m,m+i-w,m); ad[m]+=sgt::mx[1]; ad[w-m+2]-=sgt::mx[1]; } } for(ri i=1;i&lt;=w;++i){ ad[i]+=ad[i-1]; ans[i]+=ad[i]; } for(ri i=2;i&lt;=w-1;++i)cout&lt;&lt;ans[i]&lt;&lt;&apos; &apos;; return 0;} F &#x76F4;&#x63A5;&#x66B4;&#x529B;+&#x4E8C;&#x8FDB;&#x5236;&#x679A;&#x4E3E;&#x5B50;&#x96C6;&#x66F4;&#x65B0;&#x5373;&#x53EF;&#xFF0C;&#x6BCF;&#x4E2A;&#x96C6;&#x5408;&#x6700;&#x591A;&#x88AB;&#x66F4;&#x65B0;&#x4E24;&#x6B21;&#x56E0;&#x6B64;&#x590D;&#x6742;&#x5EA6;&#x662F;&#x5BF9;&#x7684;~ &#x6CA1;&#x60F3;&#x5230;&#x5427; &#x7136;&#x540E;&#x6BD4;&#x8D5B;&#x7684;&#x65F6;&#x5019;&#x662F;&#x4E2A;dd &#x5176;&#x5B9E;&#x6211;&#x73B0;&#x5728;&#x4E5F;&#x662F;dd CODE cpp12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;inline char gc(){ static char buf[rlen],*ib,*ob; (ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)); return ib==ob?-1:*ib++;}inline int read(){ int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch==&apos;-&apos;,ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;}const int N=1&lt;&lt;21|5;int cnt[N],a[N],n,lst[N],ans=0;inline void update(int vl,int ps){ if(cnt[vl]&gt;=2||lst[vl]==ps)return; lst[vl]=ps,++cnt[vl]; for(ri i=21;~i;--i)if(vl&gt;&gt;i&amp;1)update(vl^(1&lt;&lt;i),ps);}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(); for(ri i=1;i&lt;=n;++i)a[i]=read(); for(ri t,res,i=n;i;--i){ if(i&lt;=n-2){ t=((1&lt;&lt;22)-1)^a[i],res=0; for(ri j=21;~j;--j)if(t&gt;&gt;j&amp;1)if(cnt[res|(1&lt;&lt;j)]==2)res|=1&lt;&lt;j; ans=max(ans,res|a[i]); } update(a[i],i); } cout&lt;&lt;ans; return 0;} G &#x94A6;&#x5B9A;&#x6240;&#x6709;&#x7684;&#x591A;&#x8FB9;&#x5F62;&#x7684;&#x67D0;&#x4E00;&#x4E2A;&#x9876;&#x70B9;&#x91CD;&#x5408;&#x4E0E;&#x540C;&#x4E00;&#x4E2A;&#x70B9;&#xFF0C;&#x53D1;&#x73B0;&#x4E4B;&#x540E;&#x5047;&#x5982;&#x8981;&#x9009; x,x&#x2265;3x,x\\ge3x,x&#x2265;3 &#xFF0C;&#x4E14; xxx &#x7684;&#x6240;&#x6709;&#x7EA6;&#x6570;&#x5DF2;&#x7ECF;&#x88AB;&#x9009;&#xFF0C;&#x90A3;&#x4E48;&#x5B83;&#x4F1A;&#x589E;&#x52A0; &#x3D5;(x)\\phi (x)&#x3D5;(x) &#x4E2A;&#x70B9; &#xFF0C;&#x7531;&#x4E8E;&#x5BF9;&#x4E8E;&#x6BCF;&#x4E2A;&#x6570; xxx &#x548C;&#x5B83;&#x7684;&#x56E0;&#x5B50; yyy &#x6EE1;&#x8DB3; &#x3D5;(x)&#x2265;&#x3D5;(y)\\phi(x)\\ge\\phi(y)&#x3D5;(x)&#x2265;&#x3D5;(y) &#xFF0C;&#x56E0;&#x6B64;&#x76F4;&#x63A5;&#x8003;&#x8651;&#x628A;&#x6240;&#x6709;&#x5408;&#x6CD5;&#x7684;&#x6570;&#x6309;&#x7167; &#x3D5;\\phi&#x3D5; &#x503C;&#x5927;&#x5C0F;&#x6392;&#x5E8F;&#x8FC7;&#x540E;&#x8D2A;&#x5FC3;&#x9009;&#x62E9;&#xFF0C;&#x6CE8;&#x610F;&#x7279;&#x5224;&#x4E00;&#x4E0B; k=1,2k=1,2k=1,2 &#x7684;&#x60C5;&#x51B5;~ CODE cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;inline char gc(){ static char buf[rlen],*ib,*ob; (ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)); return ib==ob?-1:*ib++;}inline int read(){ int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch==&apos;-&apos;,ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;}typedef long long ll;const int N=2e6+5;int n,k,pri[N],tot=0,phi[N];bool vis[N];inline void init(){ phi[1]=1; for(ri i=2;i&lt;=n;++i){ if(!vis[i])pri[++tot]=i,phi[i]=i-1; for(ri j=1;j&lt;=tot&amp;&amp;i*pri[j]&lt;=n;++j){ vis[i*pri[j]]=1; if(i==i/pri[j]*pri[j]){ phi[i*pri[j]]=phi[i]*pri[j]; break; } phi[i*pri[j]]=phi[i]*(pri[j]-1); } }}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(),k=read(); if(k==1)return puts(&quot;3&quot;),0; init(); sort(phi+3,phi+n+1); ll ans=0; for(ri i=3,j=1;j&lt;=k;++j,++i)ans+=phi[i]; cout&lt;&lt;ans+2; return 0;} H &#x795E;&#x4ED9; DDPDDPDDP &#x9996;&#x5148;&#x8F6C;&#x5316;&#x95EE;&#x9898;&#xFF0C;&#x53D1;&#x73B0;&#x662F;&#x5F53; b&#x2212;r&lt;kb-r&lt;kb&#x2212;r&lt;k &#x65F6;&#x989C;&#x8272;&#x4E3A; rrr &#x8003;&#x8651;&#x5BF9;&#x6BCF;&#x4E2A;&#x70B9;&#x89C4;&#x5B9A;&#x4E00;&#x4E2A;&#x65F6;&#x95F4; t(x)t(x)t(x) ,&#x5BF9;&#x4E8E;&#x53F6;&#x5B50;&#x7ED3;&#x70B9;&#xFF0C;&#x8868;&#x793A;&#x70B9; xxx &#x5728; k&#x2265;t(x)k\\ge t(x)k&#x2265;t(x) &#x65F6;&#x4F1A;&#x53D8;&#x6210; rrr &#xFF0C;&#x5982;&#x679C;&#x989C;&#x8272;&#x4E3A; rrr &#xFF0C; t(x)=&#x2212;inft(x)=-inft(x)=&#x2212;inf &#x5426;&#x5219; t(x)=inft(x)=inft(x)=inf &#xFF0C;&#x5BF9;&#x4E8E;&#x975E;&#x53F6;&#x5B50;&#x8282;&#x70B9;&#x663E;&#x7136;&#x53EF;&#x4EE5;&#x628A;&#x5B83;&#x513F;&#x5B50;&#x7684;&#x4FE1;&#x606F;&#x63D2;&#x5165;&#x5230;&#x5E73;&#x8861;&#x6811;&#x4E2D;&#x7136;&#x540E;&#x901A;&#x8FC7;&#x8C03;&#x6574;&#x6CD5;&#x6C42;&#x51FA; t(x)t(x)t(x) &#x8FD9;&#x6837;&#x7684;&#x8BDD;&#xFF0C;&#x6211;&#x4EEC;&#x53EA;&#x9700;&#x8981;&#x5BF9;&#x4E8E;&#x4E00;&#x4E2A; xxx &#xFF0C;&#x5224;&#x65AD;&#x5176; t(x)t(x)t(x) &#x548C; kkk &#x7684;&#x5927;&#x5C0F;&#x5173;&#x7CFB;&#x8FDB;&#x800C;&#x5224;&#x65AD;&#x5B83;&#x7684;&#x989C;&#x8272; &#x4E8E;&#x662F;&#x53EA;&#x9700;&#x8981;&#x8003;&#x8651;&#x5982;&#x4F55;&#x4FEE;&#x6539;&#x53F6;&#x5B50;&#x7684;&#x989C;&#x8272; &#x7ECF;&#x8FC7;&#x601D;&#x8003;&#x53D1;&#x73B0;&#x5355;&#x7EAF;&#x7684; t(x)t(x)t(x) &#x5E76;&#x4E0D;&#x597D;&#x5408;&#x5E76;&#xFF0C;&#x4E8E;&#x662F;&#x6211;&#x4EEC;&#x8FDB;&#x884C;&#x5982;&#x4E0B;&#x7CBE;&#x5F69;&#x53D8;&#x6362;&#xFF1A; &#x5BF9;&#x6811;&#x8FDB;&#x884C;&#x91CD;&#x94FE;&#x5256;&#x5206;&#xFF0C;&#x5B9A;&#x4E49; t(x,0/1)t(x,0/1)t(x,0/1) &#x8868;&#x793A;&#x5F53; xxx &#x7684;&#x91CD;&#x513F;&#x5B50;&#x662F; r/br/br/b &#x7684;&#x65F6;&#x5019;&#x5B83;&#x6210;&#x4E3A; rrr &#x7684;&#x6700;&#x5C0F;&#x65F6;&#x523B;&#xFF0C;&#x8FD9;&#x6837;&#x5C31;&#x53EF;&#x4EE5;&#x5C06; t(x,0/1)t(x,0/1)t(x,0/1) &#x8FDB;&#x884C;&#x5408;&#x5E76;&#xFF0C;&#x800C;&#x8F7B;&#x513F;&#x5B50;&#x7684;&#x7EF4;&#x62A4;&#x6CBF;&#x7528;&#x4E0A;&#x8FF0;&#x5E73;&#x8861;&#x6811;&#x505A;&#x6CD5;&#x5373;&#x53EF; CODE(fhq_treap) cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_backusing namespace std;typedef long long ll;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; char ch=gc(); bool f=1; while(!isdigit(ch))f^=ch==&apos;-&apos;,ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;}typedef pair&lt;int,int&gt; pii;const int N=1e6+5;int rt[N],n;inline int rnd(){return rand()|(rand()&lt;&lt;15);}namespace bst{ #define lc (son[p][0]) #define rc (son[p][1]) int son[N][2],siz[N],vl[N],rd[N]; int stk[N],top=0,tot=0; inline int newidx(){return ++tot;} inline int newnode(int v){ int p=newidx(); lc=rc=0,siz[p]=1,vl[p]=v,rd[p]=rnd(); return p; } inline int pushup(int p){siz[p]=(!p?0:siz[lc]+1+siz[rc]);} inline int merge(int a,int b){ if(!a||!b)return a|b; if(rd[a]&lt;rd[b])return son[a][1]=merge(son[a][1],b),pushup(a),a; return son[b][0]=merge(a,son[b][0]),pushup(b),b; } inline pii split(int p,int k){ if(!p)return pii(0,0); pii res; if(siz[lc]&gt;=k)return res=split(lc,k),lc=res.se,pushup(p),pii(res.fi,p); return res=split(rc,k-siz[lc]-1),rc=res.fi,pushup(p),pii(p,res.se); } inline int rank(int p,int v){ if(!p)return 0; if(vl[p]&gt;v)return rank(lc,v); return siz[lc]+1+rank(rc,v); } inline void insert(int&amp;rt,int v){ int rk=rank(rt,v); pii x=split(rt,rk); rt=merge(merge(x.fi,newnode(v)),x.se); } inline void delet(int&amp;rt,int v){ int rk=rank(rt,v); pii x=split(rt,rk-1),y=split(x.se,1); rt=merge(x.fi,y.se),y.fi&amp;&amp;(stk[++top]=y.fi); } #undef lc #undef rc}struct F{ int l,r; F(int l=0,int r=0):l(l),r(r){} friend inline F operator+(F a,F b){return F(min(max(a.l,b.l),a.r),min(max(a.l,b.r),a.r));}};const int inf=1e9;int K,tg[N];int siz[N],hson[N],dep[N],top[N],fa[N],num[N],pred[N],bot[N],col[N],tot=0;vector&lt;int&gt;e[N];void dfs1(int p){ siz[p]=1; for(ri i=0,v;i&lt;e[p].size();++i){ if((v=e[p][i])==fa[p])continue; fa[v]=p,dep[v]=dep[p]+1,dfs1(v),siz[p]+=siz[v]; if(siz[v]&gt;siz[hson[p]])hson[p]=v; }}void dfs2(int p,int tp){ top[p]=tp,bot[tp]=p,pred[num[p]=++tot]=p; if(!hson[p])return; dfs2(hson[p],tp); for(ri i=0,v;i&lt;e[p].size();++i)if((v=e[p][i])!=fa[p]&amp;&amp;v!=hson[p])dfs2(v,v);}namespace sgt{ #define lc (p&lt;&lt;1) #define rc (p&lt;&lt;1|1) #define mid (l+r&gt;&gt;1) F vl[N&lt;&lt;2]; inline void pushup(int p){vl[p]=vl[lc]+vl[rc];} inline F query(int p,int l,int r,int ql,int qr){ if(ql&lt;=l&amp;&amp;r&lt;=qr)return vl[p]; if(qr&lt;=mid)return query(lc,l,mid,ql,qr); if(ql&gt;mid)return query(rc,mid+1,r,ql,qr); return query(lc,l,mid,ql,qr)+query(rc,mid+1,r,ql,qr); } inline bool check(int p,int k,int dt){ int R=bst::rank(rt[p],k)+dt,B=bst::siz[rt[p]]+1-R; return B-R&lt;k; } inline void fix(int p,int&amp;k,int dt){ while(check(p,k-1,dt))--k; while(!check(p,k,dt))++k; } inline void getval(int p,int k){ if(col[k]==1)vl[p]=F(inf,inf); else if(!col[k])vl[p]=F(-inf,-inf); else{ fix(k,vl[p].l,1); fix(k,vl[p].r,0); } } inline void build(int p,int l,int r){ if(l==r){ int k=pred[l]; getval(p,k); if(k==top[k]&amp;&amp;fa[k]){ if(bot[k]==k)bst::insert(rt[fa[k]],tg[k]=vl[p].l); else bst::insert(rt[fa[k]],tg[k]=(vl[p]+query(1,1,n,l+1,num[bot[k]])).l); } return; } build(rc,mid+1,r),build(lc,l,mid); pushup(p); } inline void update(int p,int l,int r,int k){ if(l==r)return getval(p,pred[l]); k&lt;=mid?update(lc,l,mid,k):update(rc,mid+1,r,k); pushup(p); } #undef mid #undef lc #undef rc}inline void change(int p){ int tp,ftp; while(p){ tp=top[p],ftp=fa[top[p]]; sgt::update(1,1,n,num[p]); if(ftp){ bst::delet(rt[ftp],tg[tp]); bst::insert(rt[ftp],tg[tp]=sgt::query(1,1,n,num[tp],num[bot[tp]]).l); } p=ftp; }}int main(){ srand(time(NULL)); #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(),K=read(); for(ri i=1,u,v;i&lt;n;++i){ u=read(),v=read(); e[u].pb(v),e[v].pb(u); } for(ri i=1;i&lt;=n;++i)col[i]=read(); dfs1(1),dfs2(1,1); sgt::build(1,1,n); for(ri op,x,tt=read();tt;--tt){ op=read(); switch(op){ case 1:{x=read(),cout&lt;&lt;(sgt::query(1,1,n,num[x],num[bot[top[x]]]).l&gt;K)&lt;&lt;&apos;\\n&apos;;break;} case 2:{x=read(),col[x]=read(),change(x);break;} case 3:{K=read();break;} } } return 0;} CODE(pbds) cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include&lt;bits/stdc++.h&gt;#include&lt;ext/pb_ds/tree_policy.hpp&gt;#include&lt;ext/pb_ds/assoc_container.hpp&gt;using namespace std;using namespace __gnu_pbds;using namespace __gnu_cxx;template &lt;class T&gt;using Tree=tree&lt;T,null_type,less&lt;T&gt;,rb_tree_tag,tree_order_statistics_node_update&gt;;#define ri register int#define fi first#define se second#define pb push_backusing namespace std;typedef long long ll;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; char ch=gc(); bool f=1; while(!isdigit(ch))f^=ch==&apos;-&apos;,ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;}typedef pair&lt;int,int&gt; pii;inline pii operator+(pii a,pii b){return pii(min(max(a.fi,b.fi),a.se),min(max(a.fi,b.se),a.se));}const int N=3e5+5;const int inf=1e9;int n,K,tg[N];int siz[N],hson[N],dep[N],top[N],fa[N],num[N],pred[N],bot[N],col[N],tot=0;vector&lt;int&gt;e[N];Tree&lt;pii&gt;T[N];decltype(begin(T[0])) D[N];namespace sgt{ #define lc (p&lt;&lt;1) #define rc (p&lt;&lt;1|1) #define mid (l+r&gt;&gt;1) pii vl[N&lt;&lt;2]; inline int rank(const Tree&lt;pii&gt; &amp;A,const int &amp;x){ return A.order_of_key(pii(x,inf)); } inline void pushup(int p){vl[p]=vl[lc]+vl[rc];} inline pii query(int p,int l,int r,int ql,int qr){ if(ql&lt;=l&amp;&amp;r&lt;=qr)return vl[p]; if(qr&lt;=mid)return query(lc,l,mid,ql,qr); if(ql&gt;mid)return query(rc,mid+1,r,ql,qr); return query(lc,l,mid,ql,qr)+query(rc,mid+1,r,ql,qr); } inline bool check(int p,int k,int dt){ int R=rank(T[p],k)+dt,B=(int)(T[p].size())+1-R; return B-R&lt;k; } inline void fix(int p,int&amp;k,int dt){ while(check(p,k-1,dt))--k; while(!check(p,k,dt))++k; } inline void getval(int p,int k){ if(col[k]==1)vl[p]=pii(inf,inf); else if(!col[k])vl[p]=pii(-inf,-inf); else{ fix(k,vl[p].fi,1); fix(k,vl[p].se,0); } } inline void build(int p,int l,int r){ if(l==r){ int k=pred[l]; getval(p,k); if(k==top[k]&amp;&amp;k!=1)D[k]=T[fa[k]].insert(pii(bot[k]==k?vl[p].fi:(vl[p]+query(1,1,n,l+1,num[bot[k]])).fi,k)).fi; return; } build(rc,mid+1,r),build(lc,l,mid); pushup(p); } inline void update(int p,int l,int r,int k){ if(l==r)return getval(p,pred[l]); k&lt;=mid?update(lc,l,mid,k):update(rc,mid+1,r,k); pushup(p); } #undef mid #undef lc #undef rc}void dfs1(int p){ siz[p]=1; for(ri i=0,v;i&lt;e[p].size();++i){ if((v=e[p][i])==fa[p])continue; fa[v]=p,dep[v]=dep[p]+1,dfs1(v),siz[p]+=siz[v]; if(siz[v]&gt;siz[hson[p]])hson[p]=v; }}void dfs2(int p,int tp){ top[p]=tp,bot[tp]=p,pred[num[p]=++tot]=p; if(!hson[p])return; dfs2(hson[p],tp); for(ri i=0,v;i&lt;e[p].size();++i)if((v=e[p][i])!=fa[p]&amp;&amp;v!=hson[p])dfs2(v,v);}inline void change(int p){ int tp,ftp; while(p){ ftp=fa[tp=top[p]]; sgt::update(1,1,n,num[p]); if(ftp){ T[ftp].erase(D[tp]); D[tp]=T[ftp].insert(pii(sgt::query(1,1,n,num[tp],num[bot[tp]]).fi,tp)).fi; } p=ftp; }}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(),K=read(); for(ri i=1,u,v;i&lt;n;++i){ u=read(),v=read(); e[u].pb(v),e[v].pb(u); } for(ri i=1;i&lt;=n;++i)col[i]=read(); dfs1(1),dfs2(1,1); sgt::build(1,1,n); for(ri op,x,tt=read();tt;--tt){ op=read(); switch(op){ case 1:{x=read(),cout&lt;&lt;(sgt::query(1,1,n,num[x],num[bot[top[x]]]).fi&gt;K)&lt;&lt;&apos;\\n&apos;;break;} case 2:{x=read(),col[x]=read(),change(x);break;} case 3:{K=read();break;} } } return 0;} &#x544A;&#x8F9E;","categories":[{"name":"public","slug":"public","permalink":"http://xdl030112.github.io/categories/public/"}],"tags":[{"name":"比赛题解","slug":"比赛题解","permalink":"http://xdl030112.github.io/tags/%E6%AF%94%E8%B5%9B%E9%A2%98%E8%A7%A3/"}]},{"title":"CometOJ模拟赛测试Day2 简要题解","slug":"COJ70","date":"2019-09-28T15:35:27.000Z","updated":"2019-10-11T15:33:23.915Z","comments":true,"path":"COJ70/","link":"","permalink":"http://xdl030112.github.io/COJ70/","excerpt":"","text":"21:10&#x5206;&#x8FDB;&#x5165;&#x6BD4;&#x8D5B;&#x754C;&#x9762;&#x7ED3;&#x679C;&#x624B;&#x901F;&#x6162;&#x4E86;C&#x6CA1;&#x5199;&#x5B8C;100+100+0&#x6EDA;&#x4E86; A &#x8C8C;&#x4F3C;&#x5F52;&#x5E76;&#x5C31;&#x884C;&#x4E86;&#x3002;&#x3002;&#x3002; &#x4F46;&#x6211;&#x6BD4;&#x8F83;&#x667A;&#x969C;&#x5199;&#x4E86;&#x4E2A;&#x94FE;&#x8868;&#xFF0C;&#x51D1;&#x5408;&#x770B;&#x770B;&#x5427;~ CODE cpp12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_back#define all(x) x.begin(),x.end()using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef vector&lt;int&gt; poly;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}const int N=1e5+5;int pre[N],suf[N],n,b[N],m;inline void delet(int x){ suf[pre[x]]=suf[x]; pre[suf[x]]=pre[x];}int main(){ n=read(),m=read(); for(ri i=1;i&lt;=n;++i)pre[i]=i-1,suf[i]=i+1; suf[0]=1,pre[n+1]=n; for(ri i=1;i&lt;=m;++i)delet(b[i]=read()); int ps=1; while(ps&lt;=m){ int p=suf[0]; while(p!=n+1&amp;&amp;p&lt;b[ps])cout&lt;&lt;p&lt;&lt;&apos;\\n&apos;,p=suf[p]; for(ri i=pre[p];i;i=pre[i])delet(i); cout&lt;&lt;b[ps]&lt;&lt;&apos;\\n&apos;; ++ps; } for(ri i=suf[0];i!=n+1;i=suf[i])cout&lt;&lt;i&lt;&lt;&apos;\\n&apos;; return 0;} B &#x8003;&#x8651;&#x7528; trietrietrie &#x5C06;&#x6240;&#x6709;&#x5B57;&#x7B26;&#x4E32;&#x4ECE;&#x5C0F;&#x5230;&#x5927;&#x6392;&#x5E8F;&#xFF0C;&#x7136;&#x540E;&#x95EE;&#x9898;&#x8F6C;&#x5316;&#x6210;&#x4E3A;&#x4E00;&#x4E2A;&#x6392;&#x5217;&#x5728;&#x5168;&#x6392;&#x5217;&#x4E2D;&#x7684;&#x6392;&#x540D; &#x6211;&#x5E76;&#x4E0D;&#x4F1A;&#x5EB7;&#x62D3;&#x5C55;&#x5F00;&#x7136;&#x540E;&#x8DD1;&#x53BB;rush&#x4E86;&#x4E00;&#x4E2A;bit CODE cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_back#define all(x) x.begin(),x.end()using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef vector&lt;int&gt; poly;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}inline int Read(char*s){ int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;}const int mod=1e9+7;inline int add(int a,int b){return (a+=b)&lt;mod?a:a-mod;}inline void Add(int&amp;a,int b){a=add(a,b);}inline int dec(int a,int b){return (a-=b)&lt;0?a+mod:a;}inline void Dec(int&amp;a,int b){a=dec(a,b);}inline int mul(int a,int b){return (ll)a*b%mod;}inline void Mul(int&amp;a,int b){a=(ll)a*b%mod;}const int N=1e6+5;char s[N];int son[N][26],rk[N],cnt=0,ed[N];int tot=1;inline void insert(char*s,int len,int idx){ int p=1; for(ri x,i=1;i&lt;=len;++i){ x=s[i]-&apos;a&apos;; if(!son[p][x])son[p][x]=++tot; p=son[p][x]; } ed[p]=idx;}void dfs(int p){ if(ed[p])rk[ed[p]]=++cnt; for(ri i=0;i&lt;26;++i)if(son[p][i])dfs(son[p][i]);}int n,k,a[N],top=0,fac[N],ifac[N];inline void init(){ fac[0]=fac[1]=ifac[0]=ifac[1]=1; for(ri i=2;i&lt;=n;++i)fac[i]=mul(fac[i-1],i),ifac[i]=mul(ifac[mod-mod/i*i],mod-mod/i); for(ri i=2;i&lt;=n;++i)Mul(ifac[i],ifac[i-1]);}inline int A(int n,int m){return n&lt;m||m&lt;0?0:mul(fac[n],ifac[n-m]);}int bit[N];inline int lowbit(int x){return x&amp;-x;}inline void update(int x,int v){for(ri i=x;i&lt;=n;i+=lowbit(i))bit[i]+=v;}inline int query(int x){int ret=0;for(ri i=x;i;i-=lowbit(i))ret+=bit[i];return ret;}int main(){ n=read(),k=read(); for(ri i=1,len;i&lt;=n;++i)len=Read(s),insert(s,len,i); dfs(1); int p=1,len=Read(s); for(ri i=1;i&lt;=len;++i){ p=son[p][s[i]-&apos;a&apos;]; if(ed[p]){ ++top; a[top]=rk[ed[p]]; p=1; } } init(); int res=0; for(ri i=1;i&lt;=k;++i){ Add(res,mul(a[i]-1-query(a[i]),A(n-i,k-i))); update(a[i],1); } cout&lt;&lt;res+1; return 0;} C &#x611F;&#x89C9;&#x8FD8;&#x6CA1; Day1&#x7684;CDay1&#x7684;CDay1&#x7684;C &#x96BE; &#x76F4;&#x63A5;&#x8003;&#x8651;&#x679A;&#x4E3E;&#x5220;&#x53BB;&#x7684;&#x5217;&#x7684;&#x72B6;&#x6001;&#xFF0C;&#x7136;&#x540E;&#x53EA;&#x7528;&#x770B;&#x53EF;&#x884C;&#x7684;&#x4FDD;&#x7559;&#x884C;&#x7684;&#x6570;&#x91CF;&#xFF0C;&#x8FD9;&#x4E2A;&#x76F4;&#x63A5;&#x538B;&#x4E00;&#x4E0B;&#x6BCF;&#x4E24;&#x884C;&#x6BCF;&#x4E2A;&#x4F4D;&#x7F6E;&#x7684;&#x5927;&#x5C0F;&#x72B6;&#x6001;&#x7136;&#x540E; fi,jf_{i,j}fi,j&#x200B; &#x8868;&#x793A;&#x524D; iii &#x884C;&#x4E00;&#x5B9A;&#x4FDD;&#x7559;&#x7B2C; iii &#x884C;&#x7684;&#x65B9;&#x6848;&#x6570; &#x901A;&#x8FC7;&#x5355;&#x6B21;&#x901A;&#x8FC7;&#x9884;&#x5904;&#x7406;+&#x6253;&#x65F6;&#x95F4;&#x6807;&#x8BB0;&#x53EF;&#x4EE5;&#x505A;&#x5230; O(n2)dpO(n^2)dpO(n2)dp &#x7136;&#x540E;&#x6211;&#x662F;&#x4E2A; zzzzzz &#xFF0C;&#x5148;&#x5199;&#x4E86;&#x4E00;&#x4E2A;&#x4EE5;&#x4E3A;&#x662F; O(n3)O(n^3)O(n3) &#x7684; O(n4)dpO(n^4)dpO(n4)dp &#x7136;&#x540E;&#x53EA;&#x6709; 90pts90pts90pts &#x5509;&#x600E;&#x4E48;&#x4F1A;&#x6709;90pts CODE cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_back#define all(x) x.begin(),x.end()using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef vector&lt;int&gt; poly;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}int n,m,p,q;int a[25][25];int b[25][25];ll f[25][25];inline bool check(int x,int y,int z){ for(ri i=1;i&lt;=q;++i)if((b[x][i]&gt;b[y][i])^(b[y][i]&gt;b[z][i]))return 0; return 1;}int main(){ n=read(),m=read(); for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=m;++j)a[i][j]=read(); ll res=0; vector&lt;int&gt;X,Y; for(ri s=0,up=1&lt;&lt;m;s&lt;up-1;++s){ X.clear(),Y.clear(); for(ri i=1;i&lt;=m;++i)if(!(s&gt;&gt;(i-1)&amp;1))Y.pb(i); for(ri i=1;i&lt;=n;++i){ bool ff=1; for(ri j=0;j+2&lt;Y.size();++j)if((a[i][Y[j]]&gt;a[i][Y[j+1]])^(a[i][Y[j+1]]&gt;a[i][Y[j+2]])){ff=0;break;} if(ff)X.pb(i); } p=X.size(),q=Y.size(); for(ri i=0;i&lt;X.size();++i)for(ri j=0;j&lt;Y.size();++j)b[i+1][j+1]=a[X[i]][Y[j]]; res+=p; for(ri i=1;i&lt;=p;++i){ for(ri j=i+1;j&lt;=p;++j){ f[i][j]=1; for(ri k=i-1;k;--k){ if(check(k,i,j))f[i][j]+=f[k][i]; } res+=f[i][j]; } } } cout&lt;&lt;res; return 0;} &#x7136;&#x540E;&#x53D1;&#x73B0;&#x4E8B;&#x60C5;&#x4E0D;&#x5BF9;&#xFF0C;&#x6539;&#x6210;&#x4E86; O(n3)O(n^3)O(n3) &#x7684; CODE cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_back#define all(x) x.begin(),x.end()using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef vector&lt;int&gt; poly;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}int n,m,p,q;int a[25][25];int b[25][25];ll f[25][25],ban[25][25];inline ll calc(int x,int y){ ll res=0; for(ri i=1;i&lt;=q;++i)res+=(1ll*(b[x][i]&gt;b[y][i]))&lt;&lt;(i-1); return res;}int main(){ n=read(),m=read(); for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=m;++j)a[i][j]=read(); ll res=0; vector&lt;int&gt;X,Y; for(ri s=0,up=1&lt;&lt;m;s&lt;up-1;++s){ X.clear(),Y.clear(); for(ri i=1;i&lt;=m;++i)if(!(s&gt;&gt;(i-1)&amp;1))Y.pb(i); for(ri i=1;i&lt;=n;++i){ bool ff=1; for(ri j=0;j+2&lt;Y.size();++j)if((a[i][Y[j]]&gt;a[i][Y[j+1]])^(a[i][Y[j+1]]&gt;a[i][Y[j+2]])){ff=0;break;} if(ff)X.pb(i); } p=X.size(),q=Y.size(); for(ri i=0;i&lt;X.size();++i)for(ri j=0;j&lt;Y.size();++j)b[i+1][j+1]=a[X[i]][Y[j]]; res+=p; for(ri i=1;i&lt;=p;++i)for(ri j=i+1;j&lt;=p;++j)ban[i][j]=calc(i,j); for(ri i=1;i&lt;=p;++i){ for(ri j=i+1;j&lt;=p;++j){ f[i][j]=1; for(ri k=i-1;k;--k)if(ban[k][i]==ban[i][j])f[i][j]+=f[k][i]; res+=f[i][j]; } } } cout&lt;&lt;res; return 0;} &#x7136;&#x540E;&#x53D1;&#x73B0;&#x88AB;&#x5361;&#x5E38;&#x4E86;&#xFF0C;&#x52A0;&#x4E86;&#x4E2A;&#x65F6;&#x95F4;&#x6807;&#x8BB0;&#x6539;&#x6210;&#x4E86;&#x4EE5;&#x4E3A;&#x662F; O(n2)O(n^2)O(n2) &#x7684; O(n3)dpO(n^3)dpO(n3)dp CODE cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_back#define all(x) x.begin(),x.end()using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef vector&lt;int&gt; poly;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}int n,m,p,q;int a[25][25];int b[25][25],tim[21][1&lt;&lt;20|5],Tim=0;int f[21][1&lt;&lt;20|5];int ban[25][25];inline int calc(int x,int y){ int res=0; for(ri i=1;i&lt;=q;++i)res+=(b[x][i]&gt;b[y][i])&lt;&lt;(i-1); return res;}inline int query(int x,int y){return tim[x][y]^Tim?0ll:f[x][y];}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(),m=read(); for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=m;++j)a[i][j]=read(); ll res=0; vector&lt;int&gt;X,Y; for(ri s=0,up=1&lt;&lt;m;s&lt;up-1;++s){ X.clear(),Y.clear(); for(ri i=1;i&lt;=m;++i)if(!(s&gt;&gt;(i-1)&amp;1))Y.pb(i); for(ri i=1;i&lt;=n;++i){ bool ff=1; for(ri j=0;j+2&lt;Y.size();++j)if((a[i][Y[j]]&gt;a[i][Y[j+1]])^(a[i][Y[j+1]]&gt;a[i][Y[j+2]])){ff=0;break;} if(ff)X.pb(i); } p=X.size(),q=Y.size(); for(ri i=0;i&lt;X.size();++i)for(ri j=0;j&lt;Y.size();++j)b[i+1][j+1]=a[X[i]][Y[j]]; res+=p; ++Tim; for(ri i=1;i&lt;=p;++i){ for(ri j=i+1;j&lt;=p;++j){ ban[i][j]=calc(i,j); if(tim[j][ban[i][j]]^Tim)tim[j][ban[i][j]]=Tim,f[j][ban[i][j]]=0; f[j][ban[i][j]]+=query(i,ban[i][j])+1; res+=query(i,ban[i][j])+1; } } } cout&lt;&lt;res; return 0;} &#x6700;&#x540E;&#x7EC8;&#x4E8E;&#x8FC7;&#x4E86; CODE cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_back#define all(x) x.begin(),x.end()using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef vector&lt;int&gt; poly;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;}int n,m,p,q;int a[25][25];int b[25][25],tim[21][1&lt;&lt;20|5],Tim=0;int f[21][1&lt;&lt;20|5];int ban[25][25];inline int calc(int x,int y){ int res=0; for(ri i=1;i&lt;=m;++i)res+=(a[x][i]&gt;a[y][i])&lt;&lt;(i-1); return res;}inline int query(int x,int y){return tim[x][y]^Tim?0:f[x][y];}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(),m=read(); for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=m;++j)a[i][j]=read(); for(ri i=1;i&lt;=n;++i)for(ri j=i+1;j&lt;=n;++j)ban[i][j]=calc(i,j); ll res=0; vector&lt;int&gt;X,Y; for(ri s=0,up=1&lt;&lt;m;s&lt;up-1;++s){ X.clear(),Y.clear(); for(ri i=1;i&lt;=m;++i)if(!(s&gt;&gt;(i-1)&amp;1))Y.pb(i); for(ri i=1;i&lt;=n;++i){ bool ff=1; for(ri j=0;j+2&lt;Y.size();++j)if((a[i][Y[j]]&gt;a[i][Y[j+1]])^(a[i][Y[j+1]]&gt;a[i][Y[j+2]])){ff=0;break;} if(ff)X.pb(i); } p=X.size(),q=Y.size(); res+=p; ++Tim; for(ri i=1,ss;i&lt;=p;++i){ for(ri j=i+1;j&lt;=p;++j){ ss=ban[X[i-1]][X[j-1]]&amp;((up-1)^s); (tim[j][ss]^Tim)&amp;&amp;(tim[j][ss]=Tim,f[j][ss]=0); f[j][ss]+=query(i,ss)+1; res+=query(i,ss)+1; } } } cout&lt;&lt;res; return 0;} &#x88AB;&#x5168;&#x573A;&#x540A;&#x6253;&#x4E86;&#xFF0C;&#x544A;&#x8F9E;","categories":[{"name":"public","slug":"public","permalink":"http://xdl030112.github.io/categories/public/"}],"tags":[{"name":"比赛题解","slug":"比赛题解","permalink":"http://xdl030112.github.io/tags/%E6%AF%94%E8%B5%9B%E9%A2%98%E8%A7%A3/"}]},{"title":"CometOJ模拟赛测试Day1 简要题解","slug":"COJ69","date":"2019-09-28T02:27:35.000Z","updated":"2019-10-11T15:33:25.061Z","comments":true,"path":"COJ69/","link":"","permalink":"http://xdl030112.github.io/COJ69/","excerpt":"","text":"NMD&#x56E0;&#x4E3A;&#x7F51;&#x7EDC;&#x539F;&#x56E0;&#x4EA4;&#x9519;&#x4E86;&#x9898;&#xFF0C;&#x6700;&#x540E;&#x5BFC;&#x81F4;B,C&#x7206;&#x70B8;&#x4E86; A &#x6211;&#x7684;&#x4E71;&#x641E;&#x505A;&#x6CD5;&#xFF1A; &#x5148;&#x53D6;&#x5BF9;&#x628A;&#x4E58;&#x6CD5;&#x8F6C;&#x5316;&#x6210;&#x52A0;&#x6CD5;&#xFF0C;&#x7136;&#x540E;&#x6253;&#x8868;&#x6C42;&#x51FA;&#x6BCF;&#x4E2A;&#x6570;&#x7684;&#x4E0D;&#x8D85;&#x8FC7;&#x5176;&#x4E00;&#x534A;&#x7684;&#x6700;&#x5927;&#x7684;&#x6700;&#x4F18;&#x51B3;&#x7B56;&#x70B9; &#x53D1;&#x73B0;&#x51B3;&#x7B56;&#x6A21; 666 &#x4E4B;&#x540E;&#x6709;&#x89C4;&#x5F8B;&#xFF0C;&#x5EFA;&#x7ACB;&#x4E00;&#x4E2A; solve(x)solve(x)solve(x) &#x51FD;&#x6570;&#xFF1A; x&#x2264;3x\\le3x&#x2264;3 &#xFF0C;&#x8FD4;&#x56DE; xxx (x&#x2212;3)%6&lt;4(x-3)\\%6&lt;4(x&#x2212;3)%6&lt;4 &#xFF0C;&#x8FD4;&#x56DE; solve(x/2)&#x2217;solve(x&#x2212;x/2)solve(x/2)*solve(x-x/2)solve(x/2)&#x2217;solve(x&#x2212;x/2) (x&#x2212;3)%6&gt;=4(x-3)\\%6&gt;=4(x&#x2212;3)%6&gt;=4 &#xFF0C;&#x8FD4;&#x56DE; solve(x/2&#x2212;1)&#x2217;solve(x&#x2212;x/2+1)solve(x/2-1)*solve(x-x/2+1)solve(x/2&#x2212;1)&#x2217;solve(x&#x2212;x/2+1) &#x7136;&#x540E;&#x52A0;&#x4E2A;&#x8BB0;&#x5FC6;&#x5316;&#x5C31;&#x80FD;&#x8FC7;&#x4E86; CODE cpp12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_backusing namespace std;typedef long long ll;map&lt;ll,int&gt;S;ll n;const int mod=1e9+7;inline int solve(ll n){ if(S.count(n))return S[n]; if(n&lt;=3)return S[n]=n; int t=(n-4)%6; if(t&gt;=4)return S[n]=1ll*solve(n/2-1)*solve(n-n/2+1)%mod; return S[n]=1ll*solve(n/2)*solve(n-n/2)%mod;}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif cin&gt;&gt;n; cout&lt;&lt;solve(n); return 0;} B &#x4E00;&#x9053;&#x7EAF;&#x6A21;&#x62DF;&#x9898;&#xFF0C;&#x5206;&#x5982;&#x4E0B;&#x51E0;&#x7C7B;&#x968F;&#x4FBF;&#x8BA8;&#x8BBA;&#x4E00;&#x4E0B;&#xFF1A; &#x5F62;&#x5982; &#x201C;###&#x201D; &#x6216;&#x8005; &#x201C;##.&quot; &#xFF0C;&#x90A3;&#x4E48;&#x8FD9;&#x4E24;&#x79CD;&#x60C5;&#x51B5;&#x53EA;&#x9700;&#x8003;&#x8651;&#x5B83;&#x4EEC;&#x524D;&#x9762;&#x7684;&#x6700;&#x4F18;&#x503C; &#x5F53;&#x524D;&#x8EAB;&#x4E0A;&#x6709; 222 &#x4E2A;&#x5E72;&#x6270;&#x5668;&#xFF0C;&#x90A3;&#x4E48;&#x53EF;&#x4EE5;&#x76F4;&#x63A5;&#x626B;&#x4E00;&#x904D;&#x6C42;&#x7B54;&#x6848;&#xFF0C; Ans=&#x5E72;&#x6270;&#x5668;&#x4E2A;&#x6570;&#x2212;Ans=&#x5E72;&#x6270;&#x5668;&#x4E2A;&#x6570;-Ans=&#x5E72;&#x6270;&#x5668;&#x4E2A;&#x6570;&#x2212;&#x201C;##&#x201D;&#x4E2A;&#x6570;&#x4E2A;&#x6570;&#x4E2A;&#x6570; &#x5F53;&#x524D;&#x8EAB;&#x4E0A;&#x6709; 111 &#x4E2A;&#x5E72;&#x6270;&#x5668;&#xFF0C;&#x4E14;&#x524D;&#x9762;&#x6709;&#x4E00;&#x4E2A;&#x5F62;&#x5982; &#x201C;*#&#x201D; &#x7684;&#xFF0C; &#x90A3;&#x4E48;&#x7B54;&#x6848;&#x8DDF;&#x7B2C;&#x4E8C;&#x79CD;&#x60C5;&#x51B5;&#x76F8;&#x540C; &#x8FD8;&#x6709;&#x51E0;&#x7C7B;&#x6BD4;&#x8F83;&#x5BB9;&#x6613;&#x7684;&#x5C31;&#x4E0D;&#x5217;&#x51FA;&#x6765;&#x4E86;&#x3002; CODE cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_backusing namespace std;typedef long long ll;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; char ch=gc(); bool f=1; while(!isdigit(ch))f^=ch==&apos;-&apos;,ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;}inline int Read(char*s){ int top=0; char ch=gc(); while(ch!=&apos;.&apos;&amp;&amp;ch!=&apos;*&apos;&amp;&amp;ch!=&apos;#&apos;)ch=gc(); while(ch==&apos;.&apos;||ch==&apos;*&apos;||ch==&apos;#&apos;)s[++top]=ch,ch=gc(); return top;}const int N=3e6+5;char s[N];int n;inline int calc(int l,int r){ int res=0; for(ri i=l;i&lt;=r;++i)if(s[i]==&apos;*&apos;)++res; for(ri i=l;i&lt;r;++i)if(s[i]==&apos;#&apos;&amp;&amp;s[i+1]==&apos;#&apos;)--res; return res;}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif for(ri tt=read();tt;--tt){ n=Read(s); s[n+1]=s[n+2]=&apos;#&apos;; for(ri i=1;i&lt;=n;++i){ if(s[i]==&apos;#&apos;&amp;&amp;s[i+1]==&apos;#&apos;&amp;&amp;s[i+2]!=&apos;*&apos;){ n=i-1; break; } } int res=0; for(ri ff=0,ct=0,i=1;i&lt;=n;++i){ if(s[i]==&apos;.&apos;)continue; if(s[i]==&apos;*&apos;){ ++ct,res=max(res,ct); if(ct==2){ res=calc(1,n); break; } if(ff){ res=calc(1,n); break; } continue; } if(s[i]==&apos;#&apos;){ if(!ct){ if(s[i+1]!=&apos;*&apos;)break; ff=0; continue; } else{ if(s[i+1]==&apos;#&apos;){ ff=0; i+=2; continue; } --ct,ff=1; continue; } } } cout&lt;&lt;res&lt;&lt;&apos;\\n&apos;; } return 0;} C &#x4E00;&#x9053;&#x6BD4;&#x8F83;&#x5BB9;&#x6613;&#x7684; dpdpdp &#x8003;&#x8651;&#x679A;&#x4E3E;&#x65AD;&#x8FB9;&#x7136;&#x540E;&#x5904;&#x7406;&#x51FA;&#x4E24;&#x4E2A;&#x8FDE;&#x901A;&#x5757;&#x7684;&#x8DEF;&#x5F84;&#x548C;&#x6700;&#x503C;&#x7136;&#x540E;&#x4E58;&#x8D77;&#x6765;&#x66F4;&#x65B0;&#x7B54;&#x6848;&#xFF0C;&#x4E0B;&#x9762;&#x90A3;&#x4E2A;&#x8FDE;&#x901A;&#x5757;&#x7684;&#x7B54;&#x6848;&#x53EF;&#x4EE5;&#x76F4;&#x63A5; O(n)O(n)O(n) &#x6811;&#x5F62; dpdpdp &#x4E00;&#x904D;&#x5F97;&#x5230;&#xFF0C;&#x800C;&#x4E0A;&#x9762;&#x7684;&#x7EF4;&#x62A4;&#x7B54;&#x6848;&#x5982;&#x679C;&#x4E0D;&#x60F3;&#x7E41;&#x6742;&#x8BA8;&#x8BBA;&#x7684;&#x8BDD;&#x53EF;&#x4EE5;&#x5BF9;&#x6BCF;&#x4E2A;&#x70B9;&#x641E;&#x4E2A;&#x53EF;&#x5220;&#x5806;/multiset&#xFF0C;&#x4E0D;&#x8FC7;&#x4E0D;&#x5F00; O2O2O2 &#x4F1A;&#x88AB;&#x5361;&#x6389; &#x5426;&#x5219;&#x53EF;&#x4EE5;&#x7EF4;&#x62A4;&#x513F;&#x5B50;&#x7B54;&#x6848;&#x524D;&#x540E;&#x7F00;&#x7684; min/maxmin/maxmin/max &#x6765;&#x5B9E;&#x73B0;&#x53EF;&#x5220;&#x5806;&#x4E00;&#x6837;&#x7684;&#x4E1C;&#x897F;&#xFF0C;&#x4F46;&#x8FD9;&#x79CD; O(n)O(n)O(n) &#x7684;&#x505A;&#x6CD5;&#x4E5F;&#x88AB;&#x5361; TLETLETLE &#x4E86;&#x4E00;&#x4E2A;&#x70B9;&#xFF0C;&#x9700;&#x8981;&#x624B;&#x52A8; O2O2O2 &#x53EF;&#x5220;&#x5806; cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_backusing namespace std;typedef long long ll;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; char ch=gc(); bool f=1; while(!isdigit(ch))f^=ch==&apos;-&apos;,ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;}const int N=2e5+5;int n,dep[N],mn[N],mx[N],fmn[N],fmx[N],gmx[N],gmn[N];typedef pair&lt;int,int&gt; pii;vector&lt;pii&gt;e[N];struct Q1{ priority_queue&lt;int&gt;a,b; inline void push(int x){a.push(x);} inline void del(int x){b.push(x);} inline int top(){while(b.size()&amp;&amp;a.top()==b.top())a.pop(),b.pop();return a.top();} inline void pop(){while(b.size()&amp;&amp;a.top()==b.top())a.pop(),b.pop();a.pop();} inline int stop(){int t=top(),ret;return pop(),ret=top(),a.push(t),ret;} inline int size(){return a.size()-b.size();}}S1[N],Mx[N];struct Q2{ priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;a,b; inline void push(int x){a.push(x);} inline void del(int x){b.push(x);} inline int top(){while(b.size()&amp;&amp;a.top()==b.top())a.pop(),b.pop();return a.top();} inline void pop(){while(b.size()&amp;&amp;a.top()==b.top())a.pop(),b.pop();a.pop();} inline int stop(){int t=top(),ret;return pop(),ret=top(),a.push(t),ret;} inline int size(){return a.size()-b.size();}}S2[N],Mn[N];void dfs1(int p,int fa){ for(ri i=0,v;i&lt;e[p].size();++i){ if((v=e[p][i].fi)==fa)continue; dfs1(v,p); S1[p].push(S1[v].top()+e[p][i].se); S2[p].push(S2[v].top()+e[p][i].se); } mx[p]=S1[p].top()+S1[p].stop(); mn[p]=S2[p].top()+S2[p].stop(); for(ri i=0,v;i&lt;e[p].size();++i){ if((v=e[p][i].fi)==fa)continue; mx[p]=max(mx[p],mx[v]); mn[p]=min(mn[p],mn[v]); Mx[p].push(mx[v]); Mn[p].push(mn[v]); }}ll res=0;void dfs2(int p,int fa){ for(ri i=0,v;i&lt;e[p].size();++i){ if((v=e[p][i].fi)==fa)continue; S1[p].del(S1[v].top()+e[p][i].se); S2[p].del(S2[v].top()+e[p][i].se); Mx[p].del(mx[v]); Mn[p].del(mn[v]); fmx[v]=max(0,max(fmx[p],S1[p].top())+e[p][i].se); fmn[v]=min(0,min(fmn[p],S2[p].top())+e[p][i].se); gmx[p]=max(gmx[fa],Mx[p].top()); gmx[p]=max(gmx[p],max(S1[p].stop(),fmx[p])+S1[p].top()); gmn[p]=min(gmn[fa],Mn[p].top()); gmn[p]=min(gmn[p],min(S2[p].stop(),fmn[p])+S2[p].top()); res=max(res,(ll)mx[v]*gmx[p]); res=max(res,(ll)mn[v]*gmn[p]); dfs2(v,p); S1[p].push(S1[v].top()+e[p][i].se); S2[p].push(S2[v].top()+e[p][i].se); Mx[p].push(mx[v]); Mn[p].push(mn[v]); }}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(); for(ri i=1,u,v,w;i&lt;n;++i){ u=read(),v=read(),w=read(); e[u].pb(pii(v,w)); e[v].pb(pii(u,w)); } for(ri i=1;i&lt;=n;++i)S1[i].push(0),S1[i].push(0),S2[i].push(0),S2[i].push(0),Mn[i].push(0),Mx[i].push(0); dfs1(1,0); dfs2(1,0); cout&lt;&lt;res; return 0;} &#x524D;&#x540E;&#x7F00;max cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_backusing namespace std;typedef long long ll;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read(){ int ans=0; char ch=gc(); bool f=1; while(!isdigit(ch))f^=ch==&apos;-&apos;,ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;}const int N=2e5+5;int n,mx[N],fmx[N],gmx[N],dmx[N];typedef pair&lt;int,int&gt; pii;vector&lt;pii&gt;e[N];struct Mxx{ int mx,sx; Mxx(int mx=0,int sx=0):mx(mx),sx(sx){} friend inline Mxx operator+(Mxx a,Mxx b){return Mxx(max(a.mx,b.mx),a.mx&gt;b.mx?max(a.sx,b.mx):max(a.mx,b.sx));}};vector&lt;Mxx&gt;pmx[N],smx[N],Pmx[N],Smx[N];inline void init(int p,int fa){ int n=e[p].size(); pmx[p].resize(n+1),smx[p].resize(n+1); Pmx[p].resize(n+1),Smx[p].resize(n+1); for(ri vl,i=1,ps=1;i&lt;=n;++i,++ps){ if(e[p][i-1].fi==fa){--ps;continue;} vl=dmx[e[p][i-1].fi]+e[p][i-1].se; pmx[p][ps]=pmx[p][ps-1]+Mxx(max(vl,0),0); vl=mx[e[p][i-1].fi]; Pmx[p][ps]=Pmx[p][ps-1]+Mxx(max(vl,0),0); } for(ri vl,i=n,ps=n-1;i;--i,--ps){ if(e[p][i-1].fi==fa){++ps;continue;} vl=dmx[e[p][i-1].fi]+e[p][i-1].se; smx[p][ps]=smx[p][ps+1]+Mxx(max(vl,0),0); vl=mx[e[p][i-1].fi]; Smx[p][ps]=Smx[p][ps+1]+Mxx(max(vl,0),0); }}void dfs1(int p,int fa){ for(ri i=0,v;i&lt;e[p].size();++i){ if((v=e[p][i].fi)==fa)continue; dfs1(v,p); } init(p,fa); dmx[p]=smx[p][1].mx; mx[p]=max(smx[p][1].mx+smx[p][1].sx,Smx[p][1].mx);}ll res=0;void dfs2(int p,int fa){ Mxx mx1,mx2; for(ri i=0,v,ps=1;i&lt;e[p].size();++i,++ps){ if((v=e[p][i].fi)==fa){--ps;continue;} mx1=pmx[p][ps-1]+smx[p][ps+1]; mx2=Pmx[p][ps-1]+Smx[p][ps+1]; fmx[v]=max(0,max(fmx[p],mx1.mx)+e[p][i].se); gmx[p]=max(gmx[fa],mx2.mx); gmx[p]=max(gmx[p],max(mx1.sx,fmx[p])+mx1.mx); res=max(res,(ll)mx[v]*gmx[p]); dfs2(v,p); }}int main(){ #ifdef ldxcaicai freopen(&quot;lx.in&quot;,&quot;r&quot;,stdin); #endif n=read(); for(ri i=1,u,v,w;i&lt;n;++i){ u=read(),v=read(),w=read(); e[u].pb(pii(v,w)); e[v].pb(pii(u,w)); } e[1].pb(pii(0,0)); dfs1(1,0); dfs2(1,0); for(ri i=1;i&lt;=n;++i)for(ri j=0;j&lt;e[i].size();++j)e[i][j].se*=-1; dfs1(1,0); dfs2(1,0); cout&lt;&lt;res; return 0;}","categories":[{"name":"public","slug":"public","permalink":"http://xdl030112.github.io/categories/public/"}],"tags":[{"name":"比赛题解","slug":"比赛题解","permalink":"http://xdl030112.github.io/tags/%E6%AF%94%E8%B5%9B%E9%A2%98%E8%A7%A3/"}]}]}